#include <asm/io.h>
#include <math.h>
#include <rtl_core.h>
#include <pthread.h>
#include "../../INC/datastore.h"
#include "message.h"
#include "Analog.h"
#include "FAD.h"
#include "ChannelControl.h"
#include "ChannelControl_CAN.h"
#include "PCU_Control.h"
#include "PCU.h"
#include "local_utils.h"
#include "CAN.h"
#include "FaultCond.h"

extern S_SYSTEM_DATA *myData;
extern S_MODULE_DATA *myPs;    
extern S_TEST_CONDITION *myTestCond;	//190901 lyhw
S_CH_DATA *myCh;

void ChannelControl_Ch(int bd, int ch)
{
	switch(myData->AppControl.config.systemType){
		case CYCLER_CAN:
		 	ChannelControl_Ch_CAN(bd, ch);
			break;
		default:
		 	ChannelControl_Ch_Default(bd, ch);
			break;
	}	
}

void ChannelControl_Ch_Default(int bd, int ch)
{
#if MACHINE_TYPE == 1
	int mode;

	mode = (inb(0x610) & 0xF0); //140407 oye add : Mode Select Signal
#endif

	if(bd >= myPs->config.installedBd) return;
	if(ch >= myPs->config.chPerBd) return;

	myCh = &(myData->bData[bd].cData[ch]);

	if(myCh->ChAttribute.chNo_master == P0) { //kjiw
		//parallel slave ch check
		//100426 kji w
		//fault check 100ms 
		if(myCh->op.runTime % 10 == 0) {
			cFaultCondSoft_P(bd, ch); 
			cFaultCondHard_P(bd, ch); 		
#if AUX_CONTROL == 1
	#if NETWORK_VERSION >= 4103
			cFaultCond_Aux_P(bd, ch); //20190802
	#endif
#endif
		}
	} else if(myCh->ChAttribute.opType == P0) { //kjiw
		//general ch check
		if(myCh->op.runTime % 10 == 0) {
			cFaultCondSoft(bd, ch);
			cFaultCondHard(bd, ch); 

#if AUX_CONTROL == 1
	#if NETWORK_VERSION >= 4103
			cFaultCond_Aux(bd, ch);
	#endif
#endif
		}
	}

#if FAULT_CONFIG_VERSION >= 1	
	//210901 LJS
	if(myCh->ChAttribute.chNo_master == P0){
		if(myCh->op.runTime % 10 == 0) {
			DropV_Charge_p(bd, ch);
			DropV_DisCharge_p(bd, ch);
		}
	}else if(myCh->ChAttribute.opType == P0){
		if(myCh->op.runTime % 10 == 0) {
			DropV_Charge(bd, ch);
			DropV_DisCharge(bd, ch);
		}
	}
#endif

#if MACHINE_TYPE == 1
	//140407 oys add : MODE SELECT
	cShortDioSignal(bd, ch);
	cShortModeControl(int mode);
#endif

	cStep(bd, ch);
	cStopCond(bd, ch);
	cEndCond(bd, ch);

	if(myPs->config.hwSpec < S_5V_200A) { //linear
		RangeSelectV_Ch(bd, ch);

		//180404 add for parallel Range Select
		if(myCh->ChAttribute.chNo_master == P0) {
			RangeSelectI_Ch(bd, ch - 1);
			RangeSelectI_Ch(bd, ch);
		} else {
			if(myCh->ChAttribute.opType == P0) {
				RangeSelectI_Ch(bd, ch);
			}
		}

		ParallelSwitch_OnOff_Ch(bd, ch);
		OutputSwitch_OnOff_Ch(bd, ch);
		OutputTrigger_Ch(bd, ch);
		Status_LED_OnOff(bd);
		CompWriteCh(bd, ch);

#if MACHINE_TYPE == 2
		DIO_BD_Control(bd, ch);	//oys w 20151013
#endif
		//ReadOtFault(bd); //khkw 20080428
		//ReadHwFault(bd); //khkw 20080428
		//ReadHwFault_Ch(bd, ch); //5V_600A_10A_Pack
	} else { //switching
		OutputSwitch_OnOff_Ch(bd, ch);
		V_Cmd_Output_Ch(bd, ch);
		I_Cmd_Output_Ch(bd, ch);
	}
}

void cStep(int bd, int ch)
{
	myCh = &(myData->bData[bd].cData[ch]);

	switch(myCh->op.state) {
   		case C_IDLE:	cIdle(bd, ch);		break;
   		case C_STANDBY:	cStandby(bd, ch);	break;
		case C_CALI: 	cCali(bd, ch);		break;
		case C_PAUSE:	cPause(bd, ch);		break;
		case C_RUN:
			//111125 oys w : totalRunTime increase			
			if(myCh->op.totalRunTime >= MAX_TOTAL_RUNTIME) {
				myCh->op.totalRunTime_carry += 1;
				myCh->op.totalRunTime = 0;
			}

			switch(myCh->op.type) {
				case STEP_CHARGE:		cStepCharge(bd, ch);		break;
				case STEP_DISCHARGE:	cStepDischarge(bd, ch);		break;
				case STEP_REST:			cStepRest(bd, ch);			break;
				case STEP_OCV:			cStepOcv(bd, ch);			break;
				case STEP_Z:			cStepZ(bd, ch);				break;
				case STEP_USER_PATTERN:	cStepUserPattern(bd, ch);	break;
				case STEP_USER_MAP:		cStepUserMap(bd, ch);		break;
				case STEP_BALANCE:		cStepBalance(bd, ch);		break;
#if MACHINE_TYPE == 1
				case STEP_SHORT:		cStepShort(bd, ch);			break;
#endif
				case STEP_ACIR:			cStepAcir(bd, ch);			break;
				default: //STEP_ADV_CYCLE, STEP_LOOP, STEP_END
					cStepDefault(bd, ch);
					break;
			}
			break;
    	default:
			break;
	}
}

void cNextStep(int bd, int ch)
{
	myCh = &(myData->bData[bd].cData[ch]);

#if CYCLER_TYPE == LINEAR_CYC 
	switch(myCh->op.type) {
		case STEP_CHARGE:		cStepCharge(bd, ch);		break;
		case STEP_DISCHARGE:	cStepDischarge(bd, ch);		break;
		case STEP_REST:			cStepRest(bd, ch);			break;
		case STEP_OCV:			cStepOcv(bd, ch);			break;
		case STEP_Z:			cStepZ(bd, ch);				break;
		case STEP_USER_PATTERN:	cStepUserPattern(bd, ch);	break;
		case STEP_USER_MAP:		cStepUserMap(bd, ch);		break;
		case STEP_BALANCE:		cStepBalance(bd, ch);		break;
#if MACHINE_TYPE == 1
		case STEP_SHORT:		cStepShort(bd, ch);			break;
#endif
		case STEP_ACIR:			cStepAcir(bd, ch);			break;
		default: //STEP_ADV_CYCLE, STEP_LOOP, STEP_END
			cStepDefault(bd, ch);
			break;
	}
#endif
#if CYCLER_TYPE == DIGITAL_CYC
	switch(myCh->op.type) {
		case STEP_CHARGE:		pStepCharge(bd, ch);		break;
		case STEP_DISCHARGE:	pStepDischarge(bd, ch);		break;
		case STEP_REST:			pStepRest(bd, ch);			break;
		case STEP_OCV:			pStepOcv(bd, ch);			break;
		case STEP_Z:			pStepZ(bd, ch);				break;
		case STEP_USER_PATTERN:	pStepUserPattern(bd, ch);	break;
		case STEP_USER_MAP:		pStepUserMap(bd, ch);		break;
		case STEP_BALANCE:		cStepBalance(bd, ch);		break;
		case STEP_ACIR:			cStepAcir(bd, ch);			break;
		default: //STEP_ADV_CYCLE, STEP_LOOP, STEP_END
			cStepDefault(bd, ch);
			break;
	}
#endif
#if CYCLER_TYPE == CAN_CYC
	switch(myCh->op.type) {
		case STEP_CHARGE:		cStepCharge_CAN(bd, ch);		break;
		case STEP_DISCHARGE:	cStepDischarge_CAN(bd, ch);		break;
		case STEP_REST:			cStepRest_CAN(bd, ch);			break;
		case STEP_OCV:			cStepOcv_CAN(bd, ch);			break;
		case STEP_Z:			cStepZ_CAN(bd, ch);				break;
		case STEP_USER_PATTERN:	cStepUserPattern_CAN(bd, ch);	break;
		case STEP_USER_MAP:		cStepUserMap_CAN(bd, ch);		break;
		case STEP_BALANCE:		cStepBalance_CAN(bd, ch);		break;
		case STEP_ACIR:			cStepAcir(bd, ch);				break;
		default: 				cStepDefault_CAN(bd, ch);		break;
	}
#endif
}

void cStopCond(int bd, int ch)
{
	unsigned char type;
    int rtn=0, mode;
	long capacity;
	unsigned long advStepNo, saveDt;

	S_CH_STEP_INFO step;

	myCh = &(myData->bData[bd].cData[ch]);
	
	if(myCh->op.state != C_RUN) return;
	if(myCh->op.phase != P50) return;

	step = step_info(bd, ch);
	advStepNo = step.advStepNo;
	saveDt = step.saveDt;
	saveDt = step.saveDt;
	type = step.type;
	mode = step.mode;

	if(myCh->ChAttribute.chNo_master == P0) { //kjiw
		if(myPs->config.capacityType == CAPACITY_AMPARE_HOURS) {
			capacity = myCh->op.ampareHour
					+ myData->bData[bd].cData[ch-1].op.ampareHour;
		} else if(myPs->config.capacityType == CAPACITY_CAPACITANCE) {
			capacity = myCh->op.capacitance
					+ myData->bData[bd].cData[ch-1].op.capacitance;
		} else {
			capacity = 0;
		}
	}else{
		if(myPs->config.capacityType == CAPACITY_AMPARE_HOURS) {
			capacity = myCh->op.ampareHour;
		} else if(myPs->config.capacityType == CAPACITY_CAPACITANCE) {
			capacity = myCh->op.capacitance;
		} else {
			capacity = 0;
		}
	}

	switch(type) {
    	case STEP_CHARGE:
			if(myPs->testCond[bd][ch].step[advStepNo].stopT != 0) {
				if(myCh->op.runTime >=
					myPs->testCond[bd][ch].step[advStepNo].stopT) {
					myCh->op.code = C_STOP_TIME;
					rtn = 1; break;
				}
			}

			if(myCh->op.checkDelayTime < 180) break;
			
			if(myPs->testCond[bd][ch].step[advStepNo].stopV != 0) {
				if(myCh->op.Vsens >=
					myPs->testCond[bd][ch].step[advStepNo].stopV) {
					myCh->op.code = C_STOP_VOLTAGE;
					rtn = 1; break;
				}
			}

			if(myPs->testCond[bd][ch].step[advStepNo].stopI != 0) {
				if(myCh->op.Isens <=
					myPs->testCond[bd][ch].step[advStepNo].stopI) {
					myCh->op.code = C_STOP_CURRENT;
					rtn = 1; break;
				}
			}

			if(myPs->testCond[bd][ch].step[advStepNo].stopC != 0) {
				if(capacity >=
					myPs->testCond[bd][ch].step[advStepNo].stopC) {
					myCh->op.code = C_STOP_CAPACITY;
					rtn = 1; break;
				}
			}

			if(myPs->testCond[bd][ch].step[advStepNo].stopP != 0) {
				if(myCh->op.watt >=
					myPs->testCond[bd][ch].step[advStepNo].stopP) {
					myCh->op.code = C_STOP_POWER;
					rtn = 1; break;
				}
			}

			if(myPs->testCond[bd][ch].step[advStepNo].stopWh != 0) {
				if(myCh->op.wattHour >=
					myPs->testCond[bd][ch].step[advStepNo].stopWh) {
					myCh->op.code = C_STOP_WATTHOUR;
					rtn = 1; break;
				}
			}
			break;
    	case STEP_DISCHARGE:
			if(myPs->testCond[bd][ch].step[advStepNo].stopT != 0) {
				if(myCh->op.runTime >=
					myPs->testCond[bd][ch].step[advStepNo].stopT) {
					myCh->op.code = C_STOP_TIME;
					rtn = 1; break;
				}
			}

			if(myCh->op.checkDelayTime < 180) break;

			if(myPs->testCond[bd][ch].step[advStepNo].stopV != 0) {
				if(myCh->op.Vsens <=
					myPs->testCond[bd][ch].step[advStepNo].stopV) {
					myCh->op.code = C_STOP_VOLTAGE;
					rtn = 1; break;
				}
			}

			if(myPs->testCond[bd][ch].step[advStepNo].stopI != 0) {
				if(myCh->op.Isens >=
					myPs->testCond[bd][ch].step[advStepNo].stopI * (-1)) {
					myCh->op.code = C_STOP_CURRENT;
					rtn = 1; break;
				}
			}

			if(myPs->testCond[bd][ch].step[advStepNo].stopC != 0) {
				if(capacity >=
					myPs->testCond[bd][ch].step[advStepNo].stopC) {
					myCh->op.code = C_STOP_CAPACITY;
					rtn = 1; break;
				}
			}

			if(myPs->testCond[bd][ch].step[advStepNo].stopP != 0) {
				if(myCh->op.watt >=
					myPs->testCond[bd][ch].step[advStepNo].stopP) {
					myCh->op.code = C_STOP_POWER;
					rtn = 1; break;
				}
			}

			if(myPs->testCond[bd][ch].step[advStepNo].stopWh != 0) {
				if(myCh->op.wattHour >=
					myPs->testCond[bd][ch].step[advStepNo].stopWh) {
					myCh->op.code = C_STOP_WATTHOUR;
					rtn = 1; break;
				}
			}
			break;
		default: break;
	}

	if(rtn == 1) { //stop
		myCh->op.select = SAVE_FLAG_SAVING_END;
		myCh->op.phase = P100;
		cNextStepCheck(bd, ch);
	}
}

int Save_Condition(int bd, int ch, unsigned long advStepNo)
{
	int rtn = 100;
	int save10ms, save50ms, save100ms;
	unsigned long saveDt, saveDi, cvtVal, saveCondCheckTime;
	long tmpL, LimitOffFlag;

	//190901 lyhw
	if(myData->DataSave.config.saveCond_Check_time != 0){
		saveCondCheckTime = myData->DataSave.config.saveCond_Check_time;
		//데이터 기록조건 설정시간 마다 체크
			if(myCh->op.runTime % saveCondCheckTime != 0) return rtn;
	}else{
		saveCondCheckTime = 0;
	}
		
	myCh = &(myData->bData[bd].cData[ch]);

	save10ms = myData->DataSave.config.save_10ms_time; 
	save50ms = myData->DataSave.config.save_50ms_time; 
	LimitOffFlag = myData->bData[bd].cData[ch].misc.saveDtConfig;
	//160328 oys modify : 100ms Max 1min
	save100ms = myData->DataSave.config.save_100ms_time;
	
	//20190214 SK 100ms LimitOff
	if(VENDER == 3 && LimitOffFlag == 0)  save100ms = 0;
	//20210204 LG 100ms LimitOff
	if(VENDER == 1 && LimitOffFlag == 1)  save100ms = 0;

	saveDt = myPs->testCond[bd][ch].step[advStepNo].saveDt;
	
	saveDi = myPs->testCond[bd][ch].step[advStepNo].saveDi;
	cvtVal = Convert_C_rate_to_I_value(bd, ch, saveDi);
	if(cvtVal != 0)
		saveDi = cvtVal;
	
	if(saveDt != 0){
		if(myPs->config.rt_scan_type == RT_SCAN_PERIOD_10mS) {
//			if(myCh->op.runTime == 0)
//				return rtn;	
			if(myData->DataSave.config.save_data_type == P0){
				if(save100ms != 0){	
					if(saveDt < 10)
						saveDt = 10;
					if(myCh->op.runTime > save100ms){
						if(saveDt < 100)
							saveDt = 100;
					}
				}else{
					if(saveDt < 10)
						saveDt = 10;
				}
			}else{
				if(saveDt >= 10){
					if(save100ms != 0){	
						if(myCh->op.runTime > save100ms){
							if(saveDt < 100)
								saveDt = 100;
						}
					}
				}else{
					if(save10ms != 0){	
						if(myCh->op.runTime > save10ms){
							if(saveDt < 5)
								saveDt = 5;
						}
					}
					if(save50ms != 0){	
						if(myCh->op.runTime > save50ms){
							if(saveDt < 10)
								saveDt = 10;
						}
					}
					if(save100ms != 0){	
						if(myCh->op.runTime > save100ms){
							if(saveDt < 100)
								saveDt = 100;
						}
					}
				}
			}
		} else {
			if(save100ms != 0){	
				if(saveDt < 10)
					saveDt = 10;
				if(myCh->op.runTime > save100ms){
					if(saveDt < 100)
						saveDt = 100;
				}
			}else{
				if(saveDt < 10)
					saveDt = 10;
			}
		}
	}
	
	if(myPs->testCond[bd][ch].step[advStepNo].saveDv != 0) {
   		tmpL = myCh->op.Vsens - 
				myCh->misc.saveDv;
		if(labs(tmpL) >= myPs->testCond[bd][ch].step[advStepNo].saveDv) {
			myCh->misc.saveDv = 
					myCh->op.Vsens;
			rtn = SAVE_DELTA_V;
		}
	}
	if(myCh->ChAttribute.chNo_master == 0) {
		if(saveDi != 0) {
   			tmpL = (myCh->op.Isens + 
					myData->bData[bd].cData[ch-1].op.Isens)
					- myCh->misc.saveDi;
			if(labs(tmpL) >= saveDi) {
				myCh->misc.saveDi = 
   					 (myCh->op.Isens + 
					  myData->bData[bd].cData[ch-1].op.Isens);
				rtn = SAVE_DELTA_I;
			}
		}

		if(myPs->testCond[bd][ch].step[advStepNo].saveDtemp != 0) {
   			tmpL = myData->bData[bd].cData[ch-1].op.temp 
						- myCh->misc.saveDtemp;
			if(labs(tmpL) >= myPs->testCond[bd][ch].step[advStepNo].saveDtemp) {
   				myCh->misc.saveDtemp = 
						myData->bData[bd].cData[ch-1].op.temp;
				rtn = SAVE_DELTA_TEMP;
			}
		}

	} else {	
		if(saveDi != 0) {
   			tmpL = myCh->op.Isens - 
					myCh->misc.saveDi;
			if(labs(tmpL) >= saveDi) {
				myCh->misc.saveDi = 
						myCh->op.Isens;
				rtn = SAVE_DELTA_I;
			}
		}

		if(myPs->testCond[bd][ch].step[advStepNo].saveDtemp != 0) {
   			tmpL = myCh->op.temp - 
					myCh->misc.saveDtemp;
			if(labs(tmpL) >= myPs->testCond[bd][ch].step[advStepNo].saveDtemp) {
   				myCh->misc.saveDtemp = 
						myCh->op.temp;
				rtn = SAVE_DELTA_TEMP;
			}
		}
	}
	if(myCh->op.runTime < 1 
		&& myPs->config.rt_scan_type == RT_SCAN_PERIOD_10mS){
		rtn = SAVE_START;
	}else if(myCh->op.runTime < 10
		&& myPs->config.rt_scan_type != RT_SCAN_PERIOD_10mS){
		rtn = SAVE_START;	
	}else{
		if(saveDt != 0 && myCh->misc.saveDt != myCh->op.runTime) {
			tmpL = myCh->op.runTime - myCh->misc.saveDt;
			if(tmpL >= saveDt) {
				myCh->misc.saveDt = myCh->op.runTime;
				rtn = SAVE_DELTA_T;
			}
		}
	}
	if(VENDER == 2) {
		if(saveDt > 10){
			if(myCh->op.runTime == 10){
				rtn = SAVE_DELTA_T;
			}
		}
	}
	return rtn;
}

//20180329 sch add "if(myCh->op.phase != 50)break;" for omission
void cEndCond(int bd, int ch)
{
	unsigned char type;
	unsigned long	advStepNo;
	long saveDt;
	int i, j, mode, rtn = NORMAL_COND;
	int k, GotoCount;

	S_CH_STEP_INFO step;

	myCh = &(myData->bData[bd].cData[ch]);
	myTestCond = &(myPs->testCond[bd][ch]);
	
	if(myCh->op.state != C_RUN) return;
	if(myCh->ChAttribute.opType == P1) return;

	step = step_info(bd, ch);
	
	advStepNo = step.advStepNo;
	type = step.type;
	mode = step.mode;
	k = GotoCount = 0;
	
	saveDt = myPs->testCond[bd][ch].step[advStepNo].saveDt;

	switch(type) {
		case STEP_OCV:
			if(myCh->op.phase != P50) break;
			rtn = cEndCond_Ocv(bd, ch, rtn, advStepNo);
			break;
		case STEP_REST:
			if(myCh->op.phase != P50) break;
			if(myCh->ChAttribute.chNo_master == P0) //kjiw
				rtn = cEndCond_Rest_P(bd, ch, rtn, advStepNo);
			else
				rtn = cEndCond_Rest(bd, ch, rtn, advStepNo);
			if(rtn != NORMAL_COND) break;

#if AUX_CONTROL == 1
	#if NETWORK_VERSION >= 4103
			rtn = cEndCond_Aux(bd, ch);
			if(rtn != NORMAL_COND) break;
	#endif
#endif

			rtn = cEndCond_Cycle_Common(bd, ch, rtn);
			if(rtn != NORMAL_COND) break;
			rtn = Save_Condition(bd, ch, advStepNo);
			break;
    	case STEP_CHARGE:
			if(myCh->op.phase != P50) break;
			if(myCh->ChAttribute.chNo_master == P0) //kjiw
				rtn = cEndCond_Charge_P(bd, ch, rtn, advStepNo);
			else
				rtn = cEndCond_Charge(bd, ch, rtn, advStepNo);
			if(rtn != NORMAL_COND) break;

#if AUX_CONTROL == 1
	#if NETWORK_VERSION >= 4103
			rtn = cEndCond_Aux(bd, ch);
			if(rtn != NORMAL_COND) break;
	#endif
#endif
			
			rtn = cEndCond_Cycle_Common(bd, ch, rtn);
			if(rtn != NORMAL_COND) break;
			rtn = Save_Condition(bd, ch, advStepNo);
			break;
    	case STEP_DISCHARGE:
			if(myCh->op.phase != P50) break;
			if(myCh->ChAttribute.chNo_master == P0) //kjiw
				rtn = cEndCond_Discharge_P(bd, ch, rtn, advStepNo);
			else
				rtn = cEndCond_Discharge(bd, ch, rtn, advStepNo);
			if(rtn != NORMAL_COND) break;

#if AUX_CONTROL == 1
	#if NETWORK_VERSION >= 4103
			rtn = cEndCond_Aux(bd, ch);
			if(rtn != NORMAL_COND) break;
	#endif
#endif
			
			rtn = cEndCond_Cycle_Common(bd, ch, rtn);
			if(rtn != NORMAL_COND) break;
			rtn = Save_Condition(bd, ch, advStepNo);
			break;
    	case STEP_Z:
			if(myCh->op.phase != P50) break;
			if(myCh->ChAttribute.chNo_master == P0) //kjiw
				rtn = cEndCond_Z_P(bd, ch, rtn, advStepNo);
			else
				rtn = cEndCond_Z(bd, ch, rtn, advStepNo);
			if(rtn != NORMAL_COND) break;

#if AUX_CONTROL == 1
	#if NETWORK_VERSION >= 4103
			rtn = cEndCond_Aux(bd, ch);
			if(rtn != NORMAL_COND) break;
	#endif
#endif
			
			rtn = cEndCond_Cycle_Common(bd, ch, rtn);
			if(rtn != NORMAL_COND) break;
			rtn = Save_Condition(bd, ch, advStepNo);
			break;
		case STEP_USER_PATTERN:
			if(myCh->op.phase != P50) break;
			if(myCh->ChAttribute.chNo_master == P0) //kjiw
				rtn = cEndCond_User_Pattern_P(bd, ch, rtn, advStepNo);
			else
				rtn = cEndCond_User_Pattern(bd, ch, rtn, advStepNo);
			if(rtn != NORMAL_COND) break;

#if AUX_CONTROL == 1
	#if NETWORK_VERSION >= 4103
			rtn = cEndCond_Aux(bd, ch);
			if(rtn != NORMAL_COND) break;
	#endif
#endif

			rtn = cEndCond_Cycle_Common(bd, ch, rtn);
			if(rtn != NORMAL_COND) break;
			rtn = Save_Condition(bd, ch, advStepNo);
			break;
		case STEP_USER_MAP:
			if(myCh->op.phase != P50) break;
			rtn = cEndCond_User_Map(bd, ch, rtn, advStepNo);
			if(rtn != NORMAL_COND) break;

#if AUX_CONTROL == 1
	#if NETWORK_VERSION >= 4103
			rtn = cEndCond_Aux(bd, ch);
			if(rtn != NORMAL_COND) break;
	#endif
#endif
			rtn = cEndCond_Cycle_Common(bd, ch, rtn);
			if(rtn != NORMAL_COND) break;
			rtn = Save_Condition(bd, ch, advStepNo);
			break;
#if MACHINE_TYPE == 1
		//140407 oys add
		case STEP_SHORT:
			if(myCh->op.phase != P50) break;
			rtn = cEndCond_Short(bd, ch, rtn, advStepNo);
	#if AUX_CONTROL == 1
		#if NETWORK_VERSION >= 4103
			rtn = cEndCond_Aux(bd, ch);
			if(rtn != NORMAL_COND) break;
		#endif
	#endif
			if(rtn != NORMAL_COND) break;
			rtn = cEndCond_Cycle_Common(bd, ch, rtn);
			if(rtn != NORMAL_COND) break;
			rtn = Save_Condition(bd, ch, advStepNo);
			break;
#endif
		case STEP_ACIR:
			if(myCh->op.phase != P50) break;
			rtn = cEndCond_Acir(bd, ch, rtn, advStepNo);
			break;
		default:
			rtn = 100; //don't process
			break;
	}

#if CHAMBER_TEMP_HUMIDITY == 1
	if(rtn == END_COND){
		if(myCh->op.type == STEP_CHARGE){
			myCh->misc.chargeAccAh += myCh->op.charge_ampareHour;
		}else if(myCh->op.type == STEP_DISCHARGE){
			myCh->misc.dischargeAccAh += myCh->op.discharge_ampareHour;
		}
	}
	if(rtn == END_COND && myCh->op.type == STEP_DISCHARGE){
		rtn = cEndCond_FaultCheck(bd, ch, rtn, advStepNo);
	}
#endif
	//20200309 lyhw add 
	if(rtn == END_COND && myCh->ChAttribute.opType == P0){
		rtn = cEndCond_FaultCheck(bd, ch, rtn, advStepNo);
	}

#ifdef _GROUP_ERROR
	if(rtn == END_COND){
		if(myCh->misc.endState == P0 && myCh->misc.stepSyncFlag != 0){
			myCh->misc.endState = P1;	//220203_hun
			myCh->misc.groupEndTime = myCh->op.runTime;
		}
	}
#endif
#if CAPACITY_CONTROL == 1
	if(rtn == 100){ //210402
	} else if(type == STEP_CHARGE || STEP_DISCHARGE){
		if(myPs->testCond[bd][ch].step[advStepNo].UseCheckCapaFlag != 0) {
			myCh->misc.C_Rate_stepCapacity[advStepNo] = myCh->op.ampareHour;
		}
	}
#endif
#ifdef _TRACKING_MODE
	if(rtn == 100){ //SOC
	}else if(myPs->testCond[bd][ch].step[advStepNo].rptSOC !=0){
		if(type == STEP_CHARGE){
			myCh->op.ampareHour_SOC = myCh->op.charge_ampareHour;
			myCh->misc.socTrackingStep = advStepNo; //SOC ref Step
			
		}else if(type == STEP_DISCHARGE){
			myCh->op.ampareHour_SOC = myCh->op.discharge_ampareHour;
			myCh->misc.socTrackingStep = advStepNo; //SOC ref Step
		}else{
		}
	}
	if(rtn == 100){ //SOH 211022
	}else if(myPs->testCond[bd][ch].step[advStepNo].rptSOH !=0){
		if(type == STEP_CHARGE){
			myCh->op.ampareHour_SOH = myCh->op.charge_ampareHour;
			myCh->misc.sohTrackingStep = advStepNo; //SOC ref Step
			
		}else if(type == STEP_DISCHARGE){
			myCh->op.ampareHour_SOH = myCh->op.discharge_ampareHour;
			myCh->misc.sohTrackingStep = advStepNo; //SOC ref Step
		}else{
		}
	}
#endif

	if(rtn == 100) { //don't process
	} else if(rtn == FAULT_COND) { //fault
		myCh->op.select = SAVE_FLAG_SAVING_ETC;
		if(myData->DataSave.config.save_data_type == P0) {
			if(myCh->ChAttribute.opType == P0) {
				send_save_msg(bd, ch, saveDt, 0);
			}
		}
		if(myCh->misc.tempWaitType == P0){
			myCh->misc.chGroupNo = 0;		//kjc_210825
			myCh->misc.stepSyncFlag = P0;	//kjc_210825
			myCh->misc.endState = P0;		//220203_hun
			myCh->misc.groupAvgVsens = 0;	//220203_hun
			myCh->misc.group_StartVoltage_flag = 0;
		}
		myCh->op.phase = P100;
	} else if(rtn == END_COND) { //end
		//20171212 sch add
		if(myPs->testCond[bd][ch].step[advStepNo].noTempWaitFlag == P0){
			myCh->misc.refTemp_backup 
				= myPs->testCond[bd][ch].step[advStepNo].refTemp;
			//20190626 add for parallel Temp Wait
			if(myCh->ChAttribute.chNo_master == P0){
				myData->bData[bd].cData[ch-1].misc.refTemp_backup
					= myCh->misc.refTemp_backup;
			}
		}
	//120818 kji SDI mes cycle data
		if(myPs->config.function[F_SDI_MES_USE] == P1){
			myCh->misc.mes_data_flag = 1;
			if(type == STEP_REST) {
				myCh->misc.lastRestVsens = myCh->op.Vsens;
			}
		}
		//pjy add for toshiba
		if(myData->mData.testCond[bd][ch].step[advStepNo].integralCapFlag == 1){
			if(myCh->ChAttribute.chNo_master == P0) { //kjiw
				if(type == STEP_CHARGE) {
					myCh->misc.charge_integralCap[myCh->misc.cycleNo-1]=
					(myCh->misc.charge_integralCap[myCh->misc.cycleNo-1]) 
					+ (myData->bData[bd].cData[ch].op.ampareHour)
					+ (myData->bData[bd].cData[ch-1].op.ampareHour);
				}
				if(type == STEP_DISCHARGE || type == STEP_Z) {
					myCh->misc.discharge_integralCap[myCh->misc.cycleNo-1]=
					(myCh->misc.discharge_integralCap[myCh->misc.cycleNo-1]) 
					+ (myData->bData[bd].cData[ch].op.ampareHour)
					+ (myData->bData[bd].cData[ch-1].op.ampareHour);
				}
				if(type == STEP_USER_PATTERN || type == STEP_USER_MAP) {
					if(myData->bData[bd].cData[ch].op.ampareHour > 0) {
						myCh->misc.charge_integralCap[myCh->misc.cycleNo-1]=
						(myCh->misc.charge_integralCap[myCh->misc.cycleNo-1]) 
						+ (myData->bData[bd].cData[ch].op.ampareHour)
						+ (myData->bData[bd].cData[ch-1].op.ampareHour);
					}else {
						myCh->misc.discharge_integralCap[myCh->misc.cycleNo-1]=
						(myCh->misc.discharge_integralCap[myCh->misc.cycleNo-1]) 
						+ (labs(myData->bData[bd].cData[ch].op.ampareHour))
						+ (labs(myData->bData[bd].cData[ch-1].op.ampareHour));

					}
				}
			}else{
				if(type == STEP_CHARGE) {
					myCh->misc.charge_integralCap[myCh->misc.cycleNo-1] 
					+= myData->bData[bd].cData[ch].op.ampareHour;
				}
				if(type == STEP_DISCHARGE || type == STEP_Z) {
					myCh->misc.discharge_integralCap[myCh->misc.cycleNo-1] 
					+= myData->bData[bd].cData[ch].op.ampareHour;
				}
				if(type == STEP_USER_PATTERN || type == STEP_USER_MAP) {
					if(myData->bData[bd].cData[ch].op.ampareHour > 0) {
						myCh->misc.charge_integralCap[myCh->misc.cycleNo-1] +=
						(myData->bData[bd].cData[ch].op.ampareHour);
					}else {
						myCh->misc.discharge_integralCap[myCh->misc.cycleNo-1] 
							+=(labs(myData->bData[bd].cData[ch].op.ampareHour));
					}
				}
			}
		}//end of add
		myCh->op.grade = cGrading(bd, ch, 0, GRADE_NONE);
		if(myCh->ChAttribute.chNo_master == P0)
			myData->bData[bd].cData[ch-1].op.grade = myCh->op.grade;
		#ifdef _JIG_TYPE_1
		if(myData->mData.testCond[bd][ch].step[advStepNo].type == STEP_Z) {
			if(myPs->config.hwSpec == L_5V_200A_1CH_JIG) {
				if(myCh->op.grade == 0) {
					myPs->signal[M_SIG_JIG_FAIL_LAMP] = P1;		 
					myPs->signal[M_SIG_JIG_BUZZER]  = P1;
				} else  {
					myPs->signal[M_SIG_JIG_PASS_LAMP] = P1;		 
				}
			}
		}
		#endif
		
		myCh->op.select = SAVE_FLAG_SAVING_END;
		if(myCh->ChAttribute.chNo_master == 0) //kjiw
		{	
			myData->bData[bd].cData[ch-1].op.select = 
				myCh->op.select;
		}
		if(myPs->config.capacityType == CAPACITY_AMPARE_HOURS) {
			myPs->testCond[bd][ch].step[advStepNo].socStepCap
				= labs(myCh->op.ampareHour);
			if(myCh->ChAttribute.chNo_master == 0) //kjiw
			{	
				myPs->testCond[bd][ch].step[advStepNo].socStepCap
					+= labs(myData->bData[bd].cData[ch-1].op.ampareHour);
			}
		} else if(myPs->config.capacityType == CAPACITY_CAPACITANCE) {
			myPs->testCond[bd][ch].step[advStepNo].socStepCap
				= myCh->op.capacitance;
			if(myCh->ChAttribute.chNo_master == 0) //kjiw
			{
				myPs->testCond[bd][ch].step[advStepNo].socStepCap
					+= labs(myData->bData[bd].cData[ch-1].op.capacitance);
			}	
		}
//151214 oys w : Capacity, Energy(WH), DCIR Efficiency End =====================
//160510 oys modify
//170501 oys modify : Add Energy(WH), DCIR Efficiency end
		myPs->testCond[bd][ch].step[advStepNo].socStepPower
			= myCh->op.wattHour;
		myPs->testCond[bd][ch].step[advStepNo].socStepZ
			= myCh->op.z;
		if(myCh->misc.efficiency_pause_flag == P0)
			EfficiencyEnd(bd, ch, advStepNo, type);
// add end ====================================================================
		// 10mS Data Save Process
		if(myCh->ChAttribute.opType == P0) {
			if(myData->DataSave.config.save_data_type == P1) {
				if(myCh->ChAttribute.chNo_master == 0) {
					myData->bData[bd].cData[ch-1].op.code = myCh->op.code; 
					myData->bData[bd].cData[ch-1].misc.saveDt = myCh->op.runTime;
				}
				send_save_msg(bd, ch, saveDt, 0);
			}else{
				if(myCh->ChAttribute.chNo_master == 0) {
					myData->bData[bd].cData[ch-1].op.code = myCh->op.code; 
				}
				send_save_msg(bd, ch, saveDt, 0);
			}
		}
		
		#ifdef _END_COMPARE_GOTO
		//210511 LJS FOR LGES END GOTO ADD
		for(k=0; k<MAX_COMP_GOTO; k++){
			if(myTestCond->step[advStepNo].endCompGoto[k].type &&
				myTestCond->step[advStepNo].endCompGoto[k].value &&
				myTestCond->step[advStepNo].endCompGoto[k].sign &&
				myTestCond->step[advStepNo].endCompGoto[k].gotoStepNo != 0)
				GotoCount++;		
		}
		#endif
		
		if(myCh->op.code == C_END_VOLTAGE){ //endV Goto
			if(myPs->testCond[bd][ch].step[advStepNo].endVGoto != 0) {
				if(myPs->testCond[bd][ch].step[advStepNo].balanceStepCheck)
					myPs->testCond[bd][ch].step[advStepNo].type = STEP_BALANCE;
				myCh->misc.advStepNo
					= myPs->testCond[bd][ch].step[advStepNo].endVGoto-1;
				if(myCh->ChAttribute.chNo_master == P0)
				{
					if(myPs->testCond[bd][ch-1].step[advStepNo].balanceStepCheck)
						myPs->testCond[bd][ch-1].step[advStepNo].type = STEP_BALANCE;
					myData->bData[bd].cData[ch-1].op.code = 
							myCh->op.code; 
					myData->bData[bd].cData[ch-1].op.phase = 
							myCh->op.phase; 
					myData->bData[bd].cData[ch-1].misc.advStepNo =
							myCh->misc.advStepNo;
					cStepGoto(bd, ch-1);
					myCh = &(myData->bData[bd].cData[ch]);
				}
				cStepGoto(bd, ch);
			#ifdef _END_COMPARE_GOTO
			}else if(GotoCount != 0){
				rtn = gotoStepCheck(bd, ch); //210511 LJS
				if(rtn == 0){
					myCh->op.phase = P100;
				}else{
					myCh->misc.advStepNo = myPs->testCond[bd][ch].
						step[advStepNo].endCompGoto[rtn - 1].gotoStepNo-1;
					if(myCh->ChAttribute.chNo_master == P0)
					{
						myData->bData[bd].cData[ch-1].op.code = 
								myCh->op.code; 
						myData->bData[bd].cData[ch-1].op.phase = 
								myCh->op.phase; 
						myData->bData[bd].cData[ch-1].misc.advStepNo =
								myCh->misc.advStepNo;
						cStepGoto(bd, ch-1);
						myCh = &(myData->bData[bd].cData[ch]);
					}
					cStepGoto(bd, ch);
				}
			#endif
			}else{
				myCh->op.phase = P100;
			}
		}else if(myCh->op.code == C_END_CURRENT){
			if(myPs->testCond[bd][ch].step[advStepNo].endIGoto != 0) {
				if(myPs->testCond[bd][ch].step[advStepNo].balanceStepCheck)
					myPs->testCond[bd][ch].step[advStepNo].type = STEP_BALANCE;
				myCh->misc.advStepNo
					= myPs->testCond[bd][ch].step[advStepNo].endIGoto-1;
				if(myCh->ChAttribute.chNo_master == P0)
				{
					if(myPs->testCond[bd][ch-1].step[advStepNo].balanceStepCheck)
						myPs->testCond[bd][ch-1].step[advStepNo].type = STEP_BALANCE;
					myData->bData[bd].cData[ch-1].op.code = 
							myCh->op.code; 
					myData->bData[bd].cData[ch-1].op.phase = 
							myCh->op.phase; 
					myData->bData[bd].cData[ch-1].misc.advStepNo =
							myCh->misc.advStepNo;
					cStepGoto(bd, ch-1);
					myCh = &(myData->bData[bd].cData[ch]);
				}
				cStepGoto(bd, ch);
			#ifdef _END_COMPARE_GOTO
			}else if(GotoCount != 0){
				rtn = gotoStepCheck(bd, ch); //210511 LJS
				if(rtn == 0){
					myCh->op.phase = P100;
				}else{
					myCh->misc.advStepNo = myPs->testCond[bd][ch].
						step[advStepNo].endCompGoto[rtn - 1].gotoStepNo-1;
					if(myCh->ChAttribute.chNo_master == P0)
					{
						myData->bData[bd].cData[ch-1].op.code = 
								myCh->op.code; 
						myData->bData[bd].cData[ch-1].op.phase = 
								myCh->op.phase; 
						myData->bData[bd].cData[ch-1].misc.advStepNo =
								myCh->misc.advStepNo;
						cStepGoto(bd, ch-1);
						myCh = &(myData->bData[bd].cData[ch]);
					}
					cStepGoto(bd, ch);
				}
			#endif
			}else{
				myCh->op.phase = P100;
			}
		}else if(myCh->op.code == C_END_CVTIME){
			if(myPs->testCond[bd][ch].step[advStepNo].endTCVGoto !=0){
				if(myPs->testCond[bd][ch].step[advStepNo].balanceStepCheck)
					myPs->testCond[bd][ch].step[advStepNo].type = STEP_BALANCE;
				myCh->misc.advStepNo
					= myPs->testCond[bd][ch].step[advStepNo].endTCVGoto-1;
				if(myCh->ChAttribute.chNo_master == P0)
				{
					if(myPs->testCond[bd][ch-1].step[advStepNo].balanceStepCheck)
						myPs->testCond[bd][ch-1].step[advStepNo].type = STEP_BALANCE;
					myData->bData[bd].cData[ch-1].op.code = 
							myCh->op.code; 
					myData->bData[bd].cData[ch-1].op.phase = 
							myCh->op.phase; 
					myData->bData[bd].cData[ch-1].misc.advStepNo =
							myCh->misc.advStepNo;
					cStepGoto(bd, ch-1);
					myCh = &(myData->bData[bd].cData[ch]);
				}
				cStepGoto(bd,ch);
			#ifdef _END_COMPARE_GOTO
			}else if(GotoCount != 0){
				rtn = gotoStepCheck(bd, ch); //210511 LJS
				if(rtn == 0){
					myCh->op.phase = P100;
				}else{
					myCh->misc.advStepNo = myPs->testCond[bd][ch].
						step[advStepNo].endCompGoto[rtn - 1].gotoStepNo-1;
					if(myCh->ChAttribute.chNo_master == P0)
					{
						myData->bData[bd].cData[ch-1].op.code = 
								myCh->op.code; 
						myData->bData[bd].cData[ch-1].op.phase = 
								myCh->op.phase; 
						myData->bData[bd].cData[ch-1].misc.advStepNo =
								myCh->misc.advStepNo;
						cStepGoto(bd, ch-1);
						myCh = &(myData->bData[bd].cData[ch]);
					}
					cStepGoto(bd, ch);
				}
			#endif
			}else{
				myCh->op.phase = P100;
			}
		}else if(myCh->op.code == C_END_TEMP){
			if(myPs->testCond[bd][ch].step[advStepNo].endTempGoto != 0) {
				if(myPs->testCond[bd][ch].step[advStepNo].balanceStepCheck)
					myPs->testCond[bd][ch].step[advStepNo].type = STEP_BALANCE;
				myCh->misc.advStepNo
					= myPs->testCond[bd][ch].step[advStepNo].endTempGoto-1;
				if(myCh->ChAttribute.chNo_master == P0)
				{
					if(myPs->testCond[bd][ch-1].step[advStepNo].balanceStepCheck)
						myPs->testCond[bd][ch-1].step[advStepNo].type = STEP_BALANCE;
					myData->bData[bd].cData[ch-1].op.code = 
							myCh->op.code; 
					myData->bData[bd].cData[ch-1].op.phase = 
							myCh->op.phase; 
					myData->bData[bd].cData[ch-1].misc.advStepNo =
							myCh->misc.advStepNo;
				
					cStepGoto(bd, ch-1);
					myCh = &(myData->bData[bd].cData[ch]);
				}	
				cStepGoto(bd, ch);
			#ifdef _END_COMPARE_GOTO
			}else if(GotoCount != 0){
				rtn = gotoStepCheck(bd, ch); //210511 LJS
				if(rtn == 0){
					myCh->op.phase = P100;
				}else{
					myCh->misc.advStepNo = myPs->testCond[bd][ch].
						step[advStepNo].endCompGoto[rtn - 1].gotoStepNo-1;
					if(myCh->ChAttribute.chNo_master == P0)
					{
						myData->bData[bd].cData[ch-1].op.code = 
								myCh->op.code; 
						myData->bData[bd].cData[ch-1].op.phase = 
								myCh->op.phase; 
						myData->bData[bd].cData[ch-1].misc.advStepNo =
								myCh->misc.advStepNo;
						cStepGoto(bd, ch-1);
						myCh = &(myData->bData[bd].cData[ch]);
					}
					cStepGoto(bd, ch);
				}
			#endif
			}else{
				myCh->op.phase = P100;
			}
		}else if(myCh->op.code == C_END_AUX_TEMP
				|| myCh->op.code == C_END_AUX_VOLTAGE){ //181207
#if AUX_CONTROL == 1
	#if NETWORK_VERSION >= 4103 
			if(myData->auxMisc.auxGoto[bd][ch] != 0) {
				if(myPs->testCond[bd][ch].step[advStepNo].balanceStepCheck)
					myPs->testCond[bd][ch].step[advStepNo].type = STEP_BALANCE;
				myCh->misc.advStepNo
					= myData->auxMisc.auxGoto[bd][ch] - 1;
				//	= myPs->testCond[bd][ch].step[advStepNo].endTempGoto-1;
				if(myCh->ChAttribute.chNo_master == P0)
				{
					if(myPs->testCond[bd][ch-1].step[advStepNo].balanceStepCheck)
						myPs->testCond[bd][ch-1].step[advStepNo].type = STEP_BALANCE;
					myData->bData[bd].cData[ch-1].op.code = 
							myCh->op.code; 
					myData->bData[bd].cData[ch-1].op.phase = 
							myCh->op.phase; 
					myData->bData[bd].cData[ch-1].misc.advStepNo =
							myCh->misc.advStepNo;
				
					cStepGoto(bd, ch-1);
					myCh = &(myData->bData[bd].cData[ch]);
				}	
				cStepGoto(bd, ch);
			#ifdef _END_COMPARE_GOTO
			}else if(GotoCount != 0){
				rtn = gotoStepCheck(bd, ch); //210511 LJS
				if(rtn == 0){
					myCh->op.phase = P100;
				}else{
					myCh->misc.advStepNo = myPs->testCond[bd][ch].
						step[advStepNo].endCompGoto[rtn - 1].gotoStepNo-1;
					if(myCh->ChAttribute.chNo_master == P0)
					{
						myData->bData[bd].cData[ch-1].op.code = 
								myCh->op.code; 
						myData->bData[bd].cData[ch-1].op.phase = 
								myCh->op.phase; 
						myData->bData[bd].cData[ch-1].misc.advStepNo =
								myCh->misc.advStepNo;
						cStepGoto(bd, ch-1);
						myCh = &(myData->bData[bd].cData[ch]);
					}
					cStepGoto(bd, ch);
				}
			#endif
			}else{
				myCh->op.phase = P100;
			}
	#endif
#endif
		}else if(myCh->op.code == C_END_SOC || myCh->op.code == C_END_SOE){
			if(myPs->testCond[bd][ch].step[advStepNo].endSocGoto != 0) {
				if(myPs->testCond[bd][ch].step[advStepNo].balanceStepCheck)
					myPs->testCond[bd][ch].step[advStepNo].type = STEP_BALANCE;
				myCh->misc.advStepNo
					= myPs->testCond[bd][ch].step[advStepNo].endSocGoto-1;
				if(myCh->ChAttribute.chNo_master == P0)
				{
					if(myPs->testCond[bd][ch-1].step[advStepNo].balanceStepCheck)
						myPs->testCond[bd][ch-1].step[advStepNo].type = STEP_BALANCE;
					myData->bData[bd].cData[ch-1].op.code = 
							myCh->op.code; 
					myData->bData[bd].cData[ch-1].op.phase = 
							myCh->op.phase; 
					myData->bData[bd].cData[ch-1].misc.advStepNo =
							myCh->misc.advStepNo;
				
					cStepGoto(bd, ch-1);
					myCh = &(myData->bData[bd].cData[ch]);
				}	
				cStepGoto(bd, ch);
			#ifdef _END_COMPARE_GOTO
			}else if(GotoCount != 0){
				rtn = gotoStepCheck(bd, ch); //210511 LJS
				if(rtn == 0){
					myCh->op.phase = P100;
				}else{
					myCh->misc.advStepNo = myPs->testCond[bd][ch].
						step[advStepNo].endCompGoto[rtn - 1].gotoStepNo-1;
					if(myCh->ChAttribute.chNo_master == P0)
					{
						myData->bData[bd].cData[ch-1].op.code = 
								myCh->op.code; 
						myData->bData[bd].cData[ch-1].op.phase = 
								myCh->op.phase; 
						myData->bData[bd].cData[ch-1].misc.advStepNo =
								myCh->misc.advStepNo;
						cStepGoto(bd, ch-1);
						myCh = &(myData->bData[bd].cData[ch]);
					}
					cStepGoto(bd, ch);
				}
			#endif
			}else{
				myCh->op.phase = P100;
			}
		//201028_hun_AC_FAIL_RECOVERY
		}else if(myCh->op.code == C_END_TIME || myCh->op.code == C_END_Z){
			if(myPs->testCond[bd][ch].step[advStepNo].endTGoto != 0) {
				if(myPs->testCond[bd][ch].step[advStepNo].balanceStepCheck)
					myPs->testCond[bd][ch].step[advStepNo].type = STEP_BALANCE;
				myCh->misc.advStepNo
					= myPs->testCond[bd][ch].step[advStepNo].endTGoto-1;
				if(myCh->ChAttribute.chNo_master == P0)
				{
					if(myPs->testCond[bd][ch-1].step[advStepNo].balanceStepCheck)
						myPs->testCond[bd][ch-1].step[advStepNo].type = STEP_BALANCE;
					myData->bData[bd].cData[ch-1].op.code = 
							myCh->op.code; 
					myData->bData[bd].cData[ch-1].op.phase = 
							myCh->op.phase; 
					myData->bData[bd].cData[ch-1].misc.advStepNo =
							myCh->misc.advStepNo;
					cStepGoto(bd, ch-1);
					myCh = &(myData->bData[bd].cData[ch]);
				}	
				cStepGoto(bd, ch);
			#ifdef _END_COMPARE_GOTO
			}else if(GotoCount != 0){
				rtn = gotoStepCheck(bd, ch); //210511 LJS
				if(rtn == 0){
					myCh->op.phase = P100;
				}else{
					myCh->misc.advStepNo = myPs->testCond[bd][ch].
						step[advStepNo].endCompGoto[rtn - 1].gotoStepNo-1;
					if(myCh->ChAttribute.chNo_master == P0)
					{
						myData->bData[bd].cData[ch-1].op.code = 
								myCh->op.code; 
						myData->bData[bd].cData[ch-1].op.phase = 
								myCh->op.phase; 
						myData->bData[bd].cData[ch-1].misc.advStepNo =
								myCh->misc.advStepNo;
						cStepGoto(bd, ch-1);
						myCh = &(myData->bData[bd].cData[ch]);
					}
					cStepGoto(bd, ch);
				}
			#endif
			}else{
				myCh->op.phase = P100;
			}
//020414 ljsw
#if END_V_COMPARE_GOTO == 1
		}else if(myCh->op.code == C_END_T_V_UPPER){
			if(myPs->testCond[bd][ch].step[advStepNo].endVupper_GotoStep != 0) {
				if(myPs->testCond[bd][ch].step[advStepNo].balanceStepCheck)
					myPs->testCond[bd][ch].step[advStepNo].type = STEP_BALANCE;
				myCh->misc.advStepNo
					= myPs->testCond[bd][ch].step[advStepNo].endVupper_GotoStep - 1;
				if(myCh->ChAttribute.chNo_master == P0)
				{
					if(myPs->testCond[bd][ch-1].step[advStepNo].balanceStepCheck)
						myPs->testCond[bd][ch-1].step[advStepNo].type = STEP_BALANCE;
					myData->bData[bd].cData[ch-1].op.code = 
							myCh->op.code; 
					myData->bData[bd].cData[ch-1].op.phase = 
							myCh->op.phase; 
					myData->bData[bd].cData[ch-1].misc.advStepNo =
							myCh->misc.advStepNo;
					cStepGoto(bd, ch-1);
					myCh = &(myData->bData[bd].cData[ch]);
				}	
				cStepGoto(bd, ch);
			}else{
				myCh->op.phase = P100;
			}
		//ljs	
		}else if(myCh->op.code == C_END_T_V_LOWER){
			if(myPs->testCond[bd][ch].step[advStepNo].endVlower_GotoStep != 0) {
				if(myPs->testCond[bd][ch].step[advStepNo].balanceStepCheck)
					myPs->testCond[bd][ch].step[advStepNo].type = STEP_BALANCE;
				myCh->misc.advStepNo
					= myPs->testCond[bd][ch].step[advStepNo].endVlower_GotoStep - 1;
				if(myCh->ChAttribute.chNo_master == P0)
				{
					if(myPs->testCond[bd][ch-1].step[advStepNo].balanceStepCheck)
						myPs->testCond[bd][ch-1].step[advStepNo].type = STEP_BALANCE;
					myData->bData[bd].cData[ch-1].op.code = 
							myCh->op.code; 
					myData->bData[bd].cData[ch-1].op.phase = 
							myCh->op.phase; 
					myData->bData[bd].cData[ch-1].misc.advStepNo =
							myCh->misc.advStepNo;
					cStepGoto(bd, ch-1);
					myCh = &(myData->bData[bd].cData[ch]);
				}	
				cStepGoto(bd, ch);
			}else{
				myCh->op.phase = P100;
			}
#endif
#if CAPACITY_CONTROL == 1
		}else if(myCh->op.code == C_END_CYCLE_STD_CAPACITY_STEP_CAPACITY){
			if(myPs->testCond[bd][ch].step[advStepNo].endCycleCapaGoto != 0) {
				if(myPs->testCond[bd][ch].step[advStepNo].balanceStepCheck)
					myPs->testCond[bd][ch].step[advStepNo].type = STEP_BALANCE;
				myCh->misc.advStepNo
					= myPs->testCond[bd][ch].step[advStepNo].endCycleCapaGoto - 1;
				if(myCh->ChAttribute.chNo_master == P0)
				{
					if(myPs->testCond[bd][ch-1].step[advStepNo].balanceStepCheck)
						myPs->testCond[bd][ch-1].step[advStepNo].type = STEP_BALANCE;
					myData->bData[bd].cData[ch-1].op.code = 
							myCh->op.code; 
					myData->bData[bd].cData[ch-1].op.phase = 
							myCh->op.phase; 
					myData->bData[bd].cData[ch-1].misc.advStepNo =
							myCh->misc.advStepNo;
					cStepGoto(bd, ch-1);
					myCh = &(myData->bData[bd].cData[ch]);
				}	
				cStepGoto(bd, ch);
			}else{
				myCh->op.phase = P100;
			}
		}else if(myCh->op.code == C_END_CYCLE_STD_CAPACITY_STEP_CURRENT){
			if(myPs->testCond[bd][ch].step[advStepNo].endCycleCurrentGoto != 0) {
				if(myPs->testCond[bd][ch].step[advStepNo].balanceStepCheck)
					myPs->testCond[bd][ch].step[advStepNo].type = STEP_BALANCE;
				myCh->misc.advStepNo
					= myPs->testCond[bd][ch].step[advStepNo].endCycleCurrentGoto - 1;
				if(myCh->ChAttribute.chNo_master == P0)
				{
					if(myPs->testCond[bd][ch-1].step[advStepNo].balanceStepCheck)
						myPs->testCond[bd][ch-1].step[advStepNo].type = STEP_BALANCE;
					myData->bData[bd].cData[ch-1].op.code = 
							myCh->op.code; 
					myData->bData[bd].cData[ch-1].op.phase = 
							myCh->op.phase; 
					myData->bData[bd].cData[ch-1].misc.advStepNo =
							myCh->misc.advStepNo;
					cStepGoto(bd, ch-1);
					myCh = &(myData->bData[bd].cData[ch]);
				}	
				cStepGoto(bd, ch);
			}else{
				myCh->op.phase = P100;
			}
#endif
#if GAS_DATA_CONTROL == 1		//210923 lyhw 
		}else if(myCh->op.code == C_END_GAS_TVOC){
			if(myPs->testCond[bd][ch].step[advStepNo].endGasTVOC_Goto != 0) {
				if(myPs->testCond[bd][ch].step[advStepNo].balanceStepCheck)
					myPs->testCond[bd][ch].step[advStepNo].type = STEP_BALANCE;
				myCh->misc.advStepNo
					= myPs->testCond[bd][ch].step[advStepNo].endGasTVOC_Goto-1;
				if(myCh->ChAttribute.chNo_master == P0){
					if(myPs->testCond[bd][ch-1].step[advStepNo].balanceStepCheck)
						myPs->testCond[bd][ch-1].step[advStepNo].type = STEP_BALANCE;
					myData->bData[bd].cData[ch-1].op.code 
							= myCh->op.code; 
					myData->bData[bd].cData[ch-1].op.phase 
							= myCh->op.phase; 
					myData->bData[bd].cData[ch-1].misc.advStepNo 
							= myCh->misc.advStepNo;
				
					cStepGoto(bd, ch-1);
					myCh = &(myData->bData[bd].cData[ch]);
				}	
				cStepGoto(bd, ch);
			}else{
				myCh->op.phase = P100;
			}
		}else if(myCh->op.code == C_END_GAS_ECO2){
			if(myPs->testCond[bd][ch].step[advStepNo].endGasECo2_Goto != 0) {
				if(myPs->testCond[bd][ch].step[advStepNo].balanceStepCheck)
					myPs->testCond[bd][ch].step[advStepNo].type = STEP_BALANCE;
				myCh->misc.advStepNo
					= myPs->testCond[bd][ch].step[advStepNo].endGasECo2_Goto-1;
				if(myCh->ChAttribute.chNo_master == P0){
					if(myPs->testCond[bd][ch-1].step[advStepNo].balanceStepCheck)
						myPs->testCond[bd][ch-1].step[advStepNo].type = STEP_BALANCE;
					myData->bData[bd].cData[ch-1].op.code 
							= myCh->op.code; 
					myData->bData[bd].cData[ch-1].op.phase 
							= myCh->op.phase; 
					myData->bData[bd].cData[ch-1].misc.advStepNo 
							= myCh->misc.advStepNo;
				
					cStepGoto(bd, ch-1);
					myCh = &(myData->bData[bd].cData[ch]);
				}	
				cStepGoto(bd, ch);
			}else{
				myCh->op.phase = P100;
			}
#endif
		}else if(myCh->op.code == C_END_CAPACITY){
			if(myPs->testCond[bd][ch].step[advStepNo].endCGoto != 0) {
				if(myPs->testCond[bd][ch].step[advStepNo].balanceStepCheck)
					myPs->testCond[bd][ch].step[advStepNo].type = STEP_BALANCE;
				myCh->misc.advStepNo
					= myPs->testCond[bd][ch].step[advStepNo].endCGoto-1;
				if(myCh->ChAttribute.chNo_master == P0)
				{
					if(myPs->testCond[bd][ch-1].step[advStepNo].balanceStepCheck)
						myPs->testCond[bd][ch-1].step[advStepNo].type = STEP_BALANCE;
					myData->bData[bd].cData[ch-1].op.code = 
							myCh->op.code; 
					myData->bData[bd].cData[ch-1].op.phase = 
							myCh->op.phase; 
					myData->bData[bd].cData[ch-1].misc.advStepNo =
							myCh->misc.advStepNo;
					cStepGoto(bd, ch-1);
					myCh = &(myData->bData[bd].cData[ch]);
				}
				cStepGoto(bd, ch);
			#ifdef _END_COMPARE_GOTO
			}else if(GotoCount != 0){
				rtn = gotoStepCheck(bd, ch); //210511 LJS
				if(rtn == 0){
					myCh->op.phase = P100;
				}else{
					myCh->misc.advStepNo = myPs->testCond[bd][ch].
						step[advStepNo].endCompGoto[rtn - 1].gotoStepNo-1;
					if(myCh->ChAttribute.chNo_master == P0)
					{
						myData->bData[bd].cData[ch-1].op.code = 
								myCh->op.code; 
						myData->bData[bd].cData[ch-1].op.phase = 
								myCh->op.phase; 
						myData->bData[bd].cData[ch-1].misc.advStepNo =
								myCh->misc.advStepNo;
						cStepGoto(bd, ch-1);
						myCh = &(myData->bData[bd].cData[ch]);
					}
					cStepGoto(bd, ch);
				}
			#endif
			}else{
				myCh->op.phase = P100;
			}

		//160510 oys add
		}else if(myCh->op.code == C_END_CYCLE_CAPACITY
				 || myCh->op.code == C_END_CYCLE_CAPACITY_SOC
				 //170518 lyh
				 || myCh->op.code == C_END_CYCLE_VOLTAGE
				 || myCh->op.code == C_END_CYCLE_WH_SOC
				 || myCh->op.code == C_END_CYCLE_DCIR_SOC) {
			if(myPs->testCond[bd][ch].step[advStepNo].balanceStepCheck)
				myPs->testCond[bd][ch].step[advStepNo].type = STEP_BALANCE;
			if(myCh->ChAttribute.chNo_master == P0)
			{
				if(myPs->testCond[bd][ch-1].step[advStepNo].balanceStepCheck)
					myPs->testCond[bd][ch-1].step[advStepNo].type = STEP_BALANCE;
					myData->bData[bd].cData[ch-1].op.code = myCh->op.code; 
					cStepLoop(bd, ch-1, 1);
					myCh = &(myData->bData[bd].cData[ch]);
			}
			cStepLoop(bd, ch, 1);
		//add end
		}else if(myCh->op.code == C_END_INTEGRAL_CAPACITY){
			if(myCh->misc.integralCGotoCheck == 1) {
				myPs->testCond[bd][ch].step[myCh->misc.advCycleStep].
						gotoFlag = 1;
				myPs->testCond[bd][ch].step[myCh->misc.advCycleStep].
						gotoStep = myCh->misc.advStepNo;
				if(myCh->ChAttribute.chNo_master == P0)
				{
					myPs->testCond[bd][ch-1].step[myCh->misc.advCycleStep].
							gotoFlag = 1;
					myPs->testCond[bd][ch-1].step[myCh->misc.advCycleStep].
							gotoStep = myCh->misc.advStepNo;
				}
			}

			if(myPs->testCond[bd][ch].step[advStepNo].balanceStepCheck)
				myPs->testCond[bd][ch].step[advStepNo].type = STEP_BALANCE;
			if(myCh->ChAttribute.chNo_master == P0)
			{
				if(myPs->testCond[bd][ch-1].step[advStepNo].balanceStepCheck)
					myPs->testCond[bd][ch-1].step[advStepNo].type = STEP_BALANCE;
			}

			if(myCh->misc.endIntegralCGotoStep != 0) {
				myCh->misc.advStepNo = myCh->misc.endIntegralCGotoStep -1;
				if(myCh->ChAttribute.chNo_master == P0)
				{
					myData->bData[bd].cData[ch-1].op.code = 
							myCh->op.code; 
					myData->bData[bd].cData[ch-1].op.phase = 
							myCh->op.phase; 
					myData->bData[bd].cData[ch-1].misc.advStepNo =
							myCh->misc.advStepNo;
					cStepGoto(bd, ch-1);
					myCh = &(myData->bData[bd].cData[ch]);
				}
				cStepGoto(bd, ch);
			#ifdef _END_COMPARE_GOTO
			}else if(GotoCount != 0){
				rtn = gotoStepCheck(bd, ch); //210511 LJS
				if(rtn == 0){
					myCh->op.phase = P100;
				}else{
					myCh->misc.advStepNo = myPs->testCond[bd][ch].
						step[advStepNo].endCompGoto[rtn - 1].gotoStepNo-1;
					if(myCh->ChAttribute.chNo_master == P0)
					{
						myData->bData[bd].cData[ch-1].op.code = 
								myCh->op.code; 
						myData->bData[bd].cData[ch-1].op.phase = 
								myCh->op.phase; 
						myData->bData[bd].cData[ch-1].misc.advStepNo =
								myCh->misc.advStepNo;
						cStepGoto(bd, ch-1);
						myCh = &(myData->bData[bd].cData[ch]);
					}
					cStepGoto(bd, ch);
				}
			#endif
			} else {
				if(myCh->ChAttribute.chNo_master == P0)
				{
					myData->bData[bd].cData[ch-1].op.code = 
							myCh->op.code; 
					cStepLoop(bd, ch-1, 1);
					myCh = &(myData->bData[bd].cData[ch]);
				}
				cStepLoop(bd, ch, 1);
			}
		}else if(myCh->op.code == C_END_INTEGRAL_WATTHOUR){
//110215 kji
			if(myCh->misc.integralWhGotoCheck == 1) {
				myPs->testCond[bd][ch].step[myCh->misc.advCycleStep].
						gotoFlag = 1;
				myPs->testCond[bd][ch].step[myCh->misc.advCycleStep].
						gotoStep = myCh->misc.advStepNo;
				if(myCh->ChAttribute.chNo_master == P0)
				{
					myPs->testCond[bd][ch-1].step[myCh->misc.advCycleStep].
							gotoFlag = 1;
					myPs->testCond[bd][ch-1].step[myCh->misc.advCycleStep].
							gotoStep = myCh->misc.advStepNo;
				}
			}
			if(myPs->testCond[bd][ch].step[advStepNo].balanceStepCheck)
				myPs->testCond[bd][ch].step[advStepNo].type = STEP_BALANCE;
			if(myCh->ChAttribute.chNo_master == P0)
			{
				if(myPs->testCond[bd][ch-1].step[advStepNo].balanceStepCheck)
					myPs->testCond[bd][ch-1].step[advStepNo].type = STEP_BALANCE;
			}

			if(myCh->misc.endIntegralWhGotoStep != 0) {
				myCh->misc.advStepNo = myCh->misc.endIntegralWhGotoStep -1;
				if(myCh->ChAttribute.chNo_master == P0)
				{
					myData->bData[bd].cData[ch-1].op.code = 
							myCh->op.code; 
					myData->bData[bd].cData[ch-1].op.phase = 
							myCh->op.phase; 
					myData->bData[bd].cData[ch-1].misc.advStepNo =
							myCh->misc.advStepNo;
					cStepGoto(bd, ch-1);
					myCh = &(myData->bData[bd].cData[ch]);
				}
				cStepGoto(bd, ch);
			#ifdef _END_COMPARE_GOTO
			}else if(GotoCount != 0){
				rtn = gotoStepCheck(bd, ch); //210511 LJS
				if(rtn == 0){
					myCh->op.phase = P100;
				}else{
					myCh->misc.advStepNo = myPs->testCond[bd][ch].
						step[advStepNo].endCompGoto[rtn - 1].gotoStepNo-1;
					if(myCh->ChAttribute.chNo_master == P0)
					{
						myData->bData[bd].cData[ch-1].op.code = 
								myCh->op.code; 
						myData->bData[bd].cData[ch-1].op.phase = 
								myCh->op.phase; 
						myData->bData[bd].cData[ch-1].misc.advStepNo =
								myCh->misc.advStepNo;
						cStepGoto(bd, ch-1);
						myCh = &(myData->bData[bd].cData[ch]);
					}
					cStepGoto(bd, ch);
				}
			#endif
			} else {
				if(myCh->ChAttribute.chNo_master == P0)
				{
					myData->bData[bd].cData[ch-1].op.code = 
							myCh->op.code; 
					cStepLoop(bd, ch-1, 1);
					myCh = &(myData->bData[bd].cData[ch]);
				}
				cStepLoop(bd, ch, 1);
			}
		}else if(myCh->op.code == C_END_CYCLE_TIME){
//110215 kji
			if(myCh->misc.integralTGotoCheck == 1) {
				myPs->testCond[bd][ch].step[myCh->misc.advCycleStep].
						gotoFlag = 1;
				myPs->testCond[bd][ch].step[myCh->misc.advCycleStep].
						gotoStep = myCh->misc.advStepNo;
				//140925 oys add : current userMap
				if(type == STEP_USER_MAP
					&& myData->mData.testCond[bd][ch].
						userMap.mode == PS_CURRENT){
					i = myCh->misc.advCycleStep+1;
					j = myCh->misc.advCycleStep;
					if(myData->mData.testCond[bd][ch].userMap.type == 1){
						while(1){
							if(myPs->testCond[bd][ch].step[i].refI > 0
								|| myPs->testCond[bd][ch].step[i].refV_H != 0){
								myPs->testCond[bd][ch].step[j].gotoStep = i;
								break;
							}
							i++;
							if(myPs->testCond[bd][ch].step[i].type
								== STEP_LOOP){
								break;
							}
						}
					}else if (myData->mData.testCond[bd][ch].userMap.type == 2){
						while(1){
							if(myPs->testCond[bd][ch].step[i].refI < 0
								|| myPs->testCond[bd][ch].step[i].refV_L != 0){
								myPs->testCond[bd][ch].step[j].gotoStep = i;
								break;
							}
							i++;
							if(myPs->testCond[bd][ch].step[i].type
								== STEP_LOOP){
								break;
							}
						}
					}
				}
				if(myCh->ChAttribute.chNo_master == P0)
				{
					myPs->testCond[bd][ch-1].step[myCh->misc.advCycleStep].
							gotoFlag = 1;
					myPs->testCond[bd][ch-1].step[myCh->misc.advCycleStep].
							gotoStep = myCh->misc.advStepNo;
					//140925 oys add : current userMap
					if(type == STEP_USER_MAP
						&& myData->mData.testCond[bd][ch-1].
							userMap.mode == PS_CURRENT){
						i = myCh->misc.advCycleStep+1;
						j = myCh->misc.advCycleStep;
						if(myData->mData.testCond[bd][ch-1].userMap.type == 1){
							while(1){
								if(myPs->testCond[bd][ch-1].step[i].refI > 0
								|| myPs->testCond[bd][ch].step[i].refV_H != 0){
									myPs->testCond[bd][ch-1].step[j]
									.gotoStep = i;
									break;
								}
								i++;
								if(myPs->testCond[bd][ch].step[i].type
									== STEP_LOOP){
									break;
								}
							}
						}else if (myData->mData.testCond[bd][ch-1]
									.userMap.type == 2){
							while(1){
								if(myPs->testCond[bd][ch-1].step[i].refI < 0
								|| myPs->testCond[bd][ch].step[i].refV_L != 0){
									myPs->testCond[bd][ch-1].step[j]
									.gotoStep = i;
									break;
								}
								i++;
								if(myPs->testCond[bd][ch].step[i].type
									== STEP_LOOP){
									break;
								}
							}
						}
					}
				}
			}

			if(myPs->testCond[bd][ch].step[advStepNo].balanceStepCheck)
				myPs->testCond[bd][ch].step[advStepNo].type = STEP_BALANCE;
			if(myCh->ChAttribute.chNo_master == P0)
			{
				if(myPs->testCond[bd][ch-1].step[advStepNo].balanceStepCheck)
					myPs->testCond[bd][ch-1].step[advStepNo].type = STEP_BALANCE;
			}
			if(myCh->misc.endCycleTimeGotoStep != 0) {
				myCh->misc.advStepNo = myCh->misc.endCycleTimeGotoStep -1;
				if(myCh->ChAttribute.chNo_master == P0)
				{
					myData->bData[bd].cData[ch-1].op.code = 
							myCh->op.code; 
					myData->bData[bd].cData[ch-1].op.phase = 
							myCh->op.phase; 
					myData->bData[bd].cData[ch-1].misc.advStepNo =
							myCh->misc.advStepNo;
					cStepGoto(bd, ch-1);
					myCh = &(myData->bData[bd].cData[ch]);
				}
				myCh->misc.cycleRunTime = 0;	//201027_hun
				cStepGoto(bd, ch);
			#ifdef _END_COMPARE_GOTO
			}else if(GotoCount != 0){
				rtn = gotoStepCheck(bd, ch); //210511 LJS
				if(rtn == 0){
					myCh->op.phase = P100;
				}else{
					myCh->misc.advStepNo = myPs->testCond[bd][ch].
						step[advStepNo].endCompGoto[rtn - 1].gotoStepNo-1;
					if(myCh->ChAttribute.chNo_master == P0)
					{
						myData->bData[bd].cData[ch-1].op.code = 
								myCh->op.code; 
						myData->bData[bd].cData[ch-1].op.phase = 
								myCh->op.phase; 
						myData->bData[bd].cData[ch-1].misc.advStepNo =
								myCh->misc.advStepNo;
						cStepGoto(bd, ch-1);
						myCh = &(myData->bData[bd].cData[ch]);
					}
					cStepGoto(bd, ch);
				}
			#endif
			} else {
				if(myCh->ChAttribute.chNo_master == P0)
				{
					myData->bData[bd].cData[ch-1].op.code = 
							myCh->op.code; 
					cStepLoop(bd, ch-1, 1);
					myCh = &(myData->bData[bd].cData[ch]);
				}
				cStepLoop(bd, ch, 1);
			}
		}else{
			myCh->op.phase = P100;
		}

	} else if(rtn == SAVE_START) { //save : start data //khkw
//		myCh->op.select = SAVE_FLAG_SAVING_TIME;
//		send_save_msg(bd, ch, saveDt, 1);
	// 10mS Data Save Process
	} else if((rtn >= SAVE_DELTA_T && rtn <= SAVE_DELTA_TEMP)) {
		if(myData->DataSave.config.save_data_type == P1) {
			switch(rtn){
				case SAVE_DELTA_T:
					myCh->op.select = SAVE_FLAG_SAVING_TIME;
					break;
				case SAVE_DELTA_V:
					myCh->op.select = SAVE_FLAG_SAVING_DELTA_V;
					break;
				case SAVE_DELTA_I:
					myCh->op.select = SAVE_FLAG_SAVING_DELTA_I;
					break;
				case SAVE_DELTA_TEMP:
					myCh->op.select = SAVE_FLAG_SAVING_DELTA_T;
					break;
			}

			if((type > 0 && type < 12 && (type != 7) && (type != 8))){
				if(myCh->ChAttribute.opType == P0) {
					if(myCh->ChAttribute.chNo_master == 0)
					{
						myData->bData[bd].cData[ch-1].op.select
								= myCh->op.select;
					}
					if(myCh->misc.save10msDataCount	< MAX_10MS_MSG - 3){
						if((saveDt >= 100)
							&& (myCh->op.runTime != 0)
							&&((myCh->op.runTime - myCh->misc.save10msDt)
								% saveDt == 0)) {
							send_save_msg(bd, ch, saveDt, 1);
						}else{
							send_save_msg(bd, ch, saveDt, 0);
						}
					}else if(myCh->misc.save10msDataCount >= MAX_10MS_MSG - 3){
						send_save_msg(bd, ch, saveDt, 1); //memory copy
					}
				}
				if(saveDt >= 100) {
					myCh->misc.save10msDt = myCh->op.runTime;
				}
			}
		} else {
			switch(rtn){
				case SAVE_DELTA_T:
					myCh->op.select = SAVE_FLAG_SAVING_TIME;
					break;
				case SAVE_DELTA_V:
					myCh->op.select = SAVE_FLAG_SAVING_DELTA_V;
					break;
				case SAVE_DELTA_I:
					myCh->op.select = SAVE_FLAG_SAVING_DELTA_I;
					break;
				case SAVE_DELTA_TEMP:
					myCh->op.select = SAVE_FLAG_SAVING_DELTA_T;
					break;
			}
			if(myCh->ChAttribute.opType == P0) {
				if(myCh->ChAttribute.chNo_master == 0) {
					myData->bData[bd].cData[ch-1].op.select = myCh->op.select;
				}
				send_save_msg(bd, ch, saveDt, 0);
			}
		}
	}
	
	if(myCh->op.phase == P100) {
		if(myCh->ChAttribute.chNo_master == 0) {
			myData->bData[bd].cData[ch-1].op.code = myCh->op.code; 
			myData->bData[bd].cData[ch-1].op.phase = myCh->op.phase; 
			cNextStepCheck(bd, ch-1);
			myCh = &(myData->bData[bd].cData[ch]);
		}
		cNextStepCheck(bd, ch);
	}
}

int cEndCond_Cycle_Common(int bd, int ch, int rtn)
{
	long integral_Ah, integral_Wh;

	integral_Ah = integral_Wh = 0;

	myCh = &(myData->bData[bd].cData[ch]);
	
	if(myCh->misc.endCycleTime != 0) {
		if(myCh->misc.cycleRunTime >= myCh->misc.endCycleTime) {
#if CYCLER_TYPE == DIGITAL_CYC	//181217
			myCh->op.checkDelayTime = 0;
#endif
			myCh->op.code = C_END_CYCLE_TIME;
			rtn = END_COND;
			return rtn;
		}
	}
#if MACHINE_TYPE == 1
	if((myCh->op.type == STEP_REST)||(myCh->op.type == STEP_SHORT)) return rtn;
#else
	if(myCh->op.type == STEP_REST) return rtn;
#endif
			
	if(myCh->ChAttribute.chNo_master == P0) { //parallel mode
		integral_Ah = myCh->op.integral_ampareHour
				+ myData->bData[bd].cData[ch-1].op.integral_ampareHour;
		integral_Wh = myCh->op.integral_WattHour
				+ myData->bData[bd].cData[ch-1].op.integral_WattHour;
	} else {
		integral_Ah = myCh->op.integral_ampareHour;
		integral_Wh = myCh->op.integral_WattHour;
	}
	//170518 lyh add for 5V20A
	if(myCh->misc.cycleEndV != 0){
		//1.Charge V End
		if(myCh->misc.startV < myCh->misc.cycleEndV){
			if(myCh->misc.cycleEndV <= myCh->op.Vsens){
				if(myCh->misc.completeFlag == P1){
					myCh->op.code = C_STOP_CYCLE_VOLTAGE;
					rtn = END_COND;
				}else{
					myCh->op.code = C_END_CYCLE_VOLTAGE;
					rtn = END_COND;
				}
				return rtn;
			}
			//2.Discharge V End
		}else{
			if(myCh->misc.cycleEndV >= myCh->op.Vsens){
				if(myCh->misc.completeFlag == P1){
					myCh->op.code = C_STOP_CYCLE_VOLTAGE;
					rtn = END_COND;
				}else{
					myCh->op.code = C_END_CYCLE_VOLTAGE;
					rtn = END_COND;
				}
				return rtn;
			}
		}
	}

	if(myCh->misc.endIntegralC != 0) {
		if(myCh->misc.endIntegralC > 0) {
			if(integral_Ah >= myCh->misc.endIntegralC) {
				myCh->op.code = C_END_INTEGRAL_CAPACITY;
				rtn = END_COND;
				return rtn;
			}
		} else {
			if(integral_Ah <= myCh->misc.endIntegralC) {
				myCh->op.code = C_END_INTEGRAL_CAPACITY;
				rtn = END_COND;
				return rtn;
			}
		}
	}

	if(myCh->misc.endIntegralWh != 0) {
		if(myCh->misc.endIntegralWh > 0) {
			if(integral_Wh >= myCh->misc.endIntegralWh) {
				myCh->op.code = C_END_INTEGRAL_WATTHOUR;
				rtn = END_COND;
				return rtn;
			}
		} else {
			if(integral_Wh <= myCh->misc.endIntegralWh) {
				myCh->op.code = C_END_INTEGRAL_WATTHOUR;
				rtn = END_COND;
				return rtn;
			}
		}
	}
	return rtn;
}

int cEndCond_Ocv(int bd, int ch, int rtn, unsigned long advStepNo)
{
	myCh = &(myData->bData[bd].cData[ch]);
	myCh->op.code = C_END_OCV;
	rtn = END_COND;
	return rtn;
}

int cEndCond_Charge(int bd, int ch, int rtn, unsigned long advStepNo)
{
	double tmp;
	long capacity = 0, val1, maxV, endV, endI, endI_step, cvtVal;
	int	rangeV, mode;
	unsigned short SocSoeFlag;

	S_CH_STEP_INFO step;
	myCh = &(myData->bData[bd].cData[ch]);
	step = step_info(bd, ch);
	val1 = step.refV;
	rangeV = step.rangeV;
	mode = step.mode;
	maxV = myPs->config.maxVoltage[rangeV];
	SocSoeFlag = myData->mData.testCond[bd][ch].step[advStepNo].SocSoeFlag;
	
	if(myCh->signal[C_SIG_NEXTSTEP] == P1) {
		myCh->signal[C_SIG_NEXTSTEP] = P0;
		myCh->op.code = C_FAULT_NEXTSTEP_CMD;
		rtn = END_COND;
		return rtn;
	}
	
	if(myPs->config.capacityType == CAPACITY_AMPARE_HOURS) {
		capacity = myCh->op.ampareHour;
	} else if(myPs->config.capacityType == CAPACITY_CAPACITANCE) {
		capacity = myCh->op.capacitance;
	} else {
		capacity = 0;
	}
	
	if(myCh->op.mode == CP)
	{
		endV = myCh->misc.tmpVsens;
		endI = myCh->misc.tmpIsens;
	} else {
		endV = myCh->op.Vsens;
		endI = myCh->op.Isens;
	}

	//190801 oys add start : Convert C-rate to I value
	endI_step = myPs->testCond[bd][ch].step[advStepNo].endI;
	cvtVal = Convert_C_rate_to_I_value(bd, ch, endI_step);
	if(cvtVal != 0)
		endI_step = cvtVal;
	
	if(myPs->testCond[bd][ch].step[advStepNo].endT != 0) {
		if(myCh->op.runTime >=
			myPs->testCond[bd][ch].step[advStepNo].endT) {
			myCh->op.code = C_END_TIME;
			rtn = END_COND;
		}
	}
	
	if(myPs->testCond[bd][ch].step[advStepNo].endTemp != 0) {
		rtn = tempEndCheck(bd, ch, rtn, advStepNo);
	}

	if(myCh->op.checkDelayTime < 10) return rtn;
	//180903 add
#if CYCLER_TYPE == DIGITAL_CYC
		if(myCh->misc.endFlag == P1){
			myCh->misc.endFlag = P0;
			myCh->op.code = C_END_VOLTAGE;
			rtn = END_COND;
		}
#endif

	//CVendTime
	if(myPs->testCond[bd][ch].step[advStepNo].endT_CV != 0) {
		if(myCh->misc.cvTime >=
			myPs->testCond[bd][ch].step[advStepNo].endT_CV) {
			myCh->op.code = C_END_CVTIME;
			rtn = END_COND;
		}
	}

	if(myPs->testCond[bd][ch].step[advStepNo].endV != 0
		|| myPs->testCond[bd][ch].step[advStepNo].endZeroVoltageFlag == 1) {
		if(endV >=
			myPs->testCond[bd][ch].step[advStepNo].endV) {
			myCh->op.code = C_END_VOLTAGE;
			rtn = END_COND;
		}
	}

	if(myPs->testCond[bd][ch].step[advStepNo].endDeltaV != 0) {
		if((myCh->misc.maxV - myCh->op.Vsens) >=
			myPs->testCond[bd][ch].step[advStepNo].endDeltaV) {
			myCh->op.code = C_END_DELTA_V;
			rtn = END_COND;
		}
	}

	if((val1 - myCh->op.Vsens) < maxV * 0.001){
		if(endI_step != 0) {
			if(myCh->signal[C_SIG_PAUSE] != P1) {
				if(endI <= endI_step) {
					myCh->op.code = C_END_CURRENT;
					rtn = END_COND;
				}
			}
		}
	}

	if(myPs->testCond[bd][ch].step[advStepNo].endC != 0) {
		if(capacity >=
			myPs->testCond[bd][ch].step[advStepNo].endC) {
			myCh->op.code = C_END_CAPACITY;
			rtn = END_COND;
		}
	}
	//cEndCharge
	if(myPs->testCond[bd][ch].step[advStepNo].endSoc != 0) {
		//20190214 SocSoeFlag 0:SOC / 1:DOD / 2:SOE / 3:DOE
		if(SocSoeFlag < 2) {
			tmp = (double)capacity / (double)myCh->misc.actualCapacity
				* 10000.0;
			//endSoc=10000 -> soc=100.00%
			if((unsigned short int)tmp >=
				myPs->testCond[bd][ch].step[advStepNo].endSoc) {
				myCh->op.code = C_END_SOC;
				rtn = END_COND;
			}
		} else {
			tmp = (double)myCh->op.wattHour /(double)myCh->misc.actualWattHour
				* 10000.0;
			//endSoc=10000 -> soc=100.00%
			if((unsigned short int)tmp >=
				myPs->testCond[bd][ch].step[advStepNo].endSoc) {		
				myCh->op.code = C_END_SOE;
				rtn = END_COND;
			}
		}
	}
	
	
	if(myPs->testCond[bd][ch].step[advStepNo].endP != 0) {
		if(myCh->op.watt >=
			myPs->testCond[bd][ch].step[advStepNo].endP) {
			myCh->op.code = C_END_POWER;
			rtn = END_COND;
		}
	}

	if(myPs->testCond[bd][ch].step[advStepNo].endWh != 0) {
		if(myCh->op.wattHour >=
			myPs->testCond[bd][ch].step[advStepNo].endWh) {
			myCh->op.code = C_END_WATTHOUR;
			rtn = END_COND;
		}
	}
#if CAPACITY_CONTROL == 1
	//210402 Cycle Soc Step Capacity End [Charge]
	if(myPs->testCond[bd][ch].step[advStepNo].endCycleCapaRate[0] != 0){		
		myCh->misc.Sum_End_Capa_Capacity 
				= Calculate_End_Capacity(bd, ch, advStepNo, 1);
		if(capacity >= myCh->misc.Sum_End_Capa_Capacity){		
			myCh->op.code = C_END_CYCLE_STD_CAPACITY_STEP_CAPACITY;
			rtn = END_COND;
		}
	}
	//210402 Cycle Soc Step Current End [Charge]
	if((val1 - myCh->op.Vsens) < maxV * 0.001){	
		if(myPs->testCond[bd][ch].step[advStepNo].endCycleCurrentRate[0] != 0){
			myCh->misc.Sum_End_Current_Capacity 
					= Calculate_End_Capacity(bd, ch, advStepNo, 2);
			if(endI <= myCh->misc.Sum_End_Current_Capacity){		
				myCh->op.code = C_END_CYCLE_STD_CAPACITY_STEP_CURRENT;
				rtn = END_COND;
			}
		}
	}
#endif

//210923 lyhw add for lges gas control (charge)
#if GAS_DATA_CONTROL == 1
	//Gas TVOC
	if(myPs->testCond[bd][ch].step[advStepNo].endGasTVOC != 0) {
		if(myCh->misc.gas_TVOC >=
			myPs->testCond[bd][ch].step[advStepNo].endGasTVOC) {
			myCh->op.code = C_END_GAS_TVOC;
			rtn = END_COND;
		}
	}
	
	if(myPs->testCond[bd][ch].step[advStepNo].endGasECo2 != 0) {
		if(myCh->misc.gas_eCo2 >=
			myPs->testCond[bd][ch].step[advStepNo].endGasECo2) {
			myCh->op.code = C_END_GAS_ECO2;
			rtn = END_COND;
		}
	}
#endif

	if(rtn == END_COND){
		if(myPs->testCond[bd][ch].safety.faultLowerC != 0) {
			if(capacity <= myPs->testCond[bd][ch].safety
				.faultLowerC) {
				myCh->misc.tmpState = myCh->op.state;
				myCh->misc.tmpCode = myCh->op.code;
				myCh->op.code = C_FAULT_LOWER_CAPACITY;
				myCh->op.code = code_convert(myCh->op.code, SAFETY); //safety
				Fault_Value_Check(myCh->misc.advStepNo, capacity,
				myPs->testCond[bd][ch].safety.faultLowerC, 0, 0, 0, 0, 0, 0, 0);
				rtn = FAULT_COND;
				return rtn;
			}
		}
		if(myPs->testCond[bd][ch].step[advStepNo]
			.faultLowerC != 0) {
			if(capacity <= myPs->testCond[bd][ch].step[advStepNo]
				.faultLowerC) {
				myCh->misc.tmpState = myCh->op.state;
				myCh->misc.tmpCode = myCh->op.code;
				myCh->op.code = C_FAULT_LOWER_CAPACITY;
				myCh->op.code = code_convert(myCh->op.code, STEP_SAFETY); //step_safety
				Fault_Value_Check(myCh->misc.advStepNo, capacity,
				myPs->testCond[bd][ch].step[advStepNo].faultLowerC,
			   	0, 0, 0, 0, 0, 0, 0);
				rtn = FAULT_COND;
				return rtn;
			}
		}
	}

	rtn = deltaCapacityCheck(bd, ch, rtn, advStepNo);

	return rtn;
}

int cEndCond_Charge_P(int bd, int ch, int rtn, unsigned long advStepNo)
{
	double tmp;
	long capacity = 0, val1, maxV, cvTime , watt , wattHour;
	long endV , endI, endI_step, cvtVal;
	int	rangeV, mode;
	unsigned short SocSoeFlag;

	S_CH_STEP_INFO step;
	myCh = &(myData->bData[bd].cData[ch]);
	step = step_info(bd, ch);
	val1 = step.refV;
	mode = step.mode;
	rangeV = step.rangeV;
	maxV = myPs->config.maxVoltage[rangeV];
	SocSoeFlag = myData->mData.testCond[bd][ch].step[advStepNo].SocSoeFlag;

	if(myCh->signal[C_SIG_NEXTSTEP] == P1) {
		myCh->signal[C_SIG_NEXTSTEP] = P0;
		myData->bData[bd].cData[ch-1].signal[C_SIG_NEXTSTEP] = P0;
		myCh->op.code = C_FAULT_NEXTSTEP_CMD;
		rtn = END_COND;
		return rtn;
	}

	if(myPs->config.capacityType == CAPACITY_AMPARE_HOURS) {
		capacity = myCh->op.ampareHour
				+ myData->bData[bd].cData[ch-1].op.ampareHour;
	} else if(myPs->config.capacityType == CAPACITY_CAPACITANCE) {
		capacity = myCh->op.capacitance
				+ myData->bData[bd].cData[ch-1].op.capacitance;
	} else {
		capacity = 0;
	}

	if(myCh->op.mode == CP)
	{
		endV = myCh->misc.tmpVsens;
		endI = myCh->misc.tmpIsens + 
				myData->bData[bd].cData[ch-1].misc.tmpIsens;
	} else {
		endV = myCh->op.Vsens;
		endI = myCh->op.Isens + myData->bData[bd].cData[ch-1].op.Isens;
	}

	//190801 oys add start : Convert C-rate to I value
	endI_step = myPs->testCond[bd][ch].step[advStepNo].endI;
	cvtVal = Convert_C_rate_to_I_value(bd, ch, endI_step);
	if(cvtVal != 0)
		endI_step = cvtVal;

	if(myPs->testCond[bd][ch].step[advStepNo].endT != 0) {
		if(myCh->op.runTime >=
			myPs->testCond[bd][ch].step[advStepNo].endT) {
			myCh->op.code = C_END_TIME;
			rtn = END_COND;
		}
	}

	if(myPs->testCond[bd][ch].step[advStepNo].endTemp != 0) {
		rtn = tempEndCheck(bd, ch, rtn, advStepNo);
	}

	if(myCh->op.checkDelayTime < 10) return rtn;
	//180903 add
#if CYCLER_TYPE == DIGITAL_CYC
		if(myCh->misc.endFlag == P1){
			myCh->misc.endFlag = P0;
			myCh->op.code = C_END_VOLTAGE;
			rtn = END_COND;
		}
#endif

	//CVendTime
	if(myPs->testCond[bd][ch].step[advStepNo].endT_CV != 0) {
		if(myCh->misc.cvTime > myData->bData[bd].cData[ch-1].misc.cvTime) {
			cvTime = myCh->misc.cvTime;
		} else {
			cvTime = myData->bData[bd].cData[ch-1].misc.cvTime;
		}
		if(cvTime >=
			myPs->testCond[bd][ch].step[advStepNo].endT_CV) {
			myCh->op.code = C_END_CVTIME;
			rtn = END_COND;
		}
	}


	if(myPs->testCond[bd][ch].step[advStepNo].endV != 0
		|| myPs->testCond[bd][ch].step[advStepNo].endZeroVoltageFlag == 1) {
		if(endV >=
			myPs->testCond[bd][ch].step[advStepNo].endV) {
			myCh->op.code = C_END_VOLTAGE;
			rtn = END_COND;
		}
	}

	if(myPs->testCond[bd][ch].step[advStepNo].endDeltaV != 0) {
		if((myCh->misc.maxV - myCh->op.Vsens) >=
			myPs->testCond[bd][ch].step[advStepNo].endDeltaV) {
			myCh->op.code = C_END_DELTA_V;
			rtn = END_COND;
		}
	}

	if((val1 - myCh->op.Vsens) < maxV * 0.001){
		if(endI_step != 0) {
			if(myCh->signal[C_SIG_PAUSE] != P1) {
				if(endI <= endI_step) {
					myCh->op.code = C_END_CURRENT;
					rtn = END_COND;
				}
			}
		}
	}

	if(myPs->testCond[bd][ch].step[advStepNo].endC != 0) {
		if(capacity >=
			myPs->testCond[bd][ch].step[advStepNo].endC) {
			myCh->op.code = C_END_CAPACITY;
			rtn = END_COND;
		}
	}

	//cEndCharge_P
	if(myPs->testCond[bd][ch].step[advStepNo].endSoc != 0) {
		//20190214 SocSoeFlag 0:SOC / 1:DOD / 2:SOE / 3:DOE
		if(SocSoeFlag < 2) {
			tmp = (double)capacity / (double)myCh->misc.actualCapacity
				* 10000.0;
			//endSoc=10000 -> soc=100.00%
			if((unsigned short int)tmp >=
				myPs->testCond[bd][ch].step[advStepNo].endSoc) {
				myCh->op.code = C_END_SOC;
				rtn = END_COND;
			}
		} else { 
			wattHour = myCh->op.wattHour +
					myData->bData[bd].cData[ch-1].op.wattHour;
			tmp = (double)wattHour /(double)myCh->misc.actualWattHour
				* 10000.0;
			//endSoc=10000 -> soc=100.00%
			if((unsigned short int)tmp >=
				myPs->testCond[bd][ch].step[advStepNo].endSoc) {		
				myCh->op.code = C_END_SOE;
				rtn = END_COND;
			}
		}
	}	
	if(myPs->testCond[bd][ch].step[advStepNo].endP != 0) {
		watt = myCh->op.watt + myData->bData[bd].cData[ch-1].op.watt;
		if(watt >= myPs->testCond[bd][ch].step[advStepNo].endP) {
			myCh->op.code = C_END_POWER;
			rtn = END_COND;
		}
	}

	if(myPs->testCond[bd][ch].step[advStepNo].endWh != 0) {
		wattHour = myCh->op.wattHour + 
				myData->bData[bd].cData[ch-1].op.wattHour;
		if(wattHour >= myPs->testCond[bd][ch].step[advStepNo].endWh) {
			myCh->op.code = C_END_WATTHOUR;
			rtn = END_COND;
		}
	}
	
#if CAPACITY_CONTROL == 1
	//210402 Cycle Soc Step Capacity End [Charge_P]
	if(myPs->testCond[bd][ch].step[advStepNo].endCycleCapaRate[0] != 0){		
		myCh->misc.Sum_End_Capa_Capacity 
				= Calculate_End_Capacity(bd, ch, advStepNo, 1);
		if(capacity >= myCh->misc.Sum_End_Capa_Capacity){		
			myCh->op.code = C_END_CYCLE_STD_CAPACITY_STEP_CAPACITY;
			rtn = END_COND;
		}
	}
	//210402 Cycle Soc Step Current End [Charge_P]
	if((val1 - myCh->op.Vsens) < maxV * 0.001){	
		if(myPs->testCond[bd][ch].step[advStepNo].endCycleCurrentRate[0] != 0){
			myCh->misc.Sum_End_Current_Capacity 
					= Calculate_End_Capacity(bd, ch, advStepNo, 2);
			if(endI <= myCh->misc.Sum_End_Current_Capacity){		
				myCh->op.code = C_END_CYCLE_STD_CAPACITY_STEP_CURRENT;
				rtn = END_COND;
			}
		}
	}
#endif
	
	if(rtn == END_COND){
		if(myPs->testCond[bd][ch].safety.faultLowerC != 0) {
			if(capacity <= myPs->testCond[bd][ch].safety
				.faultLowerC) {
				myCh->misc.tmpState = myCh->op.state;
				myCh->misc.tmpCode = myCh->op.code;
				myCh->op.code = C_FAULT_LOWER_CAPACITY;
				myCh->op.code = code_convert(myCh->op.code, SAFETY); //safety
				Fault_Value_Check(myCh->misc.advStepNo, capacity,
				myPs->testCond[bd][ch].safety.faultLowerC, 0, 0, 0, 0, 0, 0, 0);
				rtn = FAULT_COND;
				return rtn;
			}
		}
		if(myPs->testCond[bd][ch].step[advStepNo]
			.faultLowerC != 0) {
			if(capacity <= myPs->testCond[bd][ch].step[advStepNo]
				.faultLowerC) {
				myCh->misc.tmpState = myCh->op.state;
				myCh->misc.tmpCode = myCh->op.code;
				myCh->op.code = C_FAULT_LOWER_CAPACITY;
				myCh->op.code = code_convert(myCh->op.code, STEP_SAFETY); //step_safety
				Fault_Value_Check(myCh->misc.advStepNo, capacity,
				myPs->testCond[bd][ch].step[advStepNo].faultLowerC,
			   	0, 0, 0, 0, 0, 0 ,0);
				rtn = FAULT_COND;
				return rtn;
			}
		}
	}
	
	rtn = deltaCapacityCheck(bd, ch, rtn, advStepNo);

	return rtn;
}

int cEndCond_Discharge(int bd, int ch, int rtn, unsigned long advStepNo)
{
	double tmp;
	long capacity = 0, val1, maxV, endV, endI, endI_step, cvtVal;
	int rangeV, i, mode;
	unsigned short SocSoeFlag;
	#if CHAMBER_TEMP_HUMIDITY == 1 	//kjc_210417
	int loopStepNo = 0;
	#endif
	#ifdef _SDI_SAFETY_V1	
	int loopStepNo = 0;
	#endif
	
	S_CH_STEP_INFO step;
	myCh = &(myData->bData[bd].cData[ch]);
	step = step_info(bd, ch);
	val1 = step.refV;
	rangeV = step.rangeV;
	mode = step.mode;
	maxV = myPs->config.maxVoltage[rangeV];
	SocSoeFlag = myData->mData.testCond[bd][ch].step[advStepNo].SocSoeFlag;
#if CHAMBER_TEMP_HUMIDITY == 1	//kjc_210417
	loopStepNo = myCh->misc.loopStepNo;
#endif
	if(myCh->signal[C_SIG_NEXTSTEP] == P1) {
		myCh->signal[C_SIG_NEXTSTEP] = P0;
		myCh->op.code = C_FAULT_NEXTSTEP_CMD;
#if CHAMBER_TEMP_HUMIDITY == 1	//kjc_210419
		if(myPs->testCond[bd][ch].step[loopStepNo].advCycleCount >= 2){
			if(myCh->misc.advCycle == 1){
				myCh->misc.efficiency_Ah[0] += myCh->op.discharge_ampareHour;
			}else{
				myCh->misc.efficiency_Ah[1] += myCh->op.discharge_ampareHour;
			}
		}
#endif
		rtn = END_COND;
		return rtn;
	}

	if(myPs->config.capacityType == CAPACITY_AMPARE_HOURS) {
		capacity = myCh->op.ampareHour;
	} else if(myPs->config.capacityType	== CAPACITY_CAPACITANCE) {
		capacity = myCh->op.capacitance;
	} else {
		capacity = 0;
	}

	if(myCh->op.mode == CP)
	{
		endV = myCh->misc.tmpVsens;
		endI = myCh->misc.tmpIsens;
	} else {
		endV = myCh->op.Vsens;
		endI = myCh->op.Isens;
	}

	//190801 oys add start : Convert C-rate to I value
	endI_step = myPs->testCond[bd][ch].step[advStepNo].endI;
	cvtVal = Convert_C_rate_to_I_value(bd, ch, endI_step);
	if(cvtVal != 0)
		endI_step = cvtVal;

	if(myPs->testCond[bd][ch].step[advStepNo].endT != 0) {
		if(myCh->op.runTime >=
			myPs->testCond[bd][ch].step[advStepNo].endT) {
			myCh->op.code = C_END_TIME;
			rtn = END_COND;
		}
	}

	if(myPs->testCond[bd][ch].step[advStepNo].endTemp != 0) {
		rtn = tempEndCheck(bd, ch, rtn, advStepNo);
	}

	if(myCh->op.checkDelayTime < 10) return rtn;	//100mS
	//180903 add
#if CYCLER_TYPE == DIGITAL_CYC
		if(myCh->misc.endFlag == P1){
			myCh->misc.endFlag = P0;
			myCh->op.code = C_END_VOLTAGE;
			rtn = END_COND;
		}
#endif

	//CVendTime
	if(myPs->testCond[bd][ch].step[advStepNo].endT_CV != 0) {
		if(myCh->misc.cvTime >=
			myPs->testCond[bd][ch].step[advStepNo].endT_CV) {
			myCh->op.code = C_END_CVTIME;
			rtn = END_COND;
		}
	}

	if(myPs->testCond[bd][ch].step[advStepNo].endV != 0
		|| myPs->testCond[bd][ch].step[advStepNo].endZeroVoltageFlag == 1) {
		if(endV <=
			myPs->testCond[bd][ch].step[advStepNo].endV) {
			myCh->op.code = C_END_VOLTAGE;
			rtn = END_COND;
		}
	}

	if(myPs->testCond[bd][ch].step[advStepNo].endDeltaV != 0) {
		if((myCh->op.Vsens - myCh->misc.minV) >=
			myPs->testCond[bd][ch].step[advStepNo].endDeltaV) {
			myCh->op.code = C_END_DELTA_V;
			rtn = END_COND;
		}
	}
	
	if((myCh->op.Vsens - val1) < maxV * 0.001){
		if(endI_step != 0) {
			if(myCh->signal[C_SIG_PAUSE] != P1){
				if(endI >= endI_step * (-1)) {
					myCh->op.code = C_END_CURRENT;
					rtn = END_COND;
				}
			}
		}
	}

	if(myPs->testCond[bd][ch].step[advStepNo].endC != 0) {
		if(capacity >=
			myPs->testCond[bd][ch].step[advStepNo].endC) {
			myCh->op.code = C_END_CAPACITY;
			rtn = END_COND;
		}
	}
	
	//cEndDisCharge
	if(myPs->testCond[bd][ch].step[advStepNo].endSoc != 0) {
		//20190214 SocSoeFlag 0:SOC / 1:DOD / 2:SOE / 3:DOE
		if(SocSoeFlag < 2) {
			tmp = (double)capacity / (double)myCh->misc.actualCapacity
				* 10000.0;
			//endSoc=10000 -> soc=100.00%
			if((unsigned short int)tmp >=
				myPs->testCond[bd][ch].step[advStepNo].endSoc) {
				myCh->op.code = C_END_SOC;
				rtn = END_COND;
			}
		} else { 
			tmp = (double)myCh->op.wattHour /(double)myCh->misc.actualWattHour
				* 10000.0;
			//endSoc=10000 -> soc=100.00%
			if((unsigned short int)tmp >=
				myPs->testCond[bd][ch].step[advStepNo].endSoc) {		
				myCh->op.code = C_END_SOE;
				rtn = END_COND;
			}
		}
	}
	

	//201017_SKI_kjc
	if(myPs->testCond[bd][ch].step[advStepNo].endP != 0 
		&& myCh->op.watt != 0) {
		if(myCh->op.watt <=
			myPs->testCond[bd][ch].step[advStepNo].endP) {
			myCh->op.code = C_END_POWER;
			rtn = END_COND;
		}
	}

	if(myPs->testCond[bd][ch].step[advStepNo].endWh != 0) {
		if(myCh->op.wattHour >=
			myPs->testCond[bd][ch].step[advStepNo].endWh) {
			myCh->op.code = C_END_WATTHOUR;
			rtn = END_COND;
		}
	}
	#ifdef _SDI_SAFETY_V1	
	//kjc_200409
	for(i = advStepNo; i < myPs->testCond[bd][ch].header.totalStep; i ++) {
		if(myPs->testCond[bd][ch].step[i].type == STEP_LOOP){
			loopStepNo = i;
			break;
		}
	}
	#endif

#if CAPACITY_CONTROL == 1
	//210402 Cycle Soc Step Capacity End [DisCharge]
	if(myPs->testCond[bd][ch].step[advStepNo].endCycleCapaRate[0] != 0){		
		myCh->misc.Sum_End_Capa_Capacity 
				= Calculate_End_Capacity(bd, ch, advStepNo, 1);
		if(capacity >= myCh->misc.Sum_End_Capa_Capacity){		
			myCh->op.code = C_END_CYCLE_STD_CAPACITY_STEP_CAPACITY;
			rtn = END_COND;
		}
	}
	//210402 Cycle Soc Step Current End [DisCharge]
	if((myCh->op.Vsens - val1) < maxV * 0.001){	
		if(myPs->testCond[bd][ch].step[advStepNo].endCycleCurrentRate[0] != 0){
			myCh->misc.Sum_End_Current_Capacity 
					= Calculate_End_Capacity(bd, ch, advStepNo, 2);
			if(labs(endI) <= myCh->misc.Sum_End_Current_Capacity){		
				myCh->op.code = C_END_CYCLE_STD_CAPACITY_STEP_CURRENT;
				rtn = END_COND;
			}
		}
	}
#endif

//210923 lyhw add for lges gas control (discharge)
#if GAS_DATA_CONTROL == 1
	//Gas TVOC
	if(myPs->testCond[bd][ch].step[advStepNo].endGasTVOC != 0) {
		if(myCh->misc.gas_TVOC >=
			myPs->testCond[bd][ch].step[advStepNo].endGasTVOC) {
			myCh->op.code = C_END_GAS_TVOC;
			rtn = END_COND;
		}
	}
	
	if(myPs->testCond[bd][ch].step[advStepNo].endGasECo2 != 0) {
		if(myCh->misc.gas_eCo2 >=
			myPs->testCond[bd][ch].step[advStepNo].endGasECo2) {
			myCh->op.code = C_END_GAS_ECO2;
			rtn = END_COND;
		}
	}
#endif

	if(rtn == END_COND) {
		//20180514 modify for IEC
		if(myPs->config.capacityType == CAPACITY_CAPACITANCE 
			&& myCh->misc.d_flag2 == 0) {
			myCh->misc.d_flag2 = 1;
			if(myCh->misc.d_count_iec < MAX_PULSE_DATA_IEC) {
				i = myCh->misc.d_count_iec++;
			} else {
				i = myCh->misc.d_count_iec;
			}
			myCh->misc.nAfterIncludeCnt_iec++;
			myCh->misc.d_t_iec[i] = myCh->op.runTime;
			myCh->misc.d_v_iec[i] = myCh->misc.tmpVsens;
			myCh->misc.d_i_iec[i] = myCh->misc.tmpIsens;
		//	Fad_Read_IEC(bd, ch, 0);
		}

		if(myPs->testCond[bd][ch].safety.faultLowerC != 0) {
			if(capacity <= myPs->testCond[bd][ch].safety.faultLowerC) {
				myCh->misc.tmpState = myCh->op.state;
				myCh->misc.tmpCode = myCh->op.code;
				myCh->op.code = C_FAULT_LOWER_CAPACITY;
				myCh->op.code = code_convert(myCh->op.code, SAFETY); //safety
				Fault_Value_Check(myCh->misc.advStepNo, capacity,
				myPs->testCond[bd][ch].safety.faultLowerC, 0, 0, 0, 0, 0, 0, 0);
				rtn = FAULT_COND;
				return rtn;
			}
		}
		if(myPs->testCond[bd][ch].step[advStepNo].faultLowerC != 0) {
			if(capacity <= myPs->testCond[bd][ch].step[advStepNo].faultLowerC) {
				myCh->misc.tmpState = myCh->op.state;
				myCh->misc.tmpCode = myCh->op.code;
				myCh->op.code = C_FAULT_LOWER_CAPACITY;
				myCh->op.code = code_convert(myCh->op.code, STEP_SAFETY); //step_safety
				Fault_Value_Check(myCh->misc.advStepNo, capacity,
				myPs->testCond[bd][ch].step[advStepNo].faultLowerC,
			   	0, 0, 0, 0, 0, 0, 0);
				rtn = FAULT_COND;
				return rtn;
			}
		}
		#ifdef _SDI_SAFETY_V1	
		if(myPs->testCond[bd][ch].step[loopStepNo].advCycleCount >= 2){
			if(myPs->testCond[bd][ch].safety.faultSOH != 0 ){
				if(myData->bData[bd].cData[ch].op.discharge_ampareHour
					 <= myPs->testCond[bd][ch].safety.faultSOH){
					myCh->misc.tmpState = myCh->op.state;
					myCh->misc.tmpCode = myCh->op.code;
					myCh->op.code = C_FAULT_SOH;
					Fault_Value_Check(myCh->misc.advStepNo, 
					myData->bData[bd].cData[ch].op.discharge_ampareHour,
					myPs->testCond[bd][ch].safety.faultSOH,
					myPs->testCond[bd][ch].step[loopStepNo].advCycleCount,
				   	0, 0, 0, 0, 0, 0);
					rtn = FAULT_COND;
					return rtn;
				}
			}
		}
		#endif
		#ifdef _SDI_SAFETY_V2	
	//20210415 LJS add
		if(myCh->misc.MasterFlag == 2 || myCh->misc.MasterFlag == 3){
			myCh->misc.MasterFlag = 4;
			myCh->misc.tmpState = myCh->op.state;
			myCh->misc.tmpCode = myCh->op.code;
			myCh->op.code = C_MASTER_RECIPE_WAIT_TIME;
			rtn = FAULT_COND;
			return rtn;
		}
		#endif
		#if CHAMBER_TEMP_HUMIDITY == 1	//kjc_210414
		if(myPs->testCond[bd][ch].step[loopStepNo].advCycleCount >= 2){
			if(myCh->misc.advCycle == 1){
				myCh->misc.efficiency_Ah[0] += myCh->op.discharge_ampareHour;
			} else {
				myCh->misc.efficiency_Ah[1] += myCh->op.discharge_ampareHour;
			}
			if(myCh->misc.advCycle >= 2 && myCh->misc.dischargeStepNo == advStepNo){
				myCh->misc.calc_retain_Ah 
					= ((float)myCh->misc.efficiency_Ah[1]
							/(float)myCh->misc.efficiency_Ah[0])*100;
			}
		}
		#endif
	}
	
	rtn = deltaCapacityCheck(bd, ch, rtn, advStepNo);

	return rtn;
}

int cEndCond_Discharge_P(int bd, int ch, int rtn, unsigned long advStepNo)
{
	double tmp;
	long capacity = 0, val1, maxV, watt, wattHour, cvTime, endI, endV;
   	long endI_step, cvtVal;
	int rangeV, mode;
	unsigned short SocSoeFlag;
	
	S_CH_STEP_INFO step;
	myCh = &(myData->bData[bd].cData[ch]);
	step = step_info(bd, ch);
	val1 = step.refV;
	rangeV = step.rangeV;
	mode = step.mode;
	maxV = myPs->config.maxVoltage[rangeV];	
	SocSoeFlag = myData->mData.testCond[bd][ch].step[advStepNo].SocSoeFlag;
	
	if(myCh->signal[C_SIG_NEXTSTEP] == P1) {
		myCh->signal[C_SIG_NEXTSTEP] = P0;
		myData->bData[bd].cData[ch-1].signal[C_SIG_NEXTSTEP] = P0;
		myCh->op.code = C_FAULT_NEXTSTEP_CMD;
		rtn = END_COND;
		return rtn;
	}

	if(myPs->config.capacityType == CAPACITY_AMPARE_HOURS) {
		capacity = myCh->op.ampareHour
			+ myData->bData[bd].cData[ch-1].op.ampareHour;
	} else if(myPs->config.capacityType == CAPACITY_CAPACITANCE) {
		capacity = myCh->op.capacitance
			+ myData->bData[bd].cData[ch-1].op.capacitance;
	} else {
		capacity = 0;
	}
	
	if(myCh->op.mode == CP)
	{
		endV = myCh->misc.tmpVsens;
		endI = myCh->misc.tmpIsens 
				+ myData->bData[bd].cData[ch-1].misc.tmpIsens;
	} else {
		endV = myCh->op.Vsens;
		endI = myCh->op.Isens + myData->bData[bd].cData[ch-1].op.Isens;
	}

	//190801 oys add start : Convert C-rate to I value
	endI_step = myPs->testCond[bd][ch].step[advStepNo].endI;
	cvtVal = Convert_C_rate_to_I_value(bd, ch, endI_step);
	if(cvtVal != 0)
		endI_step = cvtVal;

	if(myPs->testCond[bd][ch].step[advStepNo].endT != 0) {
		if(myCh->op.runTime >=
			myPs->testCond[bd][ch].step[advStepNo].endT) {
			myCh->op.code = C_END_TIME;
			rtn = END_COND;
		}
	}
	
	if(myPs->testCond[bd][ch].step[advStepNo].endTemp != 0) {
		rtn = tempEndCheck(bd, ch, rtn, advStepNo);
	}

	if(myCh->op.checkDelayTime < 10) return rtn;
	//180903 add
#if CYCLER_TYPE == DIGITAL_CYC
		if(myCh->misc.endFlag == P1){
			myCh->misc.endFlag = P0;
			myCh->op.code = C_END_VOLTAGE;
			rtn = END_COND;
		}
#endif

	//CVendTime
	if(myPs->testCond[bd][ch].step[advStepNo].endT_CV != 0) {
		if(myCh->misc.cvTime > myData->bData[bd].cData[ch-1].misc.cvTime) {
			cvTime = myCh->misc.cvTime;
		} else {
			cvTime = myData->bData[bd].cData[ch-1].misc.cvTime;
		}
		if(cvTime >=
			myPs->testCond[bd][ch].step[advStepNo].endT_CV) {
			myCh->op.code = C_END_CVTIME;
			rtn = END_COND;
		}
	}

	if(myPs->testCond[bd][ch].step[advStepNo].endV != 0
		|| myPs->testCond[bd][ch].step[advStepNo].endZeroVoltageFlag == 1) {
		if(endV <=
			myPs->testCond[bd][ch].step[advStepNo].endV) {
			myCh->op.code = C_END_VOLTAGE;
			rtn = END_COND;
		}
	}

	if(myPs->testCond[bd][ch].step[advStepNo].endDeltaV != 0) {
		if((myCh->op.Vsens - myCh->misc.minV) >=
			myPs->testCond[bd][ch].step[advStepNo].endDeltaV) {
			myCh->op.code = C_END_DELTA_V;
			rtn = END_COND;
		}
	}

	if((myCh->op.Vsens - val1) < maxV * 0.001){
		if(endI_step != 0) {
			if(myCh->signal[C_SIG_PAUSE] != P1){
				if(endI >= endI_step * (-1)) {
					myCh->op.code = C_END_CURRENT;
					rtn = END_COND;
				}
			}
		}
	}
		
	if(myPs->testCond[bd][ch].step[advStepNo].endC != 0) {
		if(capacity >=
			myPs->testCond[bd][ch].step[advStepNo].endC) {
			myCh->op.code = C_END_CAPACITY;
			rtn = END_COND;
		}
	}
	
	//cEndDischarge_P
	if(myPs->testCond[bd][ch].step[advStepNo].endSoc != 0) {
		//20190214 SocSoeFlag 0:SOC / 1:DOD / 2:SOE / 3:DOE
		if(SocSoeFlag < 2) {
			tmp = (double)capacity / (double)myCh->misc.actualCapacity
				* 10000.0;
			//endSoc=10000 -> soc=100.00%
			if((unsigned short int)tmp >=
				myPs->testCond[bd][ch].step[advStepNo].endSoc) {
				myCh->op.code = C_END_SOC;
				rtn = END_COND;
			}
		} else {
			wattHour = myCh->op.wattHour + 
					myData->bData[bd].cData[ch-1].op.wattHour;
			tmp = (double)wattHour /(double)myCh->misc.actualWattHour
				* 10000.0;
			//endSoc=10000 -> soc=100.00%
			if((unsigned short int)tmp >=
				myPs->testCond[bd][ch].step[advStepNo].endSoc) {		
				myCh->op.code = C_END_SOE;
				rtn = END_COND;
			}
		}
	}
	

	if(myPs->testCond[bd][ch].step[advStepNo].endP != 0) {
		watt = myCh->op.watt + myData->bData[bd].cData[ch-1].op.watt;
		if(watt <= myPs->testCond[bd][ch].step[advStepNo].endP) {
			myCh->op.code = C_END_POWER;
			rtn = END_COND;
		}
	}
	if(myPs->testCond[bd][ch].step[advStepNo].endWh != 0) {
		wattHour = myCh->op.wattHour+myData->bData[bd].cData[ch-1].op.wattHour;
		if(wattHour >= myPs->testCond[bd][ch].step[advStepNo].endWh) {
			myCh->op.code = C_END_WATTHOUR;
			rtn = END_COND;
		}
	}

#if CAPACITY_CONTROL == 1
	//210402 Cycle Soc Step Capacity End [DisCharge_P]
	if(myPs->testCond[bd][ch].step[advStepNo].endCycleCapaRate[0] != 0){		
		myCh->misc.Sum_End_Capa_Capacity 
				= Calculate_End_Capacity(bd, ch, advStepNo, 1);
		if(capacity >= myCh->misc.Sum_End_Capa_Capacity){		
			myCh->op.code = C_END_CYCLE_STD_CAPACITY_STEP_CAPACITY;
			rtn = END_COND;
		}
	}
	//210402 Cycle Soc Step Current End [DisCharge_P]
	if((myCh->op.Vsens - val1) < maxV * 0.001){	
		if(myPs->testCond[bd][ch].step[advStepNo].endCycleCurrentRate[0] != 0){
			myCh->misc.Sum_End_Current_Capacity 
					= Calculate_End_Capacity(bd, ch, advStepNo, 2);
			if(labs(endI) <= myCh->misc.Sum_End_Current_Capacity){		
				myCh->op.code = C_END_CYCLE_STD_CAPACITY_STEP_CURRENT;
				rtn = END_COND;
			}
		}
	}
#endif
	
	if(rtn == END_COND){
		if(myPs->testCond[bd][ch].safety.faultLowerC != 0) {
			if(capacity <= myPs->testCond[bd][ch].safety.faultLowerC) {
				myCh->misc.tmpState = myCh->op.state;
				myCh->misc.tmpCode = myCh->op.code;
				myCh->op.code = C_FAULT_LOWER_CAPACITY;
				myCh->op.code = code_convert(myCh->op.code, SAFETY); //safety
				Fault_Value_Check(myCh->misc.advStepNo, capacity,
				myPs->testCond[bd][ch].safety.faultLowerC, 0, 0, 0, 0, 0, 0, 0);
				rtn = FAULT_COND;
				return rtn;
			}
		}
		if(myPs->testCond[bd][ch].step[advStepNo].faultLowerC != 0) {
			if(capacity <= myPs->testCond[bd][ch].step[advStepNo].faultLowerC) {
				myCh->misc.tmpState = myCh->op.state;
				myCh->misc.tmpCode = myCh->op.code;
				myCh->op.code = C_FAULT_LOWER_CAPACITY;
				myCh->op.code = code_convert(myCh->op.code, STEP_SAFETY); //step_safety
				Fault_Value_Check(myCh->misc.advStepNo, capacity,
				myPs->testCond[bd][ch].step[advStepNo].faultLowerC,
			   	0, 0, 0, 0, 0, 0, 0);
				rtn = FAULT_COND;
				return rtn;
			}
		}
	}

	rtn = deltaCapacityCheck(bd, ch, rtn, advStepNo);

	return rtn;
}

int cEndCond_Rest(int bd, int ch, int rtn, unsigned long advStepNo)
{
	int diff=0;
	unsigned long i;
	unsigned char type;

	myCh = &(myData->bData[bd].cData[ch]);
	myTestCond = &(myPs->testCond[bd][ch]);
	
	if(myPs->testCond[bd][ch].step[advStepNo].endT != 0) {
		if(myPs->testCond[bd][ch].step[advStepNo].endT >= 6000) { // 1 minute
			if(myCh->misc.nextDelay == P0) {
				myCh->signal[C_SIG_OUT_SWITCH] = P0;
			}
		}
		diff = myPs->testCond[bd][ch].step[advStepNo].endT
				- myCh->op.runTime;
		if(diff <= 200 && myCh->misc.nextDelay < P10){ 	//200414
			//111215 kji goto stepcheck
			if(myPs->testCond[bd][ch].step[advStepNo].endTGoto != 0) {
				i = myPs->testCond[bd][ch].step[advStepNo].endTGoto - 1;
				type = myPs->testCond[bd][ch].step[i].type;
			} else {
				type = cSemi_Rest_Check(bd, ch);
				i = cSemi_Rest_StepNo_Check(bd, ch);
			}
			if(type == STEP_REST){
				if(myPs->testCond[bd][ch].step[i].endT != 0){
					if(myPs->testCond[bd][ch].step[i].endT >= 6000){ // 1 minute
						myCh->signal[C_SIG_OUT_SWITCH] = P0;
						myCh->signal[C_SIG_RANGE_SWITCH] = P0;	
					}
				} else {
					myCh->signal[C_SIG_OUT_SWITCH] = P0;
					myCh->signal[C_SIG_RANGE_SWITCH] = P0;
				}
			}else if(type != STEP_END){
				//210809 add for 2uA Step
				if(myPs->config.hwSpec == L_5V_500mA_2uA_R4
					&& (myPs->testCond[bd][ch].step[i].rangeI + 1) == RANGE4){
				}else{
					myCh->op.rangeV 
						= myPs->testCond[bd][ch].step[i].rangeV;
					myCh->op.rangeI 
						= myPs->testCond[bd][ch].step[i].rangeI;
					myCh->signal[C_SIG_V_RANGE]
						= myCh->op.rangeV + 1;
					myCh->signal[C_SIG_I_RANGE]
						= myCh->op.rangeI + 1;
				}

				if(myData->AppControl.config.systemType == CYCLER_CAN){
					//210818 lyhw
					myCh->misc.nextDelay = P2;
					if(diff == 90)	cSemiSwitch_CAN(bd, ch);
					if(diff == 80)	myCh->signal[C_SIG_RANGE_SWITCH] = P1;
					if(diff <= 50){
						myCh->signal[C_SIG_OUT_SWITCH] = P1;
					}
				}else{
					if(myPs->config.hwSpec < S_5V_200A) { //linear
						myCh->signal[C_SIG_OUT_SWITCH] = P1;
						myCh->signal[C_SIG_RANGE_SWITCH] = P1;
					}
				}
			}
		}
#if END_V_COMPARE_GOTO == 1
		if(myTestCond->step[advStepNo].endVupper_GotoStep != 0
				||myTestCond->step[advStepNo].endVlower_GotoStep != 0){
			if(myCh->misc.nextDelay == P0){
				myCh->misc.nextDelay = P10;
			}
		}
#endif
	}else {
		if(myCh->misc.nextDelay == P0)
			myCh->signal[C_SIG_OUT_SWITCH] = P0;
	}

	if(myCh->signal[C_SIG_NEXTSTEP] == P1) {
		myCh->signal[C_SIG_NEXTSTEP] = P0;
		type = cSemi_Rest_Check(bd, ch);
		i = cSemi_Rest_StepNo_Check(bd, ch);
		if(type == STEP_REST){
			if(myPs->testCond[bd][ch].step[i].endT != 0) {
				if(myPs->testCond[bd][ch].step[i].endT >= 6000) { // 1 minute
					myCh->signal[C_SIG_OUT_SWITCH] = P0;
					myCh->signal[C_SIG_RANGE_SWITCH] = P0;
				}else{
					if(myData->AppControl.config.systemType == CYCLER_CAN){
						myCh->signal[C_SIG_OUT_SWITCH] = P0;
						myCh->signal[C_SIG_RANGE_SWITCH] = P0;
					}else{
						if(myPs->config.hwSpec < S_5V_200A) { //linear
							myCh->signal[C_SIG_OUT_SWITCH] = P1;
							myCh->signal[C_SIG_RANGE_SWITCH] = P1;
						}
					}
				}
			} else {
				myCh->signal[C_SIG_OUT_SWITCH] = P0;
				myCh->signal[C_SIG_RANGE_SWITCH] = P0;
			}
		}else if(type != STEP_END){
			//210809 add for 2uA Step
			if(myPs->config.hwSpec == L_5V_500mA_2uA_R4
				&& (myPs->testCond[bd][ch].step[i].rangeI + 1) == RANGE4){
			}else{
				myCh->op.rangeI 
					= myPs->testCond[bd][ch].step[i].rangeI;
				myCh->signal[C_SIG_I_RANGE] 
					= myCh->op.rangeI + 1;
			}

			if(myData->AppControl.config.systemType == CYCLER_CAN){
			}else{								
				if(myPs->config.hwSpec < S_5V_200A) { //linear
					myCh->signal[C_SIG_OUT_SWITCH] = P1;
					myCh->signal[C_SIG_RANGE_SWITCH] = P1;
				}
			}
		}
		myCh->misc.nextDelay = P1;
		myCh->op.checkDelayTime = 0;
	}else{
		if(myCh->misc.nextDelay == P1){	// 201229 lyhw
			//210323 lyhw
			if(myData->AppControl.config.systemType == CYCLER_CAN){ 
				if(myCh->op.checkDelayTime == 80){
					cSemiSwitch_CAN(bd, ch);
				}
				if(myCh->op.checkDelayTime == 90){
					myCh->signal[C_SIG_RANGE_SWITCH] = P1; 
				}
				if(myCh->op.checkDelayTime >= 100){
					myCh->signal[C_SIG_OUT_SWITCH] = P1;
				}
			}
		
			if(myCh->op.checkDelayTime >= 200){
				myCh->misc.nextDelay = P0;
				myCh->op.checkDelayTime = 0;
				myCh->op.code = C_FAULT_NEXTSTEP_CMD;
				rtn = END_COND;
				return rtn;
			}
		}
	}

	if(myCh->misc.nextDelay < P3){ //temp end(P3) or Voltage end(P4) wait flag
		if(myPs->testCond[bd][ch].step[advStepNo].endT != 0) {
			if(myCh->op.runTime >=
				myPs->testCond[bd][ch].step[advStepNo].endT) {
				myCh->op.code = C_END_TIME;
				rtn = END_COND;
				return rtn;
			}
		}
	}

	if(myCh->misc.nextDelay == P3){
		if(myCh->op.checkDelayTime >= 200) {
			myCh->misc.nextDelay = P0;
			myCh->op.code = C_END_TEMP;
			rtn = END_COND;
			return rtn;
		}
		//111215 kji goto stepcheck
		if(myPs->testCond[bd][ch].step[advStepNo].endTempGoto != 0) {
			i = myPs->testCond[bd][ch].step[advStepNo].endTempGoto - 1;
			type = myPs->testCond[bd][ch].step[i].type;
		} else {
			type = cSemi_Rest_Check(bd, ch);
			i = cSemi_Rest_StepNo_Check(bd, ch);
		}
		if(type == STEP_REST){
			if(myPs->testCond[bd][ch].step[i].endT != 0){
				if(myPs->testCond[bd][ch].step[i].endT >= 6000){ // 1 minute
					myCh->signal[C_SIG_OUT_SWITCH] = P0;
					myCh->signal[C_SIG_RANGE_SWITCH] = P0;
				}else{
					if(myData->AppControl.config.systemType == CYCLER_CAN){
						myCh->signal[C_SIG_OUT_SWITCH] = P0;
						myCh->signal[C_SIG_RANGE_SWITCH] = P0;
					}else{
						if(myPs->config.hwSpec < S_5V_200A) { //linear
							myCh->signal[C_SIG_OUT_SWITCH] = P1;
							myCh->signal[C_SIG_RANGE_SWITCH] = P1;
						}
					}
				}
			} else {
				myCh->signal[C_SIG_OUT_SWITCH] = P0;
				myCh->signal[C_SIG_RANGE_SWITCH] = P0;
			}
		}else if(type != STEP_END){
			//210809 add for 2uA Step
			if(myPs->config.hwSpec == L_5V_500mA_2uA_R4
				&& (myPs->testCond[bd][ch].step[i].rangeI + 1) == RANGE4){
			}else{
				myCh->op.rangeV 
					= myPs->testCond[bd][ch].step[i].rangeV;
				myCh->op.rangeI 
					= myPs->testCond[bd][ch].step[i].rangeI;
				myCh->signal[C_SIG_V_RANGE]
					= myCh->op.rangeV + 1;
				myCh->signal[C_SIG_I_RANGE]
					= myCh->op.rangeI + 1;
			}

			if(myData->AppControl.config.systemType == CYCLER_CAN){
				//210323 lyhw
				if(myCh->op.checkDelayTime == 80){
					cSemiSwitch_CAN(bd, ch);
				}
				if(myCh->op.checkDelayTime == 90){
					myCh->signal[C_SIG_RANGE_SWITCH] = P1; 
				}
				if(myCh->op.checkDelayTime >= 100){
					myCh->signal[C_SIG_OUT_SWITCH] = P1;
				}
			}else{
				if(myPs->config.hwSpec < S_5V_200A) { //linear
					myCh->signal[C_SIG_OUT_SWITCH] = P1;
					myCh->signal[C_SIG_RANGE_SWITCH] = P1;
				}
			}
		}
	}

	if(myCh->misc.nextDelay >= P4 && myCh->misc.nextDelay <= P6){
		if(myCh->op.checkDelayTime >= 200) {	
			switch(myCh->misc.nextDelay){
				case P4:	myCh->op.code = C_END_VOLTAGE;	break;
				case P5:	myCh->op.code = C_END_GAS_TVOC;	break;
				case P6:	myCh->op.code = C_END_GAS_ECO2;	break;
				default: break;
			}
			myCh->misc.nextDelay = P0;
			rtn = END_COND;
			return rtn;
		}
		
		i = type = 0;
		//111215 kji goto stepcheck
		if(myCh->misc.nextDelay == P4){
			if(myPs->testCond[bd][ch].step[advStepNo].endVGoto != 0) {
				i = myPs->testCond[bd][ch].step[advStepNo].endVGoto - 1;
				type = myPs->testCond[bd][ch].step[i].type;
			} else {
				type = cSemi_Rest_Check(bd, ch);
				i = cSemi_Rest_StepNo_Check(bd, ch);
			}
		}
		#if GAS_DATA_CONTROL == 1
		//210923 lyhw add for LGES gas control Goto Step Check (Rest)
		if(myCh->misc.nextDelay == P5){
			if(myPs->testCond[bd][ch].step[advStepNo].endGasTVOC_Goto != 0) {
				i = myPs->testCond[bd][ch].step[advStepNo].endGasTVOC_Goto-1;
				type = myPs->testCond[bd][ch].step[i].type;
			}else{
				type = cSemi_Rest_Check(bd, ch);
				i = cSemi_Rest_StepNo_Check(bd, ch);
			}
		}
		if(myCh->misc.nextDelay == P6){
			if(myPs->testCond[bd][ch].step[advStepNo].endGasECo2_Goto != 0) {
				i = myPs->testCond[bd][ch].step[advStepNo].endGasECo2_Goto-1;
				type = myPs->testCond[bd][ch].step[i].type;
			}else{
				type = cSemi_Rest_Check(bd, ch);
				i = cSemi_Rest_StepNo_Check(bd, ch);
			}
		}
		#endif
		
		if(type == STEP_REST){
			if(myPs->testCond[bd][ch].step[i].endT != 0){
				if(myPs->testCond[bd][ch].step[i].endT >= 6000){ // 1 minute
					myCh->signal[C_SIG_OUT_SWITCH] = P0;
					myCh->signal[C_SIG_RANGE_SWITCH] = P0;
				}else{
					if(myData->AppControl.config.systemType == CYCLER_CAN){
						myCh->signal[C_SIG_OUT_SWITCH] = P0;
						myCh->signal[C_SIG_RANGE_SWITCH] = P0;
					}else{
						if(myPs->config.hwSpec < S_5V_200A) { //linear
							myCh->signal[C_SIG_OUT_SWITCH] = P1;
							myCh->signal[C_SIG_RANGE_SWITCH] = P1;
						}
					}
				}
			} else {
				myCh->signal[C_SIG_OUT_SWITCH] = P0;
				myCh->signal[C_SIG_RANGE_SWITCH] = P0;
			}
		}else if(type != STEP_END){
			//210809 add for 2uA Step
			if(myPs->config.hwSpec == L_5V_500mA_2uA_R4
				&& (myPs->testCond[bd][ch].step[i].rangeI + 1) == RANGE4){
			}else{
				myCh->op.rangeV 
					= myPs->testCond[bd][ch].step[i].rangeV;
				myCh->op.rangeI 
					= myPs->testCond[bd][ch].step[i].rangeI;
				myCh->signal[C_SIG_V_RANGE]
					= myCh->op.rangeV + 1;
				myCh->signal[C_SIG_I_RANGE]
					= myCh->op.rangeI + 1;
			}

			if(myData->AppControl.config.systemType == CYCLER_CAN){
				//210323 lyhw
				if(myCh->op.checkDelayTime == 80){
					cSemiSwitch_CAN(bd, ch);
				}
				if(myCh->op.checkDelayTime == 90){
					myCh->signal[C_SIG_RANGE_SWITCH] = P1; 
				}
				if(myCh->op.checkDelayTime >= 100){
					myCh->signal[C_SIG_OUT_SWITCH] = P1;
				}
			}else{
				if(myPs->config.hwSpec < S_5V_200A) { //linear
					myCh->signal[C_SIG_OUT_SWITCH] = P1;
					myCh->signal[C_SIG_RANGE_SWITCH] = P1;
				}
			}
		}
	}
	// end check voltage , temp
	// relay delay 2sec return
	if(myCh->misc.nextDelay < P3 || myCh->misc.nextDelay == P10){
		if(myPs->testCond[bd][ch].step[advStepNo].endTemp != 0) {
			tempEndCheck(bd, ch, rtn, advStepNo);
		}
		if(myPs->testCond[bd][ch].step[advStepNo].endV != 0
			|| (myPs->testCond[bd][ch].step[advStepNo].endV == 0
				&& myPs->testCond[bd][ch].step[advStepNo].endZeroVoltageFlag == 1)) {
			if(myCh->misc.tmpVsens >=
				myPs->testCond[bd][ch].step[advStepNo].endV) {
				if(myCh->misc.nextDelay != P4){
					myCh->misc.nextDelay = P4;
					myCh->op.checkDelayTime = 0;	
				}		
			}
		}
		if(myPs->testCond[bd][ch].step[advStepNo].endV_L != 0
			|| (myPs->testCond[bd][ch].step[advStepNo].endV_L == 0
				&& myPs->testCond[bd][ch].step[advStepNo].endZeroVoltageFlag == 1)) {
			if(myCh->misc.tmpVsens <=
				myPs->testCond[bd][ch].step[advStepNo].endV_L) {
				if(myCh->misc.nextDelay != P4){
					myCh->misc.nextDelay = P4;
					myCh->op.checkDelayTime = 0;
				}
			}
		}
		//150126 lyh add for rest Delta V
		if(myPs->testCond[bd][ch].step[advStepNo].endDeltaV != 0){
			if((myCh->op.runTime % myPs->testCond[bd][ch].step[advStepNo].endT_CV) == 0){
				if(labs(myCh->misc.compareV - myCh->op.Vsens) <=
					myPs->testCond[bd][ch].step[advStepNo].endDeltaV){
					myCh->op.code = C_END_DELTA_V;
					rtn = END_COND;
					return rtn;
				}else{
					myCh->misc.compareV = myCh->op.Vsens;
				}
			}
		}
		//210923 lyhw add for LGES gas control (Rest)
		#if GAS_DATA_CONTROL == 1
		if(myPs->testCond[bd][ch].step[advStepNo].endGasTVOC != 0) {
			if(myCh->misc.gas_TVOC >=
				myPs->testCond[bd][ch].step[advStepNo].endGasTVOC) {
				if(myCh->misc.nextDelay != P5){
					myCh->misc.nextDelay = P5;
					myCh->op.checkDelayTime = 0;
				}
			}
		}
	
		if(myPs->testCond[bd][ch].step[advStepNo].endGasECo2 != 0) {
			if(myCh->misc.gas_eCo2 >=
				myPs->testCond[bd][ch].step[advStepNo].endGasECo2) {
				if(myCh->misc.nextDelay != P6){
					myCh->misc.nextDelay = P6;
					myCh->op.checkDelayTime = 0;
				}
			}
		}
		#endif
	}
//020414 ljsw
#if END_V_COMPARE_GOTO == 1
	if(myCh->misc.nextDelay >= P11){
		if(myCh->misc.nextDelay == P12){
			if(myCh->op.checkDelayTime >= 200) {	
				myCh->misc.nextDelay = P0;
				myCh->op.code = C_END_T_V_UPPER;
				rtn = END_COND;
				return rtn;
			}
			//111215 kji goto stepcheck
			if(myTestCond->step[advStepNo].endVupper_GotoStep != 0) {
				i = myTestCond->step[advStepNo].endVupper_GotoStep - 1;
				type = myTestCond->step[i].type;
			} else {
				type = cSemi_Rest_Check(bd, ch);
				i = cSemi_Rest_StepNo_Check(bd, ch);
			}
		}else if(myCh->misc.nextDelay == P13){
			if(myCh->op.checkDelayTime >= 200) {	
				myCh->misc.nextDelay = P0;
				myCh->op.code = C_END_T_V_LOWER;
				rtn = END_COND;
				return rtn;
			}
			//111215 kji goto stepcheck
			if(myTestCond->step[advStepNo].endVlower_GotoStep != 0) {
				i = myTestCond->step[advStepNo].endVlower_GotoStep - 1;
				type = myTestCond->step[i].type;
			} else {
				type = cSemi_Rest_Check(bd, ch);
				i = cSemi_Rest_StepNo_Check(bd, ch);
			}
		}else{
			if(myCh->op.checkDelayTime >= 200) {	
				myCh->misc.nextDelay = P0;
				myCh->op.code = C_END_TIME;
				rtn = END_COND;
				return rtn;
			}
			if(myTestCond->step[advStepNo].endTGoto != 0) {
				i = myTestCond->step[advStepNo].endTGoto - 1;
				type = myTestCond->step[i].type;
			} else {
				type = cSemi_Rest_Check(bd, ch);
				i = cSemi_Rest_StepNo_Check(bd, ch);
			}
		}
		
		if(type == STEP_REST){
			if(myPs->testCond[bd][ch].step[i].endT != 0){
				if(myPs->testCond[bd][ch].step[i].endT >= 6000){ // 1 minute
					myCh->signal[C_SIG_OUT_SWITCH] = P0;
					myCh->signal[C_SIG_RANGE_SWITCH] = P0;
				}else{
					if(myPs->config.hwSpec < S_5V_200A) { //linear
						myCh->signal[C_SIG_OUT_SWITCH] = P1;
						myCh->signal[C_SIG_RANGE_SWITCH] = P1;
					}
				}
			} else {
				myCh->signal[C_SIG_OUT_SWITCH] = P0;
				myCh->signal[C_SIG_RANGE_SWITCH] = P0;
			}
		}else if(type != STEP_END){
			//210809 add for 2uA Step
			if(myPs->config.hwSpec == L_5V_500mA_2uA_R4
				&& (myPs->testCond[bd][ch].step[i].rangeI + 1) == RANGE4){
			}else{
				myCh->op.rangeV 
					= myPs->testCond[bd][ch].step[i].rangeV;
				myCh->op.rangeI 
					= myPs->testCond[bd][ch].step[i].rangeI;
				myCh->signal[C_SIG_V_RANGE]
					= myCh->op.rangeV + 1;
				myCh->signal[C_SIG_I_RANGE]
					= myCh->op.rangeI + 1;
			}

			if(myPs->config.hwSpec < S_5V_200A) { //linear
				myCh->signal[C_SIG_OUT_SWITCH] = P1;
				myCh->signal[C_SIG_RANGE_SWITCH] = P1;
			}
		}
	}
	
	if(myCh->misc.nextDelay == P10){
		if(myCh->op.runTime >= myTestCond->step[advStepNo].endT) {
			if(myTestCond->step[advStepNo].endVGoto_upper != 0){
				if(myCh->op.Vsens 
						>= myTestCond->step[advStepNo].endVGoto_upper){
					myCh->misc.nextDelay = P12;	
					myCh->op.checkDelayTime = 0;
				}
			}
			if(myTestCond->step[advStepNo].endVGoto_lower != 0){
				if(myCh->op.Vsens 
					< myTestCond->step[advStepNo].endVGoto_lower){
					myCh->misc.nextDelay = P13;	
					myCh->op.checkDelayTime = 0;
				}
			}
			if(myCh->misc.nextDelay == P10){	
				myCh->misc.nextDelay = P11;	
				myCh->op.checkDelayTime = 0;
			}
		}
	}
#endif
	return rtn;
}

int cEndCond_Rest_P(int bd, int ch, int rtn, unsigned long advStepNo)
{
	int diff=0;
	unsigned long i;
	unsigned char type;
	unsigned char relay_on1 = 0 , relay_on2 = 0, relay_off1 = 0 , relay_off2 = 0; 

	myCh = &(myData->bData[bd].cData[ch]);
	myTestCond = &(myPs->testCond[bd][ch]);
	
	if(myPs->config.hwSpec > DC_DIGITAL_SPEC){ //180611 add for digital
		relay_on1 = myCh->signal[C_SIG_OUT_SWITCH_ON];
		relay_off1 = myCh->signal[C_SIG_OUT_SWITCH_OFF];
		relay_on2 = myData->bData[bd].cData[ch-1].signal[C_SIG_OUT_SWITCH_ON];
		relay_off2 = myData->bData[bd].cData[ch-1].signal[C_SIG_OUT_SWITCH_OFF];
	}
	
	if(myPs->testCond[bd][ch].step[advStepNo].endT != 0) {
		if(myPs->testCond[bd][ch].step[advStepNo].endT >= 6000) { // 1 minute
			if(myCh->misc.nextDelay == P0)
			{
				myCh->signal[C_SIG_OUT_SWITCH] = P0;
				myData->bData[bd].cData[ch-1].signal[C_SIG_OUT_SWITCH] = P0;
	
			}
		}
		diff = myPs->testCond[bd][ch].step[advStepNo].endT
			- myCh->op.runTime;
		if(diff <= 200 && myCh->misc.nextDelay < P5){
			//111215 kji goto stepcheck
			if(myPs->testCond[bd][ch].step[advStepNo].endTGoto != 0) {
				i = myPs->testCond[bd][ch].step[advStepNo].endTGoto - 1;
				type = myPs->testCond[bd][ch].step[i].type;
			} else {
				type = cSemi_Rest_Check(bd, ch);
				i = cSemi_Rest_StepNo_Check(bd, ch);
			}
			if(type == STEP_REST){
				if(myPs->testCond[bd][ch].step[i].endT != 0) {
					if(myPs->testCond[bd][ch].step[i].endT >= 6000) {// 1 minute
						myCh->signal[C_SIG_OUT_SWITCH] = P0;
						myCh->signal[C_SIG_RANGE_SWITCH] = P0;
						myData->bData[bd].cData[ch-1].signal[C_SIG_OUT_SWITCH] = P0;
						myData->bData[bd].cData[ch-1].signal[C_SIG_RANGE_SWITCH] = P0;
					}else{
				//      111215 kji slave ch out switch open
				//		myCh->signal[C_SIG_OUT_SWITCH] = P1;
						if(myPs->config.hwSpec == L_5V_10A_R3_NEW)
							myCh->signal[C_SIG_OUT_SWITCH] = P1;
						myCh->signal[C_SIG_RANGE_SWITCH] = P1;
						myData->bData[bd].cData[ch-1].signal[C_SIG_OUT_SWITCH] = P1;
						myData->bData[bd].cData[ch-1].signal[C_SIG_RANGE_SWITCH] = P1;
						if(myPs->config.hwSpec > DC_DIGITAL_SPEC){//180611 add
						/* 201015
							if(relay_on1 != P3)			
								myCh->signal[C_SIG_OUT_SWITCH_ON] = P1;
							if(relay_on2 != P3)			
								myData->bData[bd].cData[ch-1].signal[C_SIG_OUT_SWITCH_ON] = P1;
						*/
						}
					}
				} else {
					myCh->signal[C_SIG_OUT_SWITCH] = P0;
					myCh->signal[C_SIG_RANGE_SWITCH] = P0;
					myData->bData[bd].cData[ch-1].signal[C_SIG_OUT_SWITCH] = P0;
					myData->bData[bd].cData[ch-1].signal[C_SIG_RANGE_SWITCH] = P0;
					if(myPs->config.hwSpec > DC_DIGITAL_SPEC){ //180611 add 
					/* 201015
						myCh->signal[C_SIG_OUT_SWITCH_OFF] = P1;
						myData->bData[bd].cData[ch-1].signal[C_SIG_OUT_SWITCH_OFF] = P1;
					*/
					}
				}
				
			}else if(type != STEP_END){
				myCh->op.rangeV 
					= myPs->testCond[bd][ch].step[i].rangeV;
				myCh->op.rangeI 
					= myPs->testCond[bd][ch].step[i].rangeI;
				myCh->signal[C_SIG_V_RANGE]
					= myCh->op.rangeV + 1;
				myCh->signal[C_SIG_I_RANGE]
					= myCh->op.rangeI + 1;
		//      111215 kji slave ch out switch open
		//		myCh->signal[C_SIG_OUT_SWITCH] = P1;
				if(myPs->config.hwSpec == L_5V_10A_R3_NEW)
					myCh->signal[C_SIG_OUT_SWITCH] = P1;
				myCh->signal[C_SIG_RANGE_SWITCH] = P1;
				myData->bData[bd].cData[ch-1].signal[C_SIG_OUT_SWITCH] = P1;
				myData->bData[bd].cData[ch-1].signal[C_SIG_RANGE_SWITCH] = P1;		
				if(myPs->config.hwSpec > DC_DIGITAL_SPEC){	//180611 add 
					/* 201015
					if(relay_on1 != P3){			
						myCh->signal[C_SIG_OUT_SWITCH_ON] = P1;
					}
					if(relay_on2 != P3){		
						myData->bData[bd].cData[ch-1]
									.signal[C_SIG_OUT_SWITCH_ON] = P1;
					}
					//180905 add for single Rest CC0
					if(diff == 10){
						ch_send_cmd(bd, ch, ADDR_PCU_CLASS_MULTICAST,
												CMD_PCU_MODE_CC, 0, 0);
					}*/
				}
			}
		}
#if END_V_COMPARE_GOTO == 1 // 210312 parallel
		if(myTestCond->step[advStepNo].endVupper_GotoStep != 0
				||myTestCond->step[advStepNo].endVlower_GotoStep != 0){
			if(myCh->misc.nextDelay == P0){
				myCh->misc.nextDelay = P5;
				myCh->op.checkDelayTime = 0;
			}
		}
#endif
	} else {
		if(myCh->misc.nextDelay == P0)
			myCh->signal[C_SIG_OUT_SWITCH] = P0;
	}

	if(myCh->signal[C_SIG_NEXTSTEP] == P1) {
		myCh->signal[C_SIG_NEXTSTEP] = P0;
		myData->bData[bd].cData[ch-1].signal[C_SIG_NEXTSTEP] = P0;
		type = cSemi_Rest_Check(bd, ch);
		i = cSemi_Rest_StepNo_Check(bd, ch);
		if(type == STEP_REST){
			if(myPs->testCond[bd][ch].step[i].endT != 0) {
				if(myPs->testCond[bd][ch].step[i].endT >= 6000) {// 1 minute
					myCh->signal[C_SIG_OUT_SWITCH] = P0;
					myCh->signal[C_SIG_RANGE_SWITCH] = P0;
					myData->bData[bd].cData[ch-1].signal[C_SIG_OUT_SWITCH] = P0;
					myData->bData[bd].cData[ch-1].signal[C_SIG_RANGE_SWITCH] = P0;				
					if(myPs->config.hwSpec > DC_DIGITAL_SPEC){ //180611 add 
						/* 201015
						myCh->signal[C_SIG_OUT_SWITCH_OFF] = P1;
						myData->bData[bd].cData[ch-1].signal[C_SIG_OUT_SWITCH_OFF] = P1;
						*/
					}
				}else{
			//      111215 kji slave ch out switch open
			//		myCh->signal[C_SIG_OUT_SWITCH] = P1;
					if(myPs->config.hwSpec == L_5V_10A_R3_NEW)
						myCh->signal[C_SIG_OUT_SWITCH] = P1;
					myCh->signal[C_SIG_RANGE_SWITCH] = P1;
					myData->bData[bd].cData[ch-1].signal[C_SIG_OUT_SWITCH] = P1;
					myData->bData[bd].cData[ch-1].signal[C_SIG_RANGE_SWITCH] = P1;
					if(myPs->config.hwSpec > DC_DIGITAL_SPEC){	//180611 add 
						/* 201015
						myData->bData[bd].cData[ch-1].signal[C_SIG_OUT_SWITCH_ON] = P1;
						*/
					}
				}
			} else {
				myCh->signal[C_SIG_OUT_SWITCH] = P0;
				myCh->signal[C_SIG_RANGE_SWITCH] = P0;
				myData->bData[bd].cData[ch-1].signal[C_SIG_OUT_SWITCH] = P0;
				myData->bData[bd].cData[ch-1].signal[C_SIG_RANGE_SWITCH] = P0;
				if(myPs->config.hwSpec > DC_DIGITAL_SPEC){	//180611 add 
					/* 201015
					myCh->signal[C_SIG_OUT_SWITCH_OFF] = P1;
					myData->bData[bd].cData[ch-1].signal[C_SIG_OUT_SWITCH_OFF] = P1;
					*/
				}
			}
	//	}else if(type == STEP_CHARGE
	//		|| type == STEP_DISCHARGE
	//		|| type == STEP_Z){
	// 111215 kji add 
		}else if(type != STEP_END){
			myCh->op.rangeI 
				= myPs->testCond[bd][ch].step[i].rangeI;
			myCh->signal[C_SIG_I_RANGE]
				= myCh->op.rangeI + 1;
//			myCh->misc.preRangeI
//			 	= myCh->op.rangeI;
	//      111215 kji slave ch out switch open
	//		myCh->signal[C_SIG_OUT_SWITCH] = P1;
			if(myPs->config.hwSpec == L_5V_10A_R3_NEW)
				myCh->signal[C_SIG_OUT_SWITCH] = P1;
			myCh->signal[C_SIG_RANGE_SWITCH] = P1;
			myData->bData[bd].cData[ch-1].signal[C_SIG_OUT_SWITCH] = P1;
			myData->bData[bd].cData[ch-1].signal[C_SIG_RANGE_SWITCH] = P1;		
			if(myPs->config.hwSpec > DC_DIGITAL_SPEC){	//180611 add 
				/* 201015
				if(relay_on1 != P3)
					myCh->signal[C_SIG_OUT_SWITCH_ON] = P1;
				if(relay_on2 != P3)
					myData->bData[bd].cData[ch-1].signal[C_SIG_OUT_SWITCH_ON] = P1;
				*/
			}
		}

		myCh->misc.nextDelay = P1;
		myCh->op.checkDelayTime = 0;
	}else{
		if(myCh->misc.nextDelay == P1){
			if(myCh->op.checkDelayTime >=200){
				myCh->misc.nextDelay = P0;
				myCh->op.checkDelayTime = 0;
				myCh->op.code = C_FAULT_NEXTSTEP_CMD;
				rtn = END_COND;
				return rtn;
			}
		}
	}
	/* 111215 kji delete
	if(myPs->testCond[bd][ch].step[advStepNo].endT != 0) {
		if(myCh->op.runTime >=
			myPs->testCond[bd][ch].step[advStepNo].endT) {
			myCh->op.code = C_END_TIME;
			rtn = END_COND;
			return rtn;
		}
	}*/
	if(myCh->misc.nextDelay < P3){ //temp end(P3) or Voltage end(P4) wait flag
		if(myPs->testCond[bd][ch].step[advStepNo].endT != 0) {
			if(myCh->op.runTime >=
				myPs->testCond[bd][ch].step[advStepNo].endT) {
				myCh->op.code = C_END_TIME;
				rtn = END_COND;
				return rtn;
			}
		}
	}
	if(myCh->misc.nextDelay == P3){
		if(myCh->op.checkDelayTime >= 200) {
			myCh->misc.nextDelay = P0;
			myCh->op.code = C_END_TEMP;
			rtn = END_COND;
			return rtn;
		}
			//111215 kji goto stepcheck
		if(myPs->testCond[bd][ch].step[advStepNo].endTempGoto != 0) {
			i = myPs->testCond[bd][ch].step[advStepNo].endTempGoto - 1;
			type = myPs->testCond[bd][ch].step[i].type;
		} else {
			type = cSemi_Rest_Check(bd, ch);
			i = cSemi_Rest_StepNo_Check(bd, ch);
		}
		if(type == STEP_REST){
			if(myPs->testCond[bd][ch].step[i].endT != 0){
				if(myPs->testCond[bd][ch].step[i].endT >= 6000){ // 1 minute
					myCh->signal[C_SIG_OUT_SWITCH] = P0;
					myCh->signal[C_SIG_RANGE_SWITCH] = P0;
					//111215 kji w
					myData->bData[bd].cData[ch-1].signal[C_SIG_OUT_SWITCH] = P0;
					myData->bData[bd].cData[ch-1].signal[C_SIG_RANGE_SWITCH] = P0;
				}else{
					if(myPs->config.hwSpec < S_5V_200A) { //linear
				//      111215 kji slave ch out switch open
				//		myCh->signal[C_SIG_OUT_SWITCH] = P1;
						if(myPs->config.hwSpec == L_5V_10A_R3_NEW)
							myCh->signal[C_SIG_OUT_SWITCH] = P1;
						myCh->signal[C_SIG_RANGE_SWITCH] = P1;
					//111215 kji w
						myData->bData[bd].cData[ch-1].signal[C_SIG_OUT_SWITCH] = P1;
						myData->bData[bd].cData[ch-1].signal[C_SIG_RANGE_SWITCH] = P1;
					}else if(myPs->config.hwSpec > DC_DIGITAL_SPEC){ //180611 
						/* 201015
						myCh->signal[C_SIG_RANGE_SWITCH] = P1;
						myData->bData[bd].cData[ch-1].signal[C_SIG_OUT_SWITCH] = P1;
						myData->bData[bd].cData[ch-1].signal[C_SIG_RANGE_SWITCH] = P1;
						if(relay_on1 != P3)
							myCh->signal[C_SIG_OUT_SWITCH_ON] = P1;
						if(relay_on2 != P3)
							myData->bData[bd].cData[ch-1].signal[C_SIG_OUT_SWITCH_ON] = P1;
						*/
					}
				}
			} else {
				myCh->signal[C_SIG_OUT_SWITCH] = P0;
				myCh->signal[C_SIG_RANGE_SWITCH] = P0;
					//111215 kji w
				myData->bData[bd].cData[ch-1].signal[C_SIG_OUT_SWITCH] = P0;
				myData->bData[bd].cData[ch-1].signal[C_SIG_RANGE_SWITCH] = P0;
				//180611 add for digital
				if(myPs->config.hwSpec > DC_DIGITAL_SPEC){	//180611 add 
					/* 201015
					if(relay_off1 != P3)
						myCh->signal[C_SIG_OUT_SWITCH_OFF] = P1;
					if(relay_off2 != P3)
						myData->bData[bd].cData[ch-1].signal[C_SIG_OUT_SWITCH_OFF] = P1;
					*/
				}
			}
		}else if(type != STEP_END){
			myCh->op.rangeV 
				= myPs->testCond[bd][ch].step[i].rangeV;
			myCh->op.rangeI 
				= myPs->testCond[bd][ch].step[i].rangeI;
			myCh->signal[C_SIG_V_RANGE]
				= myCh->op.rangeV + 1;
			myCh->signal[C_SIG_I_RANGE]
				= myCh->op.rangeI + 1;
			if(myPs->config.hwSpec < S_5V_200A) { //linear
		//      111215 kji slave ch out switch open
		//		myCh->signal[C_SIG_OUT_SWITCH] = P1;
				if(myPs->config.hwSpec == L_5V_10A_R3_NEW)
					myCh->signal[C_SIG_OUT_SWITCH] = P1;
				myCh->signal[C_SIG_RANGE_SWITCH] = P1;
					//111215 kji w
				myData->bData[bd].cData[ch-1].signal[C_SIG_OUT_SWITCH] = P1;
				myData->bData[bd].cData[ch-1].signal[C_SIG_RANGE_SWITCH] = P1;			
				if(myPs->config.hwSpec > DC_DIGITAL_SPEC){	//180611 add
					/* 201015 
					if(relay_on1 != P3)
						myCh->signal[C_SIG_OUT_SWITCH_ON] = P1;
					if(relay_on2 != P3)
						myData->bData[bd].cData[ch-1].signal[C_SIG_OUT_SWITCH_ON] = P1;
					*/
				}
			}
		}
	}
	if(myCh->misc.nextDelay == P4){
		if(myCh->op.checkDelayTime >= 200) {
			myCh->misc.nextDelay = P0;
			myCh->op.code = C_END_VOLTAGE;
			rtn = END_COND;
			return rtn;
		}
			//111215 kji goto stepcheck
		if(myPs->testCond[bd][ch].step[advStepNo].endVGoto != 0) {
			i = myPs->testCond[bd][ch].step[advStepNo].endVGoto - 1;
			type = myPs->testCond[bd][ch].step[i].type;
		} else {
			type = cSemi_Rest_Check(bd, ch);
			i = cSemi_Rest_StepNo_Check(bd, ch);
		}
		if(type == STEP_REST){
			if(myPs->testCond[bd][ch].step[i].endT != 0){
				if(myPs->testCond[bd][ch].step[i].endT >= 6000){ // 1 minute
					myCh->signal[C_SIG_OUT_SWITCH] = P0;
					myCh->signal[C_SIG_RANGE_SWITCH] = P0;
					//111215 kji w
					myData->bData[bd].cData[ch-1].signal[C_SIG_OUT_SWITCH] = P0;
					myData->bData[bd].cData[ch-1].signal[C_SIG_RANGE_SWITCH] = P0;
				}else{
					if(myPs->config.hwSpec < S_5V_200A) { //linear
				//      111215 kji slave ch out switch open
				//		myCh->signal[C_SIG_OUT_SWITCH] = P1;
						if(myPs->config.hwSpec == L_5V_10A_R3_NEW)
							myCh->signal[C_SIG_OUT_SWITCH] = P1;
						myCh->signal[C_SIG_RANGE_SWITCH] = P1;
						myData->bData[bd].cData[ch-1].signal[C_SIG_OUT_SWITCH] = P1;
						myData->bData[bd].cData[ch-1].signal[C_SIG_RANGE_SWITCH] = P1;
					}else if(myPs->config.hwSpec > DC_DIGITAL_SPEC){ //180611 
						/* 201015
						myCh->signal[C_SIG_RANGE_SWITCH] = P1;
						myData->bData[bd].cData[ch-1].signal[C_SIG_OUT_SWITCH] = P1;
						myData->bData[bd].cData[ch-1].signal[C_SIG_RANGE_SWITCH] = P1;
						if(relay_on1 != P3)
							myCh->signal[C_SIG_OUT_SWITCH_ON] = P1;
						if(relay_on2 != P3)
							myData->bData[bd].cData[ch-1].signal[C_SIG_OUT_SWITCH_ON] = P1;
						*/
					}
				}
			} else {
				myCh->signal[C_SIG_OUT_SWITCH] = P0;
				myCh->signal[C_SIG_RANGE_SWITCH] = P0;
					//111215 kji w
				myData->bData[bd].cData[ch-1].signal[C_SIG_OUT_SWITCH] = P0;
				myData->bData[bd].cData[ch-1].signal[C_SIG_RANGE_SWITCH] = P0;
				if(myPs->config.hwSpec > DC_DIGITAL_SPEC){	//180611 add 
					/*
					if(relay_off1 != P3)
						myCh->signal[C_SIG_OUT_SWITCH_OFF] = P1;
					if(relay_off2 != P3)
						myData->bData[bd].cData[ch-1].signal[C_SIG_OUT_SWITCH_OFF] = P1;
					*/
				}
			}
		}else if(type != STEP_END){
			myCh->op.rangeV 
				= myPs->testCond[bd][ch].step[i].rangeV;
			myCh->op.rangeI 
				= myPs->testCond[bd][ch].step[i].rangeI;
			myCh->signal[C_SIG_V_RANGE]
				= myCh->op.rangeV + 1;
			myCh->signal[C_SIG_I_RANGE]
				= myCh->op.rangeI + 1;
			if(myPs->config.hwSpec < S_5V_200A) { //linear
		//      111215 kji slave ch out switch open
		//		myCh->signal[C_SIG_OUT_SWITCH] = P1;
				if(myPs->config.hwSpec == L_5V_10A_R3_NEW)
					myCh->signal[C_SIG_OUT_SWITCH] = P1;
				myCh->signal[C_SIG_RANGE_SWITCH] = P1;
					//111215 kji w
				myData->bData[bd].cData[ch-1].signal[C_SIG_OUT_SWITCH] = P1;
				myData->bData[bd].cData[ch-1].signal[C_SIG_RANGE_SWITCH] = P1;
			}else if(myPs->config.hwSpec > DC_DIGITAL_SPEC){ //180611 add
				/* 201015
				myCh->signal[C_SIG_RANGE_SWITCH] = P1;
				myData->bData[bd].cData[ch-1].signal[C_SIG_OUT_SWITCH] = P1;
				myData->bData[bd].cData[ch-1].signal[C_SIG_RANGE_SWITCH] = P1;
				if(relay_on1 != P3)
					myCh->signal[C_SIG_OUT_SWITCH_ON] = P1;
				if(relay_on2 != P3)
					myData->bData[bd].cData[ch-1].signal[C_SIG_OUT_SWITCH_ON] = P1;
				*/	
			}
		}
	}

	myData->bData[bd].cData[ch-1].op.rangeV = myCh->op.rangeV;
	myData->bData[bd].cData[ch-1].op.rangeI = myCh->op.rangeI;
	myData->bData[bd].cData[ch-1].signal[C_SIG_V_RANGE] =
		        myCh->op.rangeV + 1;
	myData->bData[bd].cData[ch-1].signal[C_SIG_I_RANGE] =
		        myCh->op.rangeI + 1;
	// end check voltage , temp
	//
	// relay delay 2sec return
	if(myCh->misc.nextDelay != P3||P4){
		if(myPs->testCond[bd][ch].step[advStepNo].endTemp != 0) {
			tempEndCheck(bd, ch, rtn, advStepNo);
		}
		if(myPs->testCond[bd][ch].step[advStepNo].endV != 0
			|| (myPs->testCond[bd][ch].step[advStepNo].endV == 0
				&& myPs->testCond[bd][ch].step[advStepNo].endZeroVoltageFlag == 1)) {
			if(myCh->misc.tmpVsens >=
				myPs->testCond[bd][ch].step[advStepNo].endV) {
		//			myCh->op.code = C_END_VOLTAGE;
		//			rtn = END_COND;
		//			return rtn;
				if(myCh->misc.nextDelay != P4){
					myCh->misc.nextDelay = P4;
					myCh->op.checkDelayTime = 0;	
				return rtn;
				}		
			}
		}
		if(myPs->testCond[bd][ch].step[advStepNo].endV_L != 0
			|| (myPs->testCond[bd][ch].step[advStepNo].endV_L == 0
				&& myPs->testCond[bd][ch].step[advStepNo].endZeroVoltageFlag == 1)) {
			if(myCh->misc.tmpVsens <=
				myPs->testCond[bd][ch].step[advStepNo].endV_L) {
		//			myCh->op.code = C_END_VOLTAGE;
		//			rtn = END_COND;
		//			return rtn;
				if(myCh->misc.nextDelay != P4){
					myCh->misc.nextDelay = P4;
					myCh->op.checkDelayTime = 0;
				return rtn;
				}
			}
		}
	}
#if END_V_COMPARE_GOTO == 1 // 210312 parallel
	if(myCh->misc.nextDelay >= P6 && myCh->misc.nextDelay <= P8){
		if(myCh->misc.nextDelay == P6){
			if(myCh->op.checkDelayTime >= 200) {
				myCh->op.checkDelayTime = 0;
				myCh->misc.nextDelay = P0;
				myData->bData[bd].cData[ch-1].misc.nextDelay = P0;
				myCh->op.code = C_END_T_V_UPPER;
				rtn = END_COND;
				return rtn;
			}
			//111215 kji goto stepcheck
			if(myTestCond->step[advStepNo].endVupper_GotoStep != 0) {
				i = myTestCond->step[advStepNo].endVupper_GotoStep - 1;
				type = myTestCond->step[i].type;
			} else {
				type = cSemi_Rest_Check(bd, ch);
				i = cSemi_Rest_StepNo_Check(bd, ch);
			}
		}else if(myCh->misc.nextDelay == P7){
			if(myCh->op.checkDelayTime >= 200) {	
				myCh->op.checkDelayTime = 0;
				myCh->misc.nextDelay = P0;
				myData->bData[bd].cData[ch-1].misc.nextDelay = P0;
				myCh->op.code = C_END_T_V_LOWER;
				rtn = END_COND;
				return rtn;
			}
			//111215 kji goto stepcheck
			if(myTestCond->step[advStepNo].endVlower_GotoStep != 0) {
				i = myTestCond->step[advStepNo].endVlower_GotoStep - 1;
				type = myTestCond->step[i].type;
			} else {
				type = cSemi_Rest_Check(bd, ch);
				i = cSemi_Rest_StepNo_Check(bd, ch);
			}
		}else{
			if(myCh->op.checkDelayTime >= 200) {	
				myCh->op.checkDelayTime = 0;
				myCh->misc.nextDelay = P0;
				myData->bData[bd].cData[ch-1].misc.nextDelay = P0;
				myCh->op.code = C_END_TIME;
				rtn = END_COND;
				return rtn;
			}
			if(myTestCond->step[advStepNo].endTGoto != 0) {
				i = myTestCond->step[advStepNo].endTGoto - 1;
				type = myTestCond->step[i].type;
			} else {
				type = cSemi_Rest_Check(bd, ch);
				i = cSemi_Rest_StepNo_Check(bd, ch);
			}
		}

		if(type == STEP_REST){
			if(myPs->testCond[bd][ch].step[i].endT != 0){
				if(myPs->testCond[bd][ch].step[i].endT >= 6000){ // 1 minute
					myCh->signal[C_SIG_OUT_SWITCH] = P0;
					myCh->signal[C_SIG_RANGE_SWITCH] = P0;
					myData->bData[bd].cData[ch-1].signal[C_SIG_OUT_SWITCH] = P0;
					myData->bData[bd].cData[ch-1].signal[C_SIG_RANGE_SWITCH] = P0;
				}else{
					if(myPs->config.hwSpec < S_5V_200A) { //linear
						myCh->signal[C_SIG_OUT_SWITCH] = P1;
						myCh->signal[C_SIG_RANGE_SWITCH] = P1;
						myData->bData[bd].cData[ch-1].signal[C_SIG_OUT_SWITCH] = P1;
						myData->bData[bd].cData[ch-1].signal[C_SIG_RANGE_SWITCH] = P1;
					}else if(myPs->config.hwSpec > DC_DIGITAL_SPEC){ //180611 
					}
				}
			} else {
				myCh->signal[C_SIG_OUT_SWITCH] = P0;
				myCh->signal[C_SIG_RANGE_SWITCH] = P0;
				myData->bData[bd].cData[ch-1].signal[C_SIG_OUT_SWITCH] = P0;
				myData->bData[bd].cData[ch-1].signal[C_SIG_RANGE_SWITCH] = P0;
				if(myPs->config.hwSpec > DC_DIGITAL_SPEC){	//180611 add 
				}
			}
		}else if(type != STEP_END){
			myCh->op.rangeV 
				= myPs->testCond[bd][ch].step[i].rangeV;
			myCh->op.rangeI 
				= myPs->testCond[bd][ch].step[i].rangeI;
			myCh->signal[C_SIG_V_RANGE]
				= myCh->op.rangeV + 1;
			myCh->signal[C_SIG_I_RANGE]
				= myCh->op.rangeI + 1;
			if(myPs->config.hwSpec < S_5V_200A) { //linear
				myCh->signal[C_SIG_OUT_SWITCH] = P1;
				myCh->signal[C_SIG_RANGE_SWITCH] = P1;
				myData->bData[bd].cData[ch-1].signal[C_SIG_OUT_SWITCH] = P1;
				myData->bData[bd].cData[ch-1].signal[C_SIG_RANGE_SWITCH] = P1;
			}else if(myPs->config.hwSpec > DC_DIGITAL_SPEC){ //180611 add
			}
		}
	}else if(myCh->misc.nextDelay == P10){
	}
	
	if(myCh->misc.nextDelay == P5){
		if(myCh->op.runTime >= myTestCond->step[advStepNo].endT) {
			if(myTestCond->step[advStepNo].endVGoto_upper != 0){
				if(myCh->op.Vsens 
						>= myTestCond->step[advStepNo].endVGoto_upper){
					myCh->misc.nextDelay = P6;
					myCh->op.checkDelayTime = 0;
					myData->bData[bd].cData[ch-1].misc.nextDelay = P10;	
					myData->bData[bd].cData[ch-1].op.checkDelayTime = 0;	
				}
			}
			if(myTestCond->step[advStepNo].endVGoto_lower != 0){
				if(myCh->op.Vsens
					< myTestCond->step[advStepNo].endVGoto_lower){
					myCh->misc.nextDelay = P7;	
					myCh->op.checkDelayTime = 0;
					myData->bData[bd].cData[ch-1].misc.nextDelay = P10;	
					myData->bData[bd].cData[ch-1].op.checkDelayTime = 0;	
				}
			}
			if(myCh->misc.nextDelay == P5){	
				myCh->misc.nextDelay = P8;	
				myCh->op.checkDelayTime = 0;
				myData->bData[bd].cData[ch-1].misc.nextDelay = P10;	
				myData->bData[bd].cData[ch-1].op.checkDelayTime = 0;	
			}
		}
	}
#endif
	return rtn;
}

int cEndCond_Z(int bd, int ch, int rtn, unsigned long advStepNo)
{

	myCh = &(myData->bData[bd].cData[ch]);
	if(myCh->signal[C_SIG_NEXTSTEP] == P1) {
		myCh->signal[C_SIG_NEXTSTEP] = P0;
		myCh->op.code = C_FAULT_NEXTSTEP_CMD;
		rtn = END_COND;
		return rtn;
	}

	if(myPs->testCond[bd][ch].step[advStepNo].endT != 0) {
		if(myCh->op.runTime >=
			myPs->testCond[bd][ch].step[advStepNo].endT) {
			myCh->op.code = C_END_Z;
			rtn = END_COND;
			return rtn;
		}
	}

	if(myCh->op.checkDelayTime < 100) return rtn;
	//180903 add
#if CYCLER_TYPE == DIGITAL_CYC
	if(myCh->misc.endFlag == P1){
		myCh->misc.endFlag = P0;
		myCh->op.code = C_END_VOLTAGE;
		rtn = END_COND;
	}
#endif

	if(myPs->testCond[bd][ch].step[advStepNo].endTemp != 0) {
		rtn = tempEndCheck(bd, ch, rtn, advStepNo);
		if(rtn == END_COND)
			return rtn;
	}
	
//210923 lyhw add for lges gas control (Step Z)
#if GAS_DATA_CONTROL == 1
	//Gas TVOC
	if(myPs->testCond[bd][ch].step[advStepNo].endGasTVOC != 0) {
		if(myCh->misc.gas_TVOC >=
			myPs->testCond[bd][ch].step[advStepNo].endGasTVOC) {
			myCh->op.code = C_END_GAS_TVOC;
			rtn = END_COND;
		}
	}
	
	if(myPs->testCond[bd][ch].step[advStepNo].endGasECo2 != 0) {
		if(myCh->misc.gas_eCo2 >=
			myPs->testCond[bd][ch].step[advStepNo].endGasECo2) {
			myCh->op.code = C_END_GAS_ECO2;
			rtn = END_COND;
		}
	}
#endif
	return rtn;
}

int cEndCond_Z_P(int bd, int ch, int rtn, unsigned long advStepNo)
{

	myCh = &(myData->bData[bd].cData[ch]);
	if(myCh->signal[C_SIG_NEXTSTEP] == P1) {
		myCh->signal[C_SIG_NEXTSTEP] = P0;
		myData->bData[bd].cData[ch-1].signal[C_SIG_NEXTSTEP] = P0;
		myCh->op.code = C_FAULT_NEXTSTEP_CMD;
		rtn = END_COND;
		return rtn;
	}

	if(myPs->testCond[bd][ch].step[advStepNo].endT != 0) {
		if(myCh->op.runTime >=
			myPs->testCond[bd][ch].step[advStepNo].endT) {
			myCh->op.code = C_END_Z;
			rtn = END_COND;
			return rtn;
		}
	}

	if(myCh->op.checkDelayTime < 100) return rtn;
	//180903 add
#if CYCLER_TYPE == DIGITAL_CYC
	if(myCh->misc.endFlag == P1){
		myCh->misc.endFlag = P0;
		myCh->op.code = C_END_VOLTAGE;
		rtn = END_COND;
	}
#endif
	
	if(myPs->testCond[bd][ch].step[advStepNo].endTemp != 0) {
		rtn = tempEndCheck(bd, ch, rtn, advStepNo);
		if(rtn == END_COND)
			return rtn;
	}
	return rtn;
}

int cEndCond_User_Pattern(int bd, int ch, int rtn, unsigned long advStepNo)
{
	double tmp;
	long capacity=0;
	char endWhFlag=0;
	unsigned short SocSoeFlag; 

	SocSoeFlag = myData->mData.testCond[bd][ch].step[advStepNo].SocSoeFlag;

	myCh = &(myData->bData[bd].cData[ch]);	
	if(myCh->signal[C_SIG_NEXTSTEP] == P1) {
		myCh->signal[C_SIG_NEXTSTEP] = P0;
		myCh->op.code = C_FAULT_NEXTSTEP_CMD;
		rtn = END_COND;
		return rtn;
	}

	if(myPs->config.capacityType == CAPACITY_AMPARE_HOURS) {
		capacity = myCh->op.ampareHour;
	} else if(myPs->config.capacityType == CAPACITY_CAPACITANCE) {
		capacity = myCh->op.capacitance;
	} else {
		capacity = 0;
	}

	if(myPs->testCond[bd][ch].step[advStepNo].endT != 0) {
		if(myCh->op.runTime >=
			myPs->testCond[bd][ch].step[advStepNo].endT) {
			myCh->op.code = C_END_TIME;
			rtn = END_COND;
		}
	}
	if(myPs->testCond[bd][ch].step[advStepNo].endTemp != 0) {
		rtn = tempEndCheck(bd, ch, rtn, advStepNo);
	}

	if(myCh->op.checkDelayTime < 10) return rtn;

	if(myPs->testCond[bd][ch].step[advStepNo].endV != 0
		|| (myPs->testCond[bd][ch].step[advStepNo].endV == 0
			&& myPs->testCond[bd][ch].step[advStepNo].endZeroVoltageFlag == 1)) {
		if(myCh->misc.tmpVsens >=
			myPs->testCond[bd][ch].step[advStepNo].endV) {
			myCh->op.code = C_END_VOLTAGE;
			rtn = END_COND;
		}
	}

	if(myPs->testCond[bd][ch].step[advStepNo].endV_L != 0
		|| (myPs->testCond[bd][ch].step[advStepNo].endV_L == 0
			&& myPs->testCond[bd][ch].step[advStepNo].endZeroVoltageFlag == 1)) {
		if(myCh->misc.tmpVsens <=
			myPs->testCond[bd][ch].step[advStepNo].endV_L) {
			myCh->op.code = C_END_VOLTAGE;
			rtn = END_COND;
		}
	}
	if(myPs->testCond[bd][ch].step[advStepNo].endDeltaV != 0) {
		if((myCh->misc.maxV - myCh->misc.tmpVsens) >=
			myPs->testCond[bd][ch].step[advStepNo].endDeltaV) {
			myCh->op.code = C_END_DELTA_V;
			rtn = END_COND;
		}
	}
	if(myPs->testCond[bd][ch].step[advStepNo].endC != 0) {
		if(myPs->testCond[bd][ch].step[advStepNo].endC > 0) {
			if(capacity >=
				myPs->testCond[bd][ch].step[advStepNo].endC) {
				myCh->op.code = C_END_CAPACITY;
				rtn = END_COND;
			}
		} else {
			if(capacity <=
				myPs->testCond[bd][ch].step[advStepNo].endC) {
				myCh->op.code = C_END_CAPACITY;
				rtn = END_COND;
			}
		}
	}
	//cEndPattern
	if(myPs->testCond[bd][ch].step[advStepNo].endSoc != 0) {
		//20190214 SocSoeFlag 0:SOC / 1:DOD / 2:SOE / 3:DOE
		if(SocSoeFlag < 2) {
			tmp = (double)capacity / (double)myCh->misc.actualCapacity
				* 10000.0;
			//endSoc=10000 -> soc=100.00%
			if(myPs->testCond[bd][ch].step[advStepNo].endSoc > 0) {//20190725
				if((short int)tmp >=
					myPs->testCond[bd][ch].step[advStepNo].endSoc) {
					myCh->op.code = C_END_SOC;
					rtn = END_COND;
				}
			} else {
				if((short int)tmp <= 
					myPs->testCond[bd][ch].step[advStepNo].endSoc) {
					myCh->op.code = C_END_SOC;
					rtn = END_COND;
				}
			}
		} else { 
			tmp = (double)myCh->op.wattHour /(double)myCh->misc.actualWattHour
					* 10000.0;		
			//endSoc=10000 -> soc=100.00%
			if(myPs->testCond[bd][ch].step[advStepNo].endSoc > 0) {//20190725
				if((short int)tmp >=
					myPs->testCond[bd][ch].step[advStepNo].endSoc) {		
					myCh->op.code = C_END_SOE;
					rtn = END_COND;
				}
			} else {
				if((short int)tmp <= 
					myPs->testCond[bd][ch].step[advStepNo].endSoc) {
					myCh->op.code = C_END_SOE;
					rtn = END_COND;
				}
			}
		}
	}	
	if(myPs->testCond[bd][ch].step[advStepNo].endP != 0) {
		if(myCh->op.watt >=
			myPs->testCond[bd][ch].step[advStepNo].endP) {
			myCh->op.code = C_END_POWER;
			rtn = END_COND;
		}
	}
	if(myPs->testCond[bd][ch].step[advStepNo].endWh != 0) {
		if(myPs->testCond[bd][ch].step[advStepNo].endWh > 0) {
			if(myCh->op.wattHour >=
			myPs->testCond[bd][ch].step[advStepNo].endWh ) {
				endWhFlag = 1;
			}
		} else {
			if(myCh->op.wattHour <=
			myPs->testCond[bd][ch].step[advStepNo].endWh ) {
				endWhFlag = 1;
			}
		}
		if(endWhFlag) {		
			myCh->op.code = C_END_WATTHOUR;
			rtn = END_COND;
		}
	}
//210923 lyhw add for lges gas control (UserPattern)
#if GAS_DATA_CONTROL == 1
	//Gas TVOC
	if(myPs->testCond[bd][ch].step[advStepNo].endGasTVOC != 0) {
		if(myCh->misc.gas_TVOC >=
			myPs->testCond[bd][ch].step[advStepNo].endGasTVOC) {
			myCh->op.code = C_END_GAS_TVOC;
			rtn = END_COND;
		}
	}
	
	if(myPs->testCond[bd][ch].step[advStepNo].endGasECo2 != 0) {
		if(myCh->misc.gas_eCo2 >=
			myPs->testCond[bd][ch].step[advStepNo].endGasECo2) {
			myCh->op.code = C_END_GAS_ECO2;
			rtn = END_COND;
		}
	}
#endif

	if(rtn == END_COND){
		if(myPs->testCond[bd][ch].safety.faultLowerC != 0) {
			if(capacity <= myPs->testCond[bd][ch].safety.faultLowerC) {
				myCh->misc.tmpState = myCh->op.state;
				myCh->misc.tmpCode = myCh->op.code;
				myCh->op.code = C_FAULT_LOWER_CAPACITY;
				myCh->op.code = code_convert(myCh->op.code, SAFETY); //safety
				Fault_Value_Check(myCh->misc.advStepNo, capacity,
				myPs->testCond[bd][ch].safety.faultLowerC, 0, 0, 0, 0, 0, 0, 0);
				rtn = FAULT_COND;
				return rtn;
			}
		}
		if(myPs->testCond[bd][ch].step[advStepNo].faultLowerC != 0) {
			if(capacity <= myPs->testCond[bd][ch].step[advStepNo].faultLowerC) {
				myCh->misc.tmpState = myCh->op.state;
				myCh->misc.tmpCode = myCh->op.code;
				myCh->op.code = C_FAULT_LOWER_CAPACITY;
				myCh->op.code = code_convert(myCh->op.code, STEP_SAFETY); //step_safety
				Fault_Value_Check(myCh->misc.advStepNo, capacity,
				myPs->testCond[bd][ch].step[advStepNo].faultLowerC,
			   	0, 0, 0, 0, 0, 0, 0);
				rtn = FAULT_COND;
				return rtn;
			}
		}
	}	

	rtn = deltaCapacityCheck(bd, ch, rtn, advStepNo);

	return rtn;
}

int cEndCond_User_Pattern_P(int bd, int ch, int rtn, unsigned long advStepNo)
{
	double tmp;
	long capacity=0 , watt ,wattHour;
	char endWhFlag=0;	
	unsigned SocSoeFlag;
	
	SocSoeFlag = myData->mData.testCond[bd][ch].step[advStepNo].SocSoeFlag;
	
	myCh = &(myData->bData[bd].cData[ch]);
	if(myCh->signal[C_SIG_NEXTSTEP] == P1) {
		myCh->signal[C_SIG_NEXTSTEP] = P0;
		myData->bData[bd].cData[ch-1].signal[C_SIG_NEXTSTEP] = P0;
		myCh->op.code = C_FAULT_NEXTSTEP_CMD;
		rtn = END_COND;
		return rtn;
	}

	if(myPs->config.capacityType == CAPACITY_AMPARE_HOURS) {
		capacity = myCh->op.ampareHour
			+ myData->bData[bd].cData[ch-1].op.ampareHour;
	} else if(myPs->config.capacityType == CAPACITY_CAPACITANCE) {
		capacity = myCh->op.capacitance
			+ myData->bData[bd].cData[ch-1].op.capacitance;
	} else {
		capacity = 0;
	}

	if(myPs->testCond[bd][ch].step[advStepNo].endT != 0) {
		if(myCh->op.runTime >=
			myPs->testCond[bd][ch].step[advStepNo].endT) {
			myCh->op.code = C_END_TIME;
			rtn = END_COND;
		}
	}

	if(myPs->testCond[bd][ch].step[advStepNo].endTemp != 0) {
		rtn = tempEndCheck(bd, ch, rtn, advStepNo);
	}

	if(myCh->op.checkDelayTime < 10) return rtn;

	if(myPs->testCond[bd][ch].step[advStepNo].endV != 0
		|| (myPs->testCond[bd][ch].step[advStepNo].endV == 0
			&& myPs->testCond[bd][ch].step[advStepNo].endZeroVoltageFlag == 1)) {
		if(myCh->misc.tmpVsens >=
			myPs->testCond[bd][ch].step[advStepNo].endV) {
			myCh->op.code = C_END_VOLTAGE;
			rtn = END_COND;
		}
	}

	if(myPs->testCond[bd][ch].step[advStepNo].endV_L != 0
		|| (myPs->testCond[bd][ch].step[advStepNo].endV_L == 0
			&& myPs->testCond[bd][ch].step[advStepNo].endZeroVoltageFlag == 1)) {
		if(myCh->misc.tmpVsens <=
			myPs->testCond[bd][ch].step[advStepNo].endV_L) {
			myCh->op.code = C_END_VOLTAGE;
			rtn = END_COND;
		}
	}
	if(myPs->testCond[bd][ch].step[advStepNo].endDeltaV != 0) {
		if((myCh->misc.maxV - myCh->misc.tmpVsens) >=
			myPs->testCond[bd][ch].step[advStepNo].endDeltaV) {
			myCh->op.code = C_END_DELTA_V;
			rtn = END_COND;
		}
	}
	if(myPs->testCond[bd][ch].step[advStepNo].endC != 0) {
		if(myPs->testCond[bd][ch].step[advStepNo].endC > 0) {
			if(capacity >=
				myPs->testCond[bd][ch].step[advStepNo].endC) {
				myCh->op.code = C_END_CAPACITY;
				rtn = END_COND;
			}
		} else {
			if(capacity <=
				myPs->testCond[bd][ch].step[advStepNo].endC) {
				myCh->op.code = C_END_CAPACITY;
				rtn = END_COND;
			}
		}
	}
	/*
	if(myPs->testCond[bd][ch].step[advStepNo].endSoc != 0) {
		tmp = (double)capacity / (double)myCh->misc.actualCapacity
			* 10000.0;
		//endSoc=10000 -> soc=100.00%
		if(	myPs->testCond[bd][ch].step[advStepNo].endSoc > 0) {
			if((short int)tmp >=
				myPs->testCond[bd][ch].step[advStepNo].endSoc) {
				myCh->op.code = C_END_SOC;
				rtn = END_COND;
			}
		} else {
			if((short int)tmp <=
				myPs->testCond[bd][ch].step[advStepNo].endSoc) {
				myCh->op.code = C_END_SOC;
				rtn = END_COND;
			}
		}
	}
	*/
	//cEndPattern_P
	if(myPs->testCond[bd][ch].step[advStepNo].endSoc != 0) {
		//20190214 SocSoeFlag 0:SOC / 1:DOD / 2:SOE / 3:DOE
		if(SocSoeFlag < 2) {
			tmp = (double)capacity / (double)myCh->misc.actualCapacity
				* 10000.0;
			//endSoc=10000 -> soc=100.00%
			if(myPs->testCond[bd][ch].step[advStepNo].endSoc > 0) {//20190725
				if((short int)tmp >=
					myPs->testCond[bd][ch].step[advStepNo].endSoc) {
					myCh->op.code = C_END_SOC;
					rtn = END_COND;
				}
			} else {
				if((short int)tmp <= 
					myPs->testCond[bd][ch].step[advStepNo].endSoc) {
					myCh->op.code = C_END_SOC;
					rtn = END_COND;
				}
			}
		} else { 
			wattHour = myCh->op.wattHour + 
					myData->bData[bd].cData[ch-1].op.wattHour;
			tmp = (double)wattHour /(double)myCh->misc.actualWattHour
					* 10000.0;		
			//endSoc=10000 -> soc=100.00%
			if(myPs->testCond[bd][ch].step[advStepNo].endSoc > 0) {//20190725
				if((short int)tmp >=
					myPs->testCond[bd][ch].step[advStepNo].endSoc) {		
					myCh->op.code = C_END_SOE;
					rtn = END_COND;
				}
			} else {
				if((short int)tmp <= 
					myPs->testCond[bd][ch].step[advStepNo].endSoc) {
					myCh->op.code = C_END_SOE;
					rtn = END_COND;
				}
			}
		}
	}
	if(myPs->testCond[bd][ch].step[advStepNo].endP != 0) {
		watt = myCh->op.watt + myData->bData[bd].cData[ch].op.watt;
		if(watt >= myPs->testCond[bd][ch].step[advStepNo].endP) {
			myCh->op.code = C_END_POWER;
			rtn = END_COND;
		}
	}
	if(myPs->testCond[bd][ch].step[advStepNo].endWh != 0) {
		wattHour = myCh->op.wattHour+myData->bData[bd].cData[ch-1].op.wattHour;
		if(myPs->testCond[bd][ch].step[advStepNo].endWh > 0) {
			if(wattHour >= myPs->testCond[bd][ch].step[advStepNo].endWh ) {
				endWhFlag = 1;
			}
		} else {
			if(wattHour <= myPs->testCond[bd][ch].step[advStepNo].endWh ) {
				endWhFlag = 1;
			}
		}
		if(endWhFlag) {		
			myCh->op.code = C_END_WATTHOUR;
			rtn = END_COND;
		}
	}
	
	if(rtn == END_COND){
		if(myPs->testCond[bd][ch].safety.faultLowerC != 0) {
			if(capacity <= myPs->testCond[bd][ch].safety.faultLowerC) {
				myCh->misc.tmpState = myCh->op.state;
				myCh->misc.tmpCode = myCh->op.code;
				myCh->op.code = C_FAULT_LOWER_CAPACITY;
				myCh->op.code = code_convert(myCh->op.code, SAFETY); //safety
				Fault_Value_Check(myCh->misc.advStepNo, capacity,
				myPs->testCond[bd][ch].safety.faultLowerC, 0, 0, 0, 0, 0, 0, 0);
				rtn = FAULT_COND;
				return rtn;
			}
		}
		if(myPs->testCond[bd][ch].step[advStepNo].faultLowerC != 0) {
			if(capacity <= myPs->testCond[bd][ch].step[advStepNo].faultLowerC) {
				myCh->misc.tmpState = myCh->op.state;
				myCh->misc.tmpCode = myCh->op.code;
				myCh->op.code = C_FAULT_LOWER_CAPACITY;
				myCh->op.code = code_convert(myCh->op.code, STEP_SAFETY); //step_safety
				Fault_Value_Check(myCh->misc.advStepNo, capacity,
				myPs->testCond[bd][ch].step[advStepNo].faultLowerC,
			   	0, 0, 0, 0, 0, 0, 0);
				rtn = FAULT_COND;
				return rtn;
			}
		}
	}

	rtn = deltaCapacityCheck(bd, ch, rtn, advStepNo);

	return rtn;
}

int cEndCond_User_Map(int bd, int ch, int rtn, unsigned long advStepNo)
{
	unsigned char mode, type;
	double tmp;
	long capacity=0, tableRow;
	char endWhFlag=0;
	unsigned short SocSoeFlag;

	SocSoeFlag = myData->mData.testCond[bd][ch].step[advStepNo].SocSoeFlag;
	mode = myData->mData.testCond[bd][ch].userMap.mode;
	type = myData->mData.testCond[bd][ch].userMap.type;
	tableRow = myData->mData.testCond[bd][ch].userMap.dataTableRow;
	myCh = &(myData->bData[bd].cData[ch]);
	if(myCh->signal[C_SIG_NEXTSTEP] == P1) {
		myCh->signal[C_SIG_NEXTSTEP] = P0;
		myCh->op.code = C_FAULT_NEXTSTEP_CMD;
		rtn = END_COND;
		return rtn;
	}
//140925 oys add : current userMap
	if((mode == PS_CURRENT)
	   && (type == 2)){
		if((myCh->op.temp <
			myData->mData.testCond[bd][ch].userMap.dataTable[1][0])
			|| (myCh->op.temp >
			myData->mData.testCond[bd][ch].userMap.dataTable[tableRow][0])){
			myCh->op.code = C_END_USERMAP_OVER_TEMP;
			rtn = END_COND;
			return rtn;	
		}
	}

	if(myPs->config.capacityType == CAPACITY_AMPARE_HOURS) {
		capacity = myCh->op.ampareHour;
	} else if(myPs->config.capacityType == CAPACITY_CAPACITANCE) {
		capacity = myCh->op.capacitance;
	} else {
		capacity = 0;
	}

	if(myPs->testCond[bd][ch].step[advStepNo].endT != 0) {
		if(myCh->op.runTime >=
			myPs->testCond[bd][ch].step[advStepNo].endT) {
			myCh->op.code = C_END_TIME;
			rtn = END_COND;
		}
	}
	
	if(myPs->testCond[bd][ch].step[advStepNo].endTemp != 0) {
		rtn = tempEndCheck(bd, ch, rtn, advStepNo);
		if(rtn == END_COND)
			return rtn;
	}

	if(myCh->op.checkDelayTime < 10) return rtn;

	if(myPs->testCond[bd][ch].step[advStepNo].endV != 0
		|| (myPs->testCond[bd][ch].step[advStepNo].endV == 0
			&& myPs->testCond[bd][ch].step[advStepNo].endZeroVoltageFlag == 1)) {
		if(myCh->misc.tmpVsens >=
			myPs->testCond[bd][ch].step[advStepNo].endV) {
			myCh->op.code = C_END_VOLTAGE;
			rtn = END_COND;
		}
	}

	if(myPs->testCond[bd][ch].step[advStepNo].endV_L != 0
		|| (myPs->testCond[bd][ch].step[advStepNo].endV_L == 0
			&& myPs->testCond[bd][ch].step[advStepNo].endZeroVoltageFlag == 1)) {
		if(myCh->misc.tmpVsens <=
			myPs->testCond[bd][ch].step[advStepNo].endV_L) {
			myCh->op.code = C_END_VOLTAGE;
			rtn = END_COND;
		}
	}
	if(myPs->testCond[bd][ch].step[advStepNo].endDeltaV != 0) {
		if((myCh->misc.maxV - myCh->misc.tmpVsens) >=
			myPs->testCond[bd][ch].step[advStepNo].endDeltaV) {
			myCh->op.code = C_END_DELTA_V;
			rtn = END_COND;
		}
	}
	if(myPs->testCond[bd][ch].step[advStepNo].endC != 0) {
		if(myPs->testCond[bd][ch].step[advStepNo].endC > 0) {
			if(capacity >=
				myPs->testCond[bd][ch].step[advStepNo].endC) {
				myCh->op.code = C_END_CAPACITY;
				rtn = END_COND;
			}
		} else {
			if(capacity <=
				myPs->testCond[bd][ch].step[advStepNo].endC) {
				myCh->op.code = C_END_CAPACITY;
				rtn = END_COND;
			}
		}
	}
	//cEndUserMap	
	if(myPs->testCond[bd][ch].step[advStepNo].endSoc != 0) {
		//20190214 SocSoeFlag 0:SOC / 1:DOD / 2:SOE / 3:DOE
		if(SocSoeFlag < 2) {
			tmp = (double)capacity / (double)myCh->misc.actualCapacity
				* 10000.0;
			//endSoc=10000 -> soc=100.00%
			if(myPs->testCond[bd][ch].step[advStepNo].endSoc > 0) {//20190725
				if((short int)tmp >=
					myPs->testCond[bd][ch].step[advStepNo].endSoc) {
					myCh->op.code = C_END_SOC;
					rtn = END_COND;
				}
			} else {
				if((short int)tmp <= 
					myPs->testCond[bd][ch].step[advStepNo].endSoc) {
					myCh->op.code = C_END_SOC;
					rtn = END_COND;
				}
			}
		} else { 
			tmp = (double)myCh->op.wattHour /(double)myCh->misc.actualWattHour
					* 10000.0;		
			//endSoc=10000 -> soc=100.00%
			if(myPs->testCond[bd][ch].step[advStepNo].endSoc > 0) {//20190725
				if((short int)tmp >=
					myPs->testCond[bd][ch].step[advStepNo].endSoc) {		
					myCh->op.code = C_END_SOE;
					rtn = END_COND;
				}
			} else {
				if((short int)tmp <= 
					myPs->testCond[bd][ch].step[advStepNo].endSoc) {
					myCh->op.code = C_END_SOE;
					rtn = END_COND;
				}
			}
		}
	}
	if(myPs->testCond[bd][ch].step[advStepNo].endP != 0) {
		if(labs(myCh->op.watt) <=
			myPs->testCond[bd][ch].step[advStepNo].endP) {
			myCh->op.code = C_END_POWER;
			rtn = END_COND;
		}
	}
	if(myPs->testCond[bd][ch].step[advStepNo].endWh != 0) {
		if(myPs->testCond[bd][ch].step[advStepNo].endWh > 0) {
			if(myCh->op.wattHour >=
			myPs->testCond[bd][ch].step[advStepNo].endWh ) {
				endWhFlag = 1;
			}
		} else {
			if(myCh->op.wattHour <=
			myPs->testCond[bd][ch].step[advStepNo].endWh ) {
				endWhFlag = 1;
			}
		}
		if(endWhFlag) {		
			myCh->op.code = C_END_WATTHOUR;
			rtn = END_COND;
		}
	}
//210923 lyhw add for lges gas control (Step UserMap)
#if GAS_DATA_CONTROL == 1
	//Gas TVOC
	if(myPs->testCond[bd][ch].step[advStepNo].endGasTVOC != 0) {
		if(myCh->misc.gas_TVOC >=
			myPs->testCond[bd][ch].step[advStepNo].endGasTVOC) {
			myCh->op.code = C_END_GAS_TVOC;
			rtn = END_COND;
		}
	}
	
	if(myPs->testCond[bd][ch].step[advStepNo].endGasECo2 != 0) {
		if(myCh->misc.gas_eCo2 >=
			myPs->testCond[bd][ch].step[advStepNo].endGasECo2) {
			myCh->op.code = C_END_GAS_ECO2;
			rtn = END_COND;
		}
	}
#endif

	if(rtn == END_COND){
		if(myPs->testCond[bd][ch].safety.faultLowerC != 0) {
			if(capacity <= myPs->testCond[bd][ch].safety.faultLowerC) {
				myCh->misc.tmpState = myCh->op.state;
				myCh->misc.tmpCode = myCh->op.code;
				myCh->op.code = C_FAULT_LOWER_CAPACITY;
				myCh->op.code = code_convert(myCh->op.code, SAFETY); //safety
				Fault_Value_Check(myCh->misc.advStepNo, capacity,
				myPs->testCond[bd][ch].safety.faultLowerC, 0, 0, 0, 0, 0, 0, 0);
				rtn = FAULT_COND;
				return rtn;
			}
		}
		if(myPs->testCond[bd][ch].step[advStepNo].faultLowerC != 0) {
			if(capacity <= myPs->testCond[bd][ch].step[advStepNo].faultLowerC) {
				myCh->misc.tmpState = myCh->op.state;
				myCh->misc.tmpCode = myCh->op.code;
				myCh->op.code = C_FAULT_LOWER_CAPACITY;
				myCh->op.code = code_convert(myCh->op.code, STEP_SAFETY); //step_safety
				Fault_Value_Check(myCh->misc.advStepNo, capacity,
				myPs->testCond[bd][ch].step[advStepNo].faultLowerC,
			   	0, 0, 0, 0, 0, 0, 0);
				rtn = FAULT_COND;
				return rtn;
			}
		}
	}

	rtn = deltaCapacityCheck(bd, ch, rtn, advStepNo);

	return rtn;
}

int cEndCond_Acir(int bd, int ch, int rtn, unsigned long advStepNo)
{
	myCh = &(myData->bData[bd].cData[ch]);
	if(myCh->misc.acir_rcv_flag == 1){
		myCh->op.checkDelayTime += myPs->misc.rt_scan_time;
		if(myData->AppControl.config.systemType == CYCLER_CAN){
			if(myCh->op.checkDelayTime == 80){
				cSemiSwitch_CAN(bd, ch);
			}
			if(myCh->op.checkDelayTime == 90){
				myCh->signal[C_SIG_RANGE_SWITCH] = P1;
			}
			if(myCh->op.checkDelayTime >= 100){
				myCh->signal[C_SIG_OUT_SWITCH] = P1;
			}
		}else if(myData->AppControl.config.systemType == CYCLER_PCU){
			myCh->signal[C_SIG_OUT_SWITCH] = P1;
			myCh->signal[C_SIG_OUT_SWITCH_ON] = P1;
		}else if(myData->AppControl.config.systemType == CYCLER_LINEAR){
			myCh->signal[C_SIG_OUT_SWITCH] = P1;
			myCh->signal[C_SIG_RANGE_SWITCH] = P1;
		}
		if(myCh->op.checkDelayTime >= 200){
			myCh->op.checkDelayTime = 0;
			myCh->op.code = C_END_ACIR;
			myCh->misc.acir_rcv_flag = 0;
			myCh->misc.acir_wait_flag = 0;
			rtn = END_COND;
		}
	}
	return rtn;
}


int cEndCond_FaultCheck(int bd, int ch, int rtn, unsigned long advStepNo)
{	//20200309 lyhw add for END_COND -> voltage, temp Check
	unsigned char temp_MultiNum = 0;
	long Vsens = 0;
	unsigned long saveDt = 0;
	S_CH_STEP_INFO step;

	if(myData->mData.config.function[F_SW_FAULT_COND] == P0) return rtn;
	
	myCh = &(myData->bData[bd].cData[ch]);
	myTestCond = &(myPs->testCond[bd][ch]);
	step = step_info(bd, ch);

	saveDt = myPs->testCond[bd][ch].step[advStepNo].saveDt;
	temp_MultiNum = myData->AnalogMeter.config.multiNum;
	if(myCh->op.type == STEP_USER_PATTERN ||
	   myCh->op.type == STEP_USER_MAP ||
	   myCh->op.mode == CP ||
	   myCh->op.runTime < 100){
		Vsens = myCh->misc.tmpVsens;
	}else{
		if((saveDt < RTTASK_1000MS) &&
			(myCh->op.runTime < myData->DataSave.config.save_100ms_time)){
			Vsens = myCh->misc.tmpVsens;
		}else{
			Vsens = myCh->op.Vsens;
		}
	}
	
	if(myTestCond->safety.faultUpperV != 0) {
		if(Vsens >= myTestCond->safety.faultUpperV) {
			myCh->misc.tmpState = myCh->op.state;
			myCh->misc.tmpCode = myCh->op.code;
			myCh->op.code = C_FAULT_UPPER_VOLTAGE;
			myCh->op.code = code_convert(myCh->op.code, SAFETY); //safety
			Fault_Value_Check(myCh->misc.advStepNo, myCh->op.Vsens,
			myPs->testCond[bd][ch].safety.faultUpperV, 0, 0, 0, 0, 0, 0, 0);
			rtn = FAULT_COND;
			return rtn;
		}
	}
	
	if(myTestCond->safety.faultLowerV != 0) {
		if(Vsens <= myTestCond->safety.faultLowerV) {
			myCh->misc.tmpState = myCh->op.state;
			myCh->misc.tmpCode = myCh->op.code;
			myCh->op.code = C_FAULT_LOWER_VOLTAGE;
			myCh->op.code = code_convert(myCh->op.code, SAFETY); //safety
			Fault_Value_Check(myCh->misc.advStepNo, myCh->op.Vsens,
			myPs->testCond[bd][ch].safety.faultLowerV, 0, 0, 0, 0, 0, 0, 0);
			rtn = FAULT_COND;
			return rtn;
		}
	}
	
	if(myTestCond->step[advStepNo].faultUpperV != 0) {
		if(Vsens >= myTestCond->step[advStepNo].faultUpperV) {
			myCh->misc.tmpState = myCh->op.state;
			myCh->misc.tmpCode = myCh->op.code;
			myCh->op.code = C_FAULT_UPPER_VOLTAGE;
			myCh->op.code = code_convert(myCh->op.code, STEP_SAFETY); //step_safety
			Fault_Value_Check(myCh->misc.advStepNo, myCh->op.Vsens,
			myPs->testCond[bd][ch].step[advStepNo].faultUpperV,
		   	0, 0, 0, 0, 0, 0, 0);
			rtn = FAULT_COND;
			return rtn;
		}
	}
	
	if(myTestCond->step[advStepNo].faultLowerV != 0) {
	   	if(Vsens <= myTestCond->step[advStepNo].faultLowerV) {
			myCh->misc.tmpState = myCh->op.state;
			myCh->misc.tmpCode = myCh->op.code;
			myCh->op.code = C_FAULT_LOWER_VOLTAGE;
			myCh->op.code = code_convert(myCh->op.code, STEP_SAFETY); //step_safety
			Fault_Value_Check(myCh->misc.advStepNo, myCh->op.Vsens,
			myPs->testCond[bd][ch].step[advStepNo].faultLowerV,
		   	0, 0, 0, 0, 0, 0, 0);
			rtn = FAULT_COND;
			return rtn;
		}
	}
	#if CHAMBER_TEMP_HUMIDITY == 1	//kjc_210414
	if(myTestCond->safety.capacityRetain != 0){
		if(myCh->misc.advCycle >= 2 && myCh->misc.dischargeStepNo == advStepNo){
			if(myCh->misc.calc_retain_Ah < myTestCond->safety.capacityRetain/1000){
				myCh->misc.tmpState = myCh->op.state;
				myCh->misc.tmpCode = myCh->op.code;
				myCh->op.code = C_FAULT_CAPACITY_RETAIN;
				rtn = FAULT_COND;
				return rtn;
			}
		}
	}
	#endif

	
	if(myData->AnalogMeter.config.tempNonDisplay == P0){
		if(myTestCond->safety.faultUpperTemp != 0){
			if((myCh->op.temp >= myTestCond->safety.faultUpperTemp)
			||(temp_MultiNum == 2 
			&& myCh->op.temp1 >= myTestCond->safety.faultUpperTemp)){
				myCh->misc.tmpState = myCh->op.state;
				myCh->misc.tmpCode = myCh->op.code;
				myCh->op.code = C_FAULT_UPPER_CH_TEMP;
				myCh->op.code = code_convert(myCh->op.code, SAFETY); //safety
				Fault_Value_Check(myCh->misc.advStepNo, myCh->op.temp,
				myTestCond->safety.faultUpperTemp, 
				myTestCond->step[advStepNo].faultUpperTemp, 0, 0, 0, 0, 0, 0);
				rtn = FAULT_COND;
				return rtn;
			}
		}
	
		if(myTestCond->safety.faultLowerTemp != 0){
			if((myCh->op.temp <= myTestCond->safety.faultLowerTemp)
			||(temp_MultiNum == 2
			&& myCh->op.temp1 <= myTestCond->safety.faultLowerTemp)){
				myCh->misc.tmpState = myCh->op.state;
				myCh->misc.tmpCode = myCh->op.code;
				myCh->op.code = C_FAULT_LOWER_CH_TEMP;
				myCh->op.code = code_convert(myCh->op.code, SAFETY); //safety
				Fault_Value_Check(myCh->misc.advStepNo, 
				myData->bData[bd].cData[ch].op.temp,
				myTestCond->safety.faultLowerTemp,
				myTestCond->step[advStepNo].faultLowerTemp, 0, 0, 0, 0, 0, 0);
				rtn = FAULT_COND;
				return rtn;
			}
		}
	
		if(myTestCond->step[advStepNo].faultUpperTemp != 0){
			if((myCh->op.temp >= myTestCond->step[advStepNo].faultUpperTemp)
			||(temp_MultiNum == 2 
			&& myCh->op.temp1 >= myTestCond->step[advStepNo].faultUpperTemp)){
				myCh->misc.tmpState = myCh->op.state;
				myCh->misc.tmpCode = myCh->op.code;
				myCh->op.code = C_FAULT_UPPER_CH_TEMP;
				myCh->op.code = code_convert(myCh->op.code, STEP_SAFETY); //step_safety
				Fault_Value_Check(myCh->misc.advStepNo, 
				myCh->op.temp,
				myTestCond->safety.faultUpperTemp,
				myTestCond->step[advStepNo].faultUpperTemp,
			 	0, 0, 0, 0, 0, 0);
				rtn = FAULT_COND;
				return rtn;
			}
		}
		
		if(myTestCond->step[advStepNo].faultLowerTemp != 0){
			if((myCh->op.temp <= myTestCond->step[advStepNo].faultLowerTemp)
			||(temp_MultiNum == 2
			&& myCh->op.temp1 <= myTestCond->step[advStepNo].faultLowerTemp)){
				myCh->misc.tmpState = myCh->op.state;
				myCh->misc.tmpCode = myCh->op.code;
				myCh->op.code = C_FAULT_LOWER_CH_TEMP;
				myCh->op.code = code_convert(myCh->op.code, STEP_SAFETY); //step_safety
				Fault_Value_Check(myCh->misc.advStepNo, 
				myData->bData[bd].cData[ch].op.temp,
				myTestCond->safety.faultLowerTemp,
				myTestCond->step[advStepNo].faultLowerTemp,
				0, 0, 0, 0, 0, 0);
				rtn = FAULT_COND;
				return rtn;
			}
		}	
	}	
	
	if(myData->mData.config.installedTemp > 0){
		if(myTestCond->safety.faultUpperTemp != 0){
			if(myCh->misc.AuxTemp_max >= myTestCond->safety.faultUpperTemp){
				myCh->misc.tmpState = myCh->op.state;
				myCh->misc.tmpCode = myCh->op.code;
				myCh->op.code = C_FAULT_UPPER_CH_TEMP;
				myCh->op.code = code_convert(myCh->op.code, SAFETY); //safety
				Fault_Value_Check(myCh->misc.advStepNo, 
				myCh->misc.AuxTemp_max,
				myTestCond->safety.faultUpperTemp,
				
				myTestCond->step[advStepNo].faultUpperTemp, 0, 0, 0, 0, 0, 0);
				rtn = FAULT_COND;
				return rtn;
			}
		}
	
		if(myTestCond->safety.faultLowerTemp != 0){
			if(myCh->misc.AuxTemp_min <= myTestCond->safety.faultLowerTemp){
				myCh->misc.tmpState = myCh->op.state;
				myCh->misc.tmpCode = myCh->op.code;
				myCh->op.code = C_FAULT_LOWER_CH_TEMP;
				myCh->op.code = code_convert(myCh->op.code, SAFETY); //safety
				Fault_Value_Check(myCh->misc.advStepNo, 
				myData->bData[bd].cData[ch].misc.AuxTemp_min,
				myTestCond->safety.faultLowerTemp,
				myTestCond->step[advStepNo].faultLowerTemp, 0, 0, 0, 0, 0, 0);
				rtn = FAULT_COND;
				return rtn;
			}
		}
	
		if(myTestCond->step[advStepNo].faultUpperTemp != 0){
			if(myCh->misc.AuxTemp_max 
				>= myTestCond->step[advStepNo].faultUpperTemp){
				myCh->misc.tmpState = myCh->op.state;
				myCh->misc.tmpCode = myCh->op.code;
				myCh->op.code = C_FAULT_UPPER_CH_TEMP;
				myCh->op.code = code_convert(myCh->op.code, STEP_SAFETY); //step_safety
				Fault_Value_Check(myCh->misc.advStepNo, 
				myCh->misc.AuxTemp_max,
				myTestCond->safety.faultUpperTemp,
				myTestCond->step[advStepNo].faultUpperTemp,
			   	0, 0, 0, 0, 0, 0);
				rtn = FAULT_COND;
				return rtn;
			}
		}
		
		if(myTestCond->step[advStepNo].faultLowerTemp != 0){
			if(myCh->misc.AuxTemp_min 
				<= myTestCond->step[advStepNo].faultLowerTemp){
				myCh->misc.tmpState = myCh->op.state;
				myCh->misc.tmpCode = myCh->op.code;
				myCh->op.code = C_FAULT_LOWER_CH_TEMP;
				myCh->op.code = code_convert(myCh->op.code, STEP_SAFETY); //step_safety
				Fault_Value_Check(myCh->misc.advStepNo, 
				myData->bData[bd].cData[ch].misc.AuxTemp_min,
				myTestCond->safety.faultLowerTemp,
				myTestCond->step[advStepNo].faultLowerTemp,
				0, 0, 0, 0, 0, 0);
				rtn = FAULT_COND;
				return rtn;
			}
		}
	}
	//211025 lyhw add for SDI JIG PressTime Out
	if(myCh->op.type == STEP_REST){
		if(myCh->op.code == C_END_TIME){
			if(myTestCond->step[advStepNo].jigPressTimeOutFlag == P1){
				myCh->misc.tmpState = myCh->op.state;
				myCh->misc.tmpCode = myCh->op.code;
				myCh->op.code = C_FAULT_JIGPRESS_TIMEOUT_ERR;
				Fault_Value_Check(myCh->misc.advStepNo, 
				0, 0, 0, 0, 0, 0, 0, 0, 0);
				rtn = FAULT_COND;
				return rtn;
			}
		}
	}
	
	return rtn;
}

int tempEndCheck(int bd, int ch, int rtn, unsigned long advStepNo)
{
	unsigned short type = 0;
	
	if(myData->bData[bd].cData[ch].ChAttribute.chNo_master == P0) {
		ch = ch-1;
	}
	//Chamber Temperature
	if(myPs->testCond[bd][ch].step[advStepNo].tempType == P2) {
		//lower
		if(myPs->testCond[bd][ch].step[advStepNo].tempDir == P2) {
			type = P1;
		//upper
		} else if(myPs->testCond[bd][ch].step[advStepNo].tempDir == P1) {
			type = P2;
		}
	//Temperature Module
	} else if(myPs->testCond[bd][ch].step[advStepNo].tempType == P1) {
		//lower
		if(myPs->testCond[bd][ch].step[advStepNo].tempDir == P2) {
			if(myData->AnalogMeter.config.auxControlFlag == 1
				&& myData->AnalogMeter.config.tempNonDisplay == 1) {
				type = P5;
			} else {
				type = P3;
			}
		//upper
		} else if(myPs->testCond[bd][ch].step[advStepNo].tempDir == P1) {
			if(myData->AnalogMeter.config.auxControlFlag == 1
				&& myData->AnalogMeter.config.tempNonDisplay == 1) {
				type = P6;
			} else {
				type = P4;
			}
		}
	}	
	switch(type){
		case P1:
			if(myCh->misc.groupTemp>=
				myPs->testCond[bd][ch].step[advStepNo].endTemp){
				if(myPs->testCond[bd][ch].step[advStepNo].type == STEP_REST){
					if(myCh->misc.nextDelay != P3){
						myCh->misc.nextDelay = P3;
						myCh->op.checkDelayTime = 0;
					}
				}else{
					myCh->op.code = C_END_TEMP;
					rtn = END_COND;
				}
			}
			break;
		case P2:
			if(myCh->misc.groupTemp<=
				myPs->testCond[bd][ch].step[advStepNo].endTemp){
				if(myPs->testCond[bd][ch].step[advStepNo].type == STEP_REST){
					if(myCh->misc.nextDelay != P3){
						myCh->misc.nextDelay = P3;
						myCh->op.checkDelayTime = 0;
					}
				}else{
					myCh->op.code = C_END_TEMP;
					rtn = END_COND;
				}
			}
			break;
		case P3:
			if((myData->bData[bd].cData[ch].op.temp
					>= myPs->testCond[bd][ch].step[advStepNo].endTemp)
				|| (myData->AnalogMeter.config.multiNum == 2
					&& (myData->bData[bd].cData[ch].op.temp1
						>= myPs->testCond[bd][ch].step[advStepNo]
							.endTemp))){
				if(myPs->testCond[bd][ch].step[advStepNo].type == STEP_REST){
					if(myCh->misc.nextDelay != P3){
						myCh->misc.nextDelay = P3;
						myCh->op.checkDelayTime = 0;
					}
				}else{
					myCh->op.code = C_END_TEMP;
					rtn = END_COND;
				}
			}
			break;
		case P4:
			if((myData->bData[bd].cData[ch].op.temp
					<= myPs->testCond[bd][ch].step[advStepNo].endTemp)
				|| (myData->AnalogMeter.config.multiNum == 2
					&& (myData->bData[bd].cData[ch].op.temp1
						<= myPs->testCond[bd][ch].step[advStepNo]
							.endTemp))){
				if(myPs->testCond[bd][ch].step[advStepNo].type == STEP_REST){
					if(myCh->misc.nextDelay != P3){
						myCh->misc.nextDelay = P3;
						myCh->op.checkDelayTime = 0;
					}
				}else{
					myCh->op.code = C_END_TEMP;
					rtn = END_COND;
				}
			}
			break;
		case P5:
			if(myData->bData[bd].cData[ch].misc.AuxTemp_max
					>= myPs->testCond[bd][ch].step[advStepNo].endTemp) {
				if(myPs->testCond[bd][ch].step[advStepNo].type == STEP_REST){
					if(myCh->misc.nextDelay != P3){
						myCh->misc.nextDelay = P3;
						myCh->op.checkDelayTime = 0;
					}
				}else{
					myCh->op.code = C_END_TEMP;
					rtn = END_COND;
				}
			}
			break;
		case P6:
			if(myData->bData[bd].cData[ch].misc.AuxTemp_min
					<= myPs->testCond[bd][ch].step[advStepNo].endTemp) {
				if(myPs->testCond[bd][ch].step[advStepNo].type == STEP_REST){
					if(myCh->misc.nextDelay != P3){
						myCh->misc.nextDelay = P3;
						myCh->op.checkDelayTime = 0;
					}
				}else{
					myCh->op.code = C_END_TEMP;
					rtn = END_COND;
				}
			}
		default: break;
	}
	return rtn;
}

void EfficiencyEnd(int bd, int ch, unsigned long advStepNo, unsigned char type)
{
	unsigned long capacity = 0, wattHour = 0; 
	unsigned char endC_std_type, endP_std_type, endZ_std_type;
	unsigned char endC_proc_type, endP_proc_type, endZ_proc_type;
	unsigned short endSoc, advCycleStep;
	double tmp;
#if CAPACITY_CONTROL == 1
	unsigned long CycleNo = 0;
#endif

	advCycleStep = myCh->misc.advCycleStep;

	endC_std_type = myPs->testCond[bd][ch].step[advCycleStep].socCapStepNo;
	endP_std_type = myPs->testCond[bd][ch].step[advCycleStep].endP_std_type;
	endZ_std_type = myPs->testCond[bd][ch].step[advCycleStep].endZ_std_type;

	endC_proc_type = myPs->testCond[bd][ch].step[advCycleStep].endC_proc_type;
	endP_proc_type = myPs->testCond[bd][ch].step[advCycleStep].endP_proc_type;
	endZ_proc_type = myPs->testCond[bd][ch].step[advCycleStep].endZ_proc_type;

	//170105 oys add
	if(myPs->config.capacityType == CAPACITY_AMPARE_HOURS) {
		if(myCh->ChAttribute.chNo_master == P0) {
			capacity = labs(myCh->op.ampareHour
						+ myData->bData[bd].cData[ch-1].op.ampareHour);
		}else{
			capacity = labs(myCh->op.ampareHour);
		}
	} else if(myPs->config.capacityType	== CAPACITY_CAPACITANCE) {
		if(myCh->ChAttribute.chNo_master == P0) {
			capacity = myCh->op.capacitance
						+ myData->bData[bd].cData[ch-1].op.capacitance;
		}else{
			capacity = myCh->op.capacitance;
		}
	}
	if(myCh->ChAttribute.chNo_master == P0) {
		wattHour = labs(myCh->op.wattHour
				+ myData->bData[bd].cData[ch-1].op.wattHour);
	}else{
		wattHour = labs(myCh->op.wattHour);
	}
	//cycle non-integral capacity end
	if(myCh->misc.cycleEndC != 0) {
		if(capacity <= myCh->misc.cycleEndC) {
			myCh->op.code = C_END_CYCLE_CAPACITY;
		}
	}
	//add end
#if VENDER != 3
	//1.Capacity
	if(myCh->misc.standardC_Flag == P0){
		if(endC_std_type != 0){
			if(endC_std_type == 1){ // charge step
				if(type == STEP_CHARGE){
					myCh->misc.standardC += labs(capacity);
					if(myPs->testCond[bd][ch].step[advStepNo+1].type
						!= type){
//						myCh->misc.endC_std_type = type;
						if(myCh->misc.endC_std_sel == P0) {
							myCh->misc.standardC_Flag = P1;
						}
					}
				}
			}else if(endC_std_type == 2){ // discharge step
				if(type == STEP_DISCHARGE){
					myCh->misc.standardC += labs(capacity);
					if(myPs->testCond[bd][ch].step[advStepNo+1].type
						!= type){
//						myCh->misc.endC_std_type = type;
						if(myCh->misc.endC_std_sel == P0) {
							myCh->misc.standardC_Flag = P1;
						}
					}
				}
			}
		}
	}else if(myCh->misc.standardC_Flag == P1){
		if(myPs->testCond[bd][ch].step[advCycleStep].endSoc != 0) {
			// Soc : 100% = endSoc : 10000
			endSoc = myPs->testCond[bd][ch].step[advCycleStep].endSoc;
			tmp = (double)capacity / (double)myCh->misc.standardC * 10000.0;
			if((unsigned short)tmp <= endSoc){
//				if(myCh->misc.endC_std_type == type){
				if(type == STEP_DISCHARGE
					|| type == STEP_CHARGE
					|| type == STEP_USER_PATTERN
					|| type == STEP_USER_MAP){
					myCh->misc.socCountNo[CAPACITY_END]++;
					if(myCh->misc.socCheckCount
							<= myCh->misc.socCountNo[CAPACITY_END]) {
						myCh->op.code = C_END_CYCLE_CAPACITY_SOC;
						myCh->misc.socCountNo[CAPACITY_END] = 0;
						myCh->op.phase = P100;
					}
				}
			}
		}
	}
#else
	//1.Capacity
	if(myCh->misc.standardC_Flag == P0){
		if(myCh->misc.endC_std_sel == P1) {
			if(myCh->misc.endC_std_cycleCount == myCh->misc.advCycle){
				if(endC_std_type != 0){
					if(endC_std_type == 1){ // charge step
						if(type == STEP_CHARGE){
							myCh->misc.standardC += labs(capacity);
							myCh->misc.endC_std_type = type;
						}
					}else if(endC_std_type == 2){ // discharge step
						if(type == STEP_DISCHARGE){
							myCh->misc.standardC += labs(capacity);
							myCh->misc.endC_std_type = type;
						}
					}
					if(myPs->testCond[bd][ch].step[advStepNo+1].type
							== STEP_LOOP){
						myCh->misc.standardC_Flag = P1;
					}
				}
			}
		//20180721 sch modify for reset standardX
		}else if(myCh->misc.endC_std_sel > 1) {
			if(myCh->misc.endC_std_cycleCount == myCh->misc.advCycle){
				if(myPs->testCond[bd][ch].step[myCh->misc.endC_std_sel - 1]
					.socStepCap != 0) {
					myCh->misc.endC_std_type = myPs->testCond[bd][ch]
						.step[myCh->misc.endC_std_sel - 1].type;
					myCh->misc.standardC = myPs->testCond[bd][ch]
						.step[myCh->misc.endC_std_sel - 1].socStepCap;
					if(myPs->testCond[bd][ch].step[advStepNo+1].type
							== STEP_LOOP){
						myCh->misc.standardC_Flag = P1;
					}
				}
			}
		}
	}else if(myCh->misc.standardC_Flag == P1){
		if(myCh->misc.endC_std_type == type){
			myCh->misc.cycleSumC += labs(capacity);
		}
		if(myPs->testCond[bd][ch].step[advCycleStep].endSoc != 0) {
			if(myPs->testCond[bd][ch].step[advStepNo+1].type == STEP_LOOP) {
				// Soc : 100% = endSoc : 10000
				endSoc = myPs->testCond[bd][ch].step[advCycleStep].endSoc;
				tmp = (double)myCh->misc.cycleSumC
						/ (double)myCh->misc.standardC * 10000.0;
				if((unsigned short)tmp <= endSoc){
					myCh->misc.socCountNo[CAPACITY_END]++;
					if(myCh->misc.socCheckCount
							<= myCh->misc.socCountNo[CAPACITY_END]) {
						switch(endC_proc_type) {
							case P0://cycle end -> next Cycle
								myCh->op.code = C_END_CYCLE_CAPACITY_SOC;
								break;
							case P1://pause
								myCh->misc.tmpState = myCh->op.state;
								myCh->misc.tmpCode = myCh->op.code;
								myCh->op.code = C_FAULT_CAPACITY_SOC;
								myCh->misc.efficiency_pause_flag = P1;
								break;
							case P2://next Step
								myCh->op.code = C_END_AH_SOC;
								break;
							default :
								break;
						}
						myCh->misc.socCountNo[CAPACITY_END] = 0;
						myCh->op.phase = P100;
					}
				}
			}
		}
	}
	//2.wattHour
	if(myCh->misc.standardP_Flag == P0){
		if(myCh->misc.endP_std_sel == P1) {
			if(myCh->misc.endP_std_cycleCount == myCh->misc.advCycle){
				if(endP_std_type != 0){
					if(endP_std_type == 1){ // charge step
						if(type == STEP_CHARGE){
							myCh->misc.standardP += labs(wattHour);
							myCh->misc.endP_std_type = type;
						}
					}else if(endP_std_type == 2){ // discharge step
						if(type == STEP_DISCHARGE){
							myCh->misc.standardP += labs(wattHour);
							myCh->misc.endP_std_type = type;
						}
					}
					if(myPs->testCond[bd][ch].step[advStepNo+1].type 
							== STEP_LOOP){
						myCh->misc.standardP_Flag = P1;
					}
				}
			}
		//20180721 sch modify for reset standardX
		}else if(myCh->misc.endP_std_sel > 1) {
			if(myCh->misc.endP_std_cycleCount == myCh->misc.advCycle){
				if(myPs->testCond[bd][ch].step[myCh->misc.endP_std_sel - 1]
					.socStepPower != 0) {
					myCh->misc.endP_std_type = myPs->testCond[bd][ch]
						.step[myCh->misc.endP_std_sel - 1].type;
					myCh->misc.standardP = myPs->testCond[bd][ch]
						.step[myCh->misc.endP_std_sel - 1].socStepPower;
					if(myPs->testCond[bd][ch].step[advStepNo+1].type 
							== STEP_LOOP){
						myCh->misc.standardP_Flag = P1;
					}
				}
			}
		}
	}else if(myCh->misc.standardP_Flag == P1){
		if(myCh->misc.endP_std_type == type)
			myCh->misc.cycleSumP += labs(wattHour);
		if(myPs->testCond[bd][ch].step[advCycleStep].endP_soc != 0) {
			if(myPs->testCond[bd][ch].step[advStepNo+1].type == STEP_LOOP) {
				// Soc : 100% = endSoc : 10000
				endSoc = myPs->testCond[bd][ch].step[advCycleStep].endP_soc;
				tmp = (double)myCh->misc.cycleSumP 
						/ (double)myCh->misc.standardP * 10000.0;
				if((unsigned short)tmp <= endSoc){
					myCh->misc.socCountNo[WATTHOUR_END]++;
					if(myCh->misc.socCheckCount
							<= myCh->misc.socCountNo[WATTHOUR_END]) {
						switch(endP_proc_type) {
							case P0://cycle end -> next Cycle
								myCh->op.code = C_END_CYCLE_WH_SOC;
								break;
							case P1://pause
								myCh->misc.tmpState = myCh->op.state;
								myCh->misc.tmpCode = myCh->op.code;
								myCh->op.code = C_FAULT_WH_SOC;
								myCh->misc.efficiency_pause_flag = P1;
								break;
							case P2://next Step
								myCh->op.code = C_END_WH_SOC;
								break;
							default :
								break;
						}
						myCh->misc.socCountNo[WATTHOUR_END] = 0;
						myCh->op.phase = P100;
					}
				}
			}
		}
	}
	//3.DCIR
	if(myCh->misc.standardZ_Flag == P0){		//EndCycle, Pause
		if(myCh->misc.endZ_std_sel == P1){
			if(myCh->misc.endZ_std_cycleCount == myCh->misc.advCycle){
				if(endZ_std_type == advStepNo+1){
					myCh->misc.standardZ = labs(myCh->op.z);
					myCh->misc.standardZ_Flag = P1;
					myCh->misc.endZ_std_type = type;
				}
			}
		//20180721 sch modify for reset standardX
		}else if(myCh->misc.endZ_std_sel > 1) {	//NextCycle
			if(myCh->misc.endZ_std_cycleCount == myCh->misc.advCycle){
				if(myPs->testCond[bd][ch].step[myCh->misc.endZ_std_sel - 1]
					.socStepZ != 0) {
					//if(endZ_std_type == advStepNo+1){
					if(myCh->misc.endZ_std_sel == advStepNo+1){	//kjc_201026
						myCh->misc.endZ_std_type = myPs->testCond[bd][ch]
							.step[myCh->misc.endZ_std_sel - 1].type;
						myCh->misc.standardZ = myPs->testCond[bd][ch]
							.step[myCh->misc.endZ_std_sel - 1].socStepZ;
						myCh->misc.standardZ_Flag = P1;
					}
				}
			}
		}
	}else if(myCh->misc.standardZ_Flag == P1){
		if(myCh->op.z != 0){
			if(myPs->testCond[bd][ch].step[advCycleStep].endZ_soc != 0) {
				// Soc : 100% = endSoc : 10000
				endSoc = myPs->testCond[bd][ch].step[advCycleStep].endZ_soc;
				tmp = (double)labs(myCh->op.z)
						/ (double)myCh->misc.standardZ * 10000.0;
				if((unsigned short)tmp >= endSoc){
					if(myCh->misc.endZ_std_type == type){
						myCh->misc.socCountNo[DCIR_END]++;
						if(myCh->misc.socCheckCount
								<= myCh->misc.socCountNo[DCIR_END]) {
							switch(endZ_proc_type) {
								case P0://cycle end -> next Cycle
									myCh->op.code = C_END_CYCLE_DCIR_SOC;
									break;
								case P1://pause
									myCh->misc.tmpState = myCh->op.state;
									myCh->misc.tmpCode = myCh->op.code;
									myCh->op.code = C_FAULT_DCIR_SOC;
									myCh->misc.efficiency_pause_flag = P1;
									break;
								case P2://next Step
									myCh->op.code = C_END_DCIR_SOC;
									break;
								default :
									break;
							}
							myCh->misc.socCountNo[DCIR_END] = 0;
							myCh->op.phase = P100;
						}
					}
				}
			}
		}
	}
#endif
/*
#if SEC_TYPE == 1
	if(myCh->misc.standardC_Flag == P0){
		if(endC_std_type == 1){ // charge step
			if(type == STEP_CHARGE){
				myCh->misc.standardC += labs(capacity);
				if(myPs->testCond[bd][ch].step[advStepNo+1].type != type){
					myCh->misc.standardC_Flag = P1;
				}
			}
		}else if(endC_std_type == 2){ // discharge step
			if(type == STEP_DISCHARGE){
				myCh->misc.standardC += labs(capacity);
				if(myPs->testCond[bd][ch].step[advStepNo+1].type != type){
					myCh->misc.standardC_Flag = P1;
				}
			}
		}
	}else if(myCh->misc.standardC_Flag == P1 && type != STEP_REST){
		if(myPs->testCond[bd][ch].step[advCycleStep].endSoc != 0) {
			// Soc : 100% = endSoc : 10000
			endSoc = myPs->testCond[bd][ch].step[advCycleStep].endSoc;
			tmp = (double)capacity / (double)myCh->misc.standardC * 10000.0;
			if((unsigned short)tmp <= endSoc){
				if(myCh->misc.completeFlag == P1) {
					myCh->op.code = C_STOP_CAPACITY_SOC;
				} else {
					myCh->misc.tmpState = myCh->op.state;
					myCh->misc.tmpCode = myCh->op.code;
					myCh->op.code = C_FAULT_CAPACITY_SOC;
				}
				if(myCh->ChAttribute.chNo_master == P0) {
					myData->bData[bd].cData[ch-1].op.code = myCh->op.code; 
					myCh = &(myData->bData[bd].cData[ch]);
				}
				myCh->op.phase = P100;
			}
		}
	}
#endif
*/
#if CAPACITY_CONTROL == 1
	if(myCh->misc.CycleCapaCount != 0){ //210402
		if(type == STEP_ADV_CYCLE 
			&& myPs->testCond[bd][ch].step[advStepNo].UseCheckCapaFlag !=0){
			advStepNo = CycleNo;
		}
		if(myCh->misc.CycleCapaCount == myCh->misc.advCycle){
			myCh->misc.CycleCapacity += labs(capacity);
			myCh->misc.C_Rate_stepCapacity[CycleNo] = myCh->misc.CycleCapacity;
		}
	}
#endif
}

#if MACHINE_TYPE == 1
//140407 oys add start
int cEndCond_Short(int bd, int ch, int rtn, unsigned long advStepNo)
{
	myCh = &(myData->bData[bd].cData[ch]);
	if(myCh->signal[C_SIG_NEXTSTEP] == P1) {
		myCh->signal[C_SIG_NEXTSTEP] = P0;
		myCh->op.code = C_FAULT_NEXTSTEP_CMD;
		rtn = END_COND;
		return rtn;
	}
	if(myData->bData[bd].ch_short_di[ch].io.com == P1){
		myCh->signal[C_SIG_OUT_SWITCH] = P1;
		myCh->op.phase = P99;
		myCh->op.checkDelayTime = 0;
		myCh->op.code = C_END_SHORT;
		rtn = END_COND;
		return rtn;
	}
	return rtn;
}

void cShortDioSignal(int bd, int ch)
{
	int addr;

	//addr 610 SHORT_OUT[WR]	
	addr = myPs->addr.interface[IO_OUTPUT][2];

	//OUTPUT SIGNAL

	//READY
	if(myData->bData[bd].cData[ch].op.state == C_STANDBY
		|| myData->bData[bd].cData[ch].op.state == C_PAUSE){
		if(ch == 0){
			myData->bData[bd].ch_short_do[0].io.ready1 = P1;
			myData->bData[bd].ch_short_do[0].io.run1 = P0;
//			myData->bData[bd].ch_short_do[0].io.com1 = P0;
			myData->bData[bd].ch_short_do[0].io.alram1 = P0;
		}else{
			myData->bData[bd].ch_short_do[0].io.ready2 = P1;
			myData->bData[bd].ch_short_do[0].io.run2 = P0;
//			myData->bData[bd].ch_short_do[0].io.com2 = P0;
			myData->bData[bd].ch_short_do[0].io.alram2 = P0;
		}
	}
	//RUN
	if(myData->bData[bd].cData[ch].op.state == C_RUN){
		if(myData->bData[bd].cData[ch].op.type != STEP_SHORT){
			if(ch == 0){
				myData->bData[bd].ch_short_do[0].io.ready1 = P1;
				myData->bData[bd].ch_short_do[0].io.run1 = P1;
				myData->bData[bd].ch_short_do[0].io.com1 = P0;
				myData->bData[bd].ch_short_do[0].io.alram1 = P0;
			}else{
				myData->bData[bd].ch_short_do[0].io.ready2 = P1;
				myData->bData[bd].ch_short_do[0].io.run2 = P1;
				myData->bData[bd].ch_short_do[0].io.com2 = P0;
				myData->bData[bd].ch_short_do[0].io.alram2 = P0;
			}
		} else {
			// SHORT STEP READY STATE
			if(ch == 0){
				myData->bData[bd].ch_short_do[0].io.ready1 = P1;
				myData->bData[bd].ch_short_do[0].io.run1 = P0;
				myData->bData[bd].ch_short_do[0].io.com1 = P0;
				myData->bData[bd].ch_short_do[0].io.alram1 = P0;
			}else{
				myData->bData[bd].ch_short_do[0].io.ready2 = P1;
				myData->bData[bd].ch_short_do[0].io.run2 = P0;
				myData->bData[bd].ch_short_do[0].io.com2 = P0;
				myData->bData[bd].ch_short_do[0].io.alram2 = P0;
			}
		}
	}
	//COMPLETE
	if(myData->bData[bd].cData[ch].op.type == STEP_END
		|| myData->bData[bd].cData[ch].op.code == C_END_STEP){
		if(ch == 0){
			myData->bData[bd].ch_short_do[0].io.ready1 = P1;
			myData->bData[bd].ch_short_do[0].io.run1 = P0;
			myData->bData[bd].ch_short_do[0].io.com1 = P1;
			myData->bData[bd].ch_short_do[0].io.alram1 = P0;
		}else{
			myData->bData[bd].ch_short_do[0].io.ready2 = P1;
			myData->bData[bd].ch_short_do[0].io.run2 = P0;
			myData->bData[bd].ch_short_do[0].io.com2 = P1;
			myData->bData[bd].ch_short_do[0].io.alram2 = P0;
		}	
	}
	//ALRAM
	if(cFailCodeCheck(bd, ch) != 0){
		if(myCh->op.state == C_PAUSE) {
			if(ch == 0){
				myData->bData[bd].ch_short_do[0].io.ready1 = P0;
				myData->bData[bd].ch_short_do[0].io.run1 = P0;
				myData->bData[bd].ch_short_do[0].io.com1 = P0;
				myData->bData[bd].ch_short_do[0].io.alram1 = P1;
			}else{
				myData->bData[bd].ch_short_do[0].io.ready2 = P0;
				myData->bData[bd].ch_short_do[0].io.run2 = P0;
				myData->bData[bd].ch_short_do[0].io.com2 = P0;
				myData->bData[bd].ch_short_do[0].io.alram2 = P1;
			}
		}
	}
	if(myData->AppControl.signal[APP_SIG_QUIT] != P0){
		outb(0x00, addr);
	}else{
		outb(myData->bData[bd].ch_short_do[0].ch_io, addr);
	}
	
	//INPUT SIGNAL
	if(ch == 0){
		//addr 614 SHORT_IN[RD]	
		addr = myPs->addr.interface[IO_EXPEND][7];
	}else{
		//addr 615 SHORT_IN[RD]	
		addr = myPs->addr.interface[IO_EXPEND][8];
	}
//	myData->bData[bd].ch_short_di[ch].ch_io = inb(addr);
	switch(inb(addr)){
		case 0x00:
			myData->bData[bd].ch_short_di[ch].io.ready = P0;
			myData->bData[bd].ch_short_di[ch].io.run = P0;
			myData->bData[bd].ch_short_di[ch].io.com = P0;
			myData->bData[bd].ch_short_di[ch].io.alram = P0;
			break;
		case 0x01:
			myData->bData[bd].ch_short_di[ch].io.ready = P1;
			myData->bData[bd].ch_short_di[ch].io.run = P0;
			myData->bData[bd].ch_short_di[ch].io.com = P0;
			myData->bData[bd].ch_short_di[ch].io.alram = P0;
			break;
		case 0x02:
			myData->bData[bd].ch_short_di[ch].io.ready = P0;
			myData->bData[bd].ch_short_di[ch].io.run = P1;
			myData->bData[bd].ch_short_di[ch].io.com = P0;
			myData->bData[bd].ch_short_di[ch].io.alram = P0;
			break;
		case 0x03:
			myData->bData[bd].ch_short_di[ch].io.ready = P1;
			myData->bData[bd].ch_short_di[ch].io.run = P1;
			myData->bData[bd].ch_short_di[ch].io.com = P0;
			myData->bData[bd].ch_short_di[ch].io.alram = P0;
			break;
		case 0x04:
			myData->bData[bd].ch_short_di[ch].io.ready = P0;
			myData->bData[bd].ch_short_di[ch].io.run = P0;
			myData->bData[bd].ch_short_di[ch].io.com = P1;
			myData->bData[bd].ch_short_di[ch].io.alram = P0;
			break;
		case 0x05:
			myData->bData[bd].ch_short_di[ch].io.ready = P1;
			myData->bData[bd].ch_short_di[ch].io.run = P0;
			myData->bData[bd].ch_short_di[ch].io.com = P1;
			myData->bData[bd].ch_short_di[ch].io.alram = P0;
			break;
		case 0x06:
			myData->bData[bd].ch_short_di[ch].io.ready = P0;
			myData->bData[bd].ch_short_di[ch].io.run = P1;
			myData->bData[bd].ch_short_di[ch].io.com = P1;
			myData->bData[bd].ch_short_di[ch].io.alram = P0;
			break;
		case 0x07:
			myData->bData[bd].ch_short_di[ch].io.ready = P1;
			myData->bData[bd].ch_short_di[ch].io.run = P1;
			myData->bData[bd].ch_short_di[ch].io.com = P1;
			myData->bData[bd].ch_short_di[ch].io.alram = P0;
			break;
		case 0x08:
			myData->bData[bd].ch_short_di[ch].io.ready = P0;
			myData->bData[bd].ch_short_di[ch].io.run = P0;
			myData->bData[bd].ch_short_di[ch].io.com = P0;
			myData->bData[bd].ch_short_di[ch].io.alram = P1;
			break;
	}
}

void cShortModeControl(int mode)
{
	switch(mode){
		case 0x00:		//No Signal
			myCh->op.code = C_FAULT_SHORT_DISCONNECTED;
			myCh->op.phase = P0;
			myCh->signal[C_SIG_OUT_SWITCH] = P0;
			outb(0x00,0x615);
			return;
		case 0x10:		//Cycler Single Mode
//			myCh->op.code = C_FAULT_CYCLER_SINGLE;
			break;
		case 0x20:		//ShortTester Single Mode
			myCh->op.code = C_FAULT_SHORT_TESTER_SINGLE;
			myCh->op.phase = P0;
			myCh->signal[C_SIG_OUT_SWITCH] = P0;
			outb(0x00,0x615);
			return;
		case 0x30:		//InterLock Mode
//			myCh->op.code = C_FAULT_INTER_LOCK_MODE;
			break;
	}
}
//add end
#endif

void cIdle(int bd, int ch)
{
	myCh = &(myData->bData[bd].cData[ch]);

	switch(myCh->op.phase) {
		case P0:
   			myCh->op.code = C_CODE_IDLE;
			myCh->op.type = 0;
			myCh->op.mode = 0;
   			myCh->op.totalRunTime = 0;
   			myCh->op.totalRunTime_carry = 0;
   			myCh->misc.cycleRunTime = 0;
   			myCh->misc.cycleNo = 0;
	       	myCh->op.runTime = 0;
	       	myCh->op.checkDelayTime = 0;
			myCh->op.select = 0;
    		myCh->op.grade = 0;
	       	myCh->op.stepNo = 0;
			myCh->op.meanVolt = 0;
			myCh->op.meanCurr = 0;
        	myCh->op.watt = 0;
	       	myCh->op.wattHour = 0;
   		  	myCh->op.ampareHour = 0;
   		  	myCh->op.capacitance = 0;
			//20180206 sch
			myCh->op.capacitance_iec = 0;	
			myCh->op.capacitance_maxwell = 0;	
	       	myCh->op.z = 0;
			myCh->misc.saveZ = 0;
			myCh->op.resultIndex = 0;
			myCh->misc.preDataType = 0; //210217

		    myCh->op.phase = P1;

			//141208 oys SDI MES VER4 data
			myCh->misc.step_count = 0;
			myCh->op.meanTemp = 0;
			//190618 oys add
			myCh->misc.can_read_v = 0;
			myCh->misc.can_read_i = 0;
			myCh->misc.can_read_errCnt = 0;
			myCh->misc.can_error = 0;
			//200317 lyhw
			myCh->misc.reserved_cmd_flag = 0;
			//210126 lyhw
			myCh->misc.preMode = 0;
    		break;
		case P1:
			if(myPs->misc.timer_1sec >= 2) { //2sec
				myCh->opSave = myCh->op;
	    	    myCh->op.state = C_STANDBY;
	        	myCh->op.phase = P0;
			}
			break;
		default: break;
	}
}

void cStandby(int bd, int ch)
{
	int i, j=0, type, parallel_ch, k=0;
	long refTemp, groupTemp, refTemp_backup;
	unsigned long delay_time, startStepNo, advStepNo, saveDt;
	
	myCh = &(myData->bData[bd].cData[ch]);
    advStepNo = myCh->misc.advStepNo;
	saveDt = myPs->testCond[bd][ch].step[advStepNo].saveDt;
	
	if((ch % 2) == 0) parallel_ch = ch + 1;
	else parallel_ch = ch - 1;

	switch(myCh->op.phase) {
		case P0:
			myCh->op.checkDelayTime = 0;
			myCh->op.phase = P1;
		case P1:
			if(myCh->op.select == SAVE_FLAG_SAVING_END
				&& myCh->op.code != C_END_STEP) {
				if(myData->DataSave.config.save_data_type == P1) {
					myCh->op.checkDelayTime += myPs->misc.rt_scan_time;
					//190712 oys add : End Step save wait delay
					if(myCh->op.checkDelayTime > 100) { 
						myCh->op.checkDelayTime = 0;
						if(myCh->ChAttribute.opType == P0) {
							send_save_msg(bd, ch, saveDt, 1);
						}
						myCh->op.phase = P2;
					}else{
						break;
					}
				} else {
					if(myCh->ChAttribute.opType == P0) {
						send_save_msg(bd, ch, saveDt, 1);
					}
					myCh->op.phase = P2;
				}
			} else {
				myCh->op.phase = P2;
			}
		case P2:
			#ifdef _JIG_TYPE_1 //120206 kji
			if(myPs->config.hwSpec == L_5V_200A_1CH_JIG) {
			    myPs->signal[M_SIG_JIG_SOL] = P0;
			}
			#endif

			for(i=0; i < MAX_SIGNAL; i++) myCh->signal[i] = P0;
			for(i=0; i < MAX_STEP; i++) {
				myCh->misc.gotoCycleCount[i] = P0;
				myCh->misc.ahEndRatio[i] = 100; //default : 100
				myCh->misc.whEndRatio[i] = 100; //default : 100
				myCh->misc.sel_Cyc_C_Cap[i] = 0;
				myCh->misc.sel_Cyc_D_Cap[i] = 0;
			}

			//210311 lyhw
			#if CYCLER_TYPE == CAN_CYC
			if(myData->AppControl.config.systemType == CYCLER_CAN){
				for(i = 0; i < 8; i++){
					myPs->signal[M_SIG_CAN1_0 + i] = P0;
				}	
			}
			#endif
			for(i=0; i < MAX_CYCLE; i++) { //pjy add for toshiba
				myCh->misc.charge_integralCap[i] = 0;
				myCh->misc.discharge_integralCap[i] = 0;
			}

			myCh->op.rangeV = 0;
			myCh->op.rangeI = 0;
			if(myData->AppControl.config.debugType == P0) {
				myCh->op.preType = STEP_IDLE;
			}
			myCh->op.semiPreType = STEP_IDLE;
			myCh->misc.semiSwitchState = SEMI_IDLE;

			if(myData->bData[bd].cData[parallel_ch].misc.parallel_cycle_phase
				== P50) { //iyhw_180530
			} else {
				cSemiSwitch(bd, ch);
			}

			if(myPs->config.hwSpec >= S_5V_200A) {
				myCh->op.checkDelayTime += myPs->misc.rt_scan_time;
				if(myCh->op.checkDelayTime >= 300) {
					myCh->op.checkDelayTime = 0;
					myCh->signal[C_SIG_OUT_SWITCH] = P0;
					if(myPs->config.hwSpec > DC_DIGITAL_SPEC){	//180611 add 
						myCh->signal[C_SIG_OUT_SWITCH_OFF] = P1;
					}
					cV_Range_Select(bd, ch, 1);
					cI_Range_Select(bd, ch, 0);
					myCh->op.phase = P3;
				}
			} else {
				myCh->op.phase = P3;
			}
			break;
		case P3:
			if(myData->AppControl.loadProcess[LOAD_EXTCLIENT] == P1) {
				//20160810 KHK
				if(myCh->op.type == STEP_END) {
				} else {
					myCh->op.type = 0;
				}
			} else {
				myCh->op.z = 0;
				myCh->op.type = 0;
				//myCh->op.code = C_CODE_IDLE;
			}

			//170215 SCH add for DeltaV/I
			if(myCh->op.code == C_STOP_DELTA_V 
				|| myCh->op.code == C_STOP_DELTA_I
				|| myCh->op.code == C_FAULT_END_LIMIT_CURRENT
				|| myCh->op.code == C_FAULT_END_LIMIT_VOLTAGE) {
				//20171008 sch add
			} else {
    			myCh->op.code = C_CODE_IDLE;
			}
 			//myCh->op.code = C_CODE_IDLE;

			myCh->op.type = 0;
			myCh->op.mode = 0;
    		myCh->op.totalRunTime = 0;
   			myCh->op.totalRunTime_carry = 0;
			myCh->op.select = 0;
			myCh->op.grade = 0;
	       	myCh->op.stepNo = 0;
	       	myCh->op.runTime = 0;
   			myCh->misc.cvFlag = P0;
			#ifdef _EXTERNAL_CONTROL
			myCh->misc.chCV = P0;
			#endif					
			//210204 lyhw
   			myCh->misc.cvFaultCheckFlag = 0;
   			myCh->misc.cycleRunTime = 0;
   			myCh->misc.cycleNo = 0;
	       	myCh->op.checkDelayTime = 0;
			myCh->op.meanVolt = 0;
			myCh->op.meanCurr = 0;
        	myCh->op.watt = 0;
	       	myCh->op.wattHour = 0;
   		  	myCh->op.ampareHour = 0;
   		  	myCh->op.charge_ampareHour = 0;
   		  	myCh->op.discharge_ampareHour = 0;
   		  	myCh->op.charge_wattHour = 0;
			myCh->op.discharge_wattHour = 0;
			myCh->op.capacitance = 0;
			//20180206
			myCh->op.capacitance_iec = 0;	
			myCh->op.capacitance_maxwell = 0;	
	       	myCh->op.z = 0;
			myCh->misc.saveZ = 0;
			myCh->op.resultIndex = 0;

			myCh->misc.preRangeI = 99;

			myCh->misc.pulseDataCount = 0;
			myCh->misc.save10msDataCount = 0;
			myCh->misc.delta_flag = P0;
   		   	myCh->misc.saveDt = 0;
   		   	myCh->misc.saveDv = 0;
   		   	myCh->misc.saveDi = 0;
   		   	myCh->misc.saveDtemp = 0;
			myCh->misc.meanCount = 0;
			myCh->misc.meanSumVolt = 0;
			myCh->misc.meanSumCurr = 0;
			myCh->misc.ocv = 0;
			myCh->misc.actualCapacity = 0;
			myCh->misc.actualWattHour = 0; //20190214 add
			myCh->misc.sumCapacity = 0;
			myCh->misc.seedCapacity = 0;
			myCh->misc.sumChargeAmpareHour = 0;
			myCh->misc.sumDischargeAmpareHour = 0;
			myCh->misc.sumChargeWattHour = 0;
			myCh->misc.sumDischargeWattHour = 0;
			myCh->misc.seedChargeWattHour = 0;
			myCh->misc.seedDischargeWattHour = 0;
			myCh->misc.seedChargeAmpareHour = 0;
			myCh->misc.seedDischargeAmpareHour = 0;
        	myCh->misc.tmpWatt = 0;
			myCh->misc.sumWattHour = 0;
			myCh->misc.seedWattHour = 0;
			myCh->misc.maxV = 0;
			myCh->misc.minV = 0;
			myCh->misc.startV = 0;
			myCh->misc.startT = 0;
			myCh->misc.maxT = 0;
			myCh->misc.minT = 0;
			myCh->misc.maxI = 0;
			myCh->misc.minI = 0;
			myCh->misc.c_v1 = 0;
			myCh->misc.c_v2 = 0;
			myCh->misc.c_t1 = 0;
			myCh->misc.c_t2 = 0;
			myCh->misc.start = 1;
			myCh->misc.fbCountV_H = 0;
			myCh->misc.fbCountI_H = 0;
			myCh->misc.fbSumI_H = 0;
			myCh->misc.fbSumV_H = 0;
			myCh->misc.fbCountV_L = 0;
			myCh->misc.fbCountI_L = 0;
			myCh->misc.fbSumI_L = 0;
			myCh->misc.fbSumV_L = 0;
			myCh->misc.fbCountV_M = 0;
			myCh->misc.fbCountI_M = 0;
			myCh->misc.fbSumI_M = 0;
			myCh->misc.fbSumV_M = 0;
			myCh->misc.sensCount = 0;
			myCh->misc.userPatternCnt = 0;
			myCh->ccv[0].index = 0;
			myCh->misc.sensCountFlag = P0;
			myCh->misc.sensBufCount = 0;
			myCh->misc.sensBufCountFlag = P0;
			myCh->misc.tempDir = P0;
			myCh->misc.chamberStepNo = 0;
			myCh->misc.advStepNo = 0;
			myCh->misc.fbV = 0;
			myCh->misc.fbI = 0;
			myCh->misc.cvTime = 0;
			myCh->misc.pid_ui1[0] = 0.0;
			myCh->misc.pid_ui1[1] = 0.0;
			myCh->misc.pid_error1[0] = 0.0;
			myCh->misc.pid_error1[1] = 0.0;

			myCh->misc.relayStartFlag = 0; //110402 kji	

			//151214 oys
			myCh->misc.completeFlag = 0;
			myCh->misc.standardC_Flag = 0;
			myCh->misc.standardP_Flag = 0;
			myCh->misc.standardZ_Flag = 0;

			//160510 oys	
			myCh->misc.socCheckCount = 0;
			myCh->misc.socCountNo[0] = 0;
			myCh->misc.socCountNo[1] = 0;
			myCh->misc.socCountNo[2] = 0;
			myCh->misc.cycleEndC = 0;
			myCh->misc.standardC = 0;
			myCh->misc.standardP = 0;
			myCh->misc.standardZ = 0;
			myCh->misc.cycleSumC = 0;
			myCh->misc.cycleSumP = 0;
			myCh->misc.endC_std_type = 0;
			myCh->misc.endP_std_type = 0;
			myCh->misc.endZ_std_type = 0;
			myCh->misc.endC_std_sel = 0;
			myCh->misc.endP_std_sel = 0;
			myCh->misc.endZ_std_sel = 0;
			myCh->misc.endC_std_cycleCount = 0;
			myCh->misc.endP_std_cycleCount = 0;
			myCh->misc.endZ_std_cycleCount = 0;
			myCh->misc.pause_flag = P0;
			myCh->misc.efficiency_pause_flag = P0;
			
			myCh->misc.chamberWaitFlag = P0;
			myCh->misc.cycle_p_flag = P0;		//190308 lyhw add
			myCh->misc.cycle_p_sch_flag = P0;		//190318 lyhw add

			//111215 detail calibration add
			myCh->misc.caliCheckPoint = 0;
			myCh->misc.caliCheckSum = 0;
			myCh->misc.caliCheckSum1 = 0;
			
			//141208 oys SDI MES VER4 data
			myCh->misc.cycleMaxV = 0;
			myCh->misc.cycleMinV = 0;
			myCh->op.meanTemp = 0;
			myCh->misc.meanSumTemp = 0;
			myCh->misc.cycleSumChargeAmpareHour = 0;
			myCh->misc.cycleSumDischargeAmpareHour = 0;
			myCh->misc.sumChargeCCCVAh = 0;
			myCh->misc.seedChargeCCCVAh = 0;
			myCh->misc.chargeCCCVAh = 0;
			myCh->misc.chargeCCAh = 0;
			myCh->misc.chargeCVAh = 0;
			myCh->misc.sumDischargeCCCVAh = 0;
			myCh->misc.seedDischargeCCCVAh = 0;
			myCh->misc.dischargeCCCVAh = 0;
			myCh->misc.dischargeCCAh = 0;
			myCh->misc.dischargeCVAh = 0;
			myCh->misc.cycleSumChargeCCAh = 0;
			myCh->misc.cycleSumChargeCVAh = 0;
			myCh->misc.cycleSumDischargeCCAh = 0;
			myCh->misc.cycleSumDischargeCVAh = 0;
			myCh->misc.cycleSumChargeWatt = 0;
			myCh->misc.cycleSumDischargeWatt = 0;
			myCh->misc.cycleSumChargeWattHour = 0;
			myCh->misc.cycleSumDischargeWattHour = 0;
			myCh->misc.cycleStepCount = 0;
			myCh->misc.cycleDischargeStepCount = 0;
			myCh->misc.mes_data_flag = 0;
			myCh->misc.cycleStartV = 0;
			myCh->misc.step_count = 0;
			myCh->misc.ccTime = 0;
			myCh->misc.cycle_Charge_ccTime = 0;
			myCh->misc.cycle_Charge_cvTime = 0;
			myCh->misc.cycle_Discharge_ccTime = 0;
			myCh->misc.cycle_Discharge_cvTime = 0;
	
			myCh->misc.cycleAvgDischargeV = 0;
			myCh->misc.cycleAvgDischargeI = 0;
			myCh->misc.cycleSumAvgT = 0;
			//170105 oys
			myCh->misc.chGroupNo = 0;
			myCh->misc.chGroupCheckFlag = 0;
			myCh->misc.chamberNo = 0;
			myCh->misc.stepSyncFlag = 0;

			myCh->misc.feedback_start = P0;
			//170728 oys
			myCh->misc.gradeProcFlag = P0;
			//20171212 sch add
			myCh->misc.refTemp_backup = 999000; 
			//20171227 add
			myCh->misc.nAfterIncludeCnt_iec = 0;
			myCh->misc.preMode = 0;

			myCh->misc.parallel_cycle_phase = P0; //kjg_180521
			myCh->misc.parallel_sensFlag = P0; //kjg_180523
			//kjg_180524
			if(myData->bData[bd].cData[parallel_ch].misc.parallel_cycle_phase
				!= P50) {
				myData->bData[bd].cData[parallel_ch].misc.sensCount = 0;
				myData->bData[bd].cData[parallel_ch].misc.sensCountFlag = P0;
				myData->bData[bd].cData[parallel_ch].misc.sensBufCount = 0;
				myData->bData[bd].cData[parallel_ch].misc.sensBufCountFlag = P0;
			}
			myCh->misc.grade_flag = 0; //20190513 add

			//20180206 sch add for capacitance iec & maxwell
			myCh->misc.delta_t_iec[0] = 0;
			myCh->misc.delta_t_iec[1] = 0;
			myCh->misc.delta_v_iec[0] = 0;
			myCh->misc.delta_v_iec[1] = 0;
			myCh->misc.delta_w_iec[0] = 0;
			myCh->misc.delta_w_iec[1] = 0;
			myCh->misc.delta_flag_iec = P0;
			myCh->misc.delta_sumI_iec = 0;
			myCh->misc.delta_cnt_iec = 0;

			myCh->misc.delta_t_maxwell[0] = 0;
			myCh->misc.delta_t_maxwell[1] = 0;
			myCh->misc.delta_v_maxwell[0] = 0;
			myCh->misc.delta_v_maxwell[1] = 0;
			myCh->misc.delta_flag_maxwell = P0;
			myCh->misc.delta_sumI_maxwell = 0;
			myCh->misc.delta_cnt_maxwell = 0;
			//20190607 add
			myCh->misc.Pre_change_V = 0; 
			myCh->misc.change_V = 0; 
			myCh->misc.change_V_timer = 0;
			//20190719 oys add
			myCh->misc.save10msDt = 0;
			//190801 oys
			myCh->misc.cRateUseFlag = 0;
			//190829 oys
			myCh->misc.pre_v_chk_time = 0;
			myCh->op.changeV_Dt_cnt = 0;	//hun_200430
			myCh->misc.pre_chk_v = 0;
			myCh->misc.deltaV_timeout = 0;
			myCh->misc.deltaI_timeout = 0;
			//191029 oys
			myCh->misc.userDataNo = 0;
			myCh->misc.pattern_point_runTime = 0;
			myCh->misc.pattern_cross = 0;
			//210521 ljsw
			myCh->misc.restCheckFlag = 0;
			myCh->misc.restFaultCount = 0;
			myCh->misc.restCheckStartFlag = 0;
			myCh->misc.restCheckNum = 0;
			//200430 hun
			#ifdef _SDI_SAFETY_V1	
			myCh->misc.fault_deltaV = 0;
			#endif
			#ifdef _SDI_SAFETY_V2	
			myCh->misc.Master_recipe_deltaV = 0;	//ljs 210412
			#endif
			//210318 lyhw
			myCh->misc.sumAccumulated_Capacity = 0;
			myCh->misc.seedAccumulated_Capacity = 0;
			myCh->misc.Accumulated_Capacity = 0;
			myCh->misc.sumAccumulated_WattHour = 0;
			myCh->misc.seedAccumulated_WattHour = 0;
			myCh->misc.Accumulated_WattHour = 0;

			myCh->misc.preDataType = 0;
			myCh->misc.hw_fault_temp = 0;
			myCh->misc.Drop_maxV = 0;			//210915 LJS
			myCh->misc.Drop_minV = 0;			//210915 LJS
			myCh->misc.ch_fault_code = 0;
#if CAPACITY_CONTROL == 1
			myCh->misc.CycleCapaCount = 0;
			myCh->misc.CycleCapacity = 0;
			myCh->misc.Sum_C_Rate_Calc_Capacity = 0;
			for(i=0; i < MAX_STEP; i++){
				myCh->misc.C_Rate_stepCapacity[i] = 0;
				myCh->misc.c_rate_fault_flag[i] = 0;
			}
			for(i=0; i < 10; i++){
				myCh->misc.C_Rate_Calc_Capacity[i] = 0;
			}
			myCh->misc.Sum_End_Capa_Capacity = 0;
			myCh->misc.Sum_End_Current_Capacity = 0;
#endif

#ifdef _TRACKING_MODE
			myCh->op.rptSOC = myCh->opSave.rptSOC;
			myCh->misc.socTrackingStep = 0; //SOC ref Step
			myCh->op.rptSOH = myCh->opSave.rptSOH; //211022
			myCh->misc.sohTrackingStep = 0; //SOH ref Step
			myCh->misc.file_sucess_flag = 0;
			myCh->misc.file_fail_flag = 0;
#endif
#ifdef _EXTERNAL_CONTROL
			myCh->misc.chControl = 0;	//hun_210723
			myCh->misc.chPause = 0;		//hun_210723
			myCh->misc.external_return = 0;
			myCh->misc.external_return = 0x00001000;
#endif
			myCh->misc.chamberNoWaitFlag = P0; //211022
#ifdef _ULSAN_SDI_SAFETY
			myCh->misc.humpCheck_T = 0;
			myCh->misc.humpCheck_I = 0;
			myCh->misc.humpComp_T = 0;
			myCh->misc.humpComp_I = 0;
#endif
#ifdef _EQUATION_CURRENT	//211111
			myCh->misc.equation_calc_err_flag = P0;
#endif
			//hun_211125
			myCh->misc.charge_cc_hump_flag = P0;
			myCh->misc.charge_cv_hump_flag = P0;
			myCh->misc.charge_cc_hump_start_time = 0;
			myCh->misc.charge_cv_hump_start_time = 0;
			myCh->misc.charge_cc_hump_start_voltage = 0;
			myCh->misc.charge_cv_hump_start_current = 0;
			
			myCh->misc.discharge_cc_hump_flag = P0;
			myCh->misc.discharge_cv_hump_flag = P0;
			myCh->misc.discharge_cc_hump_start_time = 0;
			myCh->misc.discharge_cv_hump_start_time = 0;
			myCh->misc.discharge_cc_hump_start_voltage = 0;
			myCh->misc.discharge_cv_hump_start_current = 0;
	
			//220203_hun
			myCh->misc.endState = P0;
			myCh->misc.groupAvgVsens = 0;
			myCh->misc.group_StartVoltage_flag = 0;
			myCh->misc.Fault_Check_flag = 0;

			memset((char *)&myCh->misc.d_t, 0, sizeof(long)*100);
			memset((char *)&myCh->misc.d_v, 0, sizeof(long)*100);
			memset((long *)&myCh->misc.d_t_iec, 0x00, sizeof(long)*MAX_PULSE_DATA_IEC);
			memset((long *)&myCh->misc.d_v_iec, 0x00, sizeof(long)*MAX_PULSE_DATA_IEC);
			memset((long *)&myCh->misc.d_i_iec, 0x00, sizeof(long)*MAX_PULSE_DATA_IEC);
			memset((char *)&myCh->ccv, 0, sizeof(S_CH_CCV) * 2);
    		myCh->op.phase = P4;
			break;
		case P4:
			myCh->opSave = myCh->op;
			myCh->op.phase = P5;
			break;
		case P5:
			i = myCh->ccv[0].index;
			myCh->ccv[0].index++;
			if(myCh->ccv[0].count != 10) {
				myCh->ccv[0].count = myCh->ccv[0].index;
			}
			if(myCh->ccv[0].index >= 10) {
				myCh->ccv[0].index = 0;
				myCh->ccv[0].count = 10;
			}
			myCh->ccv[0].ad_ccv[i] = myCh->misc.tmpVsens;
			myCh->ccv[0].ad_cci[i] = myCh->misc.tmpIsens;

			i = 0;
			if(myCh->signal[C_SIG_RUN] == P1) {
				myCh->signal[C_SIG_RUN] = P0;
				myCh->op.code = C_CODE_IDLE; //20160810

				#ifdef _JIG_TYPE_1 //120206 kji
				if(myPs->config.hwSpec == L_5V_200A_1CH_JIG) {
					if(myData->dio.signal[DIO_SIG_JIG_RIGHT_UPPER] == P1) {
						myPs->code = M_FAIL_JIG_RIGHT_UPPER;
						send_msg(MODULE_TO_MAIN, MSG_MODULE_MAIN_EMG_STATUS,
							(int)myPs->code, 0);
						myPs->signal[M_SIG_JIG_BUZZER] = P1;
						myCh->op.state = C_STANDBY;
						myCh->op.phase = P0;
						return;
					} else if(myData->dio.signal[DIO_SIG_JIG_LEFT_UPPER] == P1){
						myPs->code = M_FAIL_JIG_LEFT_UPPER;
						send_msg(MODULE_TO_MAIN, MSG_MODULE_MAIN_EMG_STATUS,
							(int)myPs->code, 0);
						myPs->signal[M_SIG_JIG_BUZZER] = P1;
						myCh->op.state = C_STANDBY;
						myCh->op.phase = P0;
						return;
					} else if(myData->dio.signal[DIO_SIG_JIG_LIMIT] == P1) {
						myPs->code = M_FAIL_JIG_LIMIT_ERROR;
						send_msg(MODULE_TO_MAIN, MSG_MODULE_MAIN_EMG_STATUS,
							(int)myPs->code, 0);
						myPs->signal[M_SIG_JIG_BUZZER] = P1;
						myCh->op.state = C_STANDBY;
						myCh->op.phase = P0;
						return;
					} else {
						myPs->signal[M_SIG_JIG_PASS_LAMP] = P0;		 
						myPs->signal[M_SIG_JIG_FAIL_LAMP] = P0;		 
						myPs->signal[M_SIG_JIG_SOL] = P1;
					}
				}
				#endif
				
				#ifdef _TRACKING_MODE
					if(myPs->testCond[bd][ch].safety.schedule_link_flag == 1){
						myCh->op.rptSOC
							= myCh->opSave.rptSOC;
					}
					if(myPs->testCond[bd][ch].safety.schedule_link_flag2 == 1){
						myCh->op.rptSOH
							= myCh->opSave.rptSOH; //211022
					}
				#endif
				if(myPs->testCond[bd][ch].reserved.select_run == 0) {
					myCh->op.type = myPs->testCond[bd][ch].step[0].type;
					myCh->op.mode = myPs->testCond[bd][ch].step[0].mode;
					i = 1;
				} else {
					j = (int)myPs->testCond[bd][ch].reserved.select_stepNo - 1;
					if(j < 0) j = 0;
					// 120427 oys w : select cycle & step process
					// 170630 oys modify
					myCh->op.type = myPs->testCond[bd][ch].step[j].type;
					myCh->op.mode = myPs->testCond[bd][ch].step[j].mode;
					myCh->op.stepNo = myPs->testCond[bd][ch].step[j].stepNo;
					myCh->misc.advStepNo = (unsigned long)j;
					i = 2;
				}
			} else if(myCh->signal[C_SIG_RESET] == P1) {
				myCh->signal[C_SIG_RESET] = P0;
				//kjg_180521 myCh->op.state = C_STANDBY;
				i = 1;
			} else if(myCh->signal[C_SIG_CALI] == P1) {
				myCh->signal[C_SIG_CALI] = P0;
				if(myPs->config.hwSpec < S_5V_200A) { //linear
				} else { //switching
					cV_Range_Select(bd, ch, 0);
					cI_Range_Select(bd, ch, 0);
				}
				i = 3;
			} else if(myCh->signal[C_SIG_PAUSE] == P1) {
				myCh->signal[C_SIG_PAUSE] = P0;
				myCh->signal[C_SIG_RANGE_SWITCH] = P0;
				myCh->signal[C_SIG_OUT_SWITCH] = P0;
				myCh->signal[C_SIG_I_RANGE] = P0;			//151105 oys w
				if(myPs->config.hwSpec > DC_DIGITAL_SPEC){	//180611 add 
					myCh->signal[C_SIG_OUT_SWITCH_OFF] = P1;
				}
			}

			if(i == 1) {
				myCh->op.phase = P6;
				myCh->misc.advCycle = 0;
				myCh->misc.advCycleStep = 0;
				myCh->misc.advStepNo = 0;
				myCh->misc.chamberStepNo = myCh->misc.advStepNo;
				myCh->misc.currentCycle = 0;
				myCh->misc.totalCycle = 0;
				type = myPs->testCond[bd][ch].step[1].type;

				if(myCh->ChAttribute.opType == P1) {
					myCh->signal[C_SIG_PARALLEL_SWITCH] = P1;
				}

				if(myPs->config.hwSpec < S_5V_200A) { //linear
					if(myData->bData[bd].cData[parallel_ch].misc
						.parallel_cycle_phase == P50) k = 0; //kjg_180529
					else k = 1;
				} else k = 0;

				if(k == 1) {
					if(type == STEP_REST) {
						if(myPs->testCond[bd][ch].step[1].endT != 0) {
							if(myPs->testCond[bd][ch].step[1].endT >= 6000) {
								myCh->signal[C_SIG_OUT_SWITCH] = P0;
								myCh->signal[C_SIG_RANGE_SWITCH] = P0;
							} else {
								myCh->misc.relayStartFlag = 1;
								type = myPs->testCond[bd][ch].step[2].type;
								cSemiSwitch_Start(bd, ch, type);
							}
						} else {
							myCh->signal[C_SIG_OUT_SWITCH] = P0;
							myCh->signal[C_SIG_RANGE_SWITCH] = P0;
						}
					} else if(type == STEP_USER_PATTERN) {
						cSemiSwitch_Start(bd, ch, type);
						myCh->misc.relayStartFlag = 3;
					} else if(type == STEP_OCV) { 
						type = myPs->testCond[bd][ch].step[2].type;
						cSemiSwitch_Start(bd, ch, type);
						myCh->misc.relayStartFlag = 1;
					} else if(type == STEP_SHORT) {
						myCh->misc.relayStartFlag = 0;
					} else {
						cSemiSwitch_Start(bd, ch, type);
						myCh->misc.relayStartFlag = 1;
					}
				}

				if(myData->mData.config.function[F_CHAMBER_TEMP_WAIT] == P1) {
					if(myPs->testCond[bd][ch].step[1].refTemp != 999000) {
						myCh->misc.relayStartFlag = 100; //chamber temp wait
					}
				}
			} else if(i == 2) {
				myCh->op.phase = P6;
				type = myPs->testCond[bd][ch].step[j].type;

				if(myData->bData[bd].cData[parallel_ch].misc
					.parallel_cycle_phase == P50) k = 0; //kjg_180529
				else k = 1;
				if(k == 1) cSemiSwitch_Start(bd, ch, type);

				if(myCh->ChAttribute.opType == P1) {
					myCh->signal[C_SIG_PARALLEL_SWITCH] = P1;
				}

				if(myPs->config.hwSpec < S_5V_200A) { //linear
					if(myData->bData[bd].cData[parallel_ch].misc
						.parallel_cycle_phase == P50) k = 0; //kjg_180529
					else k = 1;
				} else k = 0;

				if(k == 1) {
					if(type == STEP_REST) {
						if(myPs->testCond[bd][ch].step[j].endT != 0) {
							if(myPs->testCond[bd][ch].step[j].endT >= 6000) {
								myCh->signal[C_SIG_OUT_SWITCH] = P0;
								myCh->signal[C_SIG_RANGE_SWITCH] = P0;
							} else {
								myCh->misc.relayStartFlag = 2;
							}
						} else {
							myCh->signal[C_SIG_OUT_SWITCH] = P0;
							myCh->signal[C_SIG_RANGE_SWITCH] = P0;
						}
					} else if(type == STEP_USER_PATTERN) {
						cSemiSwitch_Start(bd, ch, type);
						myCh->misc.relayStartFlag = 3;
					} else {
						cSemiSwitch_Start(bd, ch, type);
						myCh->misc.relayStartFlag = 2;
					}
				}

				if(myData->mData.config.function[F_CHAMBER_TEMP_WAIT] == P1) {
					refTemp = myPs->testCond[bd][ch].step[j].refTemp;
					groupTemp = myCh->misc.groupTemp;
					//20171212 sch add
					refTemp_backup = myCh->misc.refTemp_backup;

					switch(type) {
						case STEP_CHARGE:
						case STEP_DISCHARGE:
						case STEP_OCV:
						case STEP_REST:
						case STEP_Z:
						case STEP_USER_PATTERN:
						case STEP_BALANCE:
#if MACHINE_TYPE == 1
						case STEP_SHORT:
#endif
							if(refTemp != 999000) {
								if(refTemp == groupTemp
									|| refTemp == refTemp_backup) {
									myCh->misc.tempDir = P0;
								} else if(refTemp > groupTemp) {
									myCh->misc.tempDir = P1;
								} else {
									myCh->misc.tempDir = P2;
								}

								//chamber temp wait
								myCh->misc.relayStartFlag = 100;
							}
							break;
						default:
							myCh->misc.tempDir = P0;
							break;
					}
				}

				j = (int)myPs->testCond[bd][ch].reserved.select_cycleNo;
				if(myCh->op.type == STEP_ADV_CYCLE) j -= 1;	//190705
				if(j < 0) j = 0;
				myCh->misc.advCycle = (unsigned long)j;
				myCh->misc.currentCycle = (unsigned long)j;
				myCh->misc.totalCycle = (unsigned long)j;
				myCh->misc.advCycleStep
					= myPs->testCond[bd][ch].reserved.select_advCycleStep;
			} else if(i == 3) {
				myCh->op.phase = P8;
			}

			myCh->ccv[0].avg_v = myCh->misc.tmpVsens;
			if(myCh->ChAttribute.opType == P0) {
				//kjgw_180521 [ch-1]?
				myCh->ccv[0].avg_v = myData->bData[bd].cData[ch-1].ccv[0].avg_v;
			}
			myCh->ccv[0].avg_i = myCh->misc.tmpIsens;
			break;
		case P6:
			startStepNo = 1;
			if(myCh->misc.relayStartFlag == 2) {
				startStepNo = (unsigned long)myPs->testCond[bd][ch]
					.reserved.select_stepNo - 1;
			}

			myCh->op.checkDelayTime += myPs->misc.rt_scan_time;

			if(myPs->config.hwSpec < S_5V_200A) { //linear
				delay_time = 200;
			} else { //switching
				delay_time = 50;
			}

			if(myData->bData[bd].cData[parallel_ch].misc
				.parallel_cycle_phase == P50) k = 0; //kjg_180529
			else k = 1;

			if(myPs->config.hwSpec < S_5V_200A) { //liner run relay time delay
				if(k == 1 && myCh->op.checkDelayTime >= 100) {
					if(myCh->misc.relayStartFlag > 0) {
						if(myCh->misc.relayStartFlag < 3) { //111008 kji
							if(myPs->config.hwSpec > DC_DIGITAL_SPEC){//180611 
								if(myCh->misc.relayStartFlag < 100){
									myCh->signal[C_SIG_OUT_SWITCH] = P1;
									myCh->signal[C_SIG_OUT_SWITCH_ON] = P1;
								}
							}else{
								myCh->signal[C_SIG_OUT_SWITCH] = P1;
							}
							myCh->signal[C_SIG_RANGE_SWITCH] = P1;
							myCh->signal[C_SIG_V_RANGE]
								= myPs->testCond[bd][ch].step[startStepNo]
								.rangeV + 1;
							myCh->signal[C_SIG_I_RANGE]
								= myPs->testCond[bd][ch].step[startStepNo]
								.rangeI + 1;
						}
						myCh->misc.relayStartFlag = 0;
					}
				}
			} else { //switching
				if(k == 1 && myCh->misc.relayStartFlag > 0) {
					myCh->misc.relayStartFlag = 0;
					if(myPs->config.hwSpec > DC_DIGITAL_SPEC){//180611 
						myCh->signal[C_SIG_OUT_SWITCH_ON] = P1;
					}
					myCh->signal[C_SIG_OUT_SWITCH] = P1;
					myCh->signal[C_SIG_RANGE_SWITCH] = P1;
					myCh->signal[C_SIG_V_RANGE]
						= myPs->testCond[bd][ch].step[startStepNo].rangeV + 1;
					myCh->signal[C_SIG_I_RANGE]
						= myPs->testCond[bd][ch].step[startStepNo].rangeI + 1;
				}
			}

			if(myCh->op.checkDelayTime >= delay_time) {
				#ifdef _JIG_TYPE_1
				if(myPs->config.hwSpec == L_5V_200A_1CH_JIG) {
					if(myData->dio.signal[DIO_SIG_JIG_RIGHT_LOWER] == P1) {
						myPs->code = M_FAIL_JIG_RIGHT_LOWER;
						send_msg(MODULE_TO_MAIN, MSG_MODULE_MAIN_EMG_STATUS,
							(int)myPs->code, 0);
						myPs->signal[M_SIG_JIG_BUZZER] = P1;
						myCh->op.state = C_STANDBY;
						myCh->op.phase = P0;
						break;
					} else if(myData->dio.signal[DIO_SIG_JIG_LEFT_LOWER] == P1){
						myPs->code = M_FAIL_JIG_LEFT_LOWER;
						send_msg(MODULE_TO_MAIN, MSG_MODULE_MAIN_EMG_STATUS,
							(int)myPs->code, 0);
						myPs->signal[M_SIG_JIG_BUZZER] = P1;
						myCh->op.state = C_STANDBY;
						myCh->op.phase = P0;
						break;
					}
				}
				#endif

				myCh->op.state = C_RUN;
				myCh->op.phase = P0;
				myCh->op.checkDelayTime = 0;
			}
			break;
		case P8:
			myCh->op.checkDelayTime += myPs->misc.rt_scan_time;

			if(myPs->config.hwSpec < S_5V_200A) { //linear
				delay_time = 200;
			} else { //switching
				delay_time = 50;
			}

			if(myCh->op.checkDelayTime >= delay_time) {
				myCh->op.state = C_CALI;
				myCh->op.phase = P0;
				myCh->op.checkDelayTime = 0;
			}
			break;
		default:
			break;
	}
}

void cPause(int bd, int ch)
{
	unsigned char flag1=0, flag2=0;
	int parallel_ch, mode, sum_ch, pauseSaveDt, pauseSaveEndT = 0;
	long type, j;
	unsigned long advStepNo, saveDt, i=0;
	long long flag3;
	S_CH_STEP_INFO step;

	flag3 = 0x01;
	for(j=0; j < myPs->config.chPerBd; j++) {
	    if(j == ch) break;
	    flag3 = flag3 << 1;
	}
	flag1 = flag3;
	flag3 = flag3 >> 8;
	flag2 = flag3;
	
	myCh = &(myData->bData[bd].cData[ch]);

	step = step_info(bd, ch);
	
	advStepNo = step.advStepNo;
	saveDt = step.saveDt;
	type = step.type;
	mode = step.mode;
	
	if((ch % 2) == 0) parallel_ch = ch + 1;
	else parallel_ch = ch - 1;

	switch(myCh->op.phase) {
		case P0:
			switch(myPs->config.hwSpec) {
				case L_2V_100A:
				case L_5V_50A:
				case S_5V_200A:
				case S_5V_200A_75A_15A_AD2:
					myCh->signal[C_SIG_V_RANGE] = RANGE0;
					myCh->signal[C_SIG_I_RANGE] = RANGE0;
					break;
				default:
					break;
			}

			if(myData->bData[bd].cData[parallel_ch].misc.parallel_cycle_phase
				== P50) { //kjg_180530
			} else {
				myCh->misc.semiSwitchState = SEMI_PRE;
				myCh->signal[C_SIG_RANGE_SWITCH] = P0;
				myCh->signal[C_SIG_OUT_SWITCH] = P0;
				if(myPs->config.hwSpec > DC_DIGITAL_SPEC){//180611 
					myCh->signal[C_SIG_OUT_SWITCH_OFF] = P1;
					if(myCh->ChAttribute.opType == P1)
						myCh->signal[C_SIG_PARALLEL_SWITCH] = P0;	
				}
				myCh->signal[C_SIG_I_RANGE] = P0;	//151105 oys w
				if(myPs->config.hwSpec < S_5V_200A)  //linear
					cSemiSwitch(bd, ch);
			}

			//120206 kji
			#ifdef _JIG_TYPE_1
			if(myPs->config.hwSpec == L_5V_200A_1CH_JIG) {
			    myPs->signal[M_SIG_JIG_SOL] = P0;
			}
			#endif

			//210126 lyhw
			myCh->misc.preMode = 0;
			myCh->op.checkDelayTime = 0;
			myCh->misc.cvFaultCheckFlag = 0; 	//210204

			//210521 ljsw
			myCh->misc.restCheckFlag = 0;
			myCh->misc.restFaultCount = 0;
			myCh->misc.restCheckStartFlag = 0;
			myCh->misc.restCheckNum = 0;
			myCh->misc.ch_fault_code = 0;
			myCh->op.phase = P1;
			break;
		case P1:
			if(myData->DataSave.config.save_data_type == P1) {
				myCh->op.checkDelayTime += myPs->misc.rt_scan_time;
				if(myCh->op.checkDelayTime == 100) {
					//200317 lyhw for 10mS End Data Save
					if(myCh->misc.reserved_cmd_flag == 0){
						if(myCh->ChAttribute.opType == P0) {
							send_save_msg(bd, ch, saveDt, 1);
						}
					}else{
						myCh->misc.reserved_cmd_flag = 0;
					}
				}
				if(myCh->op.checkDelayTime >= 200) {
					myCh->op.checkDelayTime = 0;
					myCh->op.phase = P2;
				}
			} else {
				myCh->op.phase = P2;
			}
			break;
		case P2:
			if(myPs->config.parallelMode == P2) { //kjg_180528
				if(myData->bData[bd].cData[parallel_ch].misc
					.parallel_cycle_phase == P50) {
				} else {
					sens_ch_ad_count_increment(bd, ch);
				}
			} else {
				sens_ch_ad_count_increment(bd, ch);
			}

			if(myPs->config.hwSpec == L_5V_150A_R2_P) {
				outb(flag1 , 0x666);
				outb(flag2 , 0x6A6);
			}

			sum_ch = 0;
			//111215 kji w
			if(myCh->ChAttribute.chNo_master != P0) {
				if(myCh->op.code == C_FAULT_UPPER_CH_TEMP ||
					myCh->op.code == C_PAUSE_UPPER_TEMP_CH) {
					if(myPs->testCond[bd][ch].step[advStepNo].
							faultUpperTemp_restart != 0) {
						if(myPs->testCond[bd][ch].step[advStepNo].
							faultUpperTemp_restart >= myCh->op.temp) {
							myCh->misc.errCnt[C_CNT_UPPER_TEMP]++;
							if(myCh->misc.errCnt[C_CNT_UPPER_TEMP]>= 
											MAX_ERROR_CNT*4){
								//111215 kji w
								if(myCh->ChAttribute.opType == P1) {
								    myData->bData[bd].cData[ch+1].
								        misc.errCnt[C_CNT_UPPER_TEMP] = 0;
								    myData->bData[bd].cData[ch+1].
								        signal[C_SIG_CONTINUE] = P1;
								}
								myCh->misc.errCnt[C_CNT_UPPER_TEMP] = 0;
								myCh->signal[C_SIG_CONTINUE] = P1;
							}
						}
					}
				} else if(myCh->op.code == C_FAULT_LOWER_CH_TEMP ||
							myCh->op.code == C_PAUSE_LOWER_TEMP_CH) {
					if(myPs->testCond[bd][ch].step[advStepNo].
							faultLowerTemp_restart != 0) {
						if(myPs->testCond[bd][ch].step[advStepNo].
							faultLowerTemp_restart <= myCh->op.temp) {
							myCh->misc.errCnt[C_CNT_LOWER_TEMP]++;
							if(myCh->misc.errCnt[C_CNT_LOWER_TEMP]>= 
											MAX_ERROR_CNT*4){
								//111215 kji w
								if(myCh->ChAttribute.opType == P1) {
								    myData->bData[bd].cData[ch+1].
								    	misc.errCnt[C_CNT_UPPER_TEMP] = 0;
								    myData->bData[bd].cData[ch+1].
										signal[C_SIG_CONTINUE] = P1;
								}
								myCh->misc.errCnt[C_CNT_LOWER_TEMP] = 0;
								myCh->signal[C_SIG_CONTINUE] = P1;
							}
						}
					}
				}
			}
			//220322_hun
			if(myData->mData.config.swFaultConfig[HARD_VENTING_VALUE] != 0){
				if(myCh->misc.std_gasVoltage >= myData->mData.config.swFaultConfig[HARD_VENTING_VALUE]){
					myCh->op.code = C_FAULT_HARD_VENTING;
				}
			}
			//220104 hun 
			//일시정지 중 Ambient온도 이상일 경우 채널 Code 변경
			if(myData->mData.config.swFaultConfig[AMBIENT_TEMP_MAX] != 0){
				if(myCh->misc.ambientTemp > myData->mData.config.swFaultConfig[AMBIENT_TEMP_MAX]){
					if(myCh->misc.ambient_check_flag == 0){
						myCh->misc.ambient_check_time = myCh->op.runTime;
						myCh->misc.ambient_check_flag = 1;
					}else if(myCh->misc.ambient_check_flag == 1){
						myCh->misc.ambient_check_time += myPs->misc.rt_scan_time;
						if(labs(myCh->misc.ambient_check_time - myCh->op.runTime) >
							myData->mData.config.swFaultConfig[AMBIENT_TEMP_MAX_TIME] * 100){
							myCh->op.code = C_FAULT_AMBIENT_TEMP_MAX;
						}
					}
				}else if(myCh->misc.ambientTemp < myData->mData.config.swFaultConfig[AMBIENT_TEMP_MAX]){
					myCh->misc.ambient_check_flag = 0;
					myCh->misc.ambient_check_time = myCh->op.runTime;
				}
			}

			//210114 add / 190901 lyhw	
			if(myData->mData.config.function[F_PAUSE_DATA_SAVE] == P1){
				pauseSaveDt = myData->DataSave.config.pause_data_time;
				if(pauseSaveDt != 0 
					&& myCh->op.code != C_FAULT_PAUSE_CMD
					&& myCh->op.code != C_PAUSE_UPPER_TEMP_CH
					&& myCh->op.code != C_PAUSE_LOWER_TEMP_CH){
					myCh->misc.pauseRunTime += myPs->misc.rt_scan_time; 
					if(myCh->misc.pauseRunTime % pauseSaveDt == 0){
						myCh->misc.pauseRunTime = 0;
						if(myCh->ChAttribute.opType == P0) {
							myCh->op.select = SAVE_FLAG_SAVING_PAUSE;
							if(myCh->ChAttribute.chNo_master == 0){
								myData->bData[bd].cData[ch-1].op.select 
									= myCh->op.select;
							}
							send_save_msg(bd, ch, saveDt, 0);
						}
					}
				}
			}
			
			//211209 hun	
			if(myData->mData.config.sdi_pause_save_flag == P1){
				pauseSaveEndT = myData->mData.config.SDI_pause_save.pause_end_time * 100;
				pauseSaveDt = myData->mData.config.SDI_pause_save.pause_period_time * 100;
				if(pauseSaveDt != 0 && pauseSaveEndT != 0
					&& myCh->op.code != C_FAULT_PAUSE_CMD ){
					myCh->misc.pauseRunTime += myPs->misc.rt_scan_time;
					if(myCh->misc.pauseRunTime <= pauseSaveEndT){
						if(myCh->misc.pauseRunTime % pauseSaveDt == 0){
							if(myCh->ChAttribute.opType == P0) {
								myCh->op.select = SAVE_FLAG_SAVING_TIME;
								if(myCh->ChAttribute.chNo_master == 0){
									myData->bData[bd].cData[ch-1].op.select 
									= myCh->op.select;
								}
								send_save_msg(bd, ch, saveDt, 0);
							}
						}
					}
				}
			}


			if(myCh->signal[C_SIG_STOP] == P1) {
				myCh->misc.pauseRunTime = 0;
				myCh->signal[C_SIG_STOP] = P0;
				if(myCh->op.code == C_FAULT_PAUSE_CMD
					&& myCh->opSave.code != C_FAULT_PAUSE_CMD) {
				} else {
					myCh->op.select = SAVE_FLAG_SAVING_END;
				}
				//190318 add
				if(myData->mData.config.parallelMode == P2){
					cCycle_p_ch_check(bd, ch);
				}
				myCh->op.code = C_FAULT_STOP_CMD;				
				myCh->op.state = C_STANDBY;
				myCh->op.phase = P0;
				
			} else if(myCh->signal[C_SIG_PAUSE] == P1) {
				myCh->misc.pauseRunTime = 0;
				myCh->signal[C_SIG_PAUSE] = P0;
				myCh->signal[C_SIG_RANGE_SWITCH] = P0;
				myCh->signal[C_SIG_OUT_SWITCH] = P0;
				myCh->signal[C_SIG_I_RANGE] = P0;	//151105 oys w
			} else if(myCh->signal[C_SIG_CONTINUE] == P1) {
				//211209 hun	
				if(myData->mData.config.sdi_pause_save_flag == P1){
					if(myCh->ChAttribute.opType == P0) {
						myCh->op.select = SAVE_FLAG_SAVING_TIME;
						if(myCh->ChAttribute.chNo_master == 0){
							myData->bData[bd].cData[ch-1].op.select 
							= myCh->op.select;
						}
						send_save_msg(bd, ch, saveDt, 0);
					}
				}

				myCh->misc.std_gasVoltage = myCh->misc.gasVoltage;	//220322_hun
				myCh->misc.pauseRunTime = 0;
				myCh->misc.pre_v_chk_time = myCh->op.runTime;	//kjc_200426
				myCh->misc.pre_chk_v = myCh->op.Vsens;			//kjc_200426
				//hun_211125
				if(myCh->op.type == STEP_CHARGE){
					myCh->misc.charge_cc_hump_flag = P0;
					myCh->misc.charge_cv_hump_flag = P0;
					myCh->misc.charge_cc_hump_start_time = myCh->misc.ccTime;
					myCh->misc.charge_cv_hump_start_time = myCh->misc.cvTime;
				}else if(myCh->op.type == STEP_DISCHARGE){
					myCh->misc.discharge_cc_hump_flag = P0;
					myCh->misc.discharge_cv_hump_flag = P0;
					myCh->misc.discharge_cc_hump_start_time = myCh->misc.ccTime;
					myCh->misc.discharge_cv_hump_start_time = myCh->misc.cvTime;
				}
				if(myCh->op.type == STEP_CHARGE){
					if(myCh->ChAttribute.opType == P0) {
						myCh->misc.Drop_maxV = myCh->op.Vsens;	//210916 LJS
					}else if(myCh->ChAttribute.chNo_master == 0){
						myCh->misc.Drop_maxV 
							= myData->bData[bd].cData[ch-1].op.Vsens;
					}
				}else if(myCh->op.type == STEP_DISCHARGE){
					if(myCh->ChAttribute.opType == P0) {
						myCh->misc.Drop_minV = myCh->op.Vsens;	//210916 LJS
					}else if(myCh->ChAttribute.chNo_master == 0){
						myCh->misc.Drop_minV 
							= myData->bData[bd].cData[ch-1].op.Vsens;
					}
				}
				#ifdef _SDI_SAFETY_V1	
				myCh->misc.fault_deltaV = myCh->op.Vsens;		//hun_200430
				#endif
				#ifdef _SDI_SAFETY_V2	
				myCh->misc.Master_recipe_deltaV = 0;	//ljs 210412
				#endif
				myCh->op.changeV_Dt_cnt = 0;	//hun_200430
				myCh->signal[C_SIG_CONTINUE] = P0;
				if(myCh->misc.parallel_cycle_phase == P2
					|| myCh->misc.parallel_cycle_phase == P12) { //kjg_180530
				} else {
					cSemiSwitch_Start(bd,ch,type);
				}

				#ifdef _JIG_TYPE_1 //120206 kji
				if(myPs->config.hwSpec == L_5V_200A_1CH_JIG) {
					if(myData->dio.signal[DIO_SIG_JIG_RIGHT_UPPER] == P1) {
						myPs->code = M_FAIL_JIG_RIGHT_UPPER;
						send_msg(MODULE_TO_MAIN, MSG_MODULE_MAIN_EMG_STATUS,
								(int)myPs->code, 0);
						myPs->signal[M_SIG_JIG_BUZZER]  = P1;
						return;
					}else if(myData->dio.signal[DIO_SIG_JIG_LEFT_UPPER] == P1) {
						myPs->code = M_FAIL_JIG_LEFT_UPPER;
						send_msg(MODULE_TO_MAIN, MSG_MODULE_MAIN_EMG_STATUS,
								(int)myPs->code, 0);
						myPs->signal[M_SIG_JIG_BUZZER]  = P1;
						return;
					}else if(myData->dio.signal[DIO_SIG_JIG_LIMIT] == P1) {
						myPs->code = M_FAIL_JIG_LIMIT_ERROR;
						send_msg(MODULE_TO_MAIN, MSG_MODULE_MAIN_EMG_STATUS,
								(int)myPs->code, 0);
						myPs->signal[M_SIG_JIG_BUZZER]  = P1;
						return;
					} else {
						myPs->signal[M_SIG_JIG_SOL] = P1;
					}
				}
				#endif

				if(myCh->op.code == C_FAULT_PAUSE_CMD
					&& myCh->opSave.code != C_FAULT_PAUSE_CMD) {
					if(myCh->misc.parallel_cycle_phase == P2
						|| myCh->misc.parallel_cycle_phase == P12) {
						//kjg_180530
					} else {
						if(myPs->config.hwSpec < S_5V_200A) { //linear
							myCh->signal[C_SIG_RANGE_SWITCH] = P1;
							myCh->signal[C_SIG_OUT_SWITCH] = P1;
							if(myCh->ChAttribute.opType == P1) {
								myCh->signal[C_SIG_PARALLEL_SWITCH] = P1;
							}
						}
					}

	       			myCh->op.checkDelayTime = 0;
					myCh->op.phase = P6;
				} else if(myCh->op.code == C_FAULT_USER_PATTERN_READ) {
					if(myCh->misc.parallel_cycle_phase == P2
						|| myCh->misc.parallel_cycle_phase == P12) {
						//kjg_180530
					} else {
						if(myPs->config.hwSpec < S_5V_200A) { //linear
							if(myCh->op.type == STEP_REST) {
								myCh->signal[C_SIG_OUT_SWITCH] = P0;
								if(myCh->ChAttribute.opType == P1) {
									myCh->signal[C_SIG_PARALLEL_SWITCH] = P1;
								}
							} else {
								myCh->signal[C_SIG_RANGE_SWITCH] = P1;
								myCh->signal[C_SIG_OUT_SWITCH] = P1;
								if(myCh->ChAttribute.opType == P1) {
									myCh->signal[C_SIG_PARALLEL_SWITCH] = P1;
								}
							}
						}
					}

	       			myCh->op.checkDelayTime = 0;
					myCh->op.phase = P3;
				} else {
					if(myCh->misc.parallel_cycle_phase == P2
						|| myCh->misc.parallel_cycle_phase == P12) {
						//kjg_180530
					} else {
						if(myPs->config.hwSpec < S_5V_200A) { //linear
							//140407 oys modify
							if(myCh->op.type == STEP_REST
								|| myCh->op.type == STEP_SHORT) {
								myCh->signal[C_SIG_OUT_SWITCH] = P0;
								if(myCh->ChAttribute.opType == P1) {
									myCh->signal[C_SIG_PARALLEL_SWITCH] = P1;
								}
							} else {
								myCh->signal[C_SIG_RANGE_SWITCH] = P1;
								myCh->signal[C_SIG_OUT_SWITCH] = P1;
								if(myCh->ChAttribute.opType == P1) {
									myCh->signal[C_SIG_PARALLEL_SWITCH] = P1;
								}
							}
						}
					}

	       			myCh->op.checkDelayTime = 0;
					myCh->misc.restFaultCount = 0;  //LJS 210521
					myCh->misc.fbCountV_H = 0;
					myCh->misc.fbCountI_H = 0;
					myCh->misc.fbSumI_H = 0;
					myCh->misc.fbSumV_H = 0;
					myCh->misc.fbCountV_L = 0;
					myCh->misc.fbCountI_L = 0;
					myCh->misc.fbSumI_L = 0;
					myCh->misc.fbSumV_L = 0;
					myCh->misc.fbCountV_M = 0;
					myCh->misc.fbCountI_M = 0;
					myCh->misc.fbSumI_M = 0;
					myCh->misc.fbSumV_M = 0;
					myCh->misc.sensCount = 0;
					myCh->misc.sensCountFlag = P0;
					myCh->misc.sensBufCount = 0;
					myCh->misc.sensBufCountFlag = P0;
					myCh->misc.fbV = 0;
					myCh->misc.fbI = 0;
					myCh->misc.feedback_start = P0;
					myCh->op.phase = P4;
				}

				if(myCh->misc.parallel_cycle_phase == P2
					|| myCh->misc.parallel_cycle_phase == P12) {
					//kjg_180530
				} else {
					if(myCh->op.type == STEP_USER_PATTERN) {
						if(myCh->op.code != C_FAULT_USER_PATTERN_READ) {
							cSemiSwitch_Pattern(bd, ch, 0);
							i = myCh->misc.userPatternCnt;
							if(myData->mData.testCond[bd][ch].userPattern
								.data[i].data > 0) {
								myCh->misc.cmdV_dir = CMD_V_PLUS;
							} else {
								myCh->misc.cmdV_dir = CMD_V_MINUS;
							}
						}
					}
				}

				myCh->ccv[0].avg_v = myCh->misc.tmpVsens;
				myCh->ccv[0].avg_i = myCh->misc.tmpIsens;
			} else if(myCh->signal[C_SIG_NEXTSTEP] == P1) {
				myCh->misc.pauseRunTime = 0;
				myCh->signal[C_SIG_NEXTSTEP] = P0;

				if(myCh->misc.parallel_cycle_phase == P2 //kjg_180524
					|| myCh->misc.parallel_cycle_phase == P12) break; //kjg_180530

				//120206 kji
				#ifdef _JIG_TYPE_1
				if(myPs->config.hwSpec == L_5V_200A_1CH_JIG) {
					if(myData->dio.signal[DIO_SIG_JIG_RIGHT_UPPER] == P1) {
						myPs->code = M_FAIL_JIG_RIGHT_UPPER;
						send_msg(MODULE_TO_MAIN, MSG_MODULE_MAIN_EMG_STATUS,
								(int)myPs->code, 0);
						myPs->signal[M_SIG_JIG_BUZZER]  = P1;
						return;
					}else if(myData->dio.signal[DIO_SIG_JIG_LEFT_UPPER] == P1) {
						myPs->code = M_FAIL_JIG_LEFT_UPPER;
						send_msg(MODULE_TO_MAIN, MSG_MODULE_MAIN_EMG_STATUS,
								(int)myPs->code, 0);
						myPs->signal[M_SIG_JIG_BUZZER]  = P1;
						return;
					}else if(myData->dio.signal[DIO_SIG_JIG_LIMIT] == P1) {
						myPs->code = M_FAIL_JIG_LIMIT_ERROR;
						send_msg(MODULE_TO_MAIN, MSG_MODULE_MAIN_EMG_STATUS,
								(int)myPs->code, 0);
						myPs->signal[M_SIG_JIG_BUZZER]  = P1;
						return;
					} else {
						myPs->signal[M_SIG_JIG_SOL] = P1;
					}
				}
				#endif

				if(myPs->config.hwSpec < S_5V_200A) { //linear
					myCh->signal[C_SIG_OUT_SWITCH] = P1;
					if(myCh->ChAttribute.opType == P1) {
						myCh->signal[C_SIG_PARALLEL_SWITCH] = P1;
					}
				}
				myCh->op.checkDelayTime = 0;
				myCh->misc.saveDt = myCh->op.runTime;
				if(myCh->op.code == C_FAULT_PAUSE_CMD
					&& myCh->opSave.code != C_FAULT_PAUSE_CMD) {
				} else {
					myCh->op.code = C_FAULT_NEXTSTEP_CMD;
					//121205 oys add
					if(myCh->op.type != STEP_LOOP) {
						myCh->op.select = SAVE_FLAG_SAVING_END;
						if(myCh->ChAttribute.opType == P0) {
							if(myCh->ChAttribute.chNo_master == 0){
								myData->bData[bd].cData[ch-1].op.select
									= myCh->op.select;
							}
							send_save_msg(bd, ch, saveDt, 0);
						}
					}
				}

				//141030 oys add : loop step -> next step cmd process	
				if(type == STEP_LOOP) {
					myCh->op.phase = P4;
				} else {
					myCh->op.phase = P5;
				}
			}
			break;
		case P3:
			myCh->op.checkDelayTime += myPs->misc.rt_scan_time;
			if(myCh->op.checkDelayTime >= 100) {
				myCh->op.checkDelayTime = 0;
				myCh->op.state = myCh->misc.tmpState;
				myCh->op.code = myCh->misc.tmpCode;
				if(myCh->misc.parallel_cycle_phase == P2 //kjg_180524
					|| myCh->misc.parallel_cycle_phase == P12) { //kjg_180530
					myCh->op.phase = P5;
				} else {
					myCh->op.phase = P0;
				}
			}
			break;
		case P4:
			myCh->op.checkDelayTime += myPs->misc.rt_scan_time;
			if(myCh->op.checkDelayTime >= 200) {
				myCh->op.checkDelayTime = 0;
				myCh->op.state = myCh->misc.tmpState;
				myCh->op.code = myCh->misc.tmpCode;
				//myCh->signal[C_SIG_TRIGGER] = P1;
				if(myCh->op.type == STEP_USER_PATTERN) {
					cSemiSwitch_Pattern(bd, ch, 1);
				}
				if(myCh->misc.waitFlag == P1) //pause waitFlag
				{
					myCh->misc.waitFlag = P0;
					myCh->op.phase = P0;
				}
				if(myCh->misc.chamberWaitFlag == -1) {
					myCh->misc.chamberWaitFlag = P0;
					myCh->op.phase = P0;
				} else {
					if(myCh->misc.parallel_cycle_phase == P2 //kjg_180524
						|| myCh->misc.parallel_cycle_phase == P12) {//kjg_180530
						myCh->op.phase = P5;
					} else {
						myCh->op.phase = P10;
					}
				}
			}
			break;
		case P5:
			myCh->op.checkDelayTime += myPs->misc.rt_scan_time;
			if(myCh->op.checkDelayTime >= 200) {
				//170728 oys add
				myCh->misc.gradeProcFlag = P0;
				myCh->op.runTime = 0;
				//end add
				myCh->op.checkDelayTime = 0;
				myCh->op.state = C_RUN;
				myCh->op.phase = P0;
				myCh->misc.advStepNo++;
				advStepNo = myCh->misc.advStepNo;
				myCh->op.type = myPs->testCond[bd][ch].step[advStepNo].type;
				myCh->op.mode = myPs->testCond[bd][ch].step[advStepNo].mode;
				myCh->op.stepNo = myPs->testCond[bd][ch].step[advStepNo].stepNo;
			}
			break;
		case P6:
			myCh->op.checkDelayTime += myPs->misc.rt_scan_time;
			if(myCh->op.checkDelayTime >= 200) {
				myCh->op.state = myCh->misc.tmpState;
				myCh->op.code = myCh->misc.tmpCode;
				myCh->misc.advStepNo++;
				advStepNo = myCh->misc.advStepNo;
				myCh->op.type = myPs->testCond[bd][ch].step[advStepNo].type;
				myCh->op.mode = myPs->testCond[bd][ch].step[advStepNo].mode;
				myCh->op.stepNo
					= myPs->testCond[bd][ch].step[advStepNo].stepNo;
				//myCh->signal[C_SIG_TRIGGER] = P1;
				myCh->op.checkDelayTime = 0;
				myCh->op.phase = P0;
			}
			break;
		case P7:
			break;
		default: break;
	}
}

S_CH_STEP_INFO step_info(int bd, int ch)
{
	unsigned char rangeV, rangeI, type, mode;
	long refV=0, refI=0, refP=0, refTemp, endV=0, refCpI=0, tmpV=0, cvtVal=0;
//170501 oys add : CP Mode current auto derating
#if VENDER == 3
	long limitI = 0, limitI_H = 0, limitI_L = 0;
#endif
	unsigned long advStepNo, saveDt;
	double tmp1, tmp2, tmp3, tmp4;
	float para = 0.0;

#ifdef _TRACKING_MODE
	long refI_SOC = 0;
	long refI_SOH = 0; //211022
#endif
#ifdef _EQUATION_CURRENT	//211111
	long refI_EQU = 0;
#endif

	S_CH_STEP_INFO step;

	myCh = &(myData->bData[bd].cData[ch]);

	memset((char *)&step, 0, sizeof(S_CH_STEP_INFO));

    advStepNo = myCh->misc.advStepNo;
	rangeV = myPs->testCond[bd][ch].step[advStepNo].rangeV;
	rangeI = myPs->testCond[bd][ch].step[advStepNo].rangeI;
	if(myCh->misc.parallel_cycle_phase == P50) rangeI = RANGE1 - 1; //kjg_180530

	saveDt = (myPs->testCond[bd][ch].step[advStepNo].saveDt / 100) * 100;
	type = myPs->testCond[bd][ch].step[advStepNo].type;
	mode = myPs->testCond[bd][ch].step[advStepNo].mode;
	refTemp = myPs->testCond[bd][ch].step[advStepNo].refTemp;
	endV = myPs->testCond[bd][ch].step[advStepNo].endV;

#if VENDER == 3 //170501 oys add : CP Mode current auto derating
	limitI = myPs->testCond[bd][ch].step[advStepNo].refV_L;
	limitI_H = myPs->testCond[bd][ch].step[advStepNo].refI_H;
	limitI_L = myPs->testCond[bd][ch].step[advStepNo].refI_L;
#endif

	myCh->op.rangeV = rangeV;
	myCh->op.rangeI = rangeI;

	tmp1 = tmp2 = tmp3 = tmp4 = 0;
	
#if CYCLER_TYPE == LINEAR_CYC || CYCLER_TYPE == CAN_CYC
	para =1.0;
#else
	if(myCh->ChAttribute.opType == P0){	//180611 add 
		para = 1.0;
	}else{
		para = 2.0;
	}	
#endif
	

	switch(mode) {
		case CC:
		case CV:
		case CCCV:
		case DC:
		case C_RATE:
			refV = myPs->testCond[bd][ch].step[advStepNo].refV;
			if(refV > myPs->config.maxVoltage[rangeV]) {
				if(type != STEP_USER_PATTERN) {
					refV = myPs->config.maxVoltage[rangeV];
				}
			} else if(refV <= 0) {
				switch(type) {
					case STEP_Z:
					case STEP_DISCHARGE:
						if(myPs->config.capacityType == CAPACITY_CAPACITANCE) {
							switch(mode) {
								case CC:
								case DC:
									if(refV == 0) refV = -1000000; //-1000mV
									break;
								default:
									break;
							}
						}
						break;
					default:
						break;
				}
			}

			if(type != STEP_USER_PATTERN
				&& type != STEP_USER_MAP) {
				refI = myPs->testCond[bd][ch].step[advStepNo].refI;
				cvtVal = Convert_C_rate_to_I_value(bd, ch, refI);
				if(cvtVal != 0)
					refI = cvtVal;
			} else {
				refI = myPs->testCond[bd][ch].step[advStepNo].refI;
			}
#ifdef _TRACKING_MODE
			if(type == STEP_CHARGE){ //CHARGE CC MODE
				if(myPs->testCond[bd][ch].step[advStepNo].SOC_Tracking_flag == P1){ 
					if(myPs->testCond[bd][ch].step[advStepNo].trackingMode_flag == P1){ //210720
						refI_SOC = cFind_SOV_Tracking_Current(bd, ch); //SOV
					}else{
						refI_SOC = cFind_SOC_Tracking_Current(bd, ch); //SOC
					}
					if(refI_SOC != 0)
						refI = refI_SOC;
				}else if(myPs->testCond[bd][ch].step[advStepNo].SOH_Tracking_flag == P1){
					refI_SOH = cFind_SOH_Tracking_Current(bd, ch); //SOH
				}
			}else if(type == STEP_DISCHARGE){ //DISCHARGE CC MODE
				if(myPs->testCond[bd][ch].step[advStepNo].SOH_Tracking_flag == P1){ //SOH
					refI_SOH = cFind_SOH_Tracking_Current(bd, ch);
				}
			}
#endif		
#ifdef _EQUATION_CURRENT	//211111
			if(type == STEP_CHARGE){
				if(myPs->testCond[bd][ch].step[advStepNo].equation_current_flag == P1){
					refI_EQU = cFind_equation_current(bd, ch);
					if(refI_EQU != 0)
						refI = refI_EQU;
				}
			}
#endif					
			switch(type) {						
				case STEP_USER_MAP: //140925 oys add : current userMap
					if(refI > 0) {
						if(refI <= myData->mData.config.maxCurrent[3]) {
							rangeI = RANGE4 - 1;
						} else if(refI <= myData->mData.config.maxCurrent[2]) {
							rangeI = RANGE3 - 1;
						} else if(refI <= myData->mData.config.maxCurrent[1]) {
							rangeI = RANGE2 - 1;
						} else {
							rangeI = RANGE1 - 1;
						}
					} else {
						if(refI >= myData->mData.config.minCurrent[3]) {
							rangeI = RANGE4 - 1;
						} else if(refI >= myData->mData.config.minCurrent[2]) {
							rangeI = RANGE3 - 1;
						} else if(refI >= myData->mData.config.minCurrent[1]) {
							rangeI = RANGE2 - 1;
						} else {
							rangeI = RANGE1 - 1;
						}
					}
					if(myCh->misc.parallel_cycle_phase == P50) { //kjg_180530
						rangeI = RANGE1 - 1;
					}
					myCh->op.rangeI = rangeI;
					myCh->signal[C_SIG_I_RANGE] = rangeI + 1;
					break;
				case STEP_USER_PATTERN: //110411 kji pattern cv add
					if(labs(refI) > myPs->config.maxCurrent[0]*para) {
						if(refI > 0) {
							refI = myPs->config.maxCurrent[0]*para;
						} else if(refI < 0) {
							refI = myPs->config.minCurrent[0]*para;
						}
					}

					//20180410 add for pattern limit refV
					if(refI > 0) {
						if(myPs->testCond[bd][ch].step[advStepNo].refV_H != 0) {
							if(myPs->testCond[bd][ch].step[advStepNo].refV_H
								> myPs->config.maxVoltage[0]) {
								refV = myPs->config.maxVoltage[0];
							} else {
								refV = myPs->testCond[bd][ch].step[advStepNo]
									.refV_H;
							}
						}else{ //181227 add
							refV = myPs->config.maxVoltage[0];
						}
					} else if(refI < 0) {
						if(myPs->testCond[bd][ch].step[advStepNo].refV_L != 0) {
							if(myPs->testCond[bd][ch].step[advStepNo].refV_L
								< myPs->config.minVoltage[0]) {
								refV = myPs->config.minVoltage[0];
							} else {
								refV = myPs->testCond[bd][ch].step[advStepNo]
									.refV_L;
							}
						}
					}
					break;
				case STEP_CHARGE:
					if(refI > myPs->config.maxCurrent[rangeI]*para) {
						refI = myPs->config.maxCurrent[rangeI]*para;
					} else if(refI < 0) refI = 0L;
					break;
				case STEP_DISCHARGE:
				case STEP_Z:
					if(refI < myPs->config.minCurrent[rangeI]) {
						refI = myPs->config.minCurrent[rangeI];
					} else if(refI > 0) refI = 0L;
					break;
				default:
					break;
			}
			break;
		case CP:
			tmp1 = ((myPs->config.maxVoltage[rangeV] / 1000.0)
				* (myPs->config.maxCurrent[rangeI] / 1000.0)) / 1000.0;
			refP = myPs->testCond[bd][ch].step[advStepNo].refP;
			refV = myPs->testCond[bd][ch].step[advStepNo].refV;
			if(refV > myPs->config.maxVoltage[rangeV]) {
				if(type != STEP_USER_PATTERN) {
					refV = myPs->config.maxVoltage[rangeV];
				}
			} else if(refV < 0) {
				if(type != STEP_USER_PATTERN) refV = 0L;
			}
#ifdef _TRACKING_MODE
			if(type == STEP_CHARGE){ //CHARGE CP MODE
				if(myPs->testCond[bd][ch].step[advStepNo].SOC_Tracking_flag == P1){
					if(myPs->testCond[bd][ch].step[advStepNo].trackingMode_flag == P1){ //210720
						refI_SOC = cFind_SOV_Tracking_Current(bd, ch); //SOV
					}else{
						refI_SOC = cFind_SOC_Tracking_Current(bd, ch); //SOC
					}
					if(refI_SOC != 0)
						refP = refI_SOC / 1000;
				}else if(myPs->testCond[bd][ch].step[advStepNo].SOH_Tracking_flag == P1){
					refI_SOH = cFind_SOH_Tracking_Current(bd, ch); //SOH
				}
			}else if(type == STEP_DISCHARGE){ //DISCHARGE CP MODE
				if(myPs->testCond[bd][ch].step[advStepNo].SOH_Tracking_flag == P1){ 
					refI_SOH = cFind_SOH_Tracking_Current(bd, ch); //SOH
				}
			}
#endif	
#ifdef _EQUATION_CURRENT	//211111
			if(type == STEP_CHARGE){
				if(myPs->testCond[bd][ch].step[advStepNo].equation_current_flag == P1){
					refI_EQU = cFind_equation_current(bd, ch);
					if(refI_EQU != 0)
						refP = refI_EQU; //211116
				}
			}
#endif						
			switch(type) {
				case STEP_CHARGE:
				case STEP_DISCHARGE:
				case STEP_Z:
					if(refP > (long)tmp1) refP = (long)tmp1;
					break;
				case STEP_USER_PATTERN:
					if(refP > tmp1) {
					 	refP = (long)tmp1;
					} else if(refP < (-tmp1)) {
					   	refP = (long)(-tmp1);
					}
					break;
				default:
					break;
			}
			tmp1 = (double)refP;
			tmp1 /= (double)myCh->misc.tmpVsens;
			tmp1 *= 1000000000.0;
		
			switch(type) {
				case STEP_CHARGE:
					//20190725
					if(refV == 0) {
						refV = myPs->config.maxVoltage[rangeV];
					}
					refI = (long)tmp1;

#if VENDER == 3 //170501 oys add : CP Mode current auto derating
					if(limitI != 0) {
						if(refI > limitI) refI = limitI;
					}
#endif

					//cp range select
					if(myCh->op.phase == P0) {	
						myCh->misc.tmpCpVsens = myCh->misc.tmpVsens;
						if(refI <= myData->mData.config.maxCurrent[3]*para) {
							rangeI = RANGE4 - 1;
						} else if(refI <= myData->mData.config.maxCurrent[2]*para) {
							rangeI = RANGE3 - 1;
						} else if(refI <= myData->mData.config.maxCurrent[1]*para) {
							rangeI = RANGE2 - 1;
						} else {
							rangeI = RANGE1 - 1;
						}
					} else {
						tmp1 = (double)refP;
						tmp1 /= (double)myCh->misc.tmpCpVsens;
						tmp1 *= 1000000000.0;
						refCpI = (long)tmp1;

#if VENDER == 3 //170501 oys add : CP Mode current auto derating
					if(limitI != 0) {
						if(refCpI > limitI) refCpI = limitI;
					}
#endif
						if(refCpI <= myData->mData.config.maxCurrent[3]*para) {
							rangeI = RANGE4 - 1;
						} else if(refCpI <= myData->mData.config.maxCurrent[2]*para) {
							rangeI = RANGE3 - 1;
						} else if(refCpI <= myData->mData.config.maxCurrent[1]*para) {
							rangeI = RANGE2 - 1;
						} else {
							rangeI = RANGE1 - 1;
						}
					}
					if(myCh->misc.parallel_cycle_phase == P50) { //kjg_180530
						rangeI = RANGE1 - 1;
					}
#ifdef _TRACKING_MODE
					if(myPs->testCond[bd][ch].step[advStepNo].
									SOC_Tracking_flag == P1){
						rangeI = myPs->testCond[bd][ch].step[advStepNo].rangeI;
					}
#endif
#ifdef _EQUATION_CURRENT	//211111
					if(myPs->testCond[bd][ch].step[advStepNo].
									equation_current_flag == P1){
						rangeI = myPs->testCond[bd][ch].step[advStepNo].rangeI;
					}
#endif
					myCh->op.rangeI = rangeI;
					if(refI > myPs->config.maxCurrent[rangeI]*para) {
						refI = myPs->config.maxCurrent[rangeI]*para;
					} else if(refI < 0) refI = 0L;
					if(refI > myPs->testCond[bd][ch].step[advStepNo].refI) {
						refI = myPs->testCond[bd][ch].step[advStepNo].refI;
					}
					break;
				case STEP_DISCHARGE:
				case STEP_Z:
					refI = (long)(-tmp1);

#if VENDER == 3 //170501 oys add : CP Mode current auto derating
					if(limitI != 0) {
						if(refI < limitI) refI = limitI;
					}
#endif

					//cp range select
					if(endV != 0 || refV != 0 ) {
						if(endV > refV) tmpV = endV;
						else tmpV = refV;
						tmp1 = (double)refP;
						tmp1 /= (double)tmpV;
						tmp1 *= 1000000000.0;
						refCpI = (long)(-tmp1);

#if VENDER == 3 //170501 oys add : CP Mode current auto derating
						if(limitI != 0) {
							if(refCpI < limitI) refCpI = limitI;
						}
#endif

						if(refCpI >= myData->mData.config.minCurrent[3]) {
							rangeI = RANGE4 - 1;
						} else if(refCpI >= myData->mData.config.minCurrent[2]){
							rangeI = RANGE3 - 1;
						} else if(refCpI >= myData->mData.config.minCurrent[1]){
							rangeI = RANGE2 - 1;
						} else {
							rangeI = RANGE1 - 1;
						}
						if(myCh->misc.parallel_cycle_phase == P50) {
							//kjg_180530
							rangeI = RANGE1 - 1;
						}
						myCh->op.rangeI = rangeI;
					}

					if(refI < myPs->config.minCurrent[rangeI]*para) {
						refI = myPs->config.minCurrent[rangeI]*para;
					} else if(refI > 0) refI = 0L;
					if(refI < myPs->testCond[bd][ch].step[advStepNo].refI) {
						refI = myPs->testCond[bd][ch].step[advStepNo].refI;
					}
					break;
				case STEP_USER_PATTERN:
					refI = (long)tmp1;

#if VENDER == 3 //170501 oys add : CP Mode current auto derating
					if(refI > 0) {
						if(limitI_H != 0) {
							if(refI	> limitI_H) refI = limitI_H;
						}
					} else {
						if(limitI_L != 0) {
							if(refI	< limitI_L) refI = limitI_L;
						}
					}	
#endif

					if(labs(refI) > myPs->config.maxCurrent[0]) {
						if(refI > 0) {
							refI = myPs->config.maxCurrent[0];
						} else if(refI < 0) {
							refI = myPs->config.minCurrent[0];
						}
					}
					//110411 kji pattern cv add
					
					//20180410 add for pattern limit refV
					if(refI > 0) {
						if(myPs->testCond[bd][ch].step[advStepNo].refV_H != 0) {
							if(myPs->testCond[bd][ch].step[advStepNo].refV_H
								> myPs->config.maxVoltage[0]) {
								refV = myPs->config.maxVoltage[0];
							} else {
								refV = myPs->testCond[bd][ch].step[advStepNo]
									.refV_H;
							}
						}else{ //20181227 add
							refV = myPs->config.maxVoltage[0];
						}
					} else if(refI < 0) {
						if(myPs->testCond[bd][ch].step[advStepNo].refV_L != 0) {
							if(myPs->testCond[bd][ch].step[advStepNo].refV_L
								< myPs->config.minVoltage[0]) {
								refV = myPs->config.minVoltage[0];
							} else {
								refV = myPs->testCond[bd][ch].step[advStepNo]
									.refV_L;
							}
						}
					}
					break;
				case STEP_USER_MAP: //111215 kji add
					refI = (long)tmp1;

#if VENDER == 3 //170501 oys add : CP Mode current auto derating
					if(refI > 0) {
						if(limitI_H != 0) {
							if(refI	> limitI_H) refI = limitI_H;
						}
					} else {
						if(limitI_L != 0) {
							if(refI	< limitI_L) refI = limitI_L;
						}
					}	
#endif

					if(labs(refI) > myPs->config.maxCurrent[0]) {
						if(refI > 0) {
							refI = myPs->config.maxCurrent[0];
						} else if(refI < 0) {
							refI = myPs->config.minCurrent[0];
						}
					}
					break;
				default:
					break;
			}

			if(myData->bData[bd].cData[ch].op.state == C_RUN
				&& myData->bData[bd].cData[ch].op.phase == P50) { //kjg_180530
				if(myData->bData[bd].cData[ch].misc.parallel_cycle_phase
					== P50) {
					myData->bData[bd].cData[ch].misc.parallel_val2 = refI;
				}
			}
			break;
		case CR:
			refV = myPs->testCond[bd][ch].step[advStepNo].refV;
			switch(type) {
				case STEP_CHARGE:
					tmp1 = (double)(myCh->misc.tmpVsens)
						/ (double)myPs->testCond[bd][ch].step[advStepNo].refR
						* 1000.0;
					refI = (long)tmp1;
					if(refI > myPs->config.maxCurrent[rangeI])
						refI = myPs->config.maxCurrent[rangeI];
					else if(refI < 0) refI = 0;
					break;
				case STEP_DISCHARGE:
					tmp1 = (double)(myCh->misc.tmpVsens)
						/ (double)myPs->testCond[bd][ch].step[advStepNo].refR
						* 1000.0;
					refI = (long)tmp1 * (-1);
					if(refI < myPs->config.minCurrent[rangeI])
						refI = myPs->config.minCurrent[rangeI];
					else if(refI > 0) refI = 0;
					break;
				default:
					break;
			}

			if(myData->bData[bd].cData[ch].op.state == C_RUN
				&& myData->bData[bd].cData[ch].op.phase == P50) { //kjg_180530
				if(myData->bData[bd].cData[ch].misc.parallel_cycle_phase
					== P50) {
					myData->bData[bd].cData[ch].misc.parallel_val2 = refI;
				}
			}
			break;
		default:
			refV = 0L; refI = 0L; refP = 0L;
			break;
	}
	
	if(myPs->config.hwSpec == L_30V_20A_R1_AD2) {
		if(ch >= 3) {
			if(refI > (long)(myPs->config.maxCurrent[0]/2))
				refI = (long)(myPs->config.maxCurrent[0]/2);
			if(refI < (long)(myPs->config.minCurrent[0]/2))
				refI = (long)(myPs->config.minCurrent[0]/2);
		}
	}
	
	step.advStepNo = advStepNo;
	step.rangeV = rangeV;
	step.rangeI = rangeI;
	step.saveDt = saveDt;
	step.refV = refV;
	step.refI = refI;
	step.refTemp = refTemp;
	step.type = type;
	step.mode = mode;
	step.refP = refP; //191031
	
	if(myPs->config.hwSpec > DC_DIGITAL_SPEC){//180611 
		if(mode == CP || mode == CPCV){
			step.refP = refP;
		}
	}
	
	if(myData->AppControl.config.debugType != P0) { //120112 kji add debugmode 
		myCh->misc.testRefI = refI;
		myCh->misc.testRefV = refV;
	}

	return step;
}

void cStepCharge(int bd, int ch)
{
    int	rtn, rangeI, rangeV, div, parallel_ch, mode;
    long val1, val2, val3, refV, type;
	unsigned long advStepNo, saveDt;
	double tmp1;
#ifdef _TRACKING_MODE
	long maxRefI;
#endif
#ifdef _EQUATION_CURRENT
	long maxRefI_EQU;
#endif
	S_CH_STEP_INFO step;

	myCh = &(myData->bData[bd].cData[ch]);

	step = step_info(bd, ch);

	tmp1 = 0.0;
	div = 5;
	type = step.type;
	val1 = step.refV;
	val2 = step.refI;
	val3 = step.refP;
	rangeI = (int)step.rangeI;
	rangeV = (int)step.rangeV;
	saveDt = step.saveDt;
	advStepNo = step.advStepNo;
	mode = step.mode;

	refV = myPs->config.maxVoltage[rangeV] * 1.8;
	refV = val1;	//110428 kji

	switch(myPs->config.hwSpec) {
		case L_15V_100A_R3_AD2:
			break;
		case L_5V_150A_R2_P:
			refV = myPs->config.maxVoltage[rangeV];
			break;
		default:
			refV = val1;
			break;
	}

	if(myData->mData.config.rt_scan_type > 0) {
		refV = myPs->config.maxVoltage[rangeV] * 1.8;
	}
	
	//kjg_180521
	if((ch % 2) == 0) parallel_ch = ch + 1;
	else parallel_ch = ch - 1;

    switch(myCh->op.phase) {
		case P0:
			#ifdef _TRACKING_MODE
			if(myTestCond->step[advStepNo].SOC_Tracking_flag == P1 &&
				myCh->misc.file_sucess_flag == P0){
				send_msg(MODULE_TO_DATASAVE, 
							MSG_MODULE_DATASAVE_READ_USER_SOC_TRACKING, 
							ch, advStepNo);
				myCh->op.phase = P30;
				break;
			}
			#endif
			#ifdef _EQUATION_CURRENT
			if(myTestCond->step[advStepNo].equation_current_flag == P1 &&
				myCh->misc.equation_range_flag == P0){
				myCh->op.phase = P33;
				break;
			}
			#endif

			initCh(bd, ch);
			rtn = temp_wait_flag_check(bd, ch);
			if(rtn == 0) {
				cSemiSwitch_Start(bd, ch, type);
				break;
			}
			myCh->misc.step_count++;
			myCh->misc.cycleStepCount++;
			myCh->misc.endState = P0;
			myCh->misc.groupEndTime = 0;
			// 111212 oys w : cycleNo
			myCh->misc.cycleNo = myPs->testCond[bd][ch].step[advStepNo].cycleNo;

		   	myCh->op.checkDelayTime = 0;
			myCh->misc.startV = myCh->op.Vsens;
			myCh->misc.maxV = myCh->op.Vsens;
			myCh->misc.minV = myCh->op.Vsens;
			myCh->misc.Pre_change_V = myCh->op.Vsens;	//20190607
			myCh->misc.pre_chk_v = myCh->op.Vsens;		//20190829
			#ifdef _SDI_SAFETY_V1	
			myCh->misc.fault_deltaV = myCh->op.Vsens;	//hun_200430
			#endif
			myCh->misc.startT = myCh->op.temp;
			myCh->misc.maxT = myCh->op.temp;
			myCh->misc.minT = myCh->op.temp;
			myCh->misc.limit_current_timeout = myCh->op.runTime;
			myCh->misc.limit_voltage_timeout = myCh->op.runTime;
			myCh->misc.deltaV_timeout = myCh->op.runTime;
			myCh->misc.deltaI_timeout = myCh->op.runTime;
			myCh->misc.hw_fault_temp  = myCh->op.runTime;
			myCh->misc.DCR_PreV = myCh->op.Vsens;	//220221 LJS
			//120315 kji 0 sec data option
			//170501 oys modify
			if(myData->DataSave.config.zero_sec_data_save == P1) {
				if(myCh->ChAttribute.opType == P0) {
					if(myCh->ChAttribute.chNo_master == 0) {
						myData->bData[bd].cData[ch-1].op.Isens = 0;
						myData->bData[bd].cData[ch-1].misc.tmpIsens = 0;
						myData->bData[bd].cData[ch-1].op.select
							= SAVE_FLAG_SAVING_TIME;
					}
					myCh->op.Isens = 0;
					myCh->misc.tmpIsens = 0;
					myCh->op.select = SAVE_FLAG_SAVING_TIME;
					send_save_msg(bd, ch, 0, 0);
				}
			}

			rtn = SelectHwSpec(bd , ch);
			if(rtn == 1) {
				if(myCh->op.semiPreType == myCh->op.type) {
					val1 = myCh->misc.preVref;
					ref_output(bd, ch, val1, -val2, div, rangeV, rangeI, mode);
					if(myCh->misc.parallel_cycle_phase == P50) { //kjg_180521
						ref_output_p(bd, ch, parallel_ch, val1, -val2, div,
							rangeV, rangeI, mode);
					}
					myCh->op.phase = P5;
					myCh->misc.semiSwitchState = SEMI_V_P;
				} else {
					cSemiSwitch_Charge(bd, ch, 2);
					if(myPs->config.capacityType == CAPACITY_CAPACITANCE) {
						ref_output(bd, ch, val1, val2, div, rangeV, rangeI, mode);
						if(myCh->misc.parallel_cycle_phase == P50) {//kjg_180521
							ref_output_p(bd, ch, parallel_ch, val1, val2, div,
								rangeV, rangeI, mode);
						}
						if(myCh->ChAttribute.opType == P1) {
							ref_output(bd, ch + 1, val1, val2, div, rangeV, rangeI, mode);
							myCh = &(myData->bData[bd].cData[ch]);
						}
					} else {
						ref_output(bd, ch, refV, val2, div, rangeV, rangeI, mode);
						if(myCh->misc.parallel_cycle_phase == P50) {//kjg_180521
							ref_output_p(bd, ch, parallel_ch, refV, val2, div,
								rangeV, rangeI, mode);
						}
						if(myCh->ChAttribute.opType == P1) {
							ref_output(bd, ch + 1, refV, val2, div, rangeV, rangeI, mode);
							myCh = &(myData->bData[bd].cData[ch]);
						}
					}
				//	myCh->op.phase = P50;
					myCh->op.phase = P40;
				}
			} else if(rtn == 2) {
			//	myCh->misc.cmd_v = val1;
			//101002 kji step start refV 9V
				myCh->misc.cmd_v = refV;
				myCh->misc.cmd_v_div = (short int)div;
				myCh->misc.cmd_v_range = (short int)rangeV;
				myCh->misc.cmd_i = val2;
				myCh->misc.cmd_i_div = (short int)div;
				myCh->misc.cmd_i_range = (short int)rangeI;
				cSemiSwitch_Rest(bd, ch, 0, 0);
				myCh->signal[C_SIG_OUT_SWITCH] = P0;
				if(myPs->config.hwSpec > DC_DIGITAL_SPEC){//180611 
					myCh->signal[C_SIG_OUT_SWITCH_OFF] = P1;
				}
				myCh->op.phase = P4;
			} else if(rtn == 3) {
				if(myCh->misc.start != 1) cSemiSwitch_Charge(bd, ch, 0);
				myCh->op.phase = P3;
			} else if(rtn == 4) {
				cSemiSwitch(bd, ch);
				if(myCh->misc.parallel_cycle_phase == P50) { //kjg_180521
					cSemiSwitch_p(bd, ch, parallel_ch);
				}
				myCh->op.phase = P50;
			} else if(rtn == 5) {
				if(myCh->misc.start != 1) cSemiSwitch_Charge(bd, ch, 0);
				myCh->op.phase = P2;
			} else if(rtn == 6) { //100mS
				if(myCh->misc.start != 1) cSemiSwitch_Charge(bd, ch, 0);
				myCh->op.phase = P1;
			} else if(rtn == 7) { //switching same range
				myCh->misc.cmd_v = refV;
				myCh->misc.cmd_v_div = (short int)div;
				myCh->misc.cmd_v_range = (short int)rangeV;
				myCh->misc.cmd_i = val2;
				myCh->misc.cmd_i_div = (short int)div;
				myCh->misc.cmd_i_range = (short int)rangeI;
				cSemiSwitch_Rest(bd, ch, 0, 0);
				myCh->signal[C_SIG_OUT_SWITCH] = P0;
				if(myPs->config.hwSpec > DC_DIGITAL_SPEC){//180611 
					myCh->signal[C_SIG_OUT_SWITCH_OFF] = P1;
				}
				myCh->op.phase = P6;
			}
#ifdef _TRACKING_MODE
			if(myTestCond->step[advStepNo].SOC_Tracking_flag == P1 &&
				myCh->misc.file_sucess_flag == P1){
				myCh->misc.file_sucess_flag = P0;
			}
#endif
#ifdef _EQUATION_CURRENT //211116
			if(myTestCond->step[advStepNo].equation_current_flag == P1 &&
				myCh->misc.equation_range_flag == P1){
				myCh->misc.equation_range_flag = P0;
			}
#endif
			break;
		case P1: //100mS
			myCh->op.checkDelayTime = 0;
			myCh->misc.sensCount = 0;
			myCh->misc.sensCountFlag = P0;
			myCh->misc.sensBufCount = 0;
			myCh->misc.sensBufCountFlag = P0;
			if(myData->mData.config.function[F_SEMI_SWITCH_TYPE] == P1) {
				ref_output(bd, ch, val1, -val2, div, rangeV, rangeI, mode);
				if(myCh->misc.parallel_cycle_phase == P50) { //kjg_180521
					ref_output_p(bd, ch, parallel_ch, val1, -val2, div,
						rangeV, rangeI, mode);
				}
				myCh->op.phase = P5;
				myCh->misc.semiSwitchState = SEMI_V_P;
			} else {
				cSemiSwitch_Charge(bd, ch, 2);
				if(myPs->config.capacityType == CAPACITY_CAPACITANCE) {
					ref_output(bd, ch, val1, val2, div, rangeV, rangeI, mode);
					if(myCh->misc.parallel_cycle_phase == P50) { //kjg_180521
						ref_output_p(bd, ch, parallel_ch, val1, val2, div,
							rangeV, rangeI, mode);
					}
					if(myCh->ChAttribute.opType == P1) {
						ref_output(bd, ch + 1, val1, val2, div, rangeV, rangeI, mode);
						myCh = &(myData->bData[bd].cData[ch]);
					}
				} else {
					ref_output(bd, ch, refV, val2, div, rangeV, rangeI, mode);
					if(myCh->misc.parallel_cycle_phase == P50) { //kjg_180521
						ref_output_p(bd, ch, parallel_ch, refV, val2, div,
							rangeV, rangeI, mode);
					}
					if(myCh->ChAttribute.opType == P1) {
						ref_output(bd, ch + 1, refV, val2, div, rangeV, rangeI, mode);
						myCh = &(myData->bData[bd].cData[ch]);
					}
				}
			//	myCh->op.phase = P50;
				myCh->op.phase = P40;
			}	

			//0sec save LGC 5V6A 100716 kji
			if(myPs->config.hwSpec == L_5V_6A_R3) {
				myCh->op.select = SAVE_FLAG_SAVING_TIME;
				send_save_msg(bd, ch, 0, 0);
			}

//			myCh->op.phase = P50;
			break;
		case P2:
			myCh->op.checkDelayTime += myPs->misc.rt_scan_time;
			if(myCh->op.checkDelayTime == 10) {
				if(myCh->misc.start != 1) cSemiSwitch_Charge(bd, ch, 1);
			}
			if(myCh->op.checkDelayTime >= 50) {
				myCh->op.checkDelayTime = 0;
				myCh->op.phase = P1;
			}
			break;
		case P3:
			myCh->op.checkDelayTime += myPs->misc.rt_scan_time;
			if(myCh->op.checkDelayTime >= 10) {
				if(myCh->misc.start != 1) cSemiSwitch_Charge(bd, ch, 1);
				myCh->op.checkDelayTime = 0;
				myCh->op.phase = P1;
			}
			break;
		case P4:
			myCh->op.checkDelayTime += myPs->misc.rt_scan_time;
			if(myCh->op.checkDelayTime == 10) {
				cSemiSwitch(bd, ch);
				if(myCh->misc.parallel_cycle_phase == P50) { //kjg_180521
					cSemiSwitch_p(bd, ch, parallel_ch);
				}
			} else if(myCh->op.checkDelayTime > 27) {
				myCh->op.checkDelayTime = 0;
				myCh->signal[C_SIG_OUT_SWITCH] = P1;
				myCh->signal[C_SIG_V_CMD_OUTPUT] = P1;
				if(myPs->config.hwSpec > DC_DIGITAL_SPEC){//180611 
					myCh->signal[C_SIG_OUT_SWITCH_ON] = P1;
				}
				myCh->op.phase = P5;
			}
			break;
		case P5:
			myCh->signal[C_SIG_I_CMD_OUTPUT] = P1;
			myCh->op.phase = P50;
			break;
		case P6:
			myCh->op.checkDelayTime += myPs->misc.rt_scan_time;
			if(myCh->op.checkDelayTime <= 2) {
				cSemiSwitch(bd, ch);
				if(myCh->misc.parallel_cycle_phase == P50) { //kjg_180521
					cSemiSwitch_p(bd, ch, parallel_ch);
				}
				myCh->signal[C_SIG_V_CMD_OUTPUT] = P1;
				myCh->signal[C_SIG_OUT_SWITCH] = P1;
				if(myPs->config.hwSpec > DC_DIGITAL_SPEC){//180611 
					myCh->signal[C_SIG_OUT_SWITCH_ON] = P1;
				}
			} else if(myCh->op.checkDelayTime >= 4) {
				myCh->op.checkDelayTime = 0;
				myCh->signal[C_SIG_I_CMD_OUTPUT] = P1;
				myCh->op.phase = P50;
			} 
			break;
		case P10:
			//SKI_hun_201010
			if(myCh->misc.ac_fail_flag == P1){
			#ifdef _TRACKING_MODE
			if(myTestCond->step[advStepNo].SOC_Tracking_flag == P1 &&
				myCh->misc.file_sucess_flag == P0){
				send_msg(MODULE_TO_DATASAVE, 
							MSG_MODULE_DATASAVE_READ_USER_SOC_TRACKING, 
							ch, advStepNo);
				myCh->op.phase = P30;
				break;
			}
			#endif
				myCh->op.phase = P15;
			}else if(myCh->misc.ac_fail_flag == P0){			
				rtn = SelectHwSpec(bd , ch);
				if(rtn == 1 || rtn == 3 || rtn == 4 || rtn == 5 || rtn == 6) {
					myCh->misc.fbV = 0;
					myCh->misc.fbI = 0;
					myCh->misc.ocv = myCh->op.Vsens;
					myCh->misc.pid_ui1[0] = 0.0;
					myCh->misc.pid_ui1[1] = 0.0;
					myCh->misc.pid_error1[0] = 0.0;
					myCh->misc.pid_error1[1] = 0.0;
					myCh->signal[C_SIG_V_RANGE] = myCh->op.rangeV + 1;
					myCh->signal[C_SIG_I_RANGE] = myCh->op.rangeI + 1;

					myCh->op.phase = P11;
				} else if(rtn == 2 || rtn == 7) {
					myCh->misc.fbV = 0;
					myCh->misc.fbI = 0;
					myCh->misc.ocv = myCh->op.Vsens;
					myCh->misc.pid_ui1[0] = 0.0;
					myCh->misc.pid_ui1[1] = 0.0;
					myCh->misc.pid_error1[0] = 0.0;
					myCh->misc.pid_error1[1] = 0.0;
					myCh->op.checkDelayTime = 0;

					myCh->misc.cmd_v = refV;
					myCh->misc.cmd_v_div = (short int)div;
					myCh->misc.cmd_v_range = (short int)rangeV;
					myCh->misc.cmd_i = val2;
					myCh->misc.cmd_i_div = (short int)div;
					myCh->misc.cmd_i_range = (short int)rangeI;
					myCh->signal[C_SIG_V_RANGE] = rangeV + 1;
					myCh->signal[C_SIG_I_RANGE] = rangeI + 1;
					cSemiSwitch_Rest(bd, ch, 0, 0);
					myCh->op.phase = P13;
				}
			}
			break;
		case P11:
			myCh->op.phase = P12;
			break;
		case P12:
			myCh->misc.sensCount = 0;
			myCh->misc.sensCountFlag = P0;
			myCh->misc.sensBufCount = 0;
			myCh->misc.sensBufCountFlag = P0;
			myCh->op.checkDelayTime = 0;
			if(myPs->config.capacityType == CAPACITY_CAPACITANCE) {
				ref_output(bd, ch, val1, val2, div, rangeV, rangeI, mode);
				if(myCh->misc.parallel_cycle_phase == P50) { //kjg_180521
					ref_output_p(bd, ch, parallel_ch, val1, val2, div,
						rangeV, rangeI, mode);
				}
				if(myCh->ChAttribute.opType == P1) {
					ref_output(bd, ch + 1, val1, val2, div, rangeV, rangeI, mode);
					myCh = &(myData->bData[bd].cData[ch]);
				}
			} else {
				ref_output(bd, ch, val1, val2, div, rangeV, rangeI, mode);
				if(myCh->misc.parallel_cycle_phase == P50) { //kjg_180521
					ref_output_p(bd, ch, parallel_ch, val1, val2, div,
						rangeV, rangeI, mode);
				}
				if(myCh->ChAttribute.opType == P1) {
					ref_output(bd, ch + 1, val1, val2, div, rangeV, rangeI, mode);
					myCh = &(myData->bData[bd].cData[ch]);
				}
			}
		//	myCh->op.phase = P50;
			myCh->op.phase = P40;
			break;
		case P13:
			myCh->op.checkDelayTime += myPs->misc.rt_scan_time;
			if(myCh->op.checkDelayTime == 10) {
				cSemiSwitch(bd, ch);
				if(myCh->misc.parallel_cycle_phase == P50) { //kjg_180521
					cSemiSwitch_p(bd, ch, parallel_ch);
				}
			} else if(myCh->op.checkDelayTime >= 30) {
				myCh->misc.sensCount = 0;
				myCh->misc.sensCountFlag = P0;
				myCh->misc.sensBufCount = 0;
				myCh->misc.sensBufCountFlag = P0;
		
				myCh->op.checkDelayTime = 0;
				myCh->signal[C_SIG_OUT_SWITCH] = P1;
				if(myPs->config.hwSpec > DC_DIGITAL_SPEC){//180611 
					myCh->signal[C_SIG_OUT_SWITCH_ON] = P1;
				}
				myCh->signal[C_SIG_V_CMD_OUTPUT] = P1;
				myCh->signal[C_SIG_I_CMD_OUTPUT] = P1;
				myCh->op.phase = P50;
			}
			break;
		case P14:
			cSemiSwitch_Charge(bd, ch, 4);
			myCh->op.phase = P11;
			break;
		//SKI_hun_201010
		case P15:
			myCh->misc.ac_fail_flag = P0;
			rtn = temp_wait_flag_check(bd, ch);
			if(rtn == 0) {
				cSemiSwitch_Start(bd, ch, type);
				break;
			}
			myCh->misc.saveDt = myCh->op.runTime;
			
			rtn = SelectHwSpec(bd , ch);
			if(rtn == 1 || rtn == 3 || rtn == 4 || rtn == 5 || rtn == 6) {
				myCh->misc.fbV = 0;
				myCh->misc.fbI = 0;
				myCh->misc.ocv = myCh->op.Vsens;
				myCh->misc.pid_ui1[0] = 0.0;
				myCh->misc.pid_ui1[1] = 0.0;
				myCh->misc.pid_error1[0] = 0.0;
				myCh->misc.pid_error1[1] = 0.0;
				myCh->signal[C_SIG_V_RANGE] = myCh->op.rangeV + 1;
				myCh->signal[C_SIG_I_RANGE] = myCh->op.rangeI + 1;
			
				myCh->op.phase = P11;
			} else if(rtn == 2 || rtn == 7) {
				myCh->misc.fbV = 0;
				myCh->misc.fbI = 0;
				myCh->misc.ocv = myCh->op.Vsens;
				myCh->misc.pid_ui1[0] = 0.0;
				myCh->misc.pid_ui1[1] = 0.0;
				myCh->misc.pid_error1[0] = 0.0;
				myCh->misc.pid_error1[1] = 0.0;
				myCh->op.checkDelayTime = 0;
			
				myCh->misc.cmd_v = refV;
				myCh->misc.cmd_v_div = (short int)div;
				myCh->misc.cmd_v_range = (short int)rangeV;
				myCh->misc.cmd_i = val2;
				myCh->misc.cmd_i_div = (short int)div;
				myCh->misc.cmd_i_range = (short int)rangeI;
				myCh->signal[C_SIG_V_RANGE] = rangeV + 1;
				myCh->signal[C_SIG_I_RANGE] = rangeI + 1;
				cSemiSwitch_Rest(bd, ch, 0, 0);
				myCh->op.phase = P13;
			}
#ifdef _TRACKING_MODE
			if(myTestCond->step[advStepNo].SOC_Tracking_flag == P1 &&
				myCh->misc.file_sucess_flag == P1){
				myCh->misc.file_sucess_flag = P0;
			}
#endif
			break;
		case P20:
			//111130 kji run relay check 
			myCh->op.checkDelayTime += myPs->misc.rt_scan_time;
			if(myCh->op.checkDelayTime >= 100) {
				myCh->op.checkDelayTime = 0;
				myCh->op.phase = P0;
			}
			break;
		case P30: //210609
#ifdef _TRACKING_MODE
			if(myCh->misc.file_sucess_flag != P0){
				maxRefI = myPs->testCond[bd][ch].SOC_tracking[type].maxI;
				if(mode != CP){
					if(maxRefI != 0){
						if(maxRefI <= myData->mData.config.maxCurrent[3]) {
							rangeI = RANGE4 - 1;
						} else if(maxRefI <= myData->mData.config.maxCurrent[2]) {
							rangeI = RANGE3 - 1;
						} else if(maxRefI <= myData->mData.config.maxCurrent[1]) {
							rangeI = RANGE2 - 1;
						} else {
							rangeI = RANGE1 - 1;
						}
					}
				}else{
					tmp1 = (double)maxRefI / 1000;
					tmp1 /= (double)myCh->misc.tmpVsens;
					tmp1 *= 1000000000.0;
					maxRefI = (long)tmp1;
					if(maxRefI != 0){
						if(maxRefI <= myData->mData.config.maxCurrent[3]) {
							rangeI = RANGE4 - 1;
						} else if(maxRefI <= myData->mData.config.maxCurrent[2]) {
							rangeI = RANGE3 - 1;
						} else if(maxRefI <= myData->mData.config.maxCurrent[1]) {
							rangeI = RANGE2 - 1;
						} else {
							rangeI = RANGE1 - 1;
						}
					}
				}
				
				if(mode != CP){ //CC , CCCV, CRATE
					maxRefI = myPs->testCond[bd][ch].SOC_tracking[type].maxI;
					myPs->testCond[bd][ch].step[advStepNo].refI = maxRefI;
					myPs->testCond[bd][ch].step[advStepNo].rangeI = rangeI;
				}else{ //CP
					myPs->testCond[bd][ch].step[advStepNo].refP = maxRefI /1000;
					myPs->testCond[bd][ch].step[advStepNo].rangeI = rangeI;
				}
				
				myCh->op.checkDelayTime += myPs->misc.rt_scan_time;
				if(myCh->op.checkDelayTime >= 100) {
					myCh->op.checkDelayTime = 0;

					if(myCh->misc.ac_fail_flag == P1){
						myCh->op.phase = P10; //211022
					}else{
						myCh->op.phase = P0;
					}
				}
			}else{	//210720
			  	if(myCh->signal[C_SIG_STOP] == P1) {
					myCh->op.code = C_FAULT_STOP_CMD;
					myCh->op.select = SAVE_FLAG_SAVING_END;
					myCh->signal[C_SIG_STOP] = P0;
					myCh->op.phase = P100;
				} else if(myCh->signal[C_SIG_PAUSE] == P1) {
					//cmd, soft fault
					myCh->misc.tmpState = myCh->op.state;
					myCh->misc.tmpCode = myCh->op.code;
					myCh->op.code = C_FAULT_PAUSE_CMD;
					myCh->opSave = myCh->op;
					myCh->signal[C_SIG_PAUSE] = P0;
					myCh->op.phase = P100;
				}else if(myCh->signal[C_SIG_NEXTSTEP] == P1) {
					myCh->signal[C_SIG_NEXTSTEP] = P0;
					myCh->op.code = C_FAULT_NEXTSTEP_CMD;
					myCh->op.select = SAVE_FLAG_SAVING_END;
					myCh->op.phase = P100;
				 }else if(myData->bData[bd].cData[ch].misc.file_fail_flag ==P1){
					myData->bData[bd].cData[ch]
						.signal[C_SIG_READ_FAIL_SOC_TRACKING_FILE] = P1;
					myData->bData[bd].cData[ch].misc.file_fail_flag = P0;
					cFailCodeCheck(bd, ch);
				}
			}
#endif
			break;
		case P33:
#ifdef _EQUATION_CURRENT
			maxRefI_EQU = myPs->testCond[bd][ch].step[advStepNo].Max_Current_EQU;
			if(maxRefI_EQU == 0){ //211116
				maxRefI_EQU = myData->mData.config.maxCurrent[0];
			}
			if(mode != CP){
				if(maxRefI_EQU != 0){
					if(maxRefI_EQU <= myData->mData.config.maxCurrent[3]) {
						rangeI = RANGE4 - 1;
					} else if(maxRefI_EQU <= myData->mData.config.maxCurrent[2]) {
						rangeI = RANGE3 - 1;
					} else if(maxRefI_EQU <= myData->mData.config.maxCurrent[1]) {
						rangeI = RANGE2 - 1;
					} else {
						rangeI = RANGE1 - 1;
					}
				}
			}else{
				tmp1 = (double)maxRefI_EQU / 1000;
				tmp1 /= (double)myCh->misc.tmpVsens;
				tmp1 *= 1000000000.0;
				maxRefI_EQU = (long)tmp1;
				if(maxRefI_EQU != 0){
					if(maxRefI_EQU <= myData->mData.config.maxCurrent[3]) {
						rangeI = RANGE4 - 1;
					} else if(maxRefI_EQU <= myData->mData.config.maxCurrent[2]) {
						rangeI = RANGE3 - 1;
					} else if(maxRefI_EQU <= myData->mData.config.maxCurrent[1]) {
						rangeI = RANGE2 - 1;
					} else {
						rangeI = RANGE1 - 1;
					}
				}
			}
				
			if(mode != CP){ //CC , CCCV, CRATE
				maxRefI_EQU = myPs->testCond[bd][ch].step[advStepNo].Max_Current_EQU;
				myPs->testCond[bd][ch].step[advStepNo].refI = maxRefI_EQU;
				myPs->testCond[bd][ch].step[advStepNo].rangeI = rangeI;
			}else{ //CP
				myPs->testCond[bd][ch].step[advStepNo].refP = maxRefI_EQU /1000;
				myPs->testCond[bd][ch].step[advStepNo].rangeI = rangeI;
			}
				
			myCh->op.checkDelayTime += myPs->misc.rt_scan_time;
			if(myCh->op.checkDelayTime >= 100) {
				myCh->op.checkDelayTime = 0;
				myCh->op.phase = P0;
				myCh->misc.equation_range_flag = P1;
			}
#endif
			break;
		case P40:
			myCh->op.checkDelayTime += myPs->misc.rt_scan_time;
			if(myData->mData.config.function[F_SEMI_SWITCH_TYPE] == P1
					|| myCh->ChAttribute.opType == 1
					|| myCh->ChAttribute.chNo_master == 0) {
				myCh->op.checkDelayTime = 0;			//200320 lyh
				myCh->op.phase = P50;
			}else{
				//201109_pty
				if(labs(val2) <= myPs->config.maxCurrent[rangeI] * 0.1){ 
					if(myCh->misc.cvFlag == 0) {
						if(labs(myCh->op.Isens) >= labs(val2*0.8)){
							myCh->op.checkDelayTime = 0;
							myCh->op.phase = P50;
						} else {
							if(myCh->op.checkDelayTime >= 1500) {
								myCh->op.checkDelayTime = 0;
								myCh->op.phase = P50;
							}
							break;
						}
					} else {
						myCh->op.checkDelayTime = 0;
						myCh->op.phase = P50;
					}
				}else{
					myCh->op.checkDelayTime = 0;
					myCh->op.phase = P50;
				}//end
			}
		case P50:
			myCh->misc.start = 0;
	    	myCh->op.runTime += myPs->misc.rt_scan_time;
			myCh->op.totalRunTime += myPs->misc.rt_scan_time;
			myCh->misc.cycleRunTime += myPs->misc.rt_scan_time;
			myCh->op.checkDelayTime += myPs->misc.rt_scan_time;

			sens_ch_ad_count_increment(bd, ch);

			if(myCh->op.runTime >= 30) {
				myCh->misc.meanCount++;
				if(myCh->misc.meanCount <= 8) {
					myCh->misc.meanSumVolt += (myCh->misc.tmpVsens / 100);
					myCh->misc.meanSumCurr += (myCh->misc.tmpIsens / 100);
					myCh->misc.meanSumTemp += (myCh->op.temp / 100);
				} else {
					myCh->misc.meanSumVolt += (myCh->op.Vsens / 100);
					myCh->misc.meanSumCurr += (myCh->op.Isens / 100);
					myCh->misc.meanSumTemp += (myCh->op.temp / 100);
				}
				myCh->op.meanVolt = (long)(myCh->misc.meanSumVolt
					/ myCh->misc.meanCount) * 100;
				myCh->op.meanCurr = (long)(myCh->misc.meanSumCurr
					/ myCh->misc.meanCount) * 100;
				myCh->op.meanTemp = (long)(myCh->misc.meanSumTemp
					/ myCh->misc.meanCount) * 100;
			}

			if(myCh->op.checkDelayTime == myPs->misc.rt_scan_time) {
				if(myPs->config.hwSpec < S_5V_200A) {
					ref_output(bd, ch, val1, val2, div, rangeV, rangeI, mode);
					if(myCh->misc.parallel_cycle_phase == P50) { //kjg_180521
						ref_output_p(bd, ch, parallel_ch, val1, val2, div,
							rangeV, rangeI, mode);
					}
				} else {
					myCh->misc.cmd_v = val1;
					myCh->misc.cmd_v_div = (short int)div;
					myCh->misc.cmd_v_range = (short int)rangeV;
					myCh->signal[C_SIG_V_CMD_OUTPUT] = P1;
				}
			}

			if(myCh->signal[C_SIG_STOP] == P1) {
				myCh->op.code = C_FAULT_STOP_CMD;
				myCh->op.select = SAVE_FLAG_SAVING_END;
				myCh->signal[C_SIG_STOP] = P0;
				cSemiSwitch_Rest(bd, ch, advStepNo, 0);
				myCh->op.phase = P100;
			} else if(myCh->signal[C_SIG_PAUSE] == P1) {
				//cmd, soft fault
				myCh->misc.tmpState = myCh->op.state;
				myCh->misc.tmpCode = myCh->op.code;
				myCh->op.code = C_FAULT_PAUSE_CMD;
				myCh->opSave = myCh->op;
				myCh->signal[C_SIG_PAUSE] = P0;
				cSemiSwitch_Rest(bd, ch, advStepNo, 0);
				myCh->op.phase = P100;
			} else if(myCh->signal[C_SIG_DLL_STOP] == P1) {
				myCh->op.code = C_FAULT_CELL_DIAGNOSIS_STOP;
				myCh->op.select = SAVE_FLAG_SAVING_END;
				myCh->signal[C_SIG_DLL_STOP] = P0;
				cSemiSwitch_Rest(bd, ch, advStepNo, 0);
				myCh->op.phase = P100;
			} else {
				if(cFailCodeCheck(bd, ch) >= 0) {
					cSoftFeedback(bd, ch, val1, val2, val3);
				}

				if(myCh->misc.cvFlag == P1) {
					myCh->misc.cvTime += myPs->misc.rt_scan_time;
					myCh->misc.cycle_Charge_cvTime += myPs->misc.rt_scan_time;
					//kjc_211028
					#ifdef _ULSAN_SDI_SAFETY
					myCh->misc.cvTime_Ulsan += myPs->misc.rt_scan_time;
					#endif
				} else {
					myCh->misc.ccTime += myPs->misc.rt_scan_time;
					myCh->misc.cycle_Charge_ccTime += myPs->misc.rt_scan_time;
					//kjc_211028
					#ifdef _ULSAN_SDI_SAFETY
					myCh->misc.cvTime_Ulsan = 0;
					#endif
				}
			}

			//191010
			if(myCh->op.checkDelayTime < 100){
				myCh->misc.Pre_change_V = myCh->misc.tmpVsens;
				//hun_200409_s
				myCh->misc.maxV = myCh->misc.tmpVsens;
				myCh->misc.startV = myCh->misc.tmpVsens;
				myCh->misc.minV = myCh->misc.tmpVsens;
				myCh->misc.maxI = myCh->misc.tmpIsens;
				myCh->misc.minI = myCh->misc.tmpIsens;
				//hun_200409_e
			}

	    	if(myCh->op.checkDelayTime == 100) {
				myCh->misc.maxI = myCh->op.Isens;
				myCh->misc.minI = myCh->op.Isens;
			}

			if(myCh->ChAttribute.opType == P0) {
				cCalculate_Capacitance(bd, ch, advStepNo);
				cCalculate_DCR(bd, ch, advStepNo);
			}

			myCh->ccv[0].avg_v = myCh->misc.tmpVsens;
			myCh->ccv[0].avg_i = myCh->misc.tmpIsens;

			if(myCh->op.phase == P100) {
				cNextStepCheck(bd, ch);
			}
			break;
		case P100:
			break;
		default: break;
    }
}

void cStepDischarge(int bd, int ch)
{
	int rtn, rangeV, rangeI, div = 5, parallel_ch, mode;
    long val1, val2, val3, refV, refI,type;
	unsigned long advStepNo, saveDt;
	double tmp1;
	S_CH_STEP_INFO step;

	myCh = &(myData->bData[bd].cData[ch]);

	tmp1 = 0.0;
	
	step = step_info(bd, ch);

	type = step.type;
	val1 = step.refV;
	val2 = step.refI;
	val3 = step.refP;
	rangeI = (int)step.rangeI;
	rangeV = (int)step.rangeV;
	saveDt = step.saveDt;
	advStepNo = step.advStepNo;
	mode = step.mode;

	refV = myPs->config.maxVoltage[rangeV]*(-1.8);
	refI = -180000;
	refV = val1;	//110428 kji

	switch(myPs->config.hwSpec) {
		case L_15V_100A_R3_AD2:
			break;
		case L_5V_150A_R2_P:
			refV = 0;
			break;
		default:
			refV = val1;
			break;
	}

	if(myData->mData.config.rt_scan_type > 0) {
		refV = myPs->config.maxVoltage[rangeV] * (-1.8);
	}


	//kjg_180521
	if((ch % 2) == 0) parallel_ch = ch + 1;
	else parallel_ch = ch - 1;

    switch(myCh->op.phase) {
		case P0:
			initCh(bd, ch);

			rtn = temp_wait_flag_check(bd, ch);
			if(rtn == 0) {
				cSemiSwitch_Start(bd, ch, type);
		//		cSemiSwitch_Rest(bd, ch, advStepNo, 0);
				break;
			}
			myCh->misc.step_count++;
			myCh->misc.cycleStepCount++;
			myCh->misc.endState = P0;
			myCh->misc.groupEndTime = 0;
			myCh->misc.cycleDischargeStepCount++; //kjgw_180530
			// 111212 oys w : cycleNo
			myCh->misc.cycleNo = myPs->testCond[bd][ch].step[advStepNo].cycleNo;

		   	myCh->op.checkDelayTime = 0;
			myCh->misc.startV = myCh->op.Vsens;
			myCh->misc.maxV = myCh->op.Vsens;
			myCh->misc.minV = myCh->op.Vsens;
			myCh->misc.pre_chk_v = myCh->op.Vsens;		//20190829
			#ifdef _SDI_SAFETY_V1	
			myCh->misc.fault_deltaV = myCh->op.Vsens;	//hun_200430
			#endif
			#ifdef _SDI_SAFETY_V2	
			myCh->misc.Master_recipe_deltaV = myCh->op.Vsens;	//ljs 210412
			#endif
			myCh->misc.startT = myCh->op.temp;
			myCh->misc.maxT = myCh->op.temp;
			myCh->misc.minT = myCh->op.temp;
			myCh->misc.limit_current_timeout = myCh->op.runTime;
			myCh->misc.limit_voltage_timeout = myCh->op.runTime;
			myCh->misc.deltaV_timeout = myCh->op.runTime;
			myCh->misc.deltaI_timeout = myCh->op.runTime;
			myCh->misc.hw_fault_temp  = myCh->op.runTime;
			myCh->misc.DCR_PreV = myCh->op.Vsens;	//220221 LJS
			//120315 kji 0 sec data option

			//170501 oys modify
			if(myData->DataSave.config.zero_sec_data_save == P1) {
				if(myCh->ChAttribute.opType == P0) {
					if(myCh->ChAttribute.chNo_master == 0) {
						myData->bData[bd].cData[ch-1].op.Isens = 0;
						myData->bData[bd].cData[ch-1].misc.tmpIsens = 0;
						myData->bData[bd].cData[ch-1].op.select
							= SAVE_FLAG_SAVING_TIME;
					}
					myCh->op.Isens = 0;
					myCh->misc.tmpIsens = 0;
					myCh->op.select = SAVE_FLAG_SAVING_TIME;
					send_save_msg(bd, ch, 0, 0);
				}
			}

			rtn = SelectHwSpec(bd , ch);
			if(rtn == 1) {
				if(myCh->op.semiPreType == myCh->op.type) {
					val1 = myCh->misc.preVref;
					ref_output(bd, ch, val1, -val2, div, rangeV, rangeI, mode);
					if(myCh->misc.parallel_cycle_phase == P50) { //kjg_180521
						ref_output_p(bd, ch, parallel_ch, val1, -val2, div,
							rangeV, rangeI, mode);
					}
					myCh->op.phase = P5;
					myCh->misc.semiSwitchState = SEMI_V_N;
				} else {
					cSemiSwitch_Discharge(bd, ch, 2);
					if(myPs->config.capacityType == CAPACITY_CAPACITANCE) {
						ref_output(bd, ch, val1, val2, div, rangeV, rangeI, mode);
						if(myCh->misc.parallel_cycle_phase == P50) {//kjg_180521
							ref_output_p(bd, ch, parallel_ch, val1, val2, div,
								rangeV, rangeI, mode);
						}
						if(myCh->ChAttribute.opType == P1) {
							ref_output(bd, ch + 1, val1, val2, div, rangeV, rangeI, mode);
							myCh = &(myData->bData[bd].cData[ch]);
						}
					} else {
						ref_output(bd, ch, refV, val2, div, rangeV, rangeI, mode);
						if(myCh->misc.parallel_cycle_phase == P50) {//kjg_180521
							ref_output_p(bd, ch, parallel_ch, refV, val2, div,
								rangeV, rangeI, mode);
						}
						if(myCh->ChAttribute.opType == P1) {
							ref_output(bd, ch + 1, refV, val2, div, rangeV, rangeI, mode);
							myCh = &(myData->bData[bd].cData[ch]);
						}
					}
				//	myCh->op.phase = P50;
					myCh->op.phase = P40;
				}
			} else if(rtn == 2) {
				myCh->misc.cmd_v = 0;
				myCh->misc.cmd_v_div = (short int)div;
				myCh->misc.cmd_v_range = (short int)rangeV;
				myCh->misc.cmd_i = val2;
				myCh->misc.cmd_i_div = (short int)div;
				myCh->misc.cmd_i_range = (short int)rangeI;
				myCh->signal[C_SIG_OUT_SWITCH] = P0;
				if(myPs->config.hwSpec > DC_DIGITAL_SPEC){//180611 
					myCh->signal[C_SIG_OUT_SWITCH_OFF] = P1;
				}
				cSemiSwitch_Rest(bd, ch, 0, 0);
				myCh->op.phase = P4;
			} else if(rtn == 3) {
				if(myCh->misc.start != 1){
					if(myCh->op.semiPreType == myCh->op.type){
						val1 = myCh->misc.preVref;
						ref_output(bd, ch, val1, -val2, div, rangeV, rangeI, mode);
						if(myCh->misc.parallel_cycle_phase == P50) {//kjg_180521
							ref_output_p(bd, ch, parallel_ch, val1, -val2, div,
								rangeV, rangeI, mode);
						}
						myCh->misc.semiSwitchState = SEMI_V_N;
					} else {
						cSemiSwitch_Discharge(bd, ch, 0);
					}
				}
				myCh->op.phase = P3;
			} else if(rtn == 4) {
				cSemiSwitch(bd, ch);
				if(myCh->misc.parallel_cycle_phase == P50) { //kjg_180521
					cSemiSwitch_p(bd, ch, parallel_ch);
				}
				myCh->op.phase = P50;
			} else if(rtn == 5) {
				if(myCh->misc.start != 1)
					cSemiSwitch_Discharge(bd, ch, 0);
				myCh->op.phase = P2;
			} else if(rtn == 6) {
				if(myCh->misc.start != 1){
					if(myCh->op.semiPreType == myCh->op.type){
						val1 = myCh->misc.preVref;
						ref_output(bd, ch, val1, -val2, div, rangeV, rangeI, mode);
						if(myCh->misc.parallel_cycle_phase == P50) {//kjg_180521
							ref_output_p(bd, ch, parallel_ch, val1, -val2, div,
								rangeV, rangeI, mode);
						}
						myCh->misc.semiSwitchState = SEMI_V_N;
					} else {
						cSemiSwitch_Discharge(bd, ch, 0);
					}
				}
				myCh->op.phase = P1;
			} else if(rtn == 7) { //switching same range
				myCh->misc.cmd_v = 0;
				myCh->misc.cmd_v_div = (short int)div;
				myCh->misc.cmd_v_range = (short int)rangeV;
				myCh->misc.cmd_i = val2;
				myCh->misc.cmd_i_div = (short int)div;
				myCh->misc.cmd_i_range = (short int)rangeI;
				myCh->signal[C_SIG_OUT_SWITCH] = P0;
				if(myPs->config.hwSpec > DC_DIGITAL_SPEC){//180611 
					myCh->signal[C_SIG_OUT_SWITCH_OFF] = P1;
				}
				cSemiSwitch_Rest(bd, ch, 0, 0);
				myCh->op.phase = P6;
			}
			break;
		case P1:
			myCh->op.checkDelayTime = 0;
			myCh->misc.sensCount = 0;
			myCh->misc.sensCountFlag = P0;
			myCh->misc.sensBufCount = 0;
			myCh->misc.sensBufCountFlag = P0;
			if(myPs->config.capacityType == CAPACITY_CAPACITANCE) {
				if(myData->mData.config.function[F_SEMI_SWITCH_TYPE] == P1) {
					ref_output(bd, ch, val1, -val2, div, rangeV, rangeI, mode);
					if(myCh->misc.parallel_cycle_phase == P50) { //kjg_180521
						ref_output_p(bd, ch, parallel_ch, val1, -val2, div,
							rangeV, rangeI, mode);
					}
				} else {
					ref_output(bd, ch, val1, val2, div, rangeV, rangeI, mode);
					if(myCh->misc.parallel_cycle_phase == P50) { //kjg_180521
						ref_output_p(bd, ch, parallel_ch, val1, val2, div,
							rangeV, rangeI, mode);
					}
				}

				if(myCh->ChAttribute.opType == P1) {
					if(myData->mData.config.function[F_SEMI_SWITCH_TYPE] == P1){
						ref_output(bd, ch+1, val1, -val2, div, rangeV, rangeI, mode);
					}else{
						ref_output(bd, ch+1, val1, val2, div, rangeV, rangeI, mode);
					}
					myCh = &(myData->bData[bd].cData[ch]);
				}
			} else {
				if((myPs->config.hwSpec == L_5V_6A_R3)
					&& (labs(val2) < labs(refI)) && (rangeI == 2)) {
					ref_output(bd, ch, refV, refI, div, rangeV, rangeI, mode);
					if(myCh->misc.parallel_cycle_phase == P50) { //kjg_180521
						ref_output_p(bd, ch, parallel_ch, refV, refI, div,
							rangeV, rangeI, mode);
					}
				}else{
					if(myData->mData.config.function[F_SEMI_SWITCH_TYPE] == P1){
						ref_output(bd, ch, refV, -val2, div, rangeV, rangeI, mode);
						if(myCh->misc.parallel_cycle_phase == P50) {//kjg_180521
							ref_output_p(bd, ch, parallel_ch, refV, -val2, div,
								rangeV, rangeI, mode);
						}
					} else {
						ref_output(bd, ch, refV, val2, div, rangeV, rangeI, mode);
						if(myCh->misc.parallel_cycle_phase == P50) {//kjg_180521
							ref_output_p(bd, ch, parallel_ch, refV, val2, div,
								rangeV, rangeI, mode);
						}
					}

					if(myCh->ChAttribute.opType == P1) {
						if(myData->mData.config.function[F_SEMI_SWITCH_TYPE]
							== P1) {
							ref_output(bd, ch + 1, refV, -val2, div, rangeV, rangeI, mode);
						} else {
							ref_output(bd, ch + 1, refV, val2, div, rangeV, rangeI, mode);
						}

						myCh = &(myData->bData[bd].cData[ch]);
					}
				}
			}

			//0sec save LGC 5V6A 100716 kji
			if(myPs->config.hwSpec == L_5V_6A_R3) {
				myCh->op.select = SAVE_FLAG_SAVING_TIME;
				send_save_msg(bd, ch, 0, 0);
			}
		//	myCh->op.phase = P50;
			myCh->op.phase = P40;
			break;
		case P2:
			myCh->op.checkDelayTime += myPs->misc.rt_scan_time;
			if(myCh->op.checkDelayTime == 10) {
				if(myCh->misc.start != 1)
					cSemiSwitch_Discharge(bd, ch, 1);
			}
			if(myCh->op.checkDelayTime >= 50) {
				if(myCh->misc.start != 1)
					cSemiSwitch_Discharge(bd, ch, 1);
				myCh->op.checkDelayTime = 0;
				myCh->op.phase = P1;
			}
			break;
		case P3:
			myCh->op.checkDelayTime += myPs->misc.rt_scan_time;
			if(myCh->op.checkDelayTime >= 10) {
				if(myCh->misc.start != 1){
					if(myData->mData.config.function[F_SEMI_SWITCH_TYPE] == P1){
						ref_output(bd, ch, val1, -val2, div, rangeV, rangeI, mode);
						if(myCh->misc.parallel_cycle_phase == P50) {//kjg_180521
							ref_output_p(bd, ch, parallel_ch, val1, -val2, div,
								rangeV, rangeI, mode);
						}
						if(myCh->ChAttribute.opType == P1)
						{
							ref_output(bd, ch+1, val1, -val2, div, rangeV, rangeI, mode);
							myCh = &(myData->bData[bd].cData[ch]);
						}
					} else {
						cSemiSwitch_Discharge(bd, ch, 1);
					}
				}
				myCh->op.checkDelayTime = 0;
				myCh->op.phase = P1;
			}
			break;
		case P4:
			myCh->op.checkDelayTime += myPs->misc.rt_scan_time;
			if(myCh->op.checkDelayTime == 10) {
				cSemiSwitch(bd, ch);
				if(myCh->misc.parallel_cycle_phase == P50) { //kjg_180521
					cSemiSwitch_p(bd, ch, parallel_ch);
				}
			}else if(myCh->op.checkDelayTime > 27) {
				myCh->op.checkDelayTime = 0;
				myCh->signal[C_SIG_OUT_SWITCH] = P1;
				if(myPs->config.hwSpec > DC_DIGITAL_SPEC){//180611 
					myCh->signal[C_SIG_OUT_SWITCH_ON] = P1;
				}
				myCh->signal[C_SIG_V_CMD_OUTPUT] = P1;
				myCh->op.phase = P5;
			}
			break;
		case P5:
			myCh->signal[C_SIG_I_CMD_OUTPUT] = P1;
			myCh->op.phase = P50;
			break;
		case P6:
			myCh->op.checkDelayTime += myPs->misc.rt_scan_time;
			if(myCh->op.checkDelayTime <= 2) {
				cSemiSwitch(bd, ch);
				if(myCh->misc.parallel_cycle_phase == P50) { //kjg_180521
					cSemiSwitch_p(bd, ch, parallel_ch);
				}
			} else if(myCh->op.checkDelayTime >= 4) {
				myCh->op.checkDelayTime = 0;
				myCh->signal[C_SIG_OUT_SWITCH] = P1;
				if(myPs->config.hwSpec > DC_DIGITAL_SPEC){//180611 
					myCh->signal[C_SIG_OUT_SWITCH_ON] = P1;
				}
				myCh->signal[C_SIG_I_CMD_OUTPUT] = P1;
				myCh->signal[C_SIG_V_CMD_OUTPUT] = P1;
				myCh->op.phase = P50;
			} 
			break;
		case P10:
			//SKI_hun_201010
			if(myCh->misc.ac_fail_flag == P1){
				myCh->op.phase = P15;				
			}else if(myCh->misc.ac_fail_flag == P0){
				rtn = SelectHwSpec(bd , ch);
				if(rtn == 1
					|| rtn == 3
					|| rtn == 4
					|| rtn == 5
					|| rtn == 6) {
				//	cSemiSwitch_Discharge(bd, ch, 0);
					myCh->signal[C_SIG_V_RANGE] = rangeV+1;
					myCh->signal[C_SIG_I_RANGE] = rangeI+1;

					myCh->misc.fbV = 0;
					myCh->misc.fbI = 0;
					myCh->misc.ocv = myCh->op.Vsens;
					myCh->misc.pid_ui1[0] = 0.0;
					myCh->misc.pid_ui1[1] = 0.0;
					myCh->misc.pid_error1[0] = 0.0;
					myCh->misc.pid_error1[1] = 0.0;
					myCh->op.phase = P11;
				} else if(rtn == 2 || rtn == 7) {
					myCh->misc.fbV = 0;
					myCh->misc.fbI = 0;
					myCh->misc.ocv = myCh->op.Vsens;
					myCh->misc.pid_ui1[0] = 0.0;
					myCh->misc.pid_ui1[1] = 0.0;
					myCh->misc.pid_error1[0] = 0.0;
					myCh->misc.pid_error1[1] = 0.0;

					myCh->misc.cmd_v = 0;
					myCh->misc.cmd_v_div = (short int)div;
					myCh->misc.cmd_v_range = (short int)rangeV;
					myCh->misc.cmd_i = val2;
					myCh->misc.cmd_i_div = (short int)div;
					myCh->misc.cmd_i_range = (short int)rangeI;
					myCh->signal[C_SIG_V_RANGE] = rangeV+1;
					myCh->signal[C_SIG_I_RANGE] = rangeI+1;
					cSemiSwitch_Rest(bd,ch,0,0);
					myCh->op.phase = P13;
				}
			}
			break;
		case P11:
		//	cSemiSwitch_Discharge(bd, ch, 1);
			myCh->op.phase = P12;
			break;
		case P12:
			myCh->misc.sensCount = 0;
			myCh->misc.sensCountFlag = P0;
			myCh->misc.sensBufCount = 0;
			myCh->misc.sensBufCountFlag = P0;
			myCh->op.checkDelayTime = 0;
			if(myPs->config.capacityType == CAPACITY_CAPACITANCE) {
				ref_output(bd, ch, val1, val2, div, rangeV, rangeI, mode);
				if(myCh->misc.parallel_cycle_phase == P50) { //kjg_180521
					ref_output_p(bd, ch, parallel_ch, val1, val2, div,
						rangeV, rangeI, mode);
				}
				myCh->signal[C_SIG_IEC_START] = P1;	//171227 add dis
				if(myCh->ChAttribute.opType == P1)
				{
					ref_output(bd, ch+1, val1, val2, div, rangeV, rangeI, mode);
					myCh->signal[C_SIG_IEC_START] = P1;	//171227 add
					myCh = &(myData->bData[bd].cData[ch]);
				}
			} else {
				if((myPs->config.hwSpec == L_5V_6A_R3)
					&&(labs(val2) < labs(refI)) && (rangeI ==2)){
					ref_output(bd, ch, val1, refI, div, rangeV, rangeI, mode);
					if(myCh->misc.parallel_cycle_phase == P50) { //kjg_180521
						ref_output_p(bd, ch, parallel_ch, val1, refI, div,
							rangeV, rangeI, mode);
					}
				}else{
					ref_output(bd, ch, val1, val2, div, rangeV, rangeI, mode);
					if(myCh->misc.parallel_cycle_phase == P50) { //kjg_180521
						ref_output_p(bd, ch, parallel_ch, val1, val2, div,
							rangeV, rangeI, mode);
					}
					if(myCh->ChAttribute.opType == P1)
					{
						ref_output(bd, ch+1, val1, val2, div, rangeV, rangeI, mode);
						myCh = &(myData->bData[bd].cData[ch]);
					}
				}
			}
		//	myCh->op.phase = P50;
			myCh->op.phase = P40;
			break;
		case P13:
			myCh->op.checkDelayTime += myPs->misc.rt_scan_time;
			if(myCh->op.checkDelayTime == 10) {
				cSemiSwitch(bd, ch);
				if(myCh->misc.parallel_cycle_phase == P50) { //kjg_180521
					cSemiSwitch_p(bd, ch, parallel_ch);
				}
			} else if(myCh->op.checkDelayTime >= 30) {
				myCh->misc.sensCount = 0;
				myCh->misc.sensCountFlag = P0;
				myCh->misc.sensBufCount = 0;
				myCh->misc.sensBufCountFlag = P0;
		
				myCh->op.checkDelayTime = 0;
				myCh->signal[C_SIG_OUT_SWITCH] = P1;
				if(myPs->config.hwSpec > DC_DIGITAL_SPEC){//180611 
					myCh->signal[C_SIG_OUT_SWITCH_ON] = P1;
				}
				myCh->signal[C_SIG_V_CMD_OUTPUT] = P1;
				myCh->signal[C_SIG_I_CMD_OUTPUT] = P1;
				myCh->op.phase = P50;
			}
			break;
		//SKI_hun_201010
		case P15:
			myCh->misc.ac_fail_flag = P0;
			rtn = temp_wait_flag_check(bd, ch);
			if(rtn == 0) {
				cSemiSwitch_Start(bd, ch, type);
				break;
			}
			myCh->misc.saveDt = myCh->op.runTime;
			
			rtn = SelectHwSpec(bd , ch);
			if(rtn == 1
				|| rtn == 3
				|| rtn == 4
				|| rtn == 5
				|| rtn == 6) {
			//	cSemiSwitch_Discharge(bd, ch, 0);
				myCh->signal[C_SIG_V_RANGE] = rangeV+1;
				myCh->signal[C_SIG_I_RANGE] = rangeI+1;

				myCh->misc.fbV = 0;
				myCh->misc.fbI = 0;
				myCh->misc.ocv = myCh->op.Vsens;
				myCh->misc.pid_ui1[0] = 0.0;
				myCh->misc.pid_ui1[1] = 0.0;
				myCh->misc.pid_error1[0] = 0.0;
				myCh->misc.pid_error1[1] = 0.0;
				myCh->op.phase = P11;
			} else if(rtn == 2 || rtn == 7) {
				myCh->misc.fbV = 0;
				myCh->misc.fbI = 0;
				myCh->misc.ocv = myCh->op.Vsens;
				myCh->misc.pid_ui1[0] = 0.0;
				myCh->misc.pid_ui1[1] = 0.0;
				myCh->misc.pid_error1[0] = 0.0;
				myCh->misc.pid_error1[1] = 0.0;

				myCh->misc.cmd_v = 0;
				myCh->misc.cmd_v_div = (short int)div;
				myCh->misc.cmd_v_range = (short int)rangeV;
				myCh->misc.cmd_i = val2;
				myCh->misc.cmd_i_div = (short int)div;
				myCh->misc.cmd_i_range = (short int)rangeI;
				myCh->signal[C_SIG_V_RANGE] = rangeV+1;
				myCh->signal[C_SIG_I_RANGE] = rangeI+1;
				cSemiSwitch_Rest(bd,ch,0,0);
				myCh->op.phase = P13;
			}
			break;
		case P20:
			//111130 kji run relay check 
			myCh->op.checkDelayTime += myPs->misc.rt_scan_time;
			if(myCh->op.checkDelayTime >= 100) {
				myCh->op.checkDelayTime = 0;
				myCh->op.phase = P0;
			}
			break;
		case P40:
			myCh->op.checkDelayTime += myPs->misc.rt_scan_time;
			if(myData->mData.config.function[F_SEMI_SWITCH_TYPE] == P1
					|| myCh->ChAttribute.opType == 1 
					|| myCh->ChAttribute.chNo_master == 0) {
				myCh->op.checkDelayTime = 0;			//200320 lyhw
				myCh->op.phase = P50;
			}else{
				//201109_pth
				if(labs(val2) <= myPs->config.maxCurrent[rangeI] * 0.1){
					if(myCh->misc.cvFlag == 0) {
						if(labs(myCh->op.Isens) >= labs(val2*0.8)){
							myCh->op.checkDelayTime = 0;
							myCh->op.phase = P50;
						} else {
							if(myCh->op.checkDelayTime >= 1500) {
								myCh->op.checkDelayTime = 0;
								myCh->op.phase = P50;
							}
							break;
						}
					} else {
						myCh->op.checkDelayTime = 0;
						myCh->op.phase = P50;
					}
				}else{
					myCh->op.checkDelayTime = 0;
					myCh->op.phase = P50;
				}//end
			}
		case P50:
			myCh->misc.start = 0;
	    	myCh->op.runTime += myPs->misc.rt_scan_time;
			myCh->op.totalRunTime += myPs->misc.rt_scan_time;
			myCh->misc.cycleRunTime += myPs->misc.rt_scan_time;
			myCh->op.checkDelayTime += myPs->misc.rt_scan_time;

			sens_ch_ad_count_increment(bd, ch);

			if(myCh->op.runTime >= 30) {
				myCh->misc.meanCount++;
				if(myCh->misc.meanCount <= 8) {
					myCh->misc.meanSumVolt += (myCh->misc.tmpVsens / 100);
					myCh->misc.meanSumCurr += (myCh->misc.tmpIsens / 100);
					myCh->misc.meanSumTemp += (myCh->op.temp / 100);
				} else {
					myCh->misc.meanSumVolt += (myCh->op.Vsens / 100);
					myCh->misc.meanSumCurr += (myCh->op.Isens / 100);
					myCh->misc.meanSumTemp += (myCh->op.temp / 100);
				}
				myCh->op.meanVolt = (long)(myCh->misc.meanSumVolt
					/ myCh->misc.meanCount) * 100;
				myCh->op.meanCurr = (long)(myCh->misc.meanSumCurr
					/ myCh->misc.meanCount) * 100;
				myCh->op.meanTemp = (long)(myCh->misc.meanSumTemp
					/ myCh->misc.meanCount) * 100;
			}

			if(myCh->op.checkDelayTime == myPs->misc.rt_scan_time) {
				if(myPs->config.hwSpec < S_5V_200A) {
					ref_output(bd, ch, val1, val2, div, rangeV, rangeI, mode);
					if(myCh->misc.parallel_cycle_phase == P50) { //kjg_180521
						ref_output_p(bd, ch, parallel_ch, val1, val2, div,
							rangeV, rangeI, mode);
					}
				} else {
					myCh->misc.cmd_v = val1;
					myCh->misc.cmd_v_div = (short int)div;
					myCh->misc.cmd_v_range = (short int)rangeV;
					myCh->signal[C_SIG_V_CMD_OUTPUT] = P1;
				}
			}

			if(myCh->signal[C_SIG_STOP] == P1) {
				myCh->op.code = C_FAULT_STOP_CMD;
				myCh->op.select = SAVE_FLAG_SAVING_END;
				myCh->signal[C_SIG_STOP] = P0;
				cSemiSwitch_Rest(bd, ch, advStepNo, 0);
				myCh->op.phase = P100;
			} else if(myCh->signal[C_SIG_PAUSE] == P1) {
				//cmd, soft fault
				myCh->misc.tmpState = myCh->op.state;
				myCh->misc.tmpCode = myCh->op.code;
				myCh->op.code = C_FAULT_PAUSE_CMD;
				myCh->opSave = myCh->op;
				myCh->signal[C_SIG_PAUSE] = P0;
				cSemiSwitch_Rest(bd, ch, advStepNo, 0);
				myCh->op.phase = P100;
			} else if(myCh->signal[C_SIG_DLL_STOP] == P1) {
				myCh->op.code = C_FAULT_CELL_DIAGNOSIS_STOP;
				myCh->op.select = SAVE_FLAG_SAVING_END;
				myCh->signal[C_SIG_DLL_STOP] = P0;
				cSemiSwitch_Rest(bd, ch, advStepNo, 0);
				myCh->op.phase = P100;
			} else {
				if(cFailCodeCheck(bd, ch) >= 0) {
					cSoftFeedback(bd, ch, val1, val2, val3);
				}

				if(myCh->misc.cvFlag == P1) {
					myCh->misc.cvTime += myPs->misc.rt_scan_time;
					myCh->misc.cycle_Discharge_cvTime
						+= myPs->misc.rt_scan_time;
					//kjc_211028
					#ifdef _ULSAN_SDI_SAFETY
					myCh->misc.cvTime_Ulsan += myPs->misc.rt_scan_time;
					#endif
				} else {
					myCh->misc.ccTime += myPs->misc.rt_scan_time;
					myCh->misc.cycle_Discharge_ccTime
						+= myPs->misc.rt_scan_time;
					//kjc_211028
					#ifdef _ULSAN_SDI_SAFETY
					myCh->misc.cvTime_Ulsan = 0;
					#endif
				}
			}

			//191010
			if(myCh->op.checkDelayTime < 100){
				myCh->misc.Pre_change_V = myCh->misc.tmpVsens;
				//hun_200409_s
				myCh->misc.maxV = myCh->misc.tmpVsens;
				myCh->misc.startV = myCh->misc.tmpVsens;
				myCh->misc.minV = myCh->misc.tmpVsens;
				myCh->misc.maxI = myCh->misc.tmpIsens;
				myCh->misc.minI = myCh->misc.tmpIsens;
				//hun_200409_e
			}
	    	if(myCh->op.checkDelayTime == 100) {
				myCh->misc.maxI = myCh->op.Isens;
				myCh->misc.minI = myCh->op.Isens;
			}

			if(myCh->ChAttribute.opType == P0) {
				cCalculate_Capacitance(bd, ch, advStepNo);
			//20180206 sch add
			#if EDLC_TYPE == 1
				cCalculate_Capacitance_IEC(bd, ch, advStepNo);
				cCalculate_Capacitance_Maxwell(bd, ch, advStepNo);
			#endif
				cCalculate_DCR(bd, ch, advStepNo);
			}

			myCh->ccv[0].avg_v = myCh->misc.tmpVsens;
			myCh->ccv[0].avg_i = myCh->misc.tmpIsens;

			if(myCh->op.phase == P100) {
				cNextStepCheck(bd, ch);
			}
			break;
		case P100:
			break;
		default: break;
    }
}

void cStepRest(int bd, int ch)
{
	int i, rtn = 0, rangeI, rangeV,type, mode;
	unsigned long advStepNo, saveDt;
	S_CH_STEP_INFO step;

	myCh = &(myData->bData[bd].cData[ch]);

	step = step_info(bd, ch);
	type = step.type;
    advStepNo = step.advStepNo;
	rangeV = step.rangeV;
	rangeI = step.rangeI;
	saveDt = step.saveDt;
	mode = step.mode;

    switch(myCh->op.phase) {
		case P0:
			initCh(bd, ch);	
			rtn = temp_wait_flag_check(bd, ch);
			if(rtn == 0) {
				//20180305 sch modify
				cSemiSwitch_Rest(bd, ch, advStepNo, 0);
			//	cSemiSwitch_Start(bd, ch, type);
				break;
			}
			myCh->misc.step_count++;
			myCh->misc.cycleStepCount++;
			myCh->misc.endState = P0;
			myCh->misc.groupEndTime = 0;
			// 111212 oys w : cycleNo
			myCh->misc.cycleNo = myPs->testCond[bd][ch].step[advStepNo].cycleNo;
	
			myCh->op.checkDelayTime = 0;
			myCh->misc.startV = myCh->op.Vsens;
			myCh->misc.maxV = myCh->op.Vsens;
			myCh->misc.minV = myCh->op.Vsens;
			myCh->misc.startT = myCh->op.temp;
			myCh->misc.maxT = myCh->op.temp;
			myCh->misc.minT = myCh->op.temp;
			//150126 lyh add for rest Delta V
			myCh->misc.compareV = myCh->op.Vsens;
			myCh->misc.hw_fault_temp  = myCh->op.runTime;
			//120315 kji 0 sec data option
			//170501 oys modify
			if(myData->DataSave.config.zero_sec_data_save == P1) {
				if(myCh->ChAttribute.opType == P0) {
					if(myCh->ChAttribute.chNo_master == 0) {
						myData->bData[bd].cData[ch-1].op.Isens = 0;
						myData->bData[bd].cData[ch-1].misc.tmpIsens = 0;
						myData->bData[bd].cData[ch-1].op.select
							= SAVE_FLAG_SAVING_TIME;
					}
					myCh->op.Isens = 0;
					myCh->misc.tmpIsens = 0;
					myCh->op.select = SAVE_FLAG_SAVING_TIME;
					send_save_msg(bd, ch, 0, 0);
				}
			}

			rtn = SelectHwSpec(bd , ch);
			if(rtn == 2) {
				myCh->signal[C_SIG_OUT_SWITCH] = P0;
				if(myPs->config.hwSpec > DC_DIGITAL_SPEC){//180611 
					myCh->signal[C_SIG_OUT_SWITCH_OFF] = P1;
				}
			}
			cSemiSwitch_Rest(bd, ch, advStepNo, 0);
	    	myCh->op.phase = P50;
			//0sec save LGC 5V6A 100716 kji
			if(myPs->config.hwSpec == L_5V_6A_R3) myCh->op.phase = P1;
			break;
		case P1:
			myCh->op.select = SAVE_FLAG_SAVING_TIME;
			if(myCh->ChAttribute.opType == P0) {
				send_save_msg(bd, ch, 0, 0);
			}
	    	myCh->op.phase = P50;
			break;
		case P10:
			//SIK_hun_201010_s
			if(myCh->misc.ac_fail_flag == P1){
				myCh->op.phase = P15;
			}else if(myCh->misc.ac_fail_flag == P0){
				myCh->op.runTime += myPs->misc.rt_scan_time;
				myCh->op.totalRunTime += myPs->misc.rt_scan_time;
				myCh->op.phase = P50;
			}
	    	break;
		case P15:
			myCh->misc.ac_fail_flag = P0;
			rtn = temp_wait_flag_check(bd, ch);
			if(rtn == 0) {
				cSemiSwitch_Start(bd, ch, type);
				break;
			}
			myCh->misc.saveDt = myCh->op.runTime;
			//SKI_hun_201010_e
			myCh->op.runTime += myPs->misc.rt_scan_time;
			myCh->op.totalRunTime += myPs->misc.rt_scan_time;
			myCh->op.phase = P50;
			break;
		case P50:
			myCh->misc.start = 0;
			if(myCh->misc.nextDelay < P3 || myCh->misc.nextDelay == P5) {
	    		myCh->op.runTime += myPs->misc.rt_scan_time;
				myCh->op.totalRunTime += myPs->misc.rt_scan_time;
				myCh->misc.cycleRunTime += myPs->misc.rt_scan_time;
			}
			
			myCh->op.checkDelayTime += myPs->misc.rt_scan_time;
			sens_ch_ad_count_increment(bd, ch);
			if(myCh->op.checkDelayTime == 10){
				cSemiSwitch_Rest(bd, ch, advStepNo, 0);
			}else if(myCh->op.checkDelayTime == 20){
				cSemiSwitch_Rest(bd, ch, advStepNo, 1);
			}
			//191010
			if(myCh->op.checkDelayTime < 100){
				myCh->misc.Pre_change_V = myCh->misc.tmpVsens;
			}
			if(myCh->op.runTime >= 30) {
				myCh->misc.meanCount++;
				if(myCh->misc.meanCount <= 8) {
					myCh->misc.meanSumVolt += (myCh->misc.tmpVsens / 100);
					myCh->misc.meanSumCurr += (myCh->misc.tmpIsens / 100);
					myCh->misc.meanSumTemp += (myCh->op.temp / 100);
				} else {
					myCh->misc.meanSumVolt += (myCh->op.Vsens / 100);
					myCh->misc.meanSumCurr += (myCh->op.Isens / 100);
					myCh->misc.meanSumTemp += (myCh->op.temp / 100);
				}
				myCh->op.meanVolt = (long)(myCh->misc.meanSumVolt
					/ myCh->misc.meanCount) * 100;
				myCh->op.meanCurr = (long)(myCh->misc.meanSumCurr
					/ myCh->misc.meanCount) * 100;
				myCh->op.meanTemp = (long)(myCh->misc.meanSumTemp
					/ myCh->misc.meanCount) * 100;
			}
			if(myCh->signal[C_SIG_STOP] == P1) {
				myCh->op.code = C_FAULT_STOP_CMD;
				myCh->op.select = SAVE_FLAG_SAVING_END;
				myCh->signal[C_SIG_STOP] = P0;
				myCh->op.phase = P100;
			} else if(myCh->signal[C_SIG_PAUSE] == P1) {
				myCh->misc.tmpState = myCh->op.state;
				myCh->misc.tmpCode = myCh->op.code;
				myCh->op.code = C_FAULT_PAUSE_CMD;
				myCh->opSave = myCh->op;
				myCh->signal[C_SIG_PAUSE] = P0;
				myCh->op.phase = P100;
			} else if(myCh->signal[C_SIG_DLL_STOP] == P1) {
				myCh->op.code = C_FAULT_CELL_DIAGNOSIS_STOP;
				myCh->op.select = SAVE_FLAG_SAVING_END;
				myCh->signal[C_SIG_DLL_STOP] = P0;
				cSemiSwitch_Rest(bd, ch, advStepNo, 0);
				myCh->op.phase = P100;
			} else {
				i = cFailCodeCheck(bd, ch);
			}
			
			if(myPs->config.hwSpec == L_5V_150A_R3_AD2
				|| myPs->config.hwSpec == L_8CH_MAIN_AD2_P){
				cCalculate_DCR(bd, ch, advStepNo);
			}

			myCh->ccv[0].avg_v = myCh->misc.tmpVsens;
			myCh->ccv[0].avg_i = myCh->misc.tmpIsens;
			if(myCh->op.phase == P100){
				cNextStepCheck(bd, ch);
			}
	    	break;
		case P100:
			break;
		default: break;
    }
}

void cStepOcv(int bd, int ch)
{
	int i, rangeV, rangeI, rtn = 0, mode;
	unsigned long advStepNo, saveDt;

	S_CH_STEP_INFO step;
	myCh = &(myData->bData[bd].cData[ch]);
	step = step_info(bd, ch);

    advStepNo = step.advStepNo;
	rangeV = step.rangeV;
	rangeI = step.rangeI;
	saveDt = step.saveDt;
	mode = step.mode;

    switch(myCh->op.phase) {
		case P0:
			myCh->misc.step_count++;
			myCh->misc.cycleStepCount++;
			myCh->misc.endState = P0;
			myCh->misc.groupEndTime = 0;
			// 111212 oys w : cycleNo
			myCh->misc.cycleNo = myPs->testCond[bd][ch].step[advStepNo].cycleNo;

			initCh(bd, ch);
			myCh->misc.startV = myCh->op.Vsens;
			myCh->misc.startT = myCh->op.temp;
			myCh->misc.maxT = myCh->op.temp;
			myCh->misc.minT = myCh->op.temp;
			rtn = SelectHwSpec(bd , ch);
			if(rtn == 2) {
				myCh->signal[C_SIG_OUT_SWITCH] = P0;
				if(myPs->config.hwSpec > DC_DIGITAL_SPEC){//180611 
					myCh->signal[C_SIG_OUT_SWITCH_OFF] = P1;
				}
			}
//			rtn = temp_wait_flag_check(bd, ch);
//			if(rtn == 0) break;
			cSemiSwitch_Rest(bd, ch, advStepNo, 0);
			myCh->misc.start = 0;
	    	myCh->op.phase = P50;
			break;
		case P10:
		//SIK_hun_201010_s
			if(myCh->misc.ac_fail_flag == P1){
				myCh->op.phase = P15;
			}else if(myCh->misc.ac_fail_flag == P0){
				cSemiSwitch_Rest(bd, ch, advStepNo, 0);
				myCh->misc.start = 0;
		    	myCh->op.phase = P50;
			}
		case P15:
			myCh->misc.ac_fail_flag = P0;
			cSemiSwitch_Rest(bd, ch, advStepNo, 0);
		//SKI_hun_201010_e
			myCh->misc.start = 0;
			myCh->op.phase = P50;
	    	break;
		case P50:
	    	myCh->op.runTime += myPs->misc.rt_scan_time;
			myCh->op.checkDelayTime += myPs->misc.rt_scan_time;
			sens_ch_ad_count_increment(bd, ch);
			if(myCh->op.runTime >= 30) {
				myCh->misc.meanCount++;
				if(myCh->misc.meanCount <= 8) {
					myCh->misc.meanSumVolt += (myCh->misc.tmpVsens / 100);
					myCh->misc.meanSumCurr += (myCh->misc.tmpIsens / 100);
					myCh->misc.meanSumTemp += (myCh->op.temp / 100);
				} else {
					myCh->misc.meanSumVolt += (myCh->op.Vsens / 100);
					myCh->misc.meanSumCurr += (myCh->op.Isens / 100);
					myCh->misc.meanSumTemp += (myCh->op.temp / 100);
				}
				myCh->op.meanVolt = (long)(myCh->misc.meanSumVolt
					/ myCh->misc.meanCount) * 100;
				myCh->op.meanCurr = (long)(myCh->misc.meanSumCurr
					/ myCh->misc.meanCount) * 100;
				myCh->op.meanTemp = (long)(myCh->misc.meanSumTemp
					/ myCh->misc.meanCount) * 100;
			}
			//191010
			if(myCh->op.checkDelayTime < 100){
				myCh->misc.Pre_change_V = myCh->misc.tmpVsens;
			}
			if(myCh->signal[C_SIG_STOP] == P1) {
				myCh->op.code = C_FAULT_STOP_CMD;
				myCh->op.select = SAVE_FLAG_SAVING_END;
				myCh->signal[C_SIG_STOP] = P0;
				myCh->op.phase = P100;
			} else if(myCh->signal[C_SIG_PAUSE] == P1) {
				myCh->misc.tmpState = myCh->op.state;
				myCh->misc.tmpCode = myCh->op.code;
				myCh->op.code = C_FAULT_PAUSE_CMD;
				myCh->opSave = myCh->op;
				myCh->signal[C_SIG_PAUSE] = P0;
				myCh->op.phase = P100;
			} else if(myCh->signal[C_SIG_DLL_STOP] == P1) {
				myCh->op.code = C_FAULT_CELL_DIAGNOSIS_STOP;
				myCh->op.select = SAVE_FLAG_SAVING_END;
				myCh->signal[C_SIG_DLL_STOP] = P0;
				cSemiSwitch_Rest(bd, ch, advStepNo, 0);
				myCh->op.phase = P100;
			} else {
				i = cFailCodeCheck(bd, ch);
			}

			myCh->ccv[0].avg_v = myCh->misc.tmpVsens;
			myCh->ccv[0].avg_i = myCh->misc.tmpIsens;
			if(myCh->op.phase == P100){
				cNextStepCheck(bd, ch);
			}
	    	break;
		case P100:
			break;
		default: break;
    }
}

void cStepZ(int bd, int ch)
{
	int rtn, rangeV, rangeI, div = 5, parallel_ch, mode;
    long val1, val2, val3, refV, refI, type;
	unsigned long advStepNo, saveDt;
	double tmp1, tmp2;
	S_CH_STEP_INFO step;

	myCh = &(myData->bData[bd].cData[ch]);

	step = step_info(bd, ch);

	val1 = val2 = val3 = 0;
	tmp1 = tmp2 = 0.0;

    advStepNo = step.advStepNo;
	rangeV = step.rangeV;
	rangeI = step.rangeI;
	saveDt = step.saveDt;
	type = step.type;
	val1 = step.refV;
	val2 = step.refI;
	val3 = step.refP;
	mode = step.mode;

	refV = myPs->config.maxVoltage[rangeV] * (-1.8);
	refI = -180000;
	//110428 kji 
	refV = val1;
	switch(myPs->config.hwSpec){
		case L_15V_100A_R3_AD2:
			break;
		case L_5V_150A_R2_P:
			refV = 0;
			break;
		default:
			refV = val1;
			break;
	}
	if(myData->mData.config.rt_scan_type > 0){
		refV = myPs->config.maxVoltage[rangeV]*(-1.8);
	}

	//kjg_180521
	if((ch % 2) == 0) parallel_ch = ch + 1;
	else parallel_ch = ch - 1;

    switch(myCh->op.phase) {
		case P0:
			initCh(bd, ch);
			rtn = temp_wait_flag_check(bd, ch);
			if(rtn == 0) {
				cSemiSwitch_Start(bd, ch, type);
				break;
			}
			myCh->misc.step_count++;
			myCh->misc.cycleStepCount++;
			myCh->misc.endState = P0;
			myCh->misc.groupEndTime = 0;
			// 111212 oys w : cycleNo
			myCh->misc.cycleNo = myPs->testCond[bd][ch].step[advStepNo].cycleNo;

			myCh->op.checkDelayTime = 0;
			myCh->misc.startV = myCh->op.Vsens;
			myCh->misc.maxV = myCh->op.Vsens;
			myCh->misc.minV = myCh->op.Vsens;
			myCh->misc.startT = myCh->op.temp;
			myCh->misc.maxT = myCh->op.temp;
			myCh->misc.minT = myCh->op.temp;
			//120315 kji 0 sec data option
			//170501 oys modify
			if(myData->DataSave.config.zero_sec_data_save == P1) {
				if(myCh->ChAttribute.opType == P0) {
					if(myCh->ChAttribute.chNo_master == 0) {
						myData->bData[bd].cData[ch-1].op.Isens = 0;
						myData->bData[bd].cData[ch-1].misc.tmpIsens = 0;
						myData->bData[bd].cData[ch-1].op.select
							= SAVE_FLAG_SAVING_TIME;
					}
					myCh->op.Isens = 0;
					myCh->misc.tmpIsens = 0;
					myCh->op.select = SAVE_FLAG_SAVING_TIME;
					send_save_msg(bd, ch, 0, 0);
				}
			}

			rtn = SelectHwSpec(bd , ch);
			if(rtn == 1) {
				cSemiSwitch_Discharge(bd, ch, 2);
				if(myData->FADM.config.useFlag == P1 ||
					myData->mData.config.FadBdUse == 1){
					myCh->op.checkDelayTime = 0;
					cSemiSwitch_Discharge(bd, ch, 0);
					if(myCh->ChAttribute.opType == P1)
					{
						myCh->signal[C_SIG_TRIGGER] = P1;
//						myData->bData[bd].cData[ch+1].signal[C_SIG_TRIGGER] = P1;
						myData->bData[bd].cData[ch+1].op.checkDelayTime = 0;
					}else if(myData->bData[bd].cData[ch]
							.ChAttribute.opType == P0
							&& myData->bData[bd].cData[ch]
							.ChAttribute.chNo_master == P0){
					}else{
						myCh->signal[C_SIG_TRIGGER] = P1;
					}
		    		myCh->op.phase = P1;
				}else{
					if(myPs->config.capacityType == CAPACITY_CAPACITANCE) {
						ref_output(bd, ch, val1, val2, div, rangeV, rangeI, mode);
						if(myCh->misc.parallel_cycle_phase == P50) {//kjg_180521
							ref_output_p(bd, ch, parallel_ch, val1, val2, div,
								rangeV, rangeI, mode);
						}
						if(myCh->ChAttribute.opType == P1) {
							ref_output(bd, ch+1, val1, val2, div, rangeV, rangeI, mode);
							myCh = &(myData->bData[bd].cData[ch]);
						}
					} else {
						if((myPs->config.hwSpec == L_5V_6A_R3)
							&&(labs(val2) < labs(refI)) && (rangeI ==2)){
							ref_output(bd, ch, refV, refI, div, rangeV, rangeI, mode);
							if(myCh->misc.parallel_cycle_phase == P50) {
								//kjg_180521
								ref_output_p(bd, ch, parallel_ch, refV, refI,
									div, rangeV, rangeI, mode);
							}
						}else{
							ref_output(bd, ch, refV, val2, div, rangeV, rangeI, mode);
							if(myCh->misc.parallel_cycle_phase == P50) {
								//kjg_180521
								ref_output_p(bd, ch, parallel_ch, refV, val2,
									div, rangeV, rangeI, mode);
							}
							if(myCh->ChAttribute.opType == P1)
							{
								ref_output(bd, ch+1, refV, val2, div, rangeV, rangeI, mode);
								myCh = &(myData->bData[bd].cData[ch]);
							}
						}
					}
		    		myCh->op.phase = P50;
				}
			} else if(rtn == 2) {
				myCh->misc.cmd_v = 0;
				myCh->misc.cmd_v_div = (short int)div;
				myCh->misc.cmd_v_range = (short int)rangeV;
				myCh->misc.cmd_i = val2;
				myCh->misc.cmd_i_div = (short int)div;
				myCh->misc.cmd_i_range = (short int)rangeI;
				myCh->signal[C_SIG_OUT_SWITCH] = P0;
				if(myPs->config.hwSpec > DC_DIGITAL_SPEC){//180611 
					myCh->signal[C_SIG_OUT_SWITCH_OFF] = P1;
				}
				cSemiSwitch_Rest(bd, ch,0 ,0);
	    		myCh->op.phase = P5;
			} else if(rtn == 3) {
				cSemiSwitch_Discharge(bd, ch, 0);
				if(myCh->ChAttribute.opType == P1)
				{
					myCh->signal[C_SIG_TRIGGER] = P1;
//					myData->bData[bd].cData[ch+1].signal[C_SIG_TRIGGER] = P1;
				}else if(myData->bData[bd].cData[ch]
						.ChAttribute.opType == P0
						&& myData->bData[bd].cData[ch]
						.ChAttribute.chNo_master == P0){
				}else{
					myCh->signal[C_SIG_TRIGGER] = P1;
				}
	    		myCh->op.phase = P1;
			} else if(rtn == 4) {
				if(myData->FADM.config.countMeter > 0){
		    		myCh->op.phase = P3;
				}else{
					cSemiSwitch(bd, ch);
					if(myCh->misc.parallel_cycle_phase == P50) { //kjg_180521
						cSemiSwitch_p(bd, ch, parallel_ch);
					}
		    		myCh->op.phase = P50;
				}
			} else if(rtn == 5) {
				cSemiSwitch_Discharge(bd, ch, 0);
	    		myCh->op.phase = P2;
			} else if(rtn == 6) {
				cSemiSwitch_Discharge(bd, ch, 0);
				myCh->op.checkDelayTime = 0;

				if(myCh->ChAttribute.opType == P1)
				{
					myCh->signal[C_SIG_TRIGGER] = P1;
//					myData->bData[bd].cData[ch+1].signal[C_SIG_TRIGGER] = P1;
				}else if(myData->bData[bd].cData[ch]
						.ChAttribute.opType == P0
						&& myData->bData[bd].cData[ch]
						.ChAttribute.chNo_master == P0){
				}else{
					myCh->signal[C_SIG_TRIGGER] = P1;
				}
	    		myCh->op.phase = P1;
			} else if(rtn == 7) {
				myCh->misc.cmd_v = 0;
				myCh->misc.cmd_v_div = (short int)div;
				myCh->misc.cmd_v_range = (short int)rangeV;
				myCh->misc.cmd_i = val2;
				myCh->misc.cmd_i_div = (short int)div;
				myCh->misc.cmd_i_range = (short int)rangeI;
				cSemiSwitch_Rest(bd, ch,0 ,0);
	    		myCh->op.phase = P6;
			}
			break;
		case P1:
			myCh->op.checkDelayTime += myPs->misc.rt_scan_time;
			if((myData->FADM.config.useFlag == P1 || 
				myData->mData.config.FadBdUse == 1) &&
					myCh->op.checkDelayTime < 10) {
			} else {
				myCh->misc.sensCount = 0;
				myCh->op.checkDelayTime = 0;
				myCh->misc.sensCountFlag = P0;
				myCh->misc.sensBufCount = 0;
				myCh->misc.sensBufCountFlag = P0;
				if(myPs->config.capacityType == CAPACITY_CAPACITANCE) {
					ref_output(bd, ch, val1, val2, div, rangeV, rangeI, mode);
					if(myCh->misc.parallel_cycle_phase == P50) { //kjg_180521
						ref_output_p(bd, ch, parallel_ch, val1, val2, div,
							rangeV, rangeI, mode);
					}
					if(myCh->ChAttribute.opType == P1)
					{
						ref_output(bd, ch+1, val1, val2, div, rangeV, rangeI, mode);
						myCh = &(myData->bData[bd].cData[ch]);
					}
				} else {
					if((myPs->config.hwSpec == L_5V_6A_R3)
						&&(labs(val2) < labs(refI)) && (rangeI ==2)){
						ref_output(bd, ch, refV, refI, div, rangeV, rangeI, mode);
						if(myCh->misc.parallel_cycle_phase == P50) {//kjg_180521
							ref_output_p(bd, ch, parallel_ch, refV, refI, div,
								rangeV, rangeI, mode);
						}
					}else{
						ref_output(bd, ch, refV, val2, div, rangeV, rangeI, mode);
						if(myCh->misc.parallel_cycle_phase == P50) {//kjg_180521
							ref_output_p(bd, ch, parallel_ch, refV, val2, div,
								rangeV, rangeI, mode);
						}
						if(myCh->ChAttribute.opType == P1)
						{
							ref_output(bd, ch+1, refV, val2, div, rangeV, rangeI, mode);
							myCh = &(myData->bData[bd].cData[ch]);
						}
					}
				}
	
				//0sec save LGC 5V6A 100716 kji
				if(myPs->config.hwSpec == L_5V_6A_R3){
					myCh->op.select = SAVE_FLAG_SAVING_TIME;
					send_save_msg(bd, ch, 0, 0);
				}
		    	myCh->op.phase = P50;
			}
			break;
		case P2:
			myCh->op.checkDelayTime += myPs->misc.rt_scan_time;
			if(myCh->op.checkDelayTime >= 100) {
				myCh->op.checkDelayTime = 0;
				if(myCh->misc.start != 1)
					cSemiSwitch_Discharge(bd, ch, 1);
				if(myCh->ChAttribute.opType == P1)
				{
					myCh->signal[C_SIG_TRIGGER] = P1;
//					myData->bData[bd].cData[ch+1].signal[C_SIG_TRIGGER] = P1;
				}else if(myData->bData[bd].cData[ch]
						.ChAttribute.opType == P0
						&& myData->bData[bd].cData[ch]
						.ChAttribute.chNo_master == P0){
				}else{
					myCh->signal[C_SIG_TRIGGER] = P1;
				}
				myCh->op.phase = P1;
			}
			break;
		case P3:
			myCh->op.checkDelayTime += myPs->misc.rt_scan_time;
			if(myCh->op.checkDelayTime >= 10) {
				myCh->op.checkDelayTime = 0;
				if(myCh->misc.start != 1)
					cSemiSwitch_Discharge(bd, ch, 1);
		    	myCh->op.phase = P4;
			}
			break;
		case P4:
			myCh->misc.sensCount = 0;
			myCh->misc.sensCountFlag = P0;
			myCh->misc.sensBufCount = 0;
			myCh->misc.sensBufCountFlag = P0;
			rtn = SelectHwSpec(bd , ch);
			if(rtn == 4) {
				cSemiSwitch(bd, ch);
				if(myCh->misc.parallel_cycle_phase == P50) { //kjg_180521
					cSemiSwitch_p(bd, ch, parallel_ch);
				}
			} else {
				ref_output(bd, ch, refV, val2, div, rangeV, rangeI, mode);
				if(myCh->misc.parallel_cycle_phase == P50) { //kjg_180521
					ref_output_p(bd, ch, parallel_ch, refV, val2, div,
						rangeV, rangeI, mode);
				}
				if(myCh->ChAttribute.opType == P1)
				{
					ref_output(bd, ch+1, refV, val2, div, rangeV, rangeI, mode);
					myCh = &(myData->bData[bd].cData[ch]);
				}
			}
	    	myCh->op.phase = P50;
			break;
		case P5:
			myCh->op.checkDelayTime += myPs->misc.rt_scan_time;
			if(myCh->op.checkDelayTime == 10) {
				cSemiSwitch(bd, ch);
				if(myCh->misc.parallel_cycle_phase == P50) { //kjg_180521
					cSemiSwitch_p(bd, ch, parallel_ch);
				}
			}else if(myCh->op.checkDelayTime >= 30) {
				myCh->op.checkDelayTime = 0;
				myCh->signal[C_SIG_OUT_SWITCH] = P1;
				if(myPs->config.hwSpec > DC_DIGITAL_SPEC){//180611 
					myCh->signal[C_SIG_OUT_SWITCH_ON] = P1;
				}
				myCh->signal[C_SIG_I_CMD_OUTPUT] = P1;
				myCh->signal[C_SIG_V_CMD_OUTPUT] = P1;
				myCh->op.phase = P50;
			}
			break;
		case P6:
			myCh->op.checkDelayTime += myPs->misc.rt_scan_time;
			if(myCh->op.checkDelayTime <= 2) {
				cSemiSwitch(bd, ch);
				if(myCh->misc.parallel_cycle_phase == P50) { //kjg_180521
					cSemiSwitch_p(bd, ch, parallel_ch);
				}
			}else if(myCh->op.checkDelayTime >= 4) {
				myCh->op.checkDelayTime = 0;
				myCh->signal[C_SIG_OUT_SWITCH] = P1;
				if(myPs->config.hwSpec > DC_DIGITAL_SPEC){//180611 
					myCh->signal[C_SIG_OUT_SWITCH_ON] = P1;
				}
				myCh->signal[C_SIG_I_CMD_OUTPUT] = P1;
				myCh->signal[C_SIG_V_CMD_OUTPUT] = P1;
				myCh->op.phase = P50;
			}
			break;
		case P10:
		//SKI_hun_201010
			if(myCh->misc.ac_fail_flag == P1){
				myCh->op.phase = P15;
			}else if(myCh->misc.ac_fail_flag == P0){
				rtn = SelectHwSpec(bd , ch);
				if(rtn == 1
					|| rtn == 3
					|| rtn == 4
					|| rtn == 5
					|| rtn == 6) {
					cSemiSwitch_Discharge(bd, ch, 0);
					myCh->misc.ocv = myCh->op.Vsens;
					myCh->signal[C_SIG_V_RANGE] = rangeV+1;
					myCh->signal[C_SIG_I_RANGE] = rangeI+1;
				
					myCh->misc.fbV = 0;
					myCh->misc.fbI = 0;
					myCh->misc.ocv = myCh->op.Vsens;
					myCh->misc.pid_ui1[0] = 0.0;
					myCh->misc.pid_ui1[1] = 0.0;
					myCh->misc.pid_error1[0] = 0.0;
					myCh->misc.pid_error1[1] = 0.0;
					myCh->op.phase = P11;
				} else if(rtn == 2 || rtn == 7) {
					myCh->misc.ocv = myCh->op.Vsens;
				
					myCh->misc.fbV = 0;
					myCh->misc.fbI = 0;
				
					myCh->misc.cmd_v = 0;
					myCh->misc.cmd_v_div = (short int)div;
					myCh->misc.cmd_v_range = (short int)rangeV;
					myCh->misc.cmd_i = val2;
					myCh->misc.cmd_i_div = (short int)div;
					myCh->misc.cmd_i_range = (short int)rangeI;
					myCh->signal[C_SIG_V_RANGE] = rangeV+1;
					myCh->signal[C_SIG_I_RANGE] = rangeI+1;
					cSemiSwitch_Rest(bd,ch,0,0);
					myCh->op.phase = P13;
				}
			}
	    	break;
		case P11:
			cSemiSwitch_Discharge(bd, ch, 1);
			myCh->op.phase = P12;
			break;
		case P12:
			myCh->misc.sensCount = 0;
			myCh->misc.sensCountFlag = P0;
			myCh->misc.sensBufCount = 0;
			myCh->misc.sensBufCountFlag = P0;
			myCh->op.checkDelayTime = 0;
			if(myPs->config.capacityType == CAPACITY_CAPACITANCE) {
				ref_output(bd, ch, val1, val2, div, rangeV, rangeI, mode);
				if(myCh->misc.parallel_cycle_phase == P50) { //kjg_180521
					ref_output_p(bd, ch, parallel_ch, val1, val2, div,
						rangeV, rangeI, mode);
				}
				if(myCh->ChAttribute.opType == P1)
				{
					ref_output(bd, ch+1, val1, val2, div, rangeV, rangeI, mode);
					myCh = &(myData->bData[bd].cData[ch]);
				}
			} else {
				if((myPs->config.hwSpec == L_5V_6A_R3)
					&&(labs(val2) < labs(refI)) && (rangeI ==2)){
					ref_output(bd, ch, val1, refI, div, rangeV, rangeI, mode);
					if(myCh->misc.parallel_cycle_phase == P50) { //kjg_180521
						ref_output_p(bd, ch, parallel_ch, val1, refI, div,
							rangeV, rangeI, mode);
					}
				}else{
					ref_output(bd, ch, val1, val2, div, rangeV, rangeI, mode);
					if(myCh->misc.parallel_cycle_phase == P50) { //kjg_180521
						ref_output_p(bd, ch, parallel_ch, val1, val2, div,
							rangeV, rangeI, mode);
					}
					if(myCh->ChAttribute.opType == P1)
					{
						ref_output(bd, ch+1, val1, val2, div, rangeV, rangeI, mode);
						myCh = &(myData->bData[bd].cData[ch]);
					}
				}
			}
			myCh->op.phase = P50;
			break;
		case P13:
			myCh->op.checkDelayTime += myPs->misc.rt_scan_time;
			if(myCh->op.checkDelayTime == 10) {
				cSemiSwitch(bd, ch);
				if(myCh->misc.parallel_cycle_phase == P50) { //kjg_180521
					cSemiSwitch_p(bd, ch, parallel_ch);
				}
			} else if(myCh->op.checkDelayTime >= 30) {
				myCh->misc.sensCount = 0;
				myCh->misc.sensCountFlag = P0;
				myCh->misc.sensBufCount = 0;
				myCh->misc.sensBufCountFlag = P0;
		
				myCh->op.checkDelayTime = 0;
				myCh->signal[C_SIG_OUT_SWITCH] = P1;
				if(myPs->config.hwSpec > DC_DIGITAL_SPEC){//180611 
					myCh->signal[C_SIG_OUT_SWITCH_ON] = P1;
				}
				myCh->signal[C_SIG_V_CMD_OUTPUT] = P1;
				myCh->signal[C_SIG_I_CMD_OUTPUT] = P1;
				myCh->op.phase = P50;
			}
			break;
		//SKI_hun_201010
		case P15:
			myCh->misc.ac_fail_flag = P0;
			rtn = temp_wait_flag_check(bd, ch);
			if(rtn == 0) {
				cSemiSwitch_Start(bd, ch, type);
				break;
			}
			myCh->misc.saveDt = myCh->op.runTime;
			rtn = SelectHwSpec(bd , ch);
			if(rtn == 1
				|| rtn == 3
				|| rtn == 4
				|| rtn == 5
				|| rtn == 6) {
				cSemiSwitch_Discharge(bd, ch, 0);
				myCh->misc.ocv = myCh->op.Vsens;
				myCh->signal[C_SIG_V_RANGE] = rangeV+1;
				myCh->signal[C_SIG_I_RANGE] = rangeI+1;
			
				myCh->misc.fbV = 0;
				myCh->misc.fbI = 0;
				myCh->misc.ocv = myCh->op.Vsens;
				myCh->misc.pid_ui1[0] = 0.0;
				myCh->misc.pid_ui1[1] = 0.0;
				myCh->misc.pid_error1[0] = 0.0;
				myCh->misc.pid_error1[1] = 0.0;
				myCh->op.phase = P11;
			} else if(rtn == 2 || rtn == 7) {
				myCh->misc.ocv = myCh->op.Vsens;
			
				myCh->misc.fbV = 0;
				myCh->misc.fbI = 0;
			
				myCh->misc.cmd_v = 0;
				myCh->misc.cmd_v_div = (short int)div;
				myCh->misc.cmd_v_range = (short int)rangeV;
				myCh->misc.cmd_i = val2;
				myCh->misc.cmd_i_div = (short int)div;
				myCh->misc.cmd_i_range = (short int)rangeI;
				myCh->signal[C_SIG_V_RANGE] = rangeV+1;
				myCh->signal[C_SIG_I_RANGE] = rangeI+1;
				cSemiSwitch_Rest(bd,ch,0,0);
				myCh->op.phase = P13;
			}
			break;
		case P20: //111130 kji run relay check 
			myCh->op.checkDelayTime += myPs->misc.rt_scan_time;
			if(myCh->op.checkDelayTime >= 100) {
				myCh->op.checkDelayTime = 0;
				myCh->op.phase = P0;
			}
			break;
		case P50:
			myCh->misc.start = 0;
	    	myCh->op.runTime += myPs->misc.rt_scan_time;
			myCh->op.totalRunTime += myPs->misc.rt_scan_time;
			myCh->misc.cycleRunTime += myPs->misc.rt_scan_time;
			myCh->op.checkDelayTime += myPs->misc.rt_scan_time;

			sens_ch_ad_count_increment(bd, ch);

			if(myCh->op.runTime >= 30) {
				myCh->misc.meanCount++;
				if(myCh->misc.meanCount <= 8) {
					myCh->misc.meanSumVolt += (myCh->misc.tmpVsens / 100);
					myCh->misc.meanSumCurr += (myCh->misc.tmpIsens / 100);
					myCh->misc.meanSumTemp += (myCh->op.temp / 100);
				} else {
					myCh->misc.meanSumVolt += (myCh->op.Vsens / 100);
					myCh->misc.meanSumCurr += (myCh->op.Isens / 100);
					myCh->misc.meanSumTemp += (myCh->op.temp / 100);
				}
				myCh->op.meanVolt = (long)(myCh->misc.meanSumVolt
					/ myCh->misc.meanCount) * 100;
				myCh->op.meanCurr = (long)(myCh->misc.meanSumCurr
					/ myCh->misc.meanCount) * 100;
				myCh->op.meanTemp = (long)(myCh->misc.meanSumTemp
					/ myCh->misc.meanCount) * 100;
			}

			if(myCh->op.checkDelayTime == myPs->misc.rt_scan_time) {
				if(myPs->config.hwSpec < S_5V_200A) {
					ref_output(bd, ch, val1, val2, div, rangeV, rangeI, mode);
					if(myCh->misc.parallel_cycle_phase == P50) { //kjg_180521
						ref_output_p(bd, ch, parallel_ch, val1, val2, div,
							rangeV, rangeI, mode);
					}
				} else {
					myCh->misc.cmd_v = val1;
					myCh->misc.cmd_v_div = (short int)div;
					myCh->misc.cmd_v_range = (short int)rangeV;
					myCh->signal[C_SIG_V_CMD_OUTPUT] = P1;
				}
			}

			if(myCh->signal[C_SIG_STOP] == P1) {
				myCh->op.code = C_FAULT_STOP_CMD;
				myCh->op.select = SAVE_FLAG_SAVING_END;
				myCh->signal[C_SIG_STOP] = P0;
				cSemiSwitch_Rest(bd, ch, advStepNo, 0);
				myCh->op.phase = P100;
			} else if(myCh->signal[C_SIG_PAUSE] == P1) {
				myCh->misc.tmpState = myCh->op.state;
				myCh->misc.tmpCode = myCh->op.code;
				myCh->op.code = C_FAULT_PAUSE_CMD;
				myCh->opSave = myCh->op;
				myCh->signal[C_SIG_PAUSE] = P0;
				cSemiSwitch_Rest(bd, ch, advStepNo, 0);
				myCh->op.phase = P100;
			} else if(myCh->signal[C_SIG_DLL_STOP] == P1) {
				myCh->op.code = C_FAULT_CELL_DIAGNOSIS_STOP;
				myCh->op.select = SAVE_FLAG_SAVING_END;
				myCh->signal[C_SIG_DLL_STOP] = P0;
				cSemiSwitch_Rest(bd, ch, advStepNo, 0);
				myCh->op.phase = P100;
			} else {
				if(cFailCodeCheck(bd, ch) >= 0) {
					cSoftFeedback(bd, ch, val1, val2, val3);
				}
			}

/* 20120126 kji value move phase 0
			if(myCh->op.checkDelayTime == 100) {
				myCh->misc.maxV = myCh->op.Vsens;
				myCh->misc.minV = myCh->op.Vsens;
				myCh->misc.maxI = myCh->op.Isens;
				myCh->misc.minI = myCh->op.Isens;
			}
*/

			//191010
			if(myCh->op.checkDelayTime < 100){
				myCh->misc.Pre_change_V = myCh->misc.tmpVsens;
			}
	    	if(myCh->op.checkDelayTime == 100) {
				myCh->misc.maxI = myCh->op.Isens;
				myCh->misc.minI = myCh->op.Isens;
			}

//			cCalculate_Capacitance(bd, ch, advStepNo);
			if(myCh->ChAttribute.opType == P0)
				cCalculate_DCR(bd, ch, advStepNo);

			myCh->ccv[0].avg_v = myCh->misc.tmpVsens;
			myCh->ccv[0].avg_i = myCh->misc.tmpIsens;

			if(myCh->op.phase == P100) {
				cNextStepCheck(bd, ch);
			}
			break;
		case P100:
			break;
		default: break;
    }
}

void cStepAcir(int bd, int ch)
{
	int i, rtn = 0, rangeI, rangeV, type, mode;
	unsigned long advStepNo, saveDt;
	S_CH_STEP_INFO step;

	myCh = &(myData->bData[bd].cData[ch]);

	step = step_info(bd, ch);
	type = step.type;
	advStepNo = step.advStepNo;
	rangeV = step.rangeV;
	rangeI = step.rangeI;
	saveDt = step.saveDt;
	mode = step.mode;

	switch(myCh->op.phase){
		case P0:
			initCh(bd ,ch);
			rtn = acir_wait_flag_check(bd, ch);
			if(rtn == 0){
				break;
			}
			myCh->misc.step_count++;
			myCh->misc.cycleStepCount++;
			myCh->misc.cycleNo = myPs->testCond[bd][ch].step[advStepNo].cycleNo;
			
			myCh->op.phase = P50;
			break;
		case P10:
			if(myCh->misc.ac_fail_flag == P1){
				myCh->op.phase = P15;
			}else if(myCh->misc.ac_fail_flag == P0){
				myCh->op.phase = P0;
			}
			break;
		case P15:
			myCh->misc.ac_fail_flag = P0;
			rtn = acir_wait_flag_check(bd, ch);
			if(rtn == 0){
				break;
			}
			myCh->op.phase = P50;
			break;
		case P50:
			myCh->misc.start = 0;
			if(myCh->signal[C_SIG_STOP] == P1){
				myCh->op.code = C_FAULT_STOP_CMD;
				myCh->op.select = SAVE_FLAG_SAVING_END;
				myCh->signal[C_SIG_STOP] = P0;
				myCh->op.phase = P100;
			}else if(myCh->signal[C_SIG_PAUSE] == P1){
				myCh->misc.tmpState = myCh->op.state;
				myCh->misc.tmpCode = myCh->op.code;
				myCh->op.code = C_FAULT_PAUSE_CMD;
				myCh->opSave = myCh->op;
				myCh->signal[C_SIG_PAUSE] = P0;
				myCh->op.phase = P100;
			} else {
				i = cFailCodeCheck(bd, ch);
			}
			if(myCh->op.phase == P100){
				cNextStepCheck(bd, ch);
			}
			break;
		case P100:
			break;
		default: break;
	}
}

S_USER_PATTERN_DATA pattern_info(int bd, int ch)
{
	int i = 0, rangeV;
	long advStepNo, refI = 0, refP = 0 , nextRef = 0;
#ifdef _TRACKING_MODE
	long refI_Limit = 0, refP_Limit = 0, nextRef_Limit = 0;
	long refP_2 = 0, refP_Limit_2 = 0, nextRef_2 = 0, nextRef_Limit_2 = 0;
#endif
	S_USER_PATTERN_DATA pattern;

	myCh = &(myData->bData[bd].cData[ch]);
	myTestCond = &(myPs->testCond[bd][ch]);

	rangeV = 0;
	memset((char *)&pattern, 0, sizeof(S_USER_PATTERN_DATA));

	advStepNo = myCh->misc.advStepNo;

#if USER_PATTERN_500 == 0
	pattern.length = myData->mData.testCond[bd][ch].userPattern.length;
	pattern.type = myData->mData.testCond[bd][ch].userPattern.type;

	if(myData->mData.config.function[F_PATTERN_PROCESS] == 1){
		if(myCh->misc.userPatternCnt >= pattern.length) {
			myCh->misc.userPatternCnt = 0;
			myCh->misc.userPatternRunTime = myCh->op.runTime;
		}
	}else{
		if(myCh->misc.userPatternCnt >= pattern.length - 1) {
			myCh->misc.userPatternCnt = 0;
			myCh->misc.userPatternRunTime = myCh->op.runTime;
		}
	}
	
	i = myCh->misc.userPatternCnt;
	pattern.time = myData->mData.testCond[bd][ch].userPattern.data[i].time;
	
#else
	switch(myCh->misc.pattern_change_flag){
		case 0:
			pattern.length = myTestCond->userPattern.length;
			pattern.type = myTestCond->userPattern.type;
			pattern.totalNumber = myTestCond->userPattern.totalNumber;
			pattern.Number = myTestCond->userPattern.Number;
			myCh->misc.StepPattern_TotalNum = pattern.totalNumber;
		
			if(pattern.totalNumber > 1){
				if(myCh->misc.userPatternCnt >= pattern.length){
					myCh->misc.userPatternCnt = 0;
					myCh->misc.pattern_change_flag = 1;
					myCh->misc.userPattern_ReadFlag = 1;
					if(pattern.totalNumber == pattern.Number){
						myCh->misc.userPatternRunTime = myCh->op.runTime;
					}
				}
			}else{
				if(myCh->misc.userPatternCnt >= pattern.length - 1) {
					myCh->misc.userPatternCnt = 0;
					myCh->misc.userPatternRunTime = myCh->op.runTime;
				}
			}
								
			i = myCh->misc.userPatternCnt;
			pattern.time = myTestCond->userPattern.data[i].time;
			break;
		case 1:
			pattern.length = myTestCond->userPatternBuf.length;
			pattern.type = myTestCond->userPatternBuf.type;
			pattern.totalNumber = myTestCond->userPatternBuf.totalNumber;
			pattern.Number = myTestCond->userPatternBuf.Number;
			myCh->misc.StepPattern_TotalNum = pattern.totalNumber;
			
			if(myCh->misc.userPatternCnt >= pattern.length) {
				myCh->misc.userPatternCnt = 0;
				myCh->misc.pattern_change_flag = 0;
				myCh->misc.userPattern_ReadFlag = 1;
				if(pattern.totalNumber == pattern.Number){
					myCh->misc.userPatternRunTime = myCh->op.runTime;
				}
			}
					
			i = myCh->misc.userPatternCnt;
			pattern.time = myTestCond->userPatternBuf.data[i].time;
			break;
		default:
			break;
	}	
#endif
	//200805 lyh Test
	if(myData->mData.config.function[F_PATTERN_PROCESS] == 1){
		//add for After 0s Current Output
		if(pattern.time == 0 && myCh->op.runTime == 0){
			i = i+1;
		}
	}

	//20180717 sch modify for refV(min/max)
	switch((unsigned char)pattern.type) {
		case PS_CURRENT:
		case PS_C_RATE:
			if(myCh->misc.pattern_change_flag == 0){
				refI = myTestCond->userPattern.data[i].data;
				nextRef = myTestCond->userPattern.data[i+1].data;
			}else{
			#if USER_PATTERN_500 == P1
				refI = myTestCond->userPatternBuf.data[i].data;
				nextRef = myTestCond->userPatternBuf.data[i+1].data;
			#endif
			}

			if(pattern.type == PS_C_RATE) {
				refI = Convert_C_rate_to_I_value(bd, ch, refI);
				nextRef = Convert_C_rate_to_I_value(bd, ch, nextRef);
			}

			if(myCh->misc.parallel_cycle_phase == P50){	//180531 lyhw
				refI = refI / 2;
				nextRef = nextRef / 2;
			}
#ifdef _TRACKING_MODE
			if(myPs->testCond[bd][ch].step[advStepNo].SOC_Tracking_flag == P1){	
				refI = myTestCond->userPattern.data[i].data;
				if(myPs->testCond[bd][ch].step[advStepNo].trackingMode_flag == P1){ //210720
					refI_Limit = cFind_SOV_Tracking_Current_pattern(bd,ch,refI);
				}else{
					refI_Limit = cFind_SOC_Tracking_Current_pattern(bd,ch,refI);
				}
				if(refI > 0 && refI > refI_Limit) refI = refI_Limit;
				else refI = myTestCond->userPattern.data[i].data;

				nextRef = myTestCond->userPattern.data[i+1].data;

				if(myPs->testCond[bd][ch].step[advStepNo].trackingMode_flag == P1){ //210720
					nextRef_Limit = cFind_SOV_Tracking_Current_pattern(bd,ch,nextRef);
				}else{
					nextRef_Limit = cFind_SOC_Tracking_Current_pattern(bd,ch,nextRef);
				}
				if(nextRef > 0 && nextRef > nextRef_Limit) nextRef = nextRef_Limit;
				else nextRef = myTestCond->userPattern.data[i+1].data;
			}				
#endif			

			myData->mData.testCond[bd][ch].step[advStepNo].refI = refI;
			if(myCh->misc.cmdV_dir == CMD_V_PLUS){
				myCh->misc.cmdV_dir = CMD_V_IDLE;
				myData->mData.testCond[bd][ch].step[advStepNo].refV
			//		= myData->mData.config.maxVoltage[rangeV]*(1.8);
					= myData->mData.config.maxVoltage[rangeV];
			}else if(myCh->misc.cmdV_dir == CMD_V_MINUS){
				myCh->misc.cmdV_dir = CMD_V_IDLE;
				if(myPs->config.hwSpec == S_5V_200A_75A_15A_AD2) {
					myData->mData.testCond[bd][ch].step[advStepNo].refV = 0;
				} else {
					myData->mData.testCond[bd][ch].step[advStepNo].refV
						= myData->mData.config.minVoltage[rangeV];
				}
			}else{
				if(refI > 0){
					myData->mData.testCond[bd][ch].step[advStepNo].refV
//						= myData->mData.config.maxVoltage[rangeV]*(1.8);
						= myData->mData.config.maxVoltage[rangeV];
				}else if(refI < 0){
					if(myPs->config.hwSpec == S_5V_200A_75A_15A_AD2) {
						myData->mData.testCond[bd][ch].step[advStepNo].refV = 0;
					} else {
						myData->mData.testCond[bd][ch].step[advStepNo].refV
//							= myData->mData.config.maxVoltage[rangeV]*(-1.8);
							= myData->mData.config.minVoltage[rangeV];
					}
				}else {
					if(nextRef > 0) {
						myData->mData.testCond[bd][ch].step[advStepNo].refV 
//							= myData->mData.config.maxVoltage[rangeV]*(1.8);
							= myData->mData.config.maxVoltage[rangeV];
					} else if(nextRef < 0) {
						if(myPs->config.hwSpec == S_5V_200A_75A_15A_AD2) {
							myData->mData.testCond[bd][ch].step[advStepNo].refV = 0;
						} else {
							myData->mData.testCond[bd][ch].step[advStepNo].refV 
//							= myData->mData.config.maxVoltage[rangeV]*(-1.8);
								= myData->mData.config.minVoltage[rangeV];
						}
					} else {
						if(myPs->config.hwSpec == S_5V_200A_75A_15A_AD2) {
							myData->mData.testCond[bd][ch].step[advStepNo].refV 
								= myData->mData.config.maxVoltage[rangeV]*(1.8);
						} else {
							myData->mData.testCond[bd][ch].step[advStepNo].refV = 0;
						}
					}
				}
			}
			break;
		case PS_WATT:
			if(myCh->misc.pattern_change_flag == 0){
				refP = myTestCond->userPattern.data[i].data ;
				nextRef = myTestCond->userPattern.data[i+1].data;
			}else{
			#if USER_PATTERN_500 == P1
				refP = myTestCond->userPatternBuf.data[i].data ;
				nextRef = myTestCond->userPatternBuf.data[i+1].data;
			#endif
			}
			if(myCh->misc.parallel_cycle_phase == P50){	//180531 lyhw
				refP = refP / 2;
				nextRef = nextRef / 2;
			}
#ifdef _TRACKING_MODE
			if(myPs->testCond[bd][ch].step[advStepNo].SOC_Tracking_flag == P1){	
				refP = myTestCond->userPattern.data[i].data;
				refP_2 = refP * 1000;
				if(myPs->testCond[bd][ch].step[advStepNo].trackingMode_flag == P1){ //210720
					refP_Limit = cFind_SOV_Tracking_Current_pattern(bd,ch,refP_2);
				}else{
					refP_Limit = cFind_SOC_Tracking_Current_pattern(bd,ch,refP_2);
				}
				refP_Limit_2 = refP_Limit / 1000;
				if(refP > 0 && refP > refP_Limit_2) refP = refP_Limit_2;
				else refP = myTestCond->userPattern.data[i].data;

				nextRef = myTestCond->userPattern.data[i+1].data;
				nextRef_2 = nextRef * 1000;
				if(myPs->testCond[bd][ch].step[advStepNo].trackingMode_flag == P1){ //210720

					nextRef_Limit = cFind_SOV_Tracking_Current_pattern(bd,ch,nextRef_2);
				}else{
					nextRef_Limit = cFind_SOC_Tracking_Current_pattern(bd,ch,nextRef_2);
				}
				if(nextRef > 0 && nextRef > nextRef_Limit_2) nextRef = nextRef_Limit_2;
				else nextRef = myTestCond->userPattern.data[i+1].data;
			}				
#endif			
			myData->mData.testCond[bd][ch].step[advStepNo].refP = refP;
			if(refP > 0){
				myData->mData.testCond[bd][ch].step[advStepNo].refV
			//		= myData->mData.config.maxVoltage[rangeV]*(1.8);
					= myData->mData.config.maxVoltage[rangeV];
			}else if(refP < 0){
				if(myPs->config.hwSpec == S_5V_200A_75A_15A_AD2) {
					myData->mData.testCond[bd][ch].step[advStepNo].refV = 0;
				} else {
					myData->mData.testCond[bd][ch].step[advStepNo].refV
			//			= myData->mData.config.maxVoltage[rangeV]*(-1.8);
						= myData->mData.config.minVoltage[rangeV];
				}
			}else {
				if(nextRef > 0) {
					myData->mData.testCond[bd][ch].step[advStepNo].refV 
					//	= myData->mData.config.maxVoltage[rangeV]*(1.8);
						= myData->mData.config.maxVoltage[rangeV];
				} else if(nextRef < 0) {
					if(myPs->config.hwSpec == S_5V_200A_75A_15A_AD2) {
						myData->mData.testCond[bd][ch].step[advStepNo].refV = 0;
					} else {
						myData->mData.testCond[bd][ch].step[advStepNo].refV 
						//	= myData->mData.config.maxVoltage[rangeV]*(-1.8);
							= myData->mData.config.minVoltage[rangeV];
					}
				} else {
					myData->mData.testCond[bd][ch].step[advStepNo].refV = 0;
				}
			}
			break;
	}

	return pattern;
}

int find_pattern_time(int bd, int ch, long time)
{
	int value = 0;
	
	if(myData->mData.config.function[F_PATTERN_PROCESS] == 1){
		value = find_pattern_time_2(bd, ch, time);
	}else{
		value = find_pattern_time_Default(bd, ch, time);
	}
	
	return value;
}

int find_pattern_time_Default(int bd, int ch, long time)
{
	int i = 0;
	long length;

	myCh = &(myData->bData[bd].cData[ch]);
	myTestCond = &(myPs->testCond[bd][ch]);
#if USER_PATTERN_500 == 0
	length = myData->mData.testCond[bd][ch].userPattern.length;
//	for(i = 0; i < length; i++)
//	111008 kji slot time over
	for(i = myData->bData[bd].cData[ch].misc.userPatternCnt; i < length; i++){
		if(time <= myData->mData.testCond[bd][ch].userPattern.data[i].time){
			if(i == 0)	continue;
			else		break;
		}
	}
#else
	if(myCh->misc.StepPattern_TotalNum > 1){
		if(myCh->misc.pattern_change_flag == 0){
			length = myTestCond->userPattern.length;
			for(i = myCh->misc.userPatternCnt; i <= length; i++){
				if(time <= myTestCond->userPattern.data[i].time){
					if(i == 0)	continue;
					else		break;
				}
		
				if(i == length){
					if(time <= myTestCond->userPatternBuf.data[0].time){
						i = length;
						break;
					}
				}
			}
		}else{
			length = myTestCond->userPatternBuf.length;
			for(i = myCh->misc.userPatternCnt; i <= length; i++){
				if(time <= myTestCond->userPatternBuf.data[i].time){
					if(i == 0)	continue;
					else		break;
				}
				
				if(i == length){
					if(time <= myTestCond->userPattern.data[0].time){
						i = length;
						break;
					}
				}
			}
		}
	}else{
		length = myTestCond->userPattern.length;
		for(i = myCh->misc.userPatternCnt; i < length; i++){
			if(time <= myTestCond->userPattern.data[i].time){
				if(i == 0)	continue;
				else		break;
			}
		}
	}
#endif
	return i-1;
}

int find_pattern_time_2(int bd, int ch, long time)
{
	int i = 0;
	long length;

	myCh = &(myData->bData[bd].cData[ch]);
	myTestCond = &(myPs->testCond[bd][ch]);
#if USER_PATTERN_500 == 0
	length = myData->mData.testCond[bd][ch].userPattern.length;
	for(i = myData->bData[bd].cData[ch].misc.userPatternCnt; i <= length; i++){
		if(time <= myData->mData.testCond[bd][ch].userPattern.data[i].time){
			if(i == 0)	continue;
			else		break;
		}
	}
#else
	if(myCh->misc.StepPattern_TotalNum > 1){
		if(myCh->misc.pattern_change_flag == 0){
			length = myTestCond->userPattern.length;
			for(i = myCh->misc.userPatternCnt; i <= length; i++){
				if(time <= myTestCond->userPattern.data[i].time){
					if(i == 0){
						if(myTestCond->userPattern.data[i].time == 0){ 
							continue;
						}else{	
							break;
						}
					}else{
						break;
					}
				}
		
				if(i == length){
					if(time <= myTestCond->userPatternBuf.data[0].time){
						i = length;
						break;
					}
				}
			}
		}else{
			length = myTestCond->userPatternBuf.length;
			for(i = myCh->misc.userPatternCnt; i <= length; i++){
				if(time <= myTestCond->userPatternBuf.data[i].time){
					if(i == 0){
						if(myTestCond->userPatternBuf.data[i].time == 0){ 
							continue;
						}else{
							break;
						}
					}else{
						break;
					}
				}
				
				if(i == length){
					if(time <= myTestCond->userPattern.data[0].time){
						i = length;
						break;
					}
				}
			}
		}
	}else{
		length = myTestCond->userPattern.length;
		for(i = myCh->misc.userPatternCnt; i <= length; i++){
			if(time <= myTestCond->userPattern.data[i].time){
				if(i == 0)	continue;
				else		break;
			}
		}
	}
#endif
	return i;
}

void user_pattern_data(int bd, int ch)
{
	int div = 5, rangeV, rangeI, parallel_ch, mode;
	long val1, val2, refV, maxI;
	S_USER_PATTERN_DATA pattern;
	S_CH_STEP_INFO step;

	myCh = &(myData->bData[bd].cData[ch]);

	pattern = pattern_info(bd, ch);
	step = step_info(bd, ch);

	val1 = step.refV;
	val2 = step.refI;
	rangeV = step.rangeV;
	rangeI = step.rangeI;
	mode = step.mode;
	maxI = myPs->config.maxCurrent[rangeI];

	myCh->misc.sensCount = 0;
	myCh->misc.sensCountFlag = P0;
	myCh->misc.sensBufCount = 0;
	myCh->misc.sensBufCountFlag = P0;
	myCh->misc.fbSumI_M = 0;
	myCh->misc.fbCountI_M = 0;
	myCh->misc.fbSumI_H = 0;
	myCh->misc.fbCountI_H = 0;
	myCh->misc.fbSumI_L = 0;
	myCh->misc.fbCountI_L = 0;

#if CYCLER_TYPE == LINEAR_CYC || CYCLER_TYPE == CAN_CYC
	if(myPs->misc.rt_scan_time <= 2) { //rt_scan_time : 20ms, 10ms
		if(val2 > 0) { //charge
			if(myCh->misc.pattern_cross <= 0) {
				if(labs(val2) <= (long)(maxI*0.05)){
					val2 = (long)(maxI*0.1); //10%
				}
			}
		}else if(val2 < 0) { //discharge
			if(myCh->misc.pattern_cross >= 0) {
				if(labs(val2) <= (long)(maxI*0.05)){
					val2 = (long)(-maxI*0.1); //10%
				}
			}
		}
	}
#endif

	refV = val1;
	switch(myPs->config.hwSpec) {
		case L_5V_150A_R2_P:
			if(myCh->misc.preIref >= 0 && val2 < 0) { //charge -> discharge
				if(val1 > 0) {	
					refV = 0;
					myCh->misc.refFlag = P1;
				} else {
					refV = val1;
				}
			}
			if(myCh->misc.preIref < 0 && val2 >= 0) { //discharge -> charge
				if(val1 < myPs->config.maxVoltage[rangeV])	{
					refV = myPs->config.maxVoltage[rangeV];
					myCh->misc.refFlag = P1;
				}else{
					refV = val1;
				}
			}
			break;
		default:
			refV = val1;
			break;
	}

	if(myPs->config.hwSpec == S_5V_200A_75A_15A_AD2) {
		if(myCh->op.phase == P50){
			if(myCh->misc.preIref >= 0 && val2 >= 0) { //charge -> charge
				myCh->misc.cmd_v = val1;
				myCh->misc.cmd_v_div = (short int)div;
				myCh->misc.cmd_v_range = (short int)rangeV;
				myCh->misc.cmd_i = val2;
				myCh->misc.cmd_i_div = (short int)div;
				myCh->misc.cmd_i_range = (short int)rangeI;
				myCh->signal[C_SIG_I_CMD_OUTPUT] = P1;
				myCh->signal[C_SIG_V_CMD_OUTPUT] = P1;
			} else if(myCh->misc.preIref < 0 && val2 < 0) { //discharge -> discharge
				myCh->misc.cmd_v = val1;
				myCh->misc.cmd_v_div = (short int)div;
				myCh->misc.cmd_v_range = (short int)rangeV;
				myCh->misc.cmd_i = val2;
				myCh->misc.cmd_i_div = (short int)div;
				myCh->misc.cmd_i_range = (short int)rangeI;
				myCh->signal[C_SIG_I_CMD_OUTPUT] = P1;
				myCh->signal[C_SIG_V_CMD_OUTPUT] = P1;
			} else if(myCh->misc.preIref >= 0 && val2 < 0) { //charge -> discharge
				myCh->misc.cmd_v = val1;
				myCh->misc.cmd_v_div = (short int)div;
				myCh->misc.cmd_v_range = (short int)rangeV;
				myCh->misc.cmd_i = val2;
				myCh->misc.cmd_i_div = (short int)div;
				myCh->misc.cmd_i_range = (short int)rangeI;
				cSemiSwitch_Rest(bd, ch, 0, 0);
				myCh->signal[C_SIG_OUT_SWITCH] = P0;
				if(myPs->config.hwSpec > DC_DIGITAL_SPEC){//180611 
					myCh->signal[C_SIG_OUT_SWITCH_OFF] = P1;
				}
				myCh->misc.patternPhase = P11;
			} else { //discharge -> charge
				myCh->misc.cmd_v = val1;
				myCh->misc.cmd_v_div = (short int)div;
				myCh->misc.cmd_v_range = (short int)rangeV;
				myCh->misc.cmd_i = val2;
				myCh->misc.cmd_i_div = (short int)div;
				myCh->misc.cmd_i_range = (short int)rangeI;
				cSemiSwitch_Rest(bd, ch, 0, 0);
				myCh->signal[C_SIG_OUT_SWITCH] = P0;
				if(myPs->config.hwSpec > DC_DIGITAL_SPEC){//180611 
					myCh->signal[C_SIG_OUT_SWITCH_OFF] = P1;
				}
				myCh->misc.patternPhase = P1;
			}
		} else {
			myCh->misc.cmd_v = val1;
			myCh->misc.cmd_v_div = (short int)div;
			myCh->misc.cmd_v_range = (short int)rangeV;
			myCh->misc.cmd_i = val2;
			myCh->misc.cmd_i_div = (short int)div;
			myCh->misc.cmd_i_range = (short int)rangeI;
			if(val2 >= 0)
				cC_D_Select(bd, ch, P0);
			else
				cC_D_Select(bd, ch, P1);

		}
	} else {
		if(myCh->ChAttribute.opType == P0)
		{
			if(myCh->ChAttribute.chNo_master == P0)
			{
			//	ref_output(bd, ch-1, val1, val2, div, rangeV, rangeI, mode);
				ref_output(bd, ch-1, refV, val2, div, rangeV, rangeI, mode);
				myCh = &(myData->bData[bd].cData[ch]);
			}
	//		ref_output(bd, ch, val1, val2, div, rangeV, rangeI, mode);
			ref_output(bd, ch, refV, val2, div, rangeV, rangeI, mode);
			//180531 lyhw
			if(myCh->misc.parallel_cycle_phase == P50){
				if((ch%2) == 0) parallel_ch = ch + 1;
				else parallel_ch = ch - 1;
				ref_output_p(bd, ch, parallel_ch, refV, val2, div, rangeV, rangeI, mode);
			}
		}
	}
}

void Send_Read_UserPattern(int bd, int ch, unsigned long advStepNo, int num)
{
	int read_Ptn, realCh = 0;

	myCh = &(myData->bData[bd].cData[ch]);
	
	myCh->misc.userPattern_ReadFlag = 0;
	realCh = myPs->config.chPerBd * bd + ch;

	read_Ptn = (num % 2);
	if(read_Ptn == 0) read_Ptn = P2;

	switch(read_Ptn){
		case P1:
			send_msg_ptn(MODULE_TO_DATASAVE_PATTERN
						,MSG_READ_USER_PATTERN_1, realCh, advStepNo, num);	
			break;
		case P2:
			send_msg_ptn(MODULE_TO_DATASAVE_PATTERN
						,MSG_READ_USER_PATTERN_2, realCh, advStepNo, num);	
			break;
		default :
			break;
	}	
}

void user_map_info(int bd, int ch)
{ //111215 kji add
	long i=1,j=1,tableRow,tableCol,mode;
	long offset;
	long x1,x2,y1,y2;
	long value1= 0, value2 = 0, value3 = 0, value4 = 0;
	long advStepNo = myCh->misc.advStepNo;
	double gain;

	myCh = &(myData->bData[bd].cData[ch]);
	
	tableRow = myData->mData.testCond[bd][ch].userMap.dataTableRow;
	tableCol = myData->mData.testCond[bd][ch].userMap.dataTableCol;
	//140925 oys modifty : current userMap
	mode = myData->mData.testCond[bd][ch].userMap.mode;
	
	if(mode == PS_CURRENT){
		for(i=1;i<=tableCol;i++) {
			if(myCh->op.Vsens <= myData->mData.testCond[bd][ch].
								userMap.dataTable[0][i]){
				break;
			}
		}
		if(i > tableCol) 
			i--;
		for(j=1;j<=tableRow;j++) {
			if(myCh->op.temp <= myData->mData.testCond[bd][ch].
								userMap.dataTable[j][0]){
				break;
			}
		}
		if(j > tableCol) 
			j--;
	}else if(mode == PS_WATT){
		for(i=1;i<=tableCol;i++) {
			if(myCh->misc.soc < myData->mData.testCond[bd][ch].
								userMap.dataTable[0][i]){
			break;
			}
		}
		if(i == 1)
			i = 2;

		if(i > tableCol) 
			i--;
		for(j=1;j<=tableRow;j++) {
			if(myCh->op.temp < myData->mData.testCond[bd][ch].
								userMap.dataTable[j][0]){
				break;
			}
		}
		if(j == 1)
			j = 2;
		if(j > tableCol) 
			j--;
	}

	//140925 oys add : current userMap
	value4 = myData->mData.testCond[bd][ch].userMap.dataTable[j][i];

	x1 = myData->mData.testCond[bd][ch].userMap.dataTable[0][i-1];
	x2 = myData->mData.testCond[bd][ch].userMap.dataTable[0][i];
	y1 = myData->mData.testCond[bd][ch].userMap.dataTable[j-1][i-1];
	y2 = myData->mData.testCond[bd][ch].userMap.dataTable[j-1][i];
	gain = calculate_gain(x1,x2,y1,y2);
	offset = calculate_offset(x1,y1,gain);
	value1 = (long)((myCh->misc.soc * gain) + offset);

	x1 = myData->mData.testCond[bd][ch].userMap.dataTable[0][i-1];
	x2 = myData->mData.testCond[bd][ch].userMap.dataTable[0][i];
	y1 = myData->mData.testCond[bd][ch].userMap.dataTable[j][i-1];
	y2 = myData->mData.testCond[bd][ch].userMap.dataTable[j][i];
	gain = calculate_gain(x1,x2,y1,y2);
	offset = calculate_offset(x1,y1,gain);
	value2 = (long)((myCh->misc.soc * gain) + offset);
	
	x1 = myData->mData.testCond[bd][ch].userMap.dataTable[j-1][0];
	x2 = myData->mData.testCond[bd][ch].userMap.dataTable[j][0];
	y1 = value1;
	y2 = value2;
	gain = calculate_gain(x1,x2,y1,y2);
	offset = calculate_offset(x1,y1,gain);
	value3 = (long)((myCh->op.temp * gain) + offset);

	switch(mode) {
		case PS_CURRENT:
			//140925 oys modifty : current userMap
			myData->mData.testCond[bd][ch].step[advStepNo].refI = value4;
			if(value4 > 0) {
				myData->mData.testCond[bd][ch].step[advStepNo].refV = 
					myData->mData.testCond[bd][ch].step[advStepNo].refV_H;
				if(myData->mData.testCond[bd][ch].step[advStepNo].refV == 0) {
					myData->mData.testCond[bd][ch].step[advStepNo].refV =
						myData->mData.config.maxVoltage[0];
				}
			} else {
				myData->mData.testCond[bd][ch].step[advStepNo].refV = 
					myData->mData.testCond[bd][ch].step[advStepNo].refV_L;
			}

				break;
		case PS_WATT:
			myData->mData.testCond[bd][ch].step[advStepNo].refP = value3;
			if(value3 > 0) {
				myData->mData.testCond[bd][ch].step[advStepNo].refV = 
					myData->mData.testCond[bd][ch].step[advStepNo].refV_H;
				if(myData->mData.testCond[bd][ch].step[advStepNo].refV == 0) {
					myData->mData.testCond[bd][ch].step[advStepNo].refV =
						myData->mData.config.maxVoltage[0];
				}
			} else {
				myData->mData.testCond[bd][ch].step[advStepNo].refV = 
					myData->mData.testCond[bd][ch].step[advStepNo].refV_L;
			}
				break;
	}
}

//111215 kji add
void user_map_data(int bd, int ch)
{
	int div = 5, rangeV, rangeI, parallel_ch, mode;
	long val1, val2;

	S_CH_STEP_INFO	step;

	myCh = &(myData->bData[bd].cData[ch]);

	user_map_info(bd, ch);
	step = step_info(bd, ch);
	
	val1 = step.refV;
	val2 = step.refI;
	rangeV = step.rangeV;
	rangeI = step.rangeI;	
	mode = step.mode;	

	myCh->misc.sensCount = 0;
	myCh->misc.sensCountFlag = P0;
	myCh->misc.sensBufCount = 0;
	myCh->misc.sensBufCountFlag = P0;
	myCh->misc.fbSumI_M = 0;
	myCh->misc.fbCountI_M = 0;
	myCh->misc.fbSumI_H = 0;
	myCh->misc.fbCountI_H = 0;
	myCh->misc.fbSumI_L = 0;
	myCh->misc.fbCountI_L = 0;

	ref_output(bd, ch, val1, val2, div, rangeV, rangeI, mode);

	if(myCh->misc.parallel_cycle_phase == P50) { //kjg_180521
		if((ch % 2) == 0) parallel_ch = ch + 1;
		else parallel_ch = ch - 1;
		ref_output_p(bd, ch, parallel_ch, val1, val2, div, rangeV, rangeI, mode);
	}
}

int read_user_map_ocvTable(int bd, int ch)
{ //111215 kji add
	long i,tableRow,voltage;
	long x1,x2,y1,y2;
	double gain;
	long offset;
	x1=x2=y1=y2=0;
	voltage = myData->bData[bd].cData[ch].op.Vsens;
	tableRow = myData->mData.testCond[bd][ch].userMap.ocvTableRow;
	for(i=0;i<tableRow;i++) {
		if(voltage < myData->mData.testCond[bd][ch].userMap.ocvTable[i][1]) {
			break;
		}
	}
	if(i == 0)
		i++;
	if(i == tableRow)
		i--;

	x1 = myData->mData.testCond[bd][ch].userMap.ocvTable[i-1][1];
	x2 = myData->mData.testCond[bd][ch].userMap.ocvTable[i][1];
	y1 = myData->mData.testCond[bd][ch].userMap.ocvTable[i-1][0];
	y2 = myData->mData.testCond[bd][ch].userMap.ocvTable[i][0];
	
	gain = calculate_gain(x1,x2,y1,y2);
	offset = calculate_offset(x1,y1,gain);

	return (long)((voltage*gain) + offset);
}

//111215 kji add
double calculate_gain(long x1, long x2, long y1, long y2) {
	return (double)(y1-y2) / (double)(x1 -x2);
}

//111215 kji add
long calculate_offset(long x1, long y1, double gain) {
	return (long)(y1 - (gain * x1));
}

//111215 kji add
void cStepUserMap(int bd, int ch)
{
    int	rtn, realCh = 0, rangeV, rangeI, cnt, div = 5, parallel_ch, mode;
    long val1, val2, val3, deltaT;
	unsigned long advStepNo, saveDt;
	double tmp1;
	S_CH_STEP_INFO step;

	myCh = &(myData->bData[bd].cData[ch]);

	val1 = val2 = val3 = 0;
	tmp1 = 0.0;

	step = step_info(bd, ch);

    advStepNo = step.advStepNo;
	rangeV = step.rangeV;
	rangeI = step.rangeI;
	saveDt = step.saveDt;
	val1 = step.refV;
	val2 = step.refI;
	val3 = step.refP;
	mode = step.mode;

	//kjg_180521
	if((ch % 2) == 0) parallel_ch = ch + 1;
	else parallel_ch = ch - 1;

    switch(myCh->op.phase) {
		case P0:
			rtn = temp_wait_flag_check(bd, ch);
			if(rtn == 0) {
				cSemiSwitch_Rest(bd, ch, advStepNo, 0);
				break;
			}
			myCh->misc.step_count++;
			myCh->misc.cycleStepCount++;
			myCh->misc.endState = P0;
			myCh->misc.groupEndTime = 0;
			// 111212 oys w : cycleNo
			myCh->misc.cycleNo = myPs->testCond[bd][ch].step[advStepNo].cycleNo;
			myCh->misc.limit_current_timeout = myCh->op.runTime;
			myCh->misc.limit_voltage_timeout = myCh->op.runTime;
			myCh->misc.hw_fault_temp  = myCh->op.runTime;
//			rtn = temp_wait_flag_check(bd, ch);
//			if(rtn == 0) break;
			cSemiSwitch(bd, ch);
			if(myCh->misc.parallel_cycle_phase == P50) { //kjg_180521
				cSemiSwitch_p(bd, ch, parallel_ch);
			}
			realCh = myPs->config.chPerBd * bd + ch;
			send_msg(MODULE_TO_DATASAVE
					, MSG_MODULE_DATASAVE_READ_USER_MAP, realCh, advStepNo);
			myCh->misc.userMapFlag = P0;
			myCh->op.checkDelayTime = 0;
			myCh->op.phase = P1;
			initCh(bd, ch);
			break;
		case P1:
			if(myCh->misc.userMapFlag == P1){
				rtn = temp_wait_flag_check(bd, ch);
				if(rtn == 0) {
					cSemiSwitch_Rest(bd, ch, advStepNo, 0);
					break;
				}
				myCh->misc.userMapFlag = P0;
				myCh->op.checkDelayTime = 0;
				myCh->misc.startV = myCh->op.Vsens;
				myCh->misc.maxV = myCh->op.Vsens;
				myCh->misc.minV = myCh->op.Vsens;
				myCh->misc.startT = myCh->op.temp;
				myCh->misc.maxT = myCh->op.temp;
				myCh->misc.minT = myCh->op.temp;
	//			myCh->misc.limit_current_timeout= myData->mData.misc.timer_1sec;
				myCh->misc.limit_current_timeout = myCh->op.runTime;
				myCh->misc.limit_voltage_timeout = myCh->op.runTime;
				//120315 kji 0 sec data option
				//170501 oys modify
				if(myData->DataSave.config.zero_sec_data_save == P1) {
					if(myCh->ChAttribute.opType == P0) {
						if(myCh->ChAttribute.chNo_master == 0) {
							myData->bData[bd].cData[ch-1].op.Isens = 0;
							myData->bData[bd].cData[ch-1].misc.tmpIsens = 0;
							myData->bData[bd].cData[ch-1].op.select
								= SAVE_FLAG_SAVING_TIME;
						}
						myCh->op.Isens = 0;
						myCh->misc.tmpIsens = 0;
						myCh->op.select = SAVE_FLAG_SAVING_TIME;
						send_save_msg(bd, ch, 0, 0);
					}
				}
				myCh->op.phase = P3;
			}else{
			  	if(myCh->signal[C_SIG_STOP] == P1) {
					myCh->op.code = C_FAULT_STOP_CMD;
					myCh->op.select = SAVE_FLAG_SAVING_END;
					myCh->signal[C_SIG_STOP] = P0;
					myCh->op.phase = P100;
				} else if(myCh->signal[C_SIG_PAUSE] == P1) {
					//cmd, soft fault
					myCh->misc.tmpState = myCh->op.state;
					myCh->misc.tmpCode = myCh->op.code;
					myCh->op.code = C_FAULT_PAUSE_CMD;
					myCh->opSave = myCh->op;
					myCh->signal[C_SIG_PAUSE] = P0;
					myCh->op.phase = P100;
				} else if(myCh->signal[C_SIG_DLL_STOP] == P1) {
					myCh->op.code = C_FAULT_CELL_DIAGNOSIS_STOP;
					myCh->op.select = SAVE_FLAG_SAVING_END;
					myCh->signal[C_SIG_DLL_STOP] = P0;
					cSemiSwitch_Rest(bd, ch, advStepNo, 0);
					myCh->op.phase = P100;
				}else if(myCh->signal[C_SIG_NEXTSTEP] == P1) {
					myCh->signal[C_SIG_NEXTSTEP] = P0;
					myCh->op.code = C_FAULT_NEXTSTEP_CMD;
					myCh->op.select = SAVE_FLAG_SAVING_END;
					myCh->op.phase = P100;
				} else {
					cFailCodeCheck(bd, ch);
				}
			}
			break;
		case P2:
			myCh->op.checkDelayTime 
				+= myPs->misc.rt_scan_time;
			if(myCh->op.checkDelayTime >= 20) {
				cSemiSwitch_Pattern(bd, ch, 1);
				myCh->op.checkDelayTime = 0;
				myCh->op.phase = P3;
			}
			break;
		case P3:
			rtn = SelectHwSpec(bd , ch);
			myCh->misc.soc = read_user_map_ocvTable(bd, ch);
			myCh->misc.startSoc = myCh->misc.soc;
			rtn = 3;
			if(rtn == 1) {
				myCh->op.phase = P5;
			} else if(rtn == 2 || rtn == 7) {
				cSemiSwitch_Rest(bd, ch, 0, 0);
				myCh->op.phase = P6;
			} else if(rtn == 3) {
				myCh->op.phase = P5;
			} else if(rtn == 4) {
				myCh->op.phase = P5;
			} else if(rtn == 5) {
				myCh->op.phase = P5;
			} else if(rtn == 6) {
				myCh->op.phase = P5;
			}
			break;
		case P4:
			myCh->misc.sensCount = 0;
			myCh->misc.sensCountFlag = P0;
			myCh->misc.sensBufCount = 0;
			myCh->misc.sensBufCountFlag = P0;
			user_map_data(bd,ch);
			myCh->op.phase = P50;
			break;
		case P5:
			myCh->op.checkDelayTime += myPs->misc.rt_scan_time;
			if(myCh->op.checkDelayTime == 20) {
				myCh->signal[C_SIG_OUT_SWITCH] = P1;
				if(myPs->config.hwSpec > DC_DIGITAL_SPEC){//180611 
					myCh->signal[C_SIG_OUT_SWITCH_ON] = P1;
				}
			}
			if(myCh->op.checkDelayTime >= 50) {
				myCh->op.checkDelayTime = 0;
				myCh->op.phase = P4;
				//0sec save LGC 5V6A 100716 kji
				if(myPs->config.hwSpec == L_5V_6A_R3)
				{
					myCh->op.select =  SAVE_FLAG_SAVING_TIME;
					send_save_msg(bd, ch, 0, 0);
				}
			}
			break;
		case P6:
			myCh->op.checkDelayTime += myPs->misc.rt_scan_time;
			if(myCh->op.checkDelayTime == 10) {
				cV_Range_Select(bd, ch, rangeV+1);
				cI_Range_Select(bd, ch, rangeI+1);
			} else if(myCh->op.checkDelayTime > 25) {
				myCh->op.checkDelayTime = 0;
				user_pattern_data(bd, ch);
				myCh->op.phase = P7;
			}
			break;
		case P7:
			myCh->signal[C_SIG_OUT_SWITCH] = P1;
			if(myPs->config.hwSpec > DC_DIGITAL_SPEC){//180611 
				myCh->signal[C_SIG_OUT_SWITCH_ON] = P1;
			}
			myCh->signal[C_SIG_V_CMD_OUTPUT] = P1;
			myCh->op.phase = P8;
			break;
		case P8:
			myCh->misc.sensCount = 0;
			myCh->misc.sensCountFlag = P0;
			myCh->misc.sensBufCount = 0;
			myCh->misc.sensBufCountFlag = P0;
			myCh->signal[C_SIG_I_CMD_OUTPUT] = P1;
			myCh->misc.userPatternRunTime
				= myCh->op.runTime;
			myCh->op.phase = P50;
			break;
		case P10:
			rtn = SelectHwSpec(bd , ch);
			if(rtn == 1
				|| rtn == 3
				|| rtn == 4
				|| rtn == 5
				|| rtn == 6) {
				myCh->misc.ocv = myCh->op.Vsens;
				myCh->signal[C_SIG_V_RANGE] = rangeV+1;
				myCh->signal[C_SIG_I_RANGE] = rangeI+1;

				myCh->misc.fbV = 0;
				myCh->misc.fbI = 0;
				myCh->misc.ocv = myCh->op.Vsens;
				myCh->misc.pid_ui1[0] = 0.0;
				myCh->misc.pid_ui1[1] = 0.0;
				myCh->misc.pid_error1[0] = 0.0;
				myCh->misc.pid_error1[1] = 0.0;
				myCh->op.phase = P11;
			} else if(rtn == 2 || rtn == 7) {
				myCh->signal[C_SIG_V_RANGE] = rangeV+1;
				myCh->signal[C_SIG_I_RANGE] = rangeI+1;

				myCh->misc.fbV = 0;
				myCh->misc.fbI = 0;
				myCh->misc.ocv = myCh->op.Vsens;
				myCh->misc.pid_ui1[0] = 0.0;
				myCh->misc.pid_ui1[1] = 0.0;
				myCh->misc.pid_error1[0] = 0.0;
				myCh->misc.pid_error1[1] = 0.0;

				myCh->misc.cmd_v = val1;
				myCh->misc.cmd_v_div = (short int)div;
				myCh->misc.cmd_v_range = (short int)rangeV;
				myCh->misc.cmd_i = val2;
				myCh->misc.cmd_i_div = (short int)div;
				myCh->misc.cmd_i_range = (short int)rangeI;
				myCh->op.checkDelayTime = 0;
				myCh->op.phase = P12;
			}
			break;
		case P11:
			user_map_data(bd,ch);
			myCh->op.phase = P50;
			break;
		case P12:
			myCh->op.checkDelayTime += myPs->misc.rt_scan_time;
			if(myCh->op.checkDelayTime == 10) {
				cV_Range_Select(bd, ch, rangeV+1);
				cI_Range_Select(bd, ch, rangeI+1);
			} else if(myCh->op.checkDelayTime > 25) {
				myCh->op.checkDelayTime = 0;
				user_map_data(bd,ch);
				myCh->op.phase = P13;
			}
			break;
		case P13:
			myCh->signal[C_SIG_OUT_SWITCH] = P1;
			if(myPs->config.hwSpec > DC_DIGITAL_SPEC){//180611 
				myCh->signal[C_SIG_OUT_SWITCH_ON] = P1;
			}
			myCh->signal[C_SIG_V_CMD_OUTPUT] = P1;
			myCh->op.phase = P14;
			break;
		case P14:
			myCh->signal[C_SIG_I_CMD_OUTPUT] = P1;
			myCh->op.phase = P50;
			break;
		case P50:
			myCh->misc.start = 0;
	    	myCh->op.runTime += myPs->misc.rt_scan_time;
			myCh->op.totalRunTime += myPs->misc.rt_scan_time;
			myCh->misc.cycleRunTime += myPs->misc.rt_scan_time;
			myCh->op.checkDelayTime += myPs->misc.rt_scan_time;

			sens_ch_ad_count_increment(bd, ch);

			if(myCh->op.runTime % myData->mData.testCond[bd][ch].
				userMap.renewalTime == 0) {
				myCh->misc.soc = myCh->misc.startSoc
					+ (long)((double)(myCh->op.ampareHour)
					/ (double)(myData->mData.testCond[bd][ch]
					.userMap.maxCapacity) * 100000);
				user_map_data(bd,ch);
			}

			if(myCh->op.runTime >= 30) {
				myCh->misc.meanCount++;
				if(myCh->misc.meanCount <= 8) {
					myCh->misc.meanSumVolt += (myCh->misc.tmpVsens / 100);
					myCh->misc.meanSumCurr += (myCh->misc.tmpIsens / 100);
					myCh->misc.meanSumTemp += (myCh->op.temp / 100);
				} else {
					myCh->misc.meanSumVolt += (myCh->op.Vsens / 100);
					myCh->misc.meanSumCurr += (myCh->op.Isens / 100);
					myCh->misc.meanSumTemp += (myCh->op.temp / 100);
				}
				myCh->op.meanVolt = (long)(myCh->misc.meanSumVolt
					/ myCh->misc.meanCount) * 100;
				myCh->op.meanCurr = (long)(myCh->misc.meanSumCurr
					/ myCh->misc.meanCount) * 100;
				myCh->op.meanTemp = (long)(myCh->misc.meanSumTemp
					/ myCh->misc.meanCount) * 100;
			}

			if(myCh->signal[C_SIG_STOP] == P1) {
				myCh->op.code = C_FAULT_STOP_CMD;
				myCh->op.select = SAVE_FLAG_SAVING_END;
				myCh->signal[C_SIG_STOP] = P0;
				cSemiSwitch_Rest(bd, ch, advStepNo, 0);
				myCh->op.phase = P100;
			} else if(myCh->signal[C_SIG_PAUSE] == P1) {
				//cmd, soft fault
				myCh->misc.tmpState = myCh->op.state;
				myCh->misc.tmpCode = myCh->op.code;
				myCh->op.code = C_FAULT_PAUSE_CMD;
				myCh->opSave = myCh->op;
				myCh->signal[C_SIG_PAUSE] = P0;
				cSemiSwitch_Rest(bd, ch, advStepNo, 0);
				myCh->op.phase = P100;
			} else if(myCh->signal[C_SIG_DLL_STOP] == P1) {
				myCh->op.code = C_FAULT_CELL_DIAGNOSIS_STOP;
				myCh->op.select = SAVE_FLAG_SAVING_END;
				myCh->signal[C_SIG_DLL_STOP] = P0;
				cSemiSwitch_Rest(bd, ch, advStepNo, 0);
				myCh->op.phase = P100;
			} else {
				if(cFailCodeCheck(bd, ch) >= 0) {
					cSoftFeedback(bd, ch, val1, val2, val3);
				}
			}

/* 20120126 kji value move phase 0
	    	if(myCh->op.checkDelayTime == 100) {
				myCh->misc.maxV = myCh->op.Vsens;
				myCh->misc.minV = myCh->op.Vsens;
				myCh->misc.maxI = myCh->op.Isens;
				myCh->misc.minI = myCh->op.Isens;
			}
*/
			//191010
			if(myCh->op.checkDelayTime < 100){
				myCh->misc.Pre_change_V = myCh->misc.tmpVsens;
			}
	    	if(myCh->op.checkDelayTime == 100) {
				myCh->misc.maxI = myCh->op.Isens;
				myCh->misc.minI = myCh->op.Isens;
			}

			if(myCh->op.phase == P100) {
				myCh->ccv[0].avg_v = myCh->misc.tmpVsens;
				myCh->ccv[0].avg_i = myCh->misc.tmpIsens;
				cNextStepCheck(bd, ch);
			} else {
			    deltaT = ((myCh->op.runTime / 10) * 10)
					- (myCh->misc.userPatternRunTime
					- myPs->misc.rt_scan_time);
				cnt = find_pattern_time(bd, ch, deltaT);
				if(myCh->misc.userPatternCnt != cnt) {	
					myCh->misc.userPatternCnt = cnt;
					user_pattern_data(bd, ch);
				}
			}
			break;
		case P100:
			break;
		default:
			break;
    }
}

void cStepUserPattern(int bd, int ch)
{
	unsigned char slave_flag = 1;
    int	rtn, realCh = 0, rangeV, rangeI, cnt, div = 5, mode;
    long val1, val2, val3, deltaT, length;
	unsigned long advStepNo, saveDt;
	double tmp1;
	int i = 0;
	S_CH_STEP_INFO step;

	myCh = &(myData->bData[bd].cData[ch]);
	myTestCond = &(myPs->testCond[bd][ch]);

	val1 = val2 = val3 = 0;
	tmp1 = 0.0;

	length = myData->mData.testCond[bd][ch].userPattern.length;

	step = step_info(bd, ch);

    advStepNo = step.advStepNo;
	rangeV = step.rangeV;
	rangeI = step.rangeI;
	saveDt = step.saveDt;
	val1 = step.refV;
	val2 = step.refI;
	val3 = step.refP;
	mode = step.mode;

    switch(myCh->op.phase) {
		case P0:
			myCh->misc.limit_current_timeout = myCh->op.runTime;
			myCh->misc.limit_voltage_timeout = myCh->op.runTime;
			myCh->misc.hw_fault_temp  = myCh->op.runTime;
			cSemiSwitch_Pattern(bd, ch, 0);
//			cSemiSwitch(bd, ch);
			realCh = myPs->config.chPerBd * bd + ch;
			send_msg(MODULE_TO_DATASAVE
					, MSG_MODULE_DATASAVE_READ_USER_PATTERN, realCh, advStepNo);
			myCh->misc.userPatternFlag = P0;
			myCh->op.checkDelayTime = 0;
#ifdef _TRACKING_MODE
			if(myTestCond->step[advStepNo].SOC_Tracking_flag == P1){
				send_msg(MODULE_TO_DATASAVE, 
							MSG_MODULE_DATASAVE_READ_USER_SOC_TRACKING, 
							ch, advStepNo);
			}
#endif
			myCh->op.phase = P1;
			initCh(bd, ch);
			break;
		case P1:
			if(myCh->ChAttribute.opType == P1) // salve ch wait
			{
				if(myData->bData[bd].cData[ch+1].misc.userPatternFlag == P1)
				{
					slave_flag = P1;
				} else {
					slave_flag = P0;
				}
			}
			else {
				slave_flag = P1;
			}
#if TRACKING_MODE == 1
			if(myTestCond->step[advStepNo].SOC_Tracking_flag == P1){ //210720
				if(myCh->misc.file_sucess_flag == P1
					&& myCh->misc.userPatternFlag == P1){ 
					myCh->misc.file_sucess_flag = 0;
					slave_flag = P1;				
				}else{
					if(myData->bData[bd].cData[ch].misc.file_fail_flag == 1){
						myData->bData[bd].cData[ch].misc.file_fail_flag = 0;
						myData->bData[bd].cData[ch]
							.signal[C_SIG_READ_FAIL_SOC_TRACKING_FILE] = P1;
					}
					slave_flag = P0;				
				}
			}else{
				slave_flag = P1;				
			}
#endif
			if((myCh->misc.userPatternFlag == P1) && (slave_flag == P1)){
				rtn = temp_wait_flag_check(bd, ch);
				if(rtn == 0) {
					cSemiSwitch_Rest(bd, ch, advStepNo, 0);
					break;
				}
				myCh->misc.step_count++;
				myCh->misc.cycleStepCount++;
				myCh->misc.endState = P0;
				myCh->misc.groupEndTime = 0;
				// 111212 oys w : cycleNo
				myCh->misc.cycleNo = myPs->testCond[bd][ch].step[advStepNo].cycleNo;
	
				myCh->misc.userPatternFlag = P0;
				myCh->op.checkDelayTime = 0;
				myCh->misc.startV = myCh->op.Vsens;
				myCh->misc.maxV = myCh->op.Vsens;
				myCh->misc.minV = myCh->op.Vsens;
				myCh->misc.startT = myCh->op.temp;
				myCh->misc.maxT = myCh->op.temp;
				myCh->misc.minT = myCh->op.temp;
	//			myCh->misc.limit_current_timeout= myData->mData.misc.timer_1sec;
				myCh->misc.limit_current_timeout = myCh->op.runTime;
				myCh->misc.limit_voltage_timeout = myCh->op.runTime;
				//120315 kji 0 sec data option
				//170501 oys modify
				if(myData->DataSave.config.zero_sec_data_save == P1) {
					if(myCh->ChAttribute.opType == P0) {
						if(myCh->ChAttribute.chNo_master == 0) {
							myData->bData[bd].cData[ch-1].op.Isens = 0;
							myData->bData[bd].cData[ch-1].misc.tmpIsens = 0;
							myData->bData[bd].cData[ch-1].op.select
								= SAVE_FLAG_SAVING_TIME;
						}
						myCh->op.Isens = 0;
						myCh->misc.tmpIsens = 0;
						myCh->op.select = SAVE_FLAG_SAVING_TIME;
						send_save_msg(bd, ch, 0, 0);
					}
				}

				if(myPs->config.hwSpec < S_5V_200A) {
					myCh->signal[C_SIG_V_RANGE] = rangeV + 1;
					myCh->signal[C_SIG_I_RANGE] = rangeI + 1;
					if(myCh->ChAttribute.opType == P1) {
						myCh->signal[C_SIG_PARALLEL_SWITCH] = P1;
					}
					myCh->op.phase = P2;
					myCh->op.checkDelayTime = 0; //131220
				} else {
					myCh->op.phase = P3;
				}
			}else{
			  	if(myCh->signal[C_SIG_STOP] == P1) {
					myCh->op.code = C_FAULT_STOP_CMD;
					myCh->op.select = SAVE_FLAG_SAVING_END;
					myCh->signal[C_SIG_STOP] = P0;
					myCh->op.phase = P100;
				} else if(myCh->signal[C_SIG_PAUSE] == P1) {
					//cmd, soft fault
					myCh->misc.tmpState = myCh->op.state;
					myCh->misc.tmpCode = myCh->op.code;
					myCh->op.code = C_FAULT_PAUSE_CMD;
					myCh->opSave = myCh->op;
					myCh->signal[C_SIG_PAUSE] = P0;
					myCh->op.phase = P100;
				} else if(myCh->signal[C_SIG_DLL_STOP] == P1) {
					myCh->op.code = C_FAULT_CELL_DIAGNOSIS_STOP;
					myCh->op.select = SAVE_FLAG_SAVING_END;
					myCh->signal[C_SIG_DLL_STOP] = P0;
					cSemiSwitch_Rest(bd, ch, advStepNo, 0);
					myCh->op.phase = P100;
				}else if(myCh->signal[C_SIG_NEXTSTEP] == P1) {
					myCh->signal[C_SIG_NEXTSTEP] = P0;
					myCh->op.code = C_FAULT_NEXTSTEP_CMD;
					myCh->op.select = SAVE_FLAG_SAVING_END;
					myCh->op.phase = P100;
				} else {
					cFailCodeCheck(bd, ch);
				}
			}
			break;
		case P2:
			if(myCh->op.checkDelayTime == 0){ 
				cSemiSwitch_Pattern(bd, ch, 1);
			}
			myCh->op.checkDelayTime += myPs->misc.rt_scan_time;
			if(myCh->op.checkDelayTime >= 20) {
				myCh->signal[C_SIG_RANGE_SWITCH] = P1;	//131220
				myCh->op.checkDelayTime = 0;
				myCh->misc.userPatternRunTime = myCh->op.runTime;
				myCh->op.phase = P3;
			}
			break;
		case P3:
			rtn = SelectHwSpec(bd , ch);
			if(rtn == 1) {
			//	user_pattern_data(bd, ch);
				myCh->op.phase = P5;
			} else if(rtn == 2 || rtn == 7) {
				cSemiSwitch_Rest(bd, ch, 0, 0);
				myCh->op.phase = P6;
			} else if(rtn == 3) {
				myCh->op.phase = P5;
			} else if(rtn == 4) {
				myCh->op.phase = P5;
			} else if(rtn == 5) {
				myCh->op.phase = P5;
			} else if(rtn == 6) {
				myCh->op.phase = P5;
			}
			break;
		case P4:
			myCh->misc.sensCount = 0;
			myCh->misc.sensCountFlag = P0;
			myCh->misc.sensBufCount = 0;
			myCh->misc.sensBufCountFlag = P0;
			myCh->misc.userPatternRunTime = myCh->op.runTime;
			user_pattern_data(bd, ch);
			myCh->op.phase = P50;
			break;
		case P5:
			myCh->op.checkDelayTime += myPs->misc.rt_scan_time;
			if(myCh->op.checkDelayTime == 20) {
				myCh->signal[C_SIG_OUT_SWITCH] = P1;
				if(myPs->config.hwSpec > DC_DIGITAL_SPEC){//180611 
					myCh->signal[C_SIG_OUT_SWITCH_ON] = P1;
				}
			}
			if(myCh->op.checkDelayTime >= 50) {
				myCh->op.checkDelayTime = 0;
				myCh->op.phase = P4;
				//0sec save LGC 5V6A 100716 kji
				if(myPs->config.hwSpec == L_5V_6A_R3){
					myCh->op.select =  SAVE_FLAG_SAVING_TIME;
					send_save_msg(bd, ch, 0, 0);
				}
			}
			break;
		case P6:
			myCh->op.checkDelayTime += myPs->misc.rt_scan_time;
			if(myCh->op.checkDelayTime == 10) {
				cV_Range_Select(bd, ch, rangeV+1);
				cI_Range_Select(bd, ch, rangeI+1);
			} else if(myCh->op.checkDelayTime > 25) {
				myCh->op.checkDelayTime = 0;
				user_pattern_data(bd, ch);
				myCh->op.phase = P7;
			}
			break;
		case P7:
			myCh->signal[C_SIG_OUT_SWITCH] = P1;
			if(myPs->config.hwSpec > DC_DIGITAL_SPEC){//180611 
				myCh->signal[C_SIG_OUT_SWITCH_ON] = P1;
			}
			myCh->signal[C_SIG_V_CMD_OUTPUT] = P1;
			myCh->op.phase = P8;
			break;
		case P8:
			myCh->misc.sensCount = 0;
			myCh->misc.sensCountFlag = P0;
			myCh->misc.sensBufCount = 0;
			myCh->misc.sensBufCountFlag = P0;
			myCh->signal[C_SIG_I_CMD_OUTPUT] = P1;
			myCh->misc.userPatternRunTime
				= myCh->op.runTime;
			myCh->op.phase = P50;
			break;
		case P10:
		//SKI_hun_201010
			realCh = myPs->config.chPerBd * bd + ch;
			if(myCh->misc.ac_fail_flag == P1){
				send_msg(MODULE_TO_DATASAVE
					, MSG_MODULE_DATASAVE_READ_USER_PATTERN, realCh, advStepNo);
#ifdef _TRACKING_MODE
			if(myTestCond->step[advStepNo].SOC_Tracking_flag == P1){
				send_msg(MODULE_TO_DATASAVE, 
							MSG_MODULE_DATASAVE_READ_USER_SOC_TRACKING, 
							ch, advStepNo);
			}
#endif
				myCh->op.phase = P15;
			}else if(myCh->misc.ac_fail_flag == P0){
				rtn = SelectHwSpec(bd , ch);
				if(rtn == 1
					|| rtn == 3
					|| rtn == 4
					|| rtn == 5
					|| rtn == 6) {
					myCh->misc.ocv = myCh->op.Vsens;
					myCh->signal[C_SIG_V_RANGE] = rangeV+1;
					myCh->signal[C_SIG_I_RANGE] = rangeI+1;
	
					myCh->misc.fbV = 0;
					myCh->misc.fbI = 0;
					myCh->misc.ocv = myCh->op.Vsens;
					myCh->misc.pid_ui1[0] = 0.0;
					myCh->misc.pid_ui1[1] = 0.0;
					myCh->misc.pid_error1[0] = 0.0;
					myCh->misc.pid_error1[1] = 0.0;
					myCh->op.phase = P11;
				} else if(rtn == 2 || rtn == 7) {
					myCh->signal[C_SIG_V_RANGE] = rangeV+1;
					myCh->signal[C_SIG_I_RANGE] = rangeI+1;
	
					myCh->misc.fbV = 0;
					myCh->misc.fbI = 0;
					myCh->misc.ocv = myCh->op.Vsens;
					myCh->misc.pid_ui1[0] = 0.0;
					myCh->misc.pid_ui1[1] = 0.0;
					myCh->misc.pid_error1[0] = 0.0;
					myCh->misc.pid_error1[1] = 0.0;
	
					myCh->misc.cmd_v = val1;
					myCh->misc.cmd_v_div = (short int)div;
					myCh->misc.cmd_v_range = (short int)rangeV;
					myCh->misc.cmd_i = val2;
					myCh->misc.cmd_i_div = (short int)div;
					myCh->misc.cmd_i_range = (short int)rangeI;
					myCh->op.checkDelayTime = 0;
					myCh->op.phase = P12;
				}
			}
			break;
		case P11:
			user_pattern_data(bd, ch);
			myCh->op.phase = P50;
			break;
		case P12:
			myCh->op.checkDelayTime += myPs->misc.rt_scan_time;
			if(myCh->op.checkDelayTime == 10) {
				cV_Range_Select(bd, ch, rangeV+1);
				cI_Range_Select(bd, ch, rangeI+1);
			} else if(myCh->op.checkDelayTime > 25) {
				myCh->op.checkDelayTime = 0;
				user_pattern_data(bd, ch);
				myCh->op.phase = P13;
			}
			break;
		case P13:
			myCh->signal[C_SIG_OUT_SWITCH] = P1;
			if(myPs->config.hwSpec > DC_DIGITAL_SPEC){//180611 
				myCh->signal[C_SIG_OUT_SWITCH_ON] = P1;
			}
			myCh->signal[C_SIG_V_CMD_OUTPUT] = P1;
			myCh->op.phase = P14;
			break;
		case P14:
			myCh->signal[C_SIG_I_CMD_OUTPUT] = P1;
			myCh->op.phase = P50;
			break;
		//SKI_hun_201010
		case P15:
			slave_flag = P1;
#ifdef _TRACKING_MODE
			if(myTestCond->step[advStepNo].SOC_Tracking_flag == P1){ //210720
				if(myCh->misc.file_sucess_flag == P1
					&& myCh->misc.userPatternFlag == P1){ 
					myCh->misc.file_sucess_flag = 0;
					slave_flag = P1;				
				}else{
					if(myData->bData[bd].cData[ch].misc.file_fail_flag == 1){
						myData->bData[bd].cData[ch].misc.file_fail_flag = 0;
						myData->bData[bd].cData[ch]
							.signal[C_SIG_READ_FAIL_SOC_TRACKING_FILE] = P1;
					}
					slave_flag = P0;				
				}
			}else{
				slave_flag = P1;				
			}
#endif
			if(myCh->misc.userPatternFlag == P1 && slave_flag == P1){
				myCh->misc.ac_fail_flag = P0;
				length = myTestCond->userPattern.length;
				myCh->misc.saveDt = myCh->op.runTime;
				for(i = 0 ; i < length ; i++){ 
					if(myTestCond->userPattern.data[i].time >= myCh->op.runTime){
						myCh->misc.userPatternCnt = i;
						break;
					}
				}
				rtn = SelectHwSpec(bd , ch);
				if(rtn == 1
					|| rtn == 3
					|| rtn == 4
					|| rtn == 5
					|| rtn == 6) {
					myCh->misc.ocv = myCh->op.Vsens;
					myCh->signal[C_SIG_V_RANGE] = rangeV+1;
					myCh->signal[C_SIG_I_RANGE] = rangeI+1;
	
					myCh->misc.fbV = 0;
					myCh->misc.fbI = 0;
					myCh->misc.ocv = myCh->op.Vsens;
					myCh->misc.pid_ui1[0] = 0.0;
					myCh->misc.pid_ui1[1] = 0.0;
					myCh->misc.pid_error1[0] = 0.0;
					myCh->misc.pid_error1[1] = 0.0;
					myCh->op.phase = P11;
				} else if(rtn == 2 || rtn == 7) {
					myCh->signal[C_SIG_V_RANGE] = rangeV+1;
					myCh->signal[C_SIG_I_RANGE] = rangeI+1;
	
					myCh->misc.fbV = 0;
					myCh->misc.fbI = 0;
					myCh->misc.ocv = myCh->op.Vsens;
					myCh->misc.pid_ui1[0] = 0.0;
					myCh->misc.pid_ui1[1] = 0.0;
					myCh->misc.pid_error1[0] = 0.0;
					myCh->misc.pid_error1[1] = 0.0;
	
					myCh->misc.cmd_v = val1;
					myCh->misc.cmd_v_div = (short int)div;
					myCh->misc.cmd_v_range = (short int)rangeV;
					myCh->misc.cmd_i = val2;
					myCh->misc.cmd_i_div = (short int)div;
					myCh->misc.cmd_i_range = (short int)rangeI;
					myCh->op.checkDelayTime = 0;
					myCh->op.phase = P12;
				}
			}else{ //211022
			  	if(myCh->signal[C_SIG_STOP] == P1) {
					myCh->op.code = C_FAULT_STOP_CMD;
					myCh->op.select = SAVE_FLAG_SAVING_END;
					myCh->signal[C_SIG_STOP] = P0;
					myCh->op.phase = P100;
				} else if(myCh->signal[C_SIG_PAUSE] == P1) {
					//cmd, soft fault
					myCh->misc.tmpState = myCh->op.state;
					myCh->misc.tmpCode = myCh->op.code;
					myCh->op.code = C_FAULT_PAUSE_CMD;
					myCh->opSave = myCh->op;
					myCh->signal[C_SIG_PAUSE] = P0;
					myCh->op.phase = P100;
				} else if(myCh->signal[C_SIG_DLL_STOP] == P1) {
					myCh->op.code = C_FAULT_CELL_DIAGNOSIS_STOP;
					myCh->op.select = SAVE_FLAG_SAVING_END;
					myCh->signal[C_SIG_DLL_STOP] = P0;
					cSemiSwitch_Rest(bd, ch, advStepNo, 0);
					myCh->op.phase = P100;
				}else if(myCh->signal[C_SIG_NEXTSTEP] == P1) {
					myCh->signal[C_SIG_NEXTSTEP] = P0;
					myCh->op.code = C_FAULT_NEXTSTEP_CMD;
					myCh->op.select = SAVE_FLAG_SAVING_END;
					myCh->op.phase = P100;
				} else {
					cFailCodeCheck(bd, ch);
				}
			}
			break;
		case P50:
			if(myCh->misc.patternPhase == P0) {
	   	 		myCh->op.runTime += myPs->misc.rt_scan_time;
				myCh->op.totalRunTime += myPs->misc.rt_scan_time;
				myCh->misc.cycleRunTime += myPs->misc.rt_scan_time;
				myCh->op.checkDelayTime += myPs->misc.rt_scan_time;
				myCh->misc.pattern_point_runTime += myPs->misc.rt_scan_time;
				sens_ch_ad_count_increment(bd, ch);
			} else if(myCh->misc.patternPhase == P1) {
				cC_D_Select(bd, ch, P0);
				myCh->signal[C_SIG_V_CMD_OUTPUT] = P1;
				myCh->signal[C_SIG_OUT_SWITCH] = P1;
				if(myPs->config.hwSpec > DC_DIGITAL_SPEC){//180611 
					myCh->signal[C_SIG_OUT_SWITCH_ON] = P1;
				}
				myCh->misc.patternPhase++; 
			} else if(myCh->misc.patternPhase == P2) {
				myCh->signal[C_SIG_I_CMD_OUTPUT] = P1;
				myCh->misc.patternPhase = P0; 
			} else if(myCh->misc.patternPhase == P11) {
				cC_D_Select(bd, ch, P1);
				myCh->misc.patternPhase++; 
			} else if(myCh->misc.patternPhase == P12) {
				myCh->signal[C_SIG_OUT_SWITCH] = P1;
				if(myPs->config.hwSpec > DC_DIGITAL_SPEC){//180611 
					myCh->signal[C_SIG_OUT_SWITCH_ON] = P1;
				}
				myCh->signal[C_SIG_V_CMD_OUTPUT] = P1;
				myCh->signal[C_SIG_I_CMD_OUTPUT] = P1;
				myCh->misc.patternPhase = P0; 
			} else {
				myCh->misc.patternPhase = P0; 
			}

			if(myCh->op.runTime >= 30) {
				myCh->misc.meanCount++;
				if(myCh->misc.meanCount <= 8) {
					myCh->misc.meanSumVolt += (myCh->misc.tmpVsens / 100);
					myCh->misc.meanSumCurr += (myCh->misc.tmpIsens / 100);
					myCh->misc.meanSumTemp += (myCh->op.temp / 100);
				} else {
					myCh->misc.meanSumVolt += (myCh->op.Vsens / 100);
					myCh->misc.meanSumCurr += (myCh->op.Isens / 100);
					myCh->misc.meanSumTemp += (myCh->op.temp / 100);
				}
				myCh->op.meanVolt = (long)(myCh->misc.meanSumVolt
					/ myCh->misc.meanCount) * 100;
				myCh->op.meanCurr = (long)(myCh->misc.meanSumCurr
					/ myCh->misc.meanCount) * 100;
				myCh->op.meanTemp = (long)(myCh->misc.meanSumTemp
					/ myCh->misc.meanCount) * 100;
			}

			if(myCh->signal[C_SIG_STOP] == P1) {
				myCh->op.code = C_FAULT_STOP_CMD;
				myCh->op.select = SAVE_FLAG_SAVING_END;
				myCh->signal[C_SIG_STOP] = P0;
				cSemiSwitch_Rest(bd, ch, advStepNo, 0);
				myCh->op.phase = P100;
			} else if(myCh->signal[C_SIG_PAUSE] == P1) {
				//cmd, soft fault
				myCh->misc.tmpState = myCh->op.state;
				myCh->misc.tmpCode = myCh->op.code;
				myCh->op.code = C_FAULT_PAUSE_CMD;
				myCh->opSave = myCh->op;
				myCh->signal[C_SIG_PAUSE] = P0;
				cSemiSwitch_Rest(bd, ch, advStepNo, 0);
				myCh->op.phase = P100;
			} else if(myCh->signal[C_SIG_DLL_STOP] == P1) {
				myCh->op.code = C_FAULT_CELL_DIAGNOSIS_STOP;
				myCh->op.select = SAVE_FLAG_SAVING_END;
				myCh->signal[C_SIG_DLL_STOP] = P0;
				cSemiSwitch_Rest(bd, ch, advStepNo, 0);
				myCh->op.phase = P100;
			} else {
				if(cFailCodeCheck(bd, ch) >= 0) {
					cSoftFeedback(bd, ch, val1, val2, val3);
				}
			}

/* 20120126 kji value move phase 0
	    	if(myCh->op.checkDelayTime == 100) {
				myCh->misc.maxV = myCh->op.Vsens;
				myCh->misc.minV = myCh->op.Vsens;
				myCh->misc.maxI = myCh->op.Isens;
				myCh->misc.minI = myCh->op.Isens;
			}
	*/
			//201208 CanType Not Use ?
			if(myCh->misc.refFlag == P1) {
				myCh->misc.refFlag = P0;
				cCalCmdV(bd, ch, val1, div, rangeV);
			}

			//191010
			if(myCh->op.checkDelayTime < 100){
				myCh->misc.Pre_change_V = myCh->misc.tmpVsens;
			}
	    	if(myCh->op.checkDelayTime == 100) {
				myCh->misc.maxI = myCh->op.Isens;
				myCh->misc.minI = myCh->op.Isens;
			}

			if(myCh->op.phase == P100) {
				myCh->ccv[0].avg_v = myCh->misc.tmpVsens;
				myCh->ccv[0].avg_i = myCh->misc.tmpIsens;
				cNextStepCheck(bd, ch);
			} else {
			    deltaT = ((myCh->op.runTime / 10) * 10)
					- (myCh->misc.userPatternRunTime
	    			- myPs->misc.rt_scan_time);
				cnt = find_pattern_time(bd, ch, deltaT);
				if(myCh->misc.userPatternCnt != cnt) {	
					myCh->misc.userPatternCnt = cnt;
					myCh->misc.sensCount = 0;
					myCh->misc.sensCountFlag = 0;
					myCh->misc.pattern_point_runTime = 0;
					user_pattern_data(bd, ch);
				}
			}
			break;
		case P100:
			break;
		default: break;
    }
}

void cStepBalance(int bd, int ch)
{
	unsigned long refV , endV , advStepNo , mode;

	myCh = &(myData->bData[bd].cData[ch]);
	advStepNo = myCh->misc.advStepNo;
	refV = myPs->testCond[bd][ch].step[advStepNo].refV;
	endV = myPs->testCond[bd][ch].step[advStepNo].endV;
	mode = myPs->testCond[bd][ch].step[advStepNo].mode;
	
	switch(myCh->op.phase) {
		case P0:

//			rtn = temp_wait_flag_check(bd, ch);
//			if(rtn == 0) break;
	 	   	myCh->op.phase = P1;
			initCh(bd, ch);
			break;
		case P1:
			switch(mode){
				case CCCV:
				case CV:
				case C_RATE:
					if(myCh->op.Vsens > refV){ //Voltage >  refV  Discharge
						myCh->op.type = STEP_DISCHARGE;
						myCh->op.phase = P0;
						if(myPs->testCond[bd][ch].step[advStepNo].refI > 0)
							myPs->testCond[bd][ch].step[advStepNo].refI *= -1;
	 					myPs->testCond[bd][ch].step[advStepNo].type = 
								STEP_DISCHARGE;
					} else {
						myCh->op.type = STEP_CHARGE;
						myCh->op.phase = P0;
						if(myPs->testCond[bd][ch].step[advStepNo].refI < 0)
							myPs->testCond[bd][ch].step[advStepNo].refI *= -1;
	 					myPs->testCond[bd][ch].step[advStepNo].type = 
								STEP_CHARGE;
					}
					break;
				case CC:  //cc mode 
					if(endV == 0) {
						if(myCh->op.Vsens > refV){ //Voltage >  refV  Discharge
							myCh->op.type = STEP_DISCHARGE;
							myCh->op.phase = P0;
							if(myPs->testCond[bd][ch].step[advStepNo].refI > 0)
								myPs->testCond[bd][ch].step[advStepNo].refI *= -1;
	 						myPs->testCond[bd][ch].step[advStepNo].type = 
									STEP_DISCHARGE;
						} else {
							myCh->op.type = STEP_CHARGE;
							myCh->op.phase = P0;
							if(myPs->testCond[bd][ch].step[advStepNo].refI < 0)
								myPs->testCond[bd][ch].step[advStepNo].refI *= -1;
	 						myPs->testCond[bd][ch].step[advStepNo].type = 
									STEP_CHARGE;
						}
					} else {
						if(myCh->op.Vsens > endV){ //Voltage >  refV  Discharge
							myCh->op.type = STEP_DISCHARGE;
							myCh->op.phase = P0;
							if(myPs->testCond[bd][ch].step[advStepNo].refI > 0)
								myPs->testCond[bd][ch].step[advStepNo].refI *= -1;
	 						myPs->testCond[bd][ch].step[advStepNo].type = 
									STEP_DISCHARGE;
	 						myPs->testCond[bd][ch].step[advStepNo].refV =
								   endV - 100000;	
						} else {
							myCh->op.type = STEP_CHARGE;
							myCh->op.phase = P0;
							if(myPs->testCond[bd][ch].step[advStepNo].refI < 0)
								myPs->testCond[bd][ch].step[advStepNo].refI *= -1;
	 						myPs->testCond[bd][ch].step[advStepNo].type = 
									STEP_CHARGE;
	 						myPs->testCond[bd][ch].step[advStepNo].refV =
								   endV + 100000;	
						}
					}
					break;
				case CP:  //cp mode 
					if(endV == 0) {
						if(myCh->op.Vsens > refV){ //Voltage >  refV  Discharge
							myCh->op.type = STEP_DISCHARGE;
							myCh->op.phase = P0;
							if(myPs->testCond[bd][ch].step[advStepNo].refP < 0)
								myPs->testCond[bd][ch].step[advStepNo].refP *= -1;
	 						myPs->testCond[bd][ch].step[advStepNo].type = 
									STEP_DISCHARGE;
						} else {
							myCh->op.type = STEP_CHARGE;
							myCh->op.phase = P0;
							if(myPs->testCond[bd][ch].step[advStepNo].refP < 0)
								myPs->testCond[bd][ch].step[advStepNo].refP *= -1;
	 						myPs->testCond[bd][ch].step[advStepNo].type = 
									STEP_CHARGE;
						}
					} else {
						if(myCh->op.Vsens > endV){ //Voltage >  refV  Discharge
							myCh->op.type = STEP_DISCHARGE;
							myCh->op.phase = P0;
							if(myPs->testCond[bd][ch].step[advStepNo].refP < 0)
								myPs->testCond[bd][ch].step[advStepNo].refP *= -1;
	 						myPs->testCond[bd][ch].step[advStepNo].type = 
									STEP_DISCHARGE;
	 						myPs->testCond[bd][ch].step[advStepNo].refV =
								   endV - 100000;	
	 						myPs->testCond[bd][ch].step[advStepNo].refI *= -1;
						} else {
							myCh->op.type = STEP_CHARGE;
							myCh->op.phase = P0;
							if(myPs->testCond[bd][ch].step[advStepNo].refP < 0)
								myPs->testCond[bd][ch].step[advStepNo].refP *= -1;
	 						myPs->testCond[bd][ch].step[advStepNo].type = 
									STEP_CHARGE;
	 						myPs->testCond[bd][ch].step[advStepNo].refV =
								   endV + 100000;	
						}
					}
					break;
				}
			break;
		default:
			break;
	}
}

#if MACHINE_TYPE == 1
//140407 oys add
void cStepShort(int bd, int ch)
{
	int i, rangeV, rangeI, mode;
	unsigned long advStepNo, saveDt;

	S_CH_STEP_INFO step;
	myCh = &(myData->bData[bd].cData[ch]);
	step = step_info(bd, ch);

    advStepNo = step.advStepNo;
	rangeV = step.rangeV;
	rangeI = step.rangeI;
	saveDt = step.saveDt;
	mode = step.mode;
	
    switch(myCh->op.phase) {
		case P0:
			// 111212 oys w : cycleNo
			myCh->misc.cycleNo = myPs->testCond[bd][ch].step[advStepNo].cycleNo;

			initCh(bd, ch);
			myCh->misc.maxV = myCh->op.Vsens;
			myCh->misc.startV = myCh->op.Vsens;
			myCh->misc.minV = myCh->op.Vsens;
			myCh->misc.startT = myCh->op.temp;
			myCh->misc.maxT = myCh->op.temp;
			myCh->misc.minT = myCh->op.temp;
			myCh->signal[C_SIG_OUT_SWITCH] = P0;
			myCh->op.Vsens = 0;
			myCh->op.Isens = 0;
			
			cSemiSwitch_Rest(bd, ch, advStepNo, 0);
			myCh->misc.start = 0;	
			myCh->op.phase = P10;
			break;
		case P10:
			myCh->op.Vsens = 0;
			myCh->op.Isens = 0;
			cSemiSwitch_Rest(bd, ch, advStepNo, 0);
			myCh->misc.start = 0;
			myCh->op.phase = P20;
			break;
		case P20:
			myCh->op.Vsens = 0;
			myCh->op.Isens = 0;
			myCh->op.checkDelayTime += myPs->misc.rt_scan_time;
			if(myCh->op.checkDelayTime >= 60000){
				myCh->op.checkDelayTime = 0;
				myCh->misc.tmpState = myCh->op.state;
				myCh->misc.tmpCode = myCh->op.code;
				myCh->op.code = C_FAULT_SHORT_TESTER_ERROR;
				myCh->opSave = myCh->op;
				myCh->op.phase = P100;
				break;
			}
			if(myData->bData[bd].ch_short_di[ch].ch_io == P0){
				myCh->op.phase = P10;
				break;
			}else if((myData->bData[bd].ch_short_di[ch].io.ready == P1)
					 && (myData->bData[bd].ch_short_di[ch].io.run == P1)){
				myCh->op.checkDelayTime = 0;
				myCh->op.phase = P50;
				break;
			}else if(myData->bData[bd].ch_short_di[ch].io.alram == P1){
				myCh->misc.tmpState = myCh->op.state;
				myCh->misc.tmpCode = myCh->op.code;
				myCh->op.code = C_FAULT_SHORT_TESTER_ERROR;
				myCh->opSave = myCh->op;
				myCh->op.phase = P100;
				break;
			}else if(myData->bData[bd].ch_short_di[ch].io.ready == P1){
    			myCh->op.code = C_CODE_IDLE;
				myCh->op.phase = P10;
				break;	
			}
			if(myCh->signal[C_SIG_STOP] == P1) {
				myCh->op.code = C_FAULT_STOP_CMD;
				myCh->op.select = SAVE_FLAG_SAVING_END;
				myCh->signal[C_SIG_STOP] = P0;
				myCh->op.phase = P100;
				break;
			} else if(myCh->signal[C_SIG_PAUSE] == P1) {
				myCh->misc.tmpState = myCh->op.state;
				myCh->misc.tmpCode = myCh->op.code;
				myCh->op.code = C_FAULT_PAUSE_CMD;
				myCh->opSave = myCh->op;
				myCh->signal[C_SIG_PAUSE] = P0;
				myCh->op.phase = P100;
				break;
			} else if(myCh->signal[C_SIG_DLL_STOP] == P1) {
				myCh->op.code = C_FAULT_CELL_DIAGNOSIS_STOP;
				myCh->op.select = SAVE_FLAG_SAVING_END;
				myCh->signal[C_SIG_DLL_STOP] = P0;
				myCh->op.phase = P100;
				break;
			}
			break;
		case P50:
 //			sens_ch_ad_count_increment(bd, ch);
			myCh->op.Vsens = 0;
			myCh->op.Isens = 0;
			myCh->op.runTime += myPs->misc.rt_scan_time;
			myCh->misc.cycleRunTime += myPs->misc.rt_scan_time;
			myCh->op.checkDelayTime += myPs->misc.rt_scan_time;
			//ALRAM
			if(myData->bData[bd].ch_short_di[ch].io.alram == P1){
				myCh->misc.tmpState = myCh->op.state;
				myCh->misc.tmpCode = myCh->op.code;
				myCh->op.code = C_FAULT_SHORT_TESTER_ERROR;
				myCh->opSave = myCh->op;
				myCh->op.phase = P100;
			}
			if(myCh->signal[C_SIG_STOP] == P1) {
				myCh->op.code = C_FAULT_STOP_CMD;
				myCh->op.select = SAVE_FLAG_SAVING_END;
				myCh->signal[C_SIG_STOP] = P0;
				myCh->op.phase = P100;
			} else if(myCh->signal[C_SIG_PAUSE] == P1) {
				myCh->misc.tmpState = myCh->op.state;
				myCh->misc.tmpCode = myCh->op.code;
				myCh->op.code = C_FAULT_PAUSE_CMD;
				myCh->opSave = myCh->op;
				myCh->signal[C_SIG_PAUSE] = P0;
				myCh->op.phase = P100;
			} else if(myCh->signal[C_SIG_DLL_STOP] == P1) {
				myCh->op.code = C_FAULT_CELL_DIAGNOSIS_STOP;
				myCh->op.select = SAVE_FLAG_SAVING_END;
				myCh->signal[C_SIG_DLL_STOP] = P0;
				myCh->op.phase = P100;
			} else {
				i = cFailCodeCheck(bd, ch);
			}
			if(myCh->op.phase == P100){
				cNextStepCheck(bd, ch);
			}
	    	break;
		case P99:
			myCh->op.checkDelayTime += myPs->misc.rt_scan_time;
			if(myCh->op.checkDelayTime >= 200){
				myCh->op.checkDelayTime = 0;
				myCh->op.phase = P100;
				cNextStepCheck(bd, ch);
			}
	    	break;
		case P100:
			break;
		default:
			break;
    }
}
#endif

void cStepDefault(int bd, int ch)
{
	myCh = &(myData->bData[bd].cData[ch]);

	switch(myCh->op.type) {
		case STEP_ADV_CYCLE:
			cStepAdvCycle(bd, ch);
			break;
		case STEP_PARALLEL_CYCLE: //kjg_180521
			cStepParallelCycle(bd, ch);
			break;
		case STEP_LOOP:
			cStepLoop(bd, ch, 0);
			break;
		case STEP_END:
			cStepEnd(bd, ch);
			break;
		default:
			break;
	}
}

int AdvStepFlag(int bd, int ch)
{
	unsigned char bd_1, ch_1, flag;
	int i, j;

	myCh = &(myData->bData[bd].cData[ch]);

	i = 0;
	if(myPs->testCond[bd][ch].reserved.reserved_cmd == 0) {
		i = 0; //next
		myCh->misc.reserved_cmd_flag = i;
	} else if(myPs->testCond[bd][ch].reserved.reserved_cmd == 1) {
		if(myPs->testCond[bd][ch].reserved.reserved_stepNo
			<= myCh->op.stepNo) {
			if(myPs->testCond[bd][ch].reserved.reserved_cycleNo
				<= myCh->misc.currentCycle) {
				myCh->op.code = C_FAULT_STOP_CMD;
				myCh->op.select = SAVE_FLAG_SAVING_END;
				i = 1; //stop
				myCh->misc.reserved_cmd_flag = i;
			}
		}
	} else {
		if(myPs->testCond[bd][ch].reserved.reserved_stepNo
			<= myCh->op.stepNo) {
			if(myPs->testCond[bd][ch].reserved.reserved_cycleNo
				<= myCh->misc.currentCycle) {
				i = 2; //pause
				myCh->misc.tmpState = myCh->op.state;
				myCh->misc.tmpCode = myCh->op.code;
				myCh->op.code = C_FAULT_PAUSE_CMD;
				myCh->misc.reserved_cmd_flag = i;
			}
		}
	}

//170501 oys add : testCond pause option
#if VENDER == 3
	if(myCh->misc.stepNo_pause != 0 && myCh->misc.cycleNo_pause != 0) {
		if(myCh->misc.stepNo_pause <= myCh->op.stepNo) {
			if(myCh->misc.cycleNo_pause <= myCh->misc.currentCycle) {
				i = 2; //pause
				myCh->misc.stepNo_pause = 0;
				myCh->misc.cycleNo_pause = 0;
				myCh->misc.tmpState = myCh->op.state;
				myCh->misc.tmpCode = myCh->op.code;
				myCh->op.code = C_FAULT_PAUSE_CMD;
			}
		}
	}
#endif

//171123 oys add : ch group error check
	if(myCh->misc.chGroupNo != P0 && myCh->misc.tempWaitType == P1
		&& myCh->misc.stepSyncFlag == P0 && myCh->misc.chGroupCheckFlag == P0) {
		flag = 0;
		for(j=0; j < myPs->config.installedCh; j++) {
			bd_1 = j / myPs->config.chPerBd;
			ch_1 = j % myPs->config.chPerBd;
			if(myCh->misc.chGroupNo
				== myData->bData[bd_1].cData[ch_1].misc.chGroupNo) {
				if(myData->bData[bd_1].cData[ch_1].op.state == C_PAUSE) {
					flag++;
				}
			}
		}
#ifdef _TRACKING_MODE //211124 rewirte C_FAULT_CH_GROUP not use with Chamber_Wait_Release
			flag = 0;
#endif
		if(flag != 0) {
			i = 2; //pause
			myCh->misc.chGroupCheckFlag = P1;
			myCh->misc.tmpState = myCh->op.state;
			myCh->misc.tmpCode = myCh->op.code;
			myCh->op.code = C_FAULT_CH_GROUP;
		}
	}

	return i;
}

void cStepAdvCycle(int bd, int ch)
{
	unsigned char endC_std_type, endP_std_type, endZ_std_type, rangeI;
   	unsigned short	reduce_ratio_C, reduce_ratio_P, c_rate;
	int i, stepType;
	long startTemp, groupTemp, refTemp, refTemp_backup;
    long stdC_val, stdP_val, stdZ_val;
	unsigned long advStepNo;
#if CYCLER_TYPE == LINEAR_CYC
	unsigned char parallel_ch;
#endif
#if CAPACITY_CONTROL == 1
	long rtn = 0;
//	unsigned short	C_Rate_stepNo[MAX_C_RATE_STEP_NO];
//	short int		C_Rate_Persent[MAX_C_RATE_STEP_NO];
#endif
#if CHAMBER_TEMP_HUMIDITY == 1	//kjc_210417
	int j;
#endif
	
	myCh = &(myData->bData[bd].cData[ch]);
	
#ifdef _TRACKING_MODE
	if(myCh->misc.totalCycle <= 1){
		if(myPs->testCond[bd][ch].safety.schedule_link_flag == P0){
			if(myPs->testCond[bd][ch].safety.rptsoc != 0
				&& myPs->testCond[bd][ch].safety.soc != 0){
			}else{
				myCh->op.rptSOC = 0;
				myCh->op.SOC = 0;
			}
		//	myCh->op.link_rptSOC = 0;
		}
		if(myPs->testCond[bd][ch].safety.schedule_link_flag2 == P0){ //211022
			if(myPs->testCond[bd][ch].safety.rptsoh != 0
				&& myPs->testCond[bd][ch].safety.soh != 0){
			}else{
				myCh->op.rptSOH = 0;
				myCh->op.SOH = 0;
			}
		//	myCh->op.link_rptSOC = 0;
		}
	}
#endif
	
#if CYCLER_TYPE == LINEAR_CYC
	if(myPs->config.parallelMode == P2) {
		switch(myCh->op.phase) { //kjg_180521
			case P0:
				if((ch % 2) == 0) parallel_ch = ch + 1;
				else parallel_ch = ch - 1;

				if(myData->bData[bd].cData[parallel_ch].misc.
					parallel_cycle_phase == P0
				   	|| myData->bData[bd].cData[parallel_ch].misc.
					parallel_cycle_phase == P12) {
					if(myCh->misc.parallel_cycle_phase == P50) { //kjg_180521
						//cSemiSwitch(bd, ch);
						//kjg_180521 P1 -> P0
						myCh->signal[C_SIG_OUT_SWITCH] = P0;
						//kjg_180521 myCh->signal[C_SIG_RANGE_SWITCH] = P0;
						myCh->signal[C_SIG_RANGE_SWITCH] = P0;
						myCh->signal[C_SIG_PARALLEL_SWITCH] = P0;
						myCh->misc.parallel_cycle_phase = P11;
						myCh->op.phase++;
					} else {
						myCh->signal[C_SIG_OUT_SWITCH] = P1; //kjg_180521
						myCh->signal[C_SIG_PARALLEL_SWITCH] = P0;

						myCh->misc.parallel_cycle_phase = P0;

						advStepNo = myCh->misc.advStepNo + 1;
						stepType = myPs->testCond[bd][ch].step[advStepNo].type;
						if(stepType == STEP_REST) {
							if(myPs->testCond[bd][ch].
											step[advStepNo].endT != 0) {
								if(myPs->testCond[bd][ch].step[advStepNo].endT
									>= 6000) {
								} else {
									cSemiSwitch_Start(bd, ch,
										myPs->testCond[bd][ch].
											step[advStepNo + 1].type);
								}
							} else {
							}
						} else if(stepType == STEP_USER_PATTERN) {
							cSemiSwitch_Start(bd, ch, stepType);
						} else if(stepType == STEP_OCV) {
							cSemiSwitch_Start(bd, ch, myPs->testCond[bd][ch]
								.step[advStepNo + 1].type);
						} else if(stepType == STEP_SHORT) {
						} else {
							cSemiSwitch_Start(bd, ch, stepType);
						}

						myCh->op.phase = P50;
					}
				} else {
					//cSemiSwitch(bd, ch);
					//kjg_180521 P1 -> P0
					myCh->signal[C_SIG_OUT_SWITCH] = P0;
					//kjg_180521 myCh->signal[C_SIG_RANGE_SWITCH] = P0;
					myCh->signal[C_SIG_RANGE_SWITCH] = P0;
					myCh->signal[C_SIG_PARALLEL_SWITCH] = P0;
					myCh->misc.parallel_cycle_phase = P11;
					myCh->op.phase++;
				}
				break;
			case P1: //wait relay active
			case P2:
			case P3:
				myCh->op.phase++;
				break;
			case P4:
				myCh->misc.parallel_cycle_phase = P12;
				myCh->op.phase++;
				break;
			case P5:
				if((ch % 2) == 0) parallel_ch = ch + 1;
				else parallel_ch = ch - 1;

				if(myData->bData[bd].cData[parallel_ch].misc.
					parallel_cycle_phase == P0
					|| myData->bData[bd].cData[parallel_ch].misc.
					parallel_cycle_phase == P12) {

					if(myCh->misc.cycle_p_flag == P1){	//190308 lyh add
						myCh->misc.cycle_p_flag = P0;
						myCh->op.code = myCh->misc.tmpCode;
					}
					myCh->signal[C_SIG_OUT_SWITCH] = P1; //kjg_180521
					myCh->misc.parallel_cycle_phase = P0;
					advStepNo = myCh->misc.advStepNo + 1;
					stepType = myPs->testCond[bd][ch].step[advStepNo].type;
					if(stepType == STEP_REST) {
						if(myPs->testCond[bd][ch].step[advStepNo].endT != 0) {
							if(myPs->testCond[bd][ch].step[advStepNo].endT
								>= 6000) {
							} else {
								cSemiSwitch_Start(bd, ch, myPs->testCond[bd][ch]
									.step[advStepNo + 1].type);
							}
						} else {
						}
					} else if(stepType == STEP_USER_PATTERN) {
						cSemiSwitch_Start(bd, ch, stepType);
					} else if(stepType == STEP_OCV) {
						cSemiSwitch_Start(bd, ch, myPs->testCond[bd][ch]
							.step[advStepNo + 1].type);
					} else if(stepType == STEP_SHORT) {
					} else {
						cSemiSwitch_Start(bd, ch, stepType);
					}

					myCh->op.phase = P50;
				} else { //iyhw_180530
					if(myCh->signal[C_SIG_STOP] == P1) {
						myCh->op.code = C_FAULT_STOP_CMD;
						myCh->op.select = SAVE_FLAG_SAVING_END;
						myCh->signal[C_SIG_STOP] = P0;
						//kjg_180524 cSemiSwitch_Rest(bd, ch, advStepNo, 0);
						myCh->op.phase = P100;
					} else if(myCh->signal[C_SIG_PAUSE] == P1) {
						myCh->misc.tmpState = myCh->op.state;
						if(myCh->op.code != C_CYCLE_P_STEP_WAIT){
							myCh->misc.tmpCode = myCh->op.code;
						}
						myCh->op.code = C_FAULT_PAUSE_CMD;
						myCh->opSave = myCh->op;
						myCh->signal[C_SIG_PAUSE] = P0;
						//kjg_180524 cSemiSwitch_Rest(bd, ch, advStepNo, 0);
						myCh->op.phase = P100;
					} else if(myCh->signal[C_SIG_DLL_STOP] == P1) {
						myCh->op.code = C_FAULT_CELL_DIAGNOSIS_STOP;
						myCh->op.select = SAVE_FLAG_SAVING_END;
						myCh->signal[C_SIG_DLL_STOP] = P0;
						//cSemiSwitch_Rest(bd, ch, advStepNo, 0);
						myCh->op.phase = P100;
					} else if(myCh->signal[C_SIG_NEXTSTEP] == P1) {
						myCh->signal[C_SIG_NEXTSTEP] = P0;
					} else {	//190308 add
						if(myCh->misc.cycle_p_flag == P0){
							myCh->misc.cycle_p_flag = P1;
							myCh->misc.tmpCode = myCh->op.code;
						}
						myCh->op.code = C_CYCLE_P_STEP_WAIT;
					}

					if(myCh->op.phase == P100) cNextStepCheck(bd, ch);
				}
				break;
			default:
				break;
		}
		if(myCh->op.phase != P50) return;
	}
#else
	//190703 lyhw add relay Switch On off Check
	if(myCh->op.code == C_END_CYCLE_TIME){	
		switch(myCh->op.phase) { 
			case P0:
				myCh->op.checkDelayTime = 0;
				advStepNo = myCh->misc.advStepNo + 1;
				stepType = myPs->testCond[bd][ch].step[advStepNo].type;
				if(stepType == STEP_REST){
					if(myPs->testCond[bd][ch].step[advStepNo].endT >= 6000){
						myCh->op.phase = P50;
					}else{
						myCh->op.phase = P1;
					}
				}else if(stepType == STEP_SHORT){
					myCh->op.phase = P50;
				}else{
					myCh->op.phase = P1;
				}
				break;
			case P1:
				//210323 add for can cycler
				if(myData->AppControl.config.systemType == CYCLER_CAN){
					advStepNo = myCh->misc.advStepNo + 1;
					myCh->op.rangeV 
						= myPs->testCond[bd][ch].step[advStepNo].rangeV;
					myCh->op.rangeI 
						= myPs->testCond[bd][ch].step[advStepNo].rangeI;
					myCh->signal[C_SIG_V_RANGE] = myCh->op.rangeV + 1;
					myCh->signal[C_SIG_I_RANGE]	= myCh->op.rangeI + 1;

					if(myCh->op.checkDelayTime == 10){
						cSemiSwitch_CAN(bd, ch);
					}
					if(myCh->op.checkDelayTime == 20){
						myCh->signal[C_SIG_RANGE_SWITCH] = P1;
					}
					myCh->op.checkDelayTime += myPs->misc.rt_scan_time;
					if(myCh->op.checkDelayTime >= 30){
						myCh->signal[C_SIG_OUT_SWITCH] = P1;
						myCh->op.checkDelayTime = 0;
						myCh->op.phase = P50;
					}
				}else{
					if(myCh->op.checkDelayTime == 10){
						if(myCh->signal[C_SIG_OUT_SWITCH_ON] != P3)
							myCh->signal[C_SIG_OUT_SWITCH_ON] = P1;
					}
						
					if(myCh->op.checkDelayTime == 20){
						if(myCh->ChAttribute.opType == P0) {
							ch_send_cmd(bd, ch, ADDR_PCU_CLASS_MULTICAST
													, CMD_PCU_MODE_CC, 0, 0);
						}
					}
					myCh->op.checkDelayTime += myPs->misc.rt_scan_time;
					if(myCh->op.checkDelayTime > 30){
						myCh->op.checkDelayTime = 0;
						myCh->op.phase = P50;
					}
				}
				break;
			default:
				break;	
		}
		if(myCh->op.phase != P50) return;
	}
#endif	
	advStepNo = myCh->misc.advStepNo;
	stepType = myPs->testCond[bd][ch].step[advStepNo].type;
	c_rate = myPs->testCond[bd][ch].step[advStepNo].endTCVGoto;
	reduce_ratio_C = myPs->testCond[bd][ch].step[advStepNo].advCycleCount;
	reduce_ratio_P = myPs->testCond[bd][ch].step[advStepNo].reduce_ratio_P;
	
	//Standard Step Type
	endC_std_type = myPs->testCond[bd][ch].step[advStepNo].socCapStepNo;
	endP_std_type = myPs->testCond[bd][ch].step[advStepNo].endP_std_type;
	endZ_std_type = myPs->testCond[bd][ch].step[advStepNo].endZ_std_type;
	
	//151214 oys w : completeFlag -> Cycle Capacity Efficiency End Option
	//( use SEC_TYPE == 1 )
	myCh->misc.completeFlag
		= myPs->testCond[bd][ch].step[advStepNo].gotoCycleCount;

	//Soc check count
	myCh->misc.socCheckCount
		= myPs->testCond[bd][ch].step[advStepNo].endVGoto;

	//Cycle end capacity
	myCh->misc.cycleEndC
		= myPs->testCond[bd][ch].step[advStepNo].endDeltaV;

	//Standard value select <- first Cycle or step
	myCh->misc.endC_std_sel
		= myPs->testCond[bd][ch].step[advStepNo].endCGoto;
	myCh->misc.endP_std_sel
		= myPs->testCond[bd][ch].step[advStepNo].endP_std_sel;
	myCh->misc.endZ_std_sel
		= myPs->testCond[bd][ch].step[advStepNo].endZ_std_sel;
	myCh->misc.endC_std_cycleCount
		= myPs->testCond[bd][ch].step[advStepNo].endC_std_cycleCount;
	myCh->misc.endP_std_cycleCount
		= myPs->testCond[bd][ch].step[advStepNo].endP_std_cycleCount;
	myCh->misc.endZ_std_cycleCount
		= myPs->testCond[bd][ch].step[advStepNo].endZ_std_cycleCount;
#if CAPACITY_CONTROL == 1
	myCh->misc.CycleCapaCount
		= myPs->testCond[bd][ch].step[advStepNo].CycleCapaCount;	
#endif
#if CHAMBER_TEMP_HUMIDITY == 1	//kjc_210414
	myCh->misc.calc_retain_Ah = 0;
	myCh->misc.chargeAccAh = 0;
	myCh->misc.dischargeAccAh = 0;
	myCh->misc.faultEfficiencyAh = 0;
	myCh->misc.efficiency_Ah[1] = 0;

	for(i = advStepNo; i < myPs->testCond[bd][ch].header.totalStep; i ++) {
		if(myPs->testCond[bd][ch].step[i].type == STEP_LOOP){
			myCh->misc.loopStepNo = i; 
			break;
		}
	}
	for(j = myCh->misc.loopStepNo; j > advStepNo; j--){
		if(myPs->testCond[bd][ch].step[j].type == STEP_DISCHARGE){
			myCh->misc.dischargeStepNo = j;
			break;
		}	
	}
#endif
	//User standard input value	
	if(myCh->misc.cRateUseFlag == P1) {
		stdC_val = 0;
	} else {
		stdC_val = myPs->testCond[bd][ch].step[advStepNo].endP;
	}
	stdP_val = myPs->testCond[bd][ch].step[advStepNo].refV;
	stdZ_val = myPs->testCond[bd][ch].step[advStepNo].endIGoto;

	if(myCh->misc.cycleNo
		!= myPs->testCond[bd][ch].step[advStepNo].cycleNo) {
		myCh->misc.socCountNo[0] = 0;
		myCh->misc.socCountNo[1] = 0;
		myCh->misc.socCountNo[2] = 0;
		myCh->misc.pause_flag = P0;

		//190801 oys add
		for(i=0; i < MAX_STEP; i++) {
			myCh->misc.sel_Cyc_C_Cap[i] = 0;
			myCh->misc.sel_Cyc_D_Cap[i] = 0;
		}

#if VENDER == 3
		if(stdC_val != 0) {
			myCh->misc.standardC = stdC_val;
			myCh->misc.standardC_Flag = P1;
			for(i=0; i < MAX_STEP; i++) {
				myCh->misc.ahEndRatio[i] = 100; //default : 100
			}
		} else {
			if(endC_std_type != 0 || myCh->misc.endC_std_sel > 1) {
				myCh->misc.standardC_Flag = P0;
				myCh->misc.standardC = 0;
				for(i=0; i < MAX_STEP; i++) {
					myCh->misc.ahEndRatio[i] = 100; //default : 100
				}
			}
		}

		if(stdP_val != 0) {
			myCh->misc.standardP = stdP_val;
			myCh->misc.standardP_Flag = P1;
			for(i=0; i < MAX_STEP; i++) {
				myCh->misc.whEndRatio[i] = 100; //default : 100
			}
		} else {
			if(endP_std_type != 0 || myCh->misc.endP_std_sel > 1) {
				myCh->misc.standardP_Flag = P0;
				myCh->misc.standardP = 0;
				for(i=0; i < MAX_STEP; i++) {
					myCh->misc.whEndRatio[i] = 100; //default : 100
				}
			}
		}

		if(stdZ_val != 0) {
			myCh->misc.standardZ = stdZ_val;
			myCh->misc.standardZ_Flag = P1;
		} else {
			if(endZ_std_type != 0 || myCh->misc.endZ_std_sel > 1) {
				myCh->misc.standardZ_Flag = P0;
				myCh->misc.standardZ = 0;
			}
		}
#endif
	}

#if VENDER != 3
	//160510 oys w : Cycle Capacity Efficiency End
	if(stdC_val != 0) {
		myCh->misc.standardC = stdC_val;
		myCh->misc.standardC_Flag = P1;
		for(i=0; i < MAX_STEP; i++) {
			myCh->misc.ahEndRatio[i] = 100; //default : 100
		}
	} else {
		if(endC_std_type != 0) {
			if(myCh->misc.standardC_Flag == P0) myCh->misc.standardC = 0;

			for(i=0; i < MAX_STEP; i++) {
				myCh->misc.ahEndRatio[i] = 100; //default : 100
			}
		}
	}
#endif

//170501 oys add : testCond pause option
#if VENDER == 3
	if(VENDER == 3) {
		while(1) {
			advStepNo++;

			if(STEP_LOOP == myPs->testCond[bd][ch].step[advStepNo].type) {
				if(myCh->misc.pause_flag == P0) {
					if(myPs->testCond[bd][ch].step[advStepNo].stepNo_pause != 0
						|| myPs->testCond[bd][ch].step[advStepNo].cycleNo_pause
						!= 0) {
						myCh->misc.stepNo_pause = myPs->testCond[bd][ch]
							.step[advStepNo].stepNo_pause;
						myCh->misc.cycleNo_pause = myPs->testCond[bd][ch]
							.step[advStepNo].cycleNo_pause;
						myCh->misc.pause_flag = P1;
					}
				}

				advStepNo = myCh->misc.advStepNo;
				break;
			}
		}
	}
#endif

#if VENDER == 3
	if(myCh->misc.standardC != 0 || myCh->misc.standardP != 0) {
#else
	if(myCh->misc.standardC != 0) {
#endif		
		if(myCh->misc.cycleNo 
			!= myPs->testCond[bd][ch].step[advStepNo].cycleNo) {
			//LGC C-rate Standard Capacity Auto Calculation ref I value.
			if(VENDER == 1) {
				while(1) {
					advStepNo++;

					if(STEP_LOOP 
						== myPs->testCond[bd][ch].step[advStepNo].type) {
						send_msg(MODULE_TO_MAIN,
							MSG_MODULE_MAIN_STEP_COND_UPDATE, bd, ch);
						break;
					}

					if(c_rate == 0) break;

					if(myPs->testCond[bd][ch].step[advStepNo]
						.cycleEndStepSave == 1) {
						stepType = myPs->testCond[bd][ch].step[advStepNo].type;
						if(stepType == STEP_CHARGE) {
							if(myCh->ChAttribute.chNo_master == P0) {
								myPs->testCond[bd][ch].step[advStepNo].refI
									= (myCh->misc.standardC
									* ((float)c_rate / 100)) / 2;
								myPs->testCond[bd][ch-1].step[advStepNo].refI
									= myPs->testCond[bd][ch].step[advStepNo]
									.refI;
							} else {
								myPs->testCond[bd][ch].step[advStepNo].refI
									= myCh->misc.standardC
									* ((float)c_rate / 100);
							}
						} else if(stepType == STEP_DISCHARGE) {
							if(myCh->ChAttribute.chNo_master == P0) {
								myPs->testCond[bd][ch].step[advStepNo].refI
									= ((myCh->misc.standardC
									* ((float)c_rate / 100)) / 2) * -1;
								myPs->testCond[bd][ch-1].step[advStepNo].refI
									= myPs->testCond[bd][ch].step[advStepNo]
									.refI;
							} else {
								myPs->testCond[bd][ch].step[advStepNo].refI
									= (myCh->misc.standardC
									* ((float)c_rate / 100)) * -1;
							}
						}

						//171102 add for c_rate Change RangeI
						rangeI = 0;
						for(i=MAX_RANGE; i > 0; i--) {
							if(labs(myPs->testCond[bd][ch].step[advStepNo].refI)
								 <= myData->mData.config.maxCurrent[i - 1]) {
								rangeI = i - 1;
								break;
							}
						}
						
						if(myCh->ChAttribute.chNo_master == P0) {
							myData->mData.testCond[bd][ch].step[advStepNo]
								.rangeI = rangeI;
							myData->mData.testCond[bd][ch - 1].step[advStepNo]
								.rangeI = rangeI;
						} else {
							myData->mData.testCond[bd][ch].step[advStepNo]
								.rangeI = rangeI;
						}

						//add for Change standardC
						myCh->misc.standardC_Flag = P0;

						//changeRefI
						if(stepType == STEP_CHARGE
							|| stepType == STEP_DISCHARGE) {
							myCh->misc.changeRefI[advStepNo] = P1;
						}
					}	
				}
				advStepNo = myCh->misc.advStepNo;
				//changeRefI end
			} else if(VENDER == 2) {
				//ampareHour
				if(reduce_ratio_C != 0) {
					if(myCh->misc.ahEndRatio[advStepNo] > reduce_ratio_C) {
						myCh->misc.ahEndRatio[advStepNo]
							= myCh->misc.ahEndRatio[advStepNo] - reduce_ratio_C;
					}
					myCh->misc.standardC = myCh->misc.standardC
						* myCh->misc.ahEndRatio[advStepNo] / 100;
					myCh->misc.standardC_Flag = P1;
				}
			} else if(VENDER == 3) {
				//ampareHour
				if(myCh->misc.standardC != 0) {
					if(reduce_ratio_C != 0) {
						if(myCh->misc.ahEndRatio[advStepNo] > reduce_ratio_C) {
							myCh->misc.ahEndRatio[advStepNo]
								= myCh->misc.ahEndRatio[advStepNo]
								- reduce_ratio_C;
						}

						myCh->misc.standardC = myCh->misc.standardC
							* myCh->misc.ahEndRatio[advStepNo] / 100;
						myCh->misc.standardC_Flag = P1;
					}
				}

				//wattHour
				if(myCh->misc.standardP != 0) {
					if(reduce_ratio_P != 0) {
						if(myCh->misc.whEndRatio[advStepNo] > reduce_ratio_P) {
							myCh->misc.whEndRatio[advStepNo]
								= myCh->misc.whEndRatio[advStepNo]
								- reduce_ratio_P;
						}

						myCh->misc.standardP = myCh->misc.standardP
							* myCh->misc.whEndRatio[advStepNo] / 100;
						myCh->misc.standardP_Flag = P1;
					}
				}
			}
		}
	}	
#if CAPACITY_CONTROL == 1
	if(VENDER == 1){ //210402
		while(1) {
			advStepNo++;
			
			if(STEP_LOOP 
				== myPs->testCond[bd][ch].step[advStepNo].type) {
				break;
			}
	//		if(myPs->testCond[bd][ch].step[advStepNo].mode != C_RATE) break;
	
			stepType = myPs->testCond[bd][ch].step[advStepNo].type;
			if(stepType == STEP_CHARGE || stepType == STEP_DISCHARGE){
				if(myPs->testCond[bd][ch].step[advStepNo].mode == C_RATE){
				//211223 C-RATE Rewrite
				/*	for(i=0; i < 10; i++){
						C_Rate_Persent[i] = 
								myPs->testCond[bd][ch].step[advStepNo].C_Rate_Persent[i];
						C_Rate_stepNo[i] =
							   	myPs->testCond[bd][ch].step[advStepNo].C_Rate_stepNo[i]; 
						if(C_Rate_stepNo[i] !=0){
							myCh->misc.C_Rate_Calc_Capacity[i] = 
								myCh->misc.C_Rate_stepCapacity[C_Rate_stepNo[i]-1]
								* ((float)C_Rate_Persent[i]/10000);	
						}
					}
					for(i=0; i < 10; i++){
						myCh->misc.Sum_C_Rate_Calc_Capacity 
							+= myCh->misc.C_Rate_Calc_Capacity[i];
					}*/
					
					rtn = Calculate_C_Rate_Capacity(bd, ch, advStepNo);
					myCh->misc.Sum_C_Rate_Calc_Capacity = rtn;
					if(myCh->misc.Sum_C_Rate_Calc_Capacity != 0){
						if(myCh->ChAttribute.chNo_master == P0) { //parallel
							if(stepType == STEP_CHARGE){
								myCh->misc.Sum_C_Rate_Calc_Capacity =
									(labs)(myCh->misc.Sum_C_Rate_Calc_Capacity);
						//		if(myCh->misc.Sum_C_Rate_Calc_Capacity < 0){
						//			myCh->misc.c_rate_fault_flag[advStepNo]= P1;
						//		}			
							}else if(stepType == STEP_DISCHARGE){
								if(myCh->misc.Sum_C_Rate_Calc_Capacity > 0){ 
									myCh->misc.Sum_C_Rate_Calc_Capacity =
									- (myCh->misc.Sum_C_Rate_Calc_Capacity);
								}
						//		if(myCh->misc.Sum_C_Rate_Calc_Capacity > 0){
						//			myCh->misc.c_rate_fault_flag[advStepNo]= P1;
						//		}			
							}
							// refI rewrite
							myPs->testCond[bd][ch].step[advStepNo].refI
								= (myCh->misc.Sum_C_Rate_Calc_Capacity / 2);
							myPs->testCond[bd][ch-1].step[advStepNo].refI
								= myPs->testCond[bd][ch].step[advStepNo].refI;
							// refI > maxI X or refI < minI X  (parallel_mode)
							if(myPs->testCond[bd][ch].step[advStepNo].refI > 0){
								if((myCh->misc.Sum_C_Rate_Calc_Capacity / 2) 
									>= myData->mData.config.maxCurrent[0]){
									myPs->testCond[bd][ch].step[advStepNo].refI
										= myData->mData.config.maxCurrent[0];
									myPs->testCond[bd][ch-1].step[advStepNo].refI
									= myPs->testCond[bd][ch].step[advStepNo].refI;
								}
							}else{
								if((myCh->misc.Sum_C_Rate_Calc_Capacity / 2)
									<= myData->mData.config.minCurrent[0]){
									myPs->testCond[bd][ch].step[advStepNo].refI
										= myData->mData.config.minCurrent[0];
									myPs->testCond[bd][ch-1].step[advStepNo].refI
									= myPs->testCond[bd][ch].step[advStepNo].refI;
								}
							}	
						} else { //single
							if(stepType == STEP_CHARGE){
								myCh->misc.Sum_C_Rate_Calc_Capacity =
									(labs)(myCh->misc.Sum_C_Rate_Calc_Capacity);
						//		if(myCh->misc.Sum_C_Rate_Calc_Capacity < 0){
						//			myCh->misc.c_rate_fault_flag[advStepNo]= P1;
						//		}			
							}else if(stepType == STEP_DISCHARGE){		
								if(myCh->misc.Sum_C_Rate_Calc_Capacity > 0){ 
									myCh->misc.Sum_C_Rate_Calc_Capacity =
									- (myCh->misc.Sum_C_Rate_Calc_Capacity);
								}
						//		if(myCh->misc.Sum_C_Rate_Calc_Capacity > 0){
						//			myCh->misc.c_rate_fault_flag[advStepNo]= P1;
						//		}			
							}
							// refI rewirte
							myPs->testCond[bd][ch].step[advStepNo].refI
								= myCh->misc.Sum_C_Rate_Calc_Capacity;
							// refI > maxI X or refI < minI X (single_mode)
							if(myPs->testCond[bd][ch].step[advStepNo].refI > 0){
								if(myCh->misc.Sum_C_Rate_Calc_Capacity 
									>= myData->mData.config.maxCurrent[0]){
									myPs->testCond[bd][ch].step[advStepNo].refI
										= myData->mData.config.maxCurrent[0];
								}
							}else{
								if(myCh->misc.Sum_C_Rate_Calc_Capacity
									<= myData->mData.config.minCurrent[0]){
									myPs->testCond[bd][ch].step[advStepNo].refI
										= myData->mData.config.minCurrent[0];
								}
							}	
						}
					}
					if(myPs->testCond[bd][ch].step[advStepNo].mode == C_RATE){
						send_msg(MODULE_TO_MAIN, 
							MSG_MODULE_MAIN_STEP_COND_UPDATE, bd, ch);
					}
				}
				rangeI = 0;
				for(i=MAX_RANGE; i > 0; i--) {
					if(labs(myPs->testCond[bd][ch].step[advStepNo].refI)
						 <= myData->mData.config.maxCurrent[i - 1]) {
						rangeI = i - 1;
						break;
					}
				}
				if(myCh->ChAttribute.chNo_master == P0) {
					myData->mData.testCond[bd][ch].step[advStepNo]
						.rangeI = rangeI;
						myData->mData.testCond[bd][ch - 1].step[advStepNo]
						.rangeI = rangeI;
				} else {
					myData->mData.testCond[bd][ch].step[advStepNo]
						.rangeI = rangeI;
				}
				//changeRefI
				if(stepType == STEP_CHARGE
					|| stepType == STEP_DISCHARGE) {
					myCh->misc.changeRefI[advStepNo] = P1;
				}
			}
		}
		advStepNo = myCh->misc.advStepNo;
	}
#endif
			
	myCh->misc.endCycleTime = myPs->testCond[bd][ch].step[advStepNo].endT;
	myCh->misc.endIntegralC = myPs->testCond[bd][ch].step[advStepNo].endC;
	myCh->misc.endIntegralWh = myPs->testCond[bd][ch].step[advStepNo].endWh;
	myCh->misc.endCycleTimeGotoStep
		= myPs->testCond[bd][ch].step[advStepNo].endTGoto;

//170518 lyh add	
	myCh->misc.cycleEndV = myPs->testCond[bd][ch].step[advStepNo].advGotoStep;

// 171121 oys modify
	myCh->misc.endIntegralCGotoStep 
		= myPs->testCond[bd][ch].step[advStepNo].endIntegralCGoto;
	myCh->misc.endIntegralWhGotoStep 
		= myPs->testCond[bd][ch].step[advStepNo].endIntegralWhGoto;

	myCh->misc.integralTGotoCheck
		= myPs->testCond[bd][ch].step[advStepNo].cycleEndStepSave;
//rcv pc	
	myCh->misc.integralCGotoCheck
		= myPs->testCond[bd][ch].step[advStepNo].cycleEndStepSave;
	myCh->misc.integralWhGotoCheck
		= myPs->testCond[bd][ch].step[advStepNo].cycleEndStepSave;

// cycle integral Ah , Wh Flag 
	myCh->misc.endIntegralCFlag
		= (long)(myPs->testCond[bd][ch].step[advStepNo].endV / 1000);
	myCh->misc.endIntegralWhFlag
		= (long)(myPs->testCond[bd][ch].step[advStepNo].endI / 1000);
	
	myCh->misc.cycleNo = myPs->testCond[bd][ch].step[advStepNo].cycleNo;
	myCh->misc.charge_integralCap[myCh->misc.cycleNo - 1] = 0;
	myCh->misc.discharge_integralCap[myCh->misc.cycleNo - 1] = 0;
	
   	myCh->misc.cvFlag = P0;
	#ifdef _EXTERNAL_CONTROL
	myCh->misc.chCV = P0;
	#endif						
	//210204 lyhw
   	myCh->misc.cvFaultCheckFlag = 0;
	//120818 kji SDI mes cycle data
	myCh->misc.lastRestVsens = 0;
	myCh->misc.sumChargeCCCVAh = 0;
	myCh->misc.seedChargeCCCVAh = 0;
	myCh->misc.chargeCCCVAh = 0;
	myCh->misc.sumChargeCCAh = 0;
	myCh->misc.seedChargeCCAh = 0;
	myCh->misc.chargeCCAh = 0;
	myCh->misc.sumChargeCVAh = 0;
	myCh->misc.seedChargeCVAh = 0;
	myCh->misc.chargeCVAh = 0;
	myCh->misc.cycleSumChargeCCAh = 0;
	myCh->misc.cycleSumChargeCVAh = 0;
	myCh->misc.cycleSumDischargeCCAh = 0;
	myCh->misc.cycleSumDischargeCVAh = 0;
	//141208 oys SDI MES VER4 data
	myCh->misc.cycleMaxV = myCh->op.Vsens;
	myCh->misc.cycleMinV = myCh->op.Vsens;
	myCh->misc.cycleStartV = myCh->op.Vsens;
	myCh->misc.sumDischargeCCCVAh = 0;
	myCh->misc.seedDischargeCCCVAh = 0;
	myCh->misc.dischargeCCCVAh = 0;
	myCh->misc.dischargeCCAh = 0;
	myCh->misc.dischargeCVAh = 0;
	myCh->misc.sumDischargeCCAh = 0;
	myCh->misc.seedDischargeCCAh = 0;
	myCh->misc.dischargeCCAh = 0;
	myCh->misc.sumDischargeCVAh = 0;
	myCh->misc.seedDischargeCVAh = 0;
	myCh->misc.dischargeCVAh = 0;
	myCh->misc.cycleSumChargeWatt = 0;
	myCh->misc.cycleSumDischargeWatt = 0;
	myCh->misc.cycleSumChargeWattHour = 0;
	myCh->misc.cycleSumDischargeWattHour = 0;
	myCh->misc.cycleSumChargeAmpareHour = 0;
	myCh->misc.cycleSumDischargeAmpareHour = 0;
	myCh->misc.cycleAvgDischargeV = 0;
	myCh->misc.cycleAvgDischargeI = 0;
	myCh->misc.cycleSumAvgT = 0;
	myCh->misc.cycleStepCount = 0;
	myCh->misc.cycleDischargeStepCount = 0;
	myCh->misc.cycle_Charge_ccTime = 0;
	myCh->misc.cycle_Charge_cvTime = 0;
	myCh->misc.cycle_Discharge_ccTime = 0;
	myCh->misc.cycle_Discharge_cvTime = 0;

	//170501 oys add
	myCh->misc.cycleSumC = 0;
	myCh->misc.cycleSumP = 0;
	myCh->misc.efficiency_pause_flag = P0;

	i = AdvStepFlag(bd, ch);
	if(i == 0) { //next step
		//110215 kji 
		if(myCh->misc.integralInit == 0){ //default
			myCh->op.integral_ampareHour = 0;
			myCh->op.integral_WattHour = 0;
			myCh->misc.sumintegralCapacity = 0;
			myCh->misc.seedintegralCapacity = 0;
			myCh->misc.sumintegralWattHour = 0;
			myCh->misc.seedintegralWattHour = 0;
		} else if(myCh->misc.integralInit == 1) { //not init
			myCh->misc.integralInit = 0;
		}
	} else if(i == 1) { //stop
		myCh->op.state = C_STANDBY;
		myCh->op.phase = P0;
		return;
	} else { //pause
		myCh->op.state = C_PAUSE;
		myCh->op.phase = P0;
		myCh->signal[C_SIG_PAUSE] = P0;
		myCh->signal[C_SIG_OUT_SWITCH] = P0;
		if(myPs->config.hwSpec >= S_5V_200A) { //switching
			myCh->misc.semiSwitchState = SEMI_PRE;
			cV_Range_Select(bd, ch, 0);
			cI_Range_Select(bd, ch, 0);
		}
		return;
	}

	if(myPs->testCond[bd][ch].step[advStepNo].gotoFlag == 0) {
		myCh->misc.advStepNo++;
	} else { 
		myPs->testCond[bd][ch].step[advStepNo].gotoFlag = 0;
		myCh->misc.advStepNo
			= myPs->testCond[bd][ch].step[advStepNo].gotoStep;
	}

	advStepNo = myCh->misc.advStepNo;
	myCh->op.type = myPs->testCond[bd][ch].step[advStepNo].type;
	myCh->op.mode = myPs->testCond[bd][ch].step[advStepNo].mode;
	myCh->op.stepNo = myPs->testCond[bd][ch].step[advStepNo].stepNo;

	myCh->misc.totalCycle++;
	myCh->misc.advCycle++;
	myCh->misc.currentCycle = myCh->misc.advCycle;
	myCh->op.phase = P0;

	refTemp = myPs->testCond[bd][ch].step[advStepNo].refTemp;
	startTemp = myPs->testCond[bd][ch].step[advStepNo].startTemp;
	groupTemp = myCh->misc.groupTemp;

	//20171212 sch add
	refTemp_backup = myCh->misc.refTemp_backup;

	switch(myCh->op.type) {
		case STEP_CHARGE:
		case STEP_DISCHARGE:
		case STEP_OCV:
		case STEP_REST:
		case STEP_Z:
		case STEP_USER_PATTERN:
		case STEP_BALANCE:
#if MACHINE_TYPE == 1
		case STEP_SHORT:
#endif
			if(refTemp != 999000) {
			//	if(refTemp == groupTemp){
				if(refTemp == groupTemp || refTemp == refTemp_backup) {
					myCh->misc.tempDir = P0;
				} else if(refTemp > groupTemp) {
					myCh->misc.tempDir = P1;
				} else {
					myCh->misc.tempDir = P2;
				}
			}
			break;
		default:
			myCh->misc.tempDir = P0;
			break;
	}

#if CYCLER_TYPE == LINEAR_CYC 
	switch(myCh->op.type) {
		case STEP_CHARGE:		cStepCharge(bd, ch);		break;
		case STEP_DISCHARGE:	cStepDischarge(bd, ch);		break;
		case STEP_REST:			cStepRest(bd, ch);			break;
		case STEP_OCV:			cStepOcv(bd, ch);			break;
		case STEP_Z:			cStepZ(bd, ch);				break;
		case STEP_USER_PATTERN:	cStepUserPattern(bd, ch);	break;
		case STEP_BALANCE:		cStepBalance(bd, ch);		break;
#if MACHINE_TYPE == 1
		case STEP_SHORT:		cStepShort(bd, ch);			break;
#endif
		default:
			break;
	}
#endif
#if CYCLER_TYPE == DIGITAL_CYC
	switch(myCh->op.type){
		case STEP_CHARGE:		pStepCharge(bd, ch);		break;
		case STEP_DISCHARGE:	pStepDischarge(bd, ch);		break;
		case STEP_REST:			pStepRest(bd, ch);			break;
		case STEP_OCV:			pStepOcv(bd, ch);			break;
		case STEP_Z:			pStepZ(bd, ch);				break;
		case STEP_USER_PATTERN:	pStepUserPattern(bd, ch);	break;
		case STEP_BALANCE:		cStepBalance(bd, ch);		break;
		default:
		 	break;
	}
#endif
#if CYCLER_TYPE == CAN_CYC
	switch(myCh->op.type) {
		case STEP_CHARGE:			cStepCharge_CAN(bd, ch);		break;
		case STEP_DISCHARGE:		cStepDischarge_CAN(bd, ch);		break;
		case STEP_REST:				cStepRest_CAN(bd, ch);			break;
		case STEP_OCV:				cStepOcv_CAN(bd, ch);			break;
		case STEP_Z:				cStepZ_CAN(bd, ch);				break;
		case STEP_USER_PATTERN:		cStepUserPattern_CAN(bd, ch);	break;
		case STEP_BALANCE:			cStepBalance_CAN(bd, ch);		break;
		default:					cStepDefault_CAN(bd, ch);		break;
	}
#endif
}

void cStepParallelCycle(int bd, int ch)
{ //kjg_180521
	unsigned char endC_std_type, endP_std_type, endZ_std_type, rangeI;
	unsigned char parallel_ch;
   	unsigned short reduce_ratio_C, reduce_ratio_P, c_rate;
	int i, stepType;
	long startTemp, groupTemp, refTemp, refTemp_backup;
    long stdC_val, stdP_val, stdZ_val;
	unsigned long advStepNo;
	
	myCh = &(myData->bData[bd].cData[ch]);

	if((ch % 2) == 0) parallel_ch = ch + 1;
	else parallel_ch = ch - 1;

	switch(myCh->op.phase) {
		case P0:
			//cSemiSwitch(bd, ch);
			myCh->signal[C_SIG_OUT_SWITCH] = P0;
			//kjg_180521 myCh->signal[C_SIG_RANGE_SWITCH] = P0;
			myCh->signal[C_SIG_RANGE_SWITCH] = P0;
			myCh->signal[C_SIG_PARALLEL_SWITCH] = P0;
			myCh->misc.parallel_cycle_phase = P1;
			myCh->op.phase++;
			break;
		case P1: //wait relay active
		case P2:
		case P3:
			myCh->op.phase++;
			break;
		case P4:
			myCh->misc.parallel_cycle_phase = P2;
			myCh->op.phase++;
			break;
		case P5:
			if(myData->bData[bd].cData[parallel_ch].op.state == C_STANDBY
//200113		&& myData->bData[bd].cData[parallel_ch].op.phase == P3) {
				&& myData->bData[bd].cData[parallel_ch].op.phase == P5) {
				i = 1;
			} else if(myData->bData[bd].cData[parallel_ch].op.state == C_RUN) {
				if(myData->bData[bd].cData[parallel_ch].misc
					.parallel_cycle_phase == P2
					|| myData->bData[bd].cData[parallel_ch].misc
					.parallel_cycle_phase == P12) {
					i = 1;
				} else i = 0;
			} else { //C_IDLE, C_PAUSE, C_CALI
				i = 0;
			}

			if(i == 0) { //wait
				//kjg_180524
				if(myCh->signal[C_SIG_STOP] == P1) {
					myCh->op.code = C_FAULT_STOP_CMD;
					myCh->op.select = SAVE_FLAG_SAVING_END;
					myCh->signal[C_SIG_STOP] = P0;
					//kjg_180524 cSemiSwitch_Rest(bd, ch, advStepNo, 0);
					myCh->op.phase = P100;
				} else if(myCh->signal[C_SIG_PAUSE] == P1) {
					myCh->misc.tmpState = myCh->op.state;
					if(myCh->op.code != C_CYCLE_P_STEP_WAIT){
						myCh->misc.tmpCode = myCh->op.code;
					}
					myCh->op.code = C_FAULT_PAUSE_CMD;
					myCh->opSave = myCh->op;
					myCh->signal[C_SIG_PAUSE] = P0;
					//kjg_180524 cSemiSwitch_Rest(bd, ch, advStepNo, 0);
					myCh->op.phase = P100;
				} else if(myCh->signal[C_SIG_DLL_STOP] == P1) {
					myCh->op.code = C_FAULT_CELL_DIAGNOSIS_STOP;
					myCh->op.select = SAVE_FLAG_SAVING_END;
					myCh->signal[C_SIG_DLL_STOP] = P0;
					//cSemiSwitch_Rest(bd, ch, advStepNo, 0);
					myCh->op.phase = P100;
				} else if(myCh->signal[C_SIG_NEXTSTEP] == P1) {
					myCh->signal[C_SIG_NEXTSTEP] = P0;
				} else {	//190308 add
					if(myCh->misc.cycle_p_flag == P0){
						myCh->misc.cycle_p_flag = P1;
						myCh->misc.tmpCode = myCh->op.code;
					}
					myCh->op.code = C_CYCLE_P_STEP_WAIT;
				}

				if(myCh->op.phase == P100) cNextStepCheck(bd, ch);
			} else { //parallel run
				if(myCh->misc.cycle_p_flag == P1){	//190308 lyh add
					myCh->misc.cycle_p_flag = P0;
					myCh->op.code = myCh->misc.tmpCode;
				}
				myCh->misc.parallel_cycle_phase = P3;
				myData->bData[bd].cData[parallel_ch]
					.signal[C_SIG_OUT_SWITCH] = P0;
				myData->bData[bd].cData[parallel_ch]
					.signal[C_SIG_RANGE_SWITCH] = P0;
				myData->bData[bd].cData[parallel_ch]
					.signal[C_SIG_PARALLEL_SWITCH] = P0;
				myCh->op.phase = P11;
			}
			break;
		case P11: //wait relay active
			myCh->signal[C_SIG_OUT_SWITCH] = P1; //kjg_180521
			myCh->signal[C_SIG_PARALLEL_SWITCH] = P1;
		case P12:
		case P13:
			myCh->op.phase++;
			break;
		case P14:
			myCh->misc.parallel_cycle_phase = P50;

			//kjg_180523
			myCh->misc.parallel_sensFlag = P1;
			myData->bData[bd].cData[parallel_ch].misc.parallel_sensFlag = P1;

			advStepNo = myCh->misc.advStepNo + 1;
			stepType = myPs->testCond[bd][ch].step[advStepNo].type;
			if(stepType == STEP_REST) {
				if(myPs->testCond[bd][ch].step[advStepNo].endT != 0) {
					if(myPs->testCond[bd][ch].step[advStepNo].endT >= 6000) {
					} else {
						cSemiSwitch_Start(bd, ch,
							myPs->testCond[bd][ch].step[advStepNo + 1].type);
					}
				} else {
				}
			} else if(stepType == STEP_USER_PATTERN) {
				cSemiSwitch_Start(bd, ch, stepType);
			} else if(stepType == STEP_OCV) {
				cSemiSwitch_Start(bd, ch,
					myPs->testCond[bd][ch].step[advStepNo + 1].type);
			} else if(stepType == STEP_SHORT) {
			} else {
				cSemiSwitch_Start(bd, ch, stepType);
			}

			myCh->op.phase = P50;
			break;
		default:
			break;
	}
	if(myCh->op.phase != P50) return;

	advStepNo = myCh->misc.advStepNo;
	stepType = myPs->testCond[bd][ch].step[advStepNo].type;
	c_rate = myPs->testCond[bd][ch].step[advStepNo].endTCVGoto;
	reduce_ratio_C = myPs->testCond[bd][ch].step[advStepNo].advCycleCount;
	reduce_ratio_P = myPs->testCond[bd][ch].step[advStepNo].reduce_ratio_P;
	
	//Standard Step Type
	endC_std_type = myPs->testCond[bd][ch].step[advStepNo].socCapStepNo;
	endP_std_type = myPs->testCond[bd][ch].step[advStepNo].endP_std_type;
	endZ_std_type = myPs->testCond[bd][ch].step[advStepNo].endZ_std_type;
	
	//151214 oys w : completeFlag -> Cycle Capacity Efficiency End Option
	//( use SEC_TYPE == 1 )
	myCh->misc.completeFlag
		= myPs->testCond[bd][ch].step[advStepNo].gotoCycleCount;

	//Soc check count
	myCh->misc.socCheckCount
		= myPs->testCond[bd][ch].step[advStepNo].endVGoto;

	//Cycle end capacity
	myCh->misc.cycleEndC
		= myPs->testCond[bd][ch].step[advStepNo].endDeltaV;

	//Standard value select <- first Cycle or step
	myCh->misc.endC_std_sel
		= myPs->testCond[bd][ch].step[advStepNo].endCGoto;
	myCh->misc.endP_std_sel
		= myPs->testCond[bd][ch].step[advStepNo].endP_std_sel;
	myCh->misc.endZ_std_sel
		= myPs->testCond[bd][ch].step[advStepNo].endZ_std_sel;
	myCh->misc.endC_std_cycleCount
		= myPs->testCond[bd][ch].step[advStepNo].endC_std_cycleCount;
	myCh->misc.endP_std_cycleCount
		= myPs->testCond[bd][ch].step[advStepNo].endP_std_cycleCount;
	myCh->misc.endZ_std_cycleCount
		= myPs->testCond[bd][ch].step[advStepNo].endZ_std_cycleCount;
#if CAPACITY_CONTROL == 1
	myCh->misc.CycleCapaCount
		= myPs->testCond[bd][ch].step[advStepNo].CycleCapaCount;	
#endif
	//User standard input value	
	if(myCh->misc.cRateUseFlag == P1) {
		stdC_val = 0;
	} else {
		stdC_val = myPs->testCond[bd][ch].step[advStepNo].endP;
	}
	stdP_val = myPs->testCond[bd][ch].step[advStepNo].refV;
	stdZ_val = myPs->testCond[bd][ch].step[advStepNo].endIGoto;

	if(myCh->misc.cycleNo
		!= myPs->testCond[bd][ch].step[advStepNo].cycleNo) {
		myCh->misc.socCountNo[0] = 0;
		myCh->misc.socCountNo[1] = 0;
		myCh->misc.socCountNo[2] = 0;
		myCh->misc.pause_flag = P0;

		//190801 oys add
		for(i=0; i < MAX_STEP; i++) {
			myCh->misc.sel_Cyc_C_Cap[i] = 0;
			myCh->misc.sel_Cyc_D_Cap[i] = 0;
		}

#if VENDER == 3
		if(stdC_val != 0) {
			myCh->misc.standardC = stdC_val;
			myCh->misc.standardC_Flag = P1;
			for(i=0; i < MAX_STEP; i++) {
				myCh->misc.ahEndRatio[i] = 100; //default : 100
			}
		} else {
			if(endC_std_type != 0 || myCh->misc.endC_std_sel > 1) {
				myCh->misc.standardC_Flag = P0;
				myCh->misc.standardC = 0;
				for(i=0; i < MAX_STEP; i++) {
					myCh->misc.ahEndRatio[i] = 100; //default : 100
				}
			}
		}

		if(stdP_val != 0) {
			myCh->misc.standardP = stdP_val;
			myCh->misc.standardP_Flag = P1;
			for(i=0; i < MAX_STEP; i++) {
				myCh->misc.whEndRatio[i] = 100; //default : 100
			}
		} else {
			if(endP_std_type != 0 || myCh->misc.endP_std_sel > 1) {
				myCh->misc.standardP_Flag = P0;
				myCh->misc.standardP = 0;
				for(i=0; i < MAX_STEP; i++) {
					myCh->misc.whEndRatio[i] = 100; //default : 100
				}
			}
		}

		if(stdZ_val != 0) {
			myCh->misc.standardZ = stdZ_val;
			myCh->misc.standardZ_Flag = P1;
		} else {
			if(endZ_std_type != 0 || myCh->misc.endZ_std_sel > 1) {
				myCh->misc.standardZ_Flag = P0;
				myCh->misc.standardZ = 0;
			}
		}
#endif
	}

#if VENDER != 3
	//160510 oys w : Cycle Capacity Efficiency End
	if(stdC_val != 0) {
		myCh->misc.standardC = stdC_val;
		myCh->misc.standardC_Flag = P1;
		for(i=0; i < MAX_STEP; i++) {
			myCh->misc.ahEndRatio[i] = 100; //default : 100
		}
	} else {
		if(endC_std_type != 0) {
			if(myCh->misc.standardC_Flag == P0) myCh->misc.standardC = 0;

			for(i=0; i < MAX_STEP; i++) {
				myCh->misc.ahEndRatio[i] = 100; //default : 100
			}
		}
	}
#endif

//170501 oys add : testCond pause option
#if VENDER == 3
	if(VENDER == 3) {
		while(1) {
			advStepNo++;

			if(STEP_LOOP == myPs->testCond[bd][ch].step[advStepNo].type) {
				if(myCh->misc.pause_flag == P0) {
					if(myPs->testCond[bd][ch].step[advStepNo].stepNo_pause != 0
						|| myPs->testCond[bd][ch].step[advStepNo].cycleNo_pause
						!= 0) {
						myCh->misc.stepNo_pause = myPs->testCond[bd][ch]
							.step[advStepNo].stepNo_pause;
						myCh->misc.cycleNo_pause = myPs->testCond[bd][ch]
							.step[advStepNo].cycleNo_pause;
						myCh->misc.pause_flag = P1;
					}
				}

				advStepNo = myCh->misc.advStepNo;
				break;
			}
		}
	}
#endif

#if VENDER == 3
	if(myCh->misc.standardC != 0 || myCh->misc.standardP != 0) {
#else
	if(myCh->misc.standardC != 0) {
#endif		
		if(myCh->misc.cycleNo 
			!= myPs->testCond[bd][ch].step[advStepNo].cycleNo) {
			//LGC C-rate Standard Capacity Auto Calculation ref I value.
			if(VENDER == 1) {
				while(1) {
					advStepNo++;

					if(STEP_LOOP
						== myPs->testCond[bd][ch].step[advStepNo].type) {
						send_msg(MODULE_TO_MAIN,
							MSG_MODULE_MAIN_STEP_COND_UPDATE, bd, ch);
						break;
					}

					if(c_rate == 0) break;

					if(myPs->testCond[bd][ch].step[advStepNo]
						.cycleEndStepSave == 1) {
						stepType = myPs->testCond[bd][ch].step[advStepNo].type;
						if(stepType == STEP_CHARGE) {
							if(myCh->ChAttribute.chNo_master == P0) { //kjgw_180521
								myPs->testCond[bd][ch].step[advStepNo].refI
									= (myCh->misc.standardC
									* ((float)c_rate / 100)) / 2;
								myPs->testCond[bd][ch - 1].step[advStepNo].refI
									= myPs->testCond[bd][ch].step[advStepNo]
									.refI;
							} else {
								myPs->testCond[bd][ch].step[advStepNo].refI
									= myCh->misc.standardC
									* ((float)c_rate / 100);
							}
						} else if(stepType == STEP_DISCHARGE) {
							if(myCh->ChAttribute.chNo_master == P0) { //kjgw_180521
								myPs->testCond[bd][ch].step[advStepNo].refI
									= ((myCh->misc.standardC
									* ((float)c_rate / 100)) / 2) * -1;
								myPs->testCond[bd][ch - 1].step[advStepNo].refI
									= myPs->testCond[bd][ch].step[advStepNo]
									.refI;
							} else {
								myPs->testCond[bd][ch].step[advStepNo].refI
									= (myCh->misc.standardC
									* ((float)c_rate / 100)) * -1;
							}
						}

						//171102 add for c_rate Change RangeI
						rangeI = 0;
						for(i=MAX_RANGE; i > 0; i--) {
							if(labs(myPs->testCond[bd][ch].step[advStepNo].refI)
								 <= myData->mData.config.maxCurrent[i - 1]) {
								rangeI = i - 1;
								break;
							}
						}
						
						if(myCh->ChAttribute.chNo_master == P0) { //kjgw_180521
							myData->mData.testCond[bd][ch].step[advStepNo]
								.rangeI = rangeI;
							myData->mData.testCond[bd][ch - 1].step[advStepNo]
								.rangeI = rangeI;
						} else {
							myData->mData.testCond[bd][ch].step[advStepNo]
								.rangeI = rangeI;
						}

						//add for Change standardC
						myCh->misc.standardC_Flag = P0;

						//changeRefI
						if(stepType == STEP_CHARGE
							|| stepType == STEP_DISCHARGE) {
							myCh->misc.changeRefI[advStepNo] = P1;
						}
					}	
				}
				advStepNo = myCh->misc.advStepNo;
				//changeRefI end
			} else if(VENDER == 2) {
				//ampareHour
				if(reduce_ratio_C != 0) {
					if(myCh->misc.ahEndRatio[advStepNo] > reduce_ratio_C) {
						myCh->misc.ahEndRatio[advStepNo]
							= myCh->misc.ahEndRatio[advStepNo] - reduce_ratio_C;
					}
					myCh->misc.standardC = myCh->misc.standardC
						* myCh->misc.ahEndRatio[advStepNo] / 100;
					myCh->misc.standardC_Flag = P1;
				}
			} else if(VENDER == 3) {
				//ampareHour
				if(myCh->misc.standardC != 0) {
					if(reduce_ratio_C != 0) {
						if(myCh->misc.ahEndRatio[advStepNo] > reduce_ratio_C) {
							myCh->misc.ahEndRatio[advStepNo]
								= myCh->misc.ahEndRatio[advStepNo]
								- reduce_ratio_C;
						}

						myCh->misc.standardC = myCh->misc.standardC
							* myCh->misc.ahEndRatio[advStepNo] / 100;
						myCh->misc.standardC_Flag = P1;
					}
				}

				//wattHour
				if(myCh->misc.standardP != 0) {
					if(reduce_ratio_P != 0) {
						if(myCh->misc.whEndRatio[advStepNo] > reduce_ratio_P) {
							myCh->misc.whEndRatio[advStepNo]
								= myCh->misc.whEndRatio[advStepNo]
								- reduce_ratio_P;
						}

						myCh->misc.standardP = myCh->misc.standardP
							* myCh->misc.whEndRatio[advStepNo] / 100;
						myCh->misc.standardP_Flag = P1;
					}
				}
			}
		}
	}	

#if VENDER == 3
	if(myCh->misc.endC_std_sel > 1) {
		if(myPs->testCond[bd][ch].step[myCh->misc.endC_std_sel - 1]
			.socStepCap != 0) {
			myCh->misc.endC_std_type = myPs->testCond[bd][ch]
				.step[myCh->misc.endC_std_sel - 1].type;
			myCh->misc.standardC = myPs->testCond[bd][ch]
				.step[myCh->misc.endC_std_sel - 1].socStepCap;
			myCh->misc.standardC_Flag = P1;
		}
	}

	if(myCh->misc.endP_std_sel > 1) {
		if(myPs->testCond[bd][ch].step[myCh->misc.endP_std_sel - 1]
			.socStepPower != 0) {
			myCh->misc.endP_std_type = myPs->testCond[bd][ch]
				.step[myCh->misc.endP_std_sel - 1].type;
			myCh->misc.standardP = myPs->testCond[bd][ch]
				.step[myCh->misc.endP_std_sel - 1].socStepPower;
			myCh->misc.standardP_Flag = P1;
		}
	}

	if(myCh->misc.endZ_std_sel > 1) {
		if(myPs->testCond[bd][ch].step[myCh->misc.endZ_std_sel - 1]
			.socStepZ != 0) {
			myCh->misc.endZ_std_type = myPs->testCond[bd][ch]
				.step[myCh->misc.endZ_std_sel - 1].type;
			myCh->misc.standardZ = myPs->testCond[bd][ch]
				.step[myCh->misc.endZ_std_sel - 1].socStepZ;
			myCh->misc.standardZ_Flag = P1;
		}
	}
#endif
	
	myCh->misc.endCycleTime = myPs->testCond[bd][ch].step[advStepNo].endT;
	myCh->misc.endIntegralC = myPs->testCond[bd][ch].step[advStepNo].endC;
	myCh->misc.endIntegralWh = myPs->testCond[bd][ch].step[advStepNo].endWh;
	myCh->misc.endCycleTimeGotoStep
		= myPs->testCond[bd][ch].step[advStepNo].endTGoto;

//170518 lyh add	
	myCh->misc.cycleEndV = myPs->testCond[bd][ch].step[advStepNo].advGotoStep;

// 171121 oys modify
	myCh->misc.endIntegralCGotoStep 
		= myPs->testCond[bd][ch].step[advStepNo].endIntegralCGoto;
	myCh->misc.endIntegralWhGotoStep 
		= myPs->testCond[bd][ch].step[advStepNo].endIntegralWhGoto;
	
	myCh->misc.integralTGotoCheck
		= myPs->testCond[bd][ch].step[advStepNo].cycleEndStepSave;
//rcv pc	
	myCh->misc.integralCGotoCheck
		= myPs->testCond[bd][ch].step[advStepNo].cycleEndStepSave;
	myCh->misc.integralWhGotoCheck
		= myPs->testCond[bd][ch].step[advStepNo].cycleEndStepSave;

// cycle integral Ah, Wh Flag 
	myCh->misc.endIntegralCFlag
		= (long)(myPs->testCond[bd][ch].step[advStepNo].endV / 1000);
	myCh->misc.endIntegralWhFlag
		= (long)(myPs->testCond[bd][ch].step[advStepNo].endI / 1000);
	
	myCh->misc.cycleNo = myPs->testCond[bd][ch].step[advStepNo].cycleNo;
	myCh->misc.charge_integralCap[myCh->misc.cycleNo - 1] = 0;
	myCh->misc.discharge_integralCap[myCh->misc.cycleNo - 1] = 0;
	
   	myCh->misc.cvFlag = P0;
	#ifdef _EXTERNAL_CONTROL
	myCh->misc.chCV = P0;
	#endif						
	//210204 lyhw
   	myCh->misc.cvFaultCheckFlag = 0;
	//120818 kji SDI mes cycle data
	myCh->misc.lastRestVsens = 0;
	myCh->misc.sumChargeCCCVAh = 0;
	myCh->misc.seedChargeCCCVAh = 0;
	myCh->misc.chargeCCCVAh = 0;
	myCh->misc.sumChargeCCAh = 0;
	myCh->misc.seedChargeCCAh = 0;
	myCh->misc.chargeCCAh = 0;
	myCh->misc.sumChargeCVAh = 0;
	myCh->misc.seedChargeCVAh = 0;
	myCh->misc.chargeCVAh = 0;
	myCh->misc.cycleSumChargeCCAh = 0;
	myCh->misc.cycleSumChargeCVAh = 0;
	myCh->misc.cycleSumDischargeCCAh = 0;
	myCh->misc.cycleSumDischargeCVAh = 0;
	//141208 oys SDI MES VER4 data
	myCh->misc.cycleMaxV = myCh->op.Vsens;
	myCh->misc.cycleMinV = myCh->op.Vsens;
	myCh->misc.cycleStartV = myCh->op.Vsens;
	myCh->misc.sumDischargeCCCVAh = 0;
	myCh->misc.seedDischargeCCCVAh = 0;
	myCh->misc.dischargeCCCVAh = 0;
	myCh->misc.dischargeCCAh = 0;
	myCh->misc.dischargeCVAh = 0;
	myCh->misc.sumDischargeCCAh = 0;
	myCh->misc.seedDischargeCCAh = 0;
	myCh->misc.dischargeCCAh = 0;
	myCh->misc.sumDischargeCVAh = 0;
	myCh->misc.seedDischargeCVAh = 0;
	myCh->misc.dischargeCVAh = 0;
	myCh->misc.cycleSumChargeWatt = 0;
	myCh->misc.cycleSumDischargeWatt = 0;
	myCh->misc.cycleSumChargeWattHour = 0;
	myCh->misc.cycleSumDischargeWattHour = 0;
	myCh->misc.cycleSumChargeAmpareHour = 0;
	myCh->misc.cycleSumDischargeAmpareHour = 0;
	myCh->misc.cycleAvgDischargeV = 0;
	myCh->misc.cycleAvgDischargeI = 0;
	myCh->misc.cycleSumAvgT = 0;
	myCh->misc.cycleStepCount = 0;
	myCh->misc.cycleDischargeStepCount = 0;
	myCh->misc.cycle_Charge_ccTime = 0;
	myCh->misc.cycle_Charge_cvTime = 0;
	myCh->misc.cycle_Discharge_ccTime = 0;
	myCh->misc.cycle_Discharge_cvTime = 0;

	//170501 oys add
	myCh->misc.cycleSumC = 0;
	myCh->misc.cycleSumP = 0;
	myCh->misc.efficiency_pause_flag = P0;

	i = AdvStepFlag(bd, ch);
	if(i == 0) { //next step
		//110215 kji 
		if(myCh->misc.integralInit == 0) { //default
			myCh->op.integral_ampareHour = 0;
			myCh->op.integral_WattHour = 0;
			myCh->misc.sumintegralCapacity = 0;
			myCh->misc.seedintegralCapacity = 0;
			myCh->misc.sumintegralWattHour = 0;
			myCh->misc.seedintegralWattHour = 0;
		} else if(myCh->misc.integralInit == 1) { //not init
			myCh->misc.integralInit = 0;
		}
	} else if(i == 1) { //stop
		myCh->op.state = C_STANDBY;
		myCh->op.phase = P0;
		return;
	} else { //pause
		myCh->op.state = C_PAUSE;
		myCh->op.phase = P0;
		myCh->signal[C_SIG_PAUSE] = P0;
		myCh->signal[C_SIG_OUT_SWITCH] = P0;
		if(myPs->config.hwSpec >= S_5V_200A) { //switching
			myCh->misc.semiSwitchState = SEMI_PRE;
			cV_Range_Select(bd, ch, 0);
			cI_Range_Select(bd, ch, 0);
		}
		return;
	}

	if(myPs->testCond[bd][ch].step[advStepNo].gotoFlag == 0) {
		myCh->misc.advStepNo++;
	} else { 
		myPs->testCond[bd][ch].step[advStepNo].gotoFlag = 0;
		myCh->misc.advStepNo
			= myPs->testCond[bd][ch].step[advStepNo].gotoStep;
	}
	
	advStepNo = myCh->misc.advStepNo;
	myCh->op.type = myPs->testCond[bd][ch].step[advStepNo].type;
	myCh->op.mode = myPs->testCond[bd][ch].step[advStepNo].mode;
	myCh->op.stepNo = myPs->testCond[bd][ch].step[advStepNo].stepNo;

	myCh->misc.totalCycle++;
	myCh->misc.advCycle++;
	myCh->misc.currentCycle = myCh->misc.advCycle;
	myCh->op.phase = P0;

	refTemp = myPs->testCond[bd][ch].step[advStepNo].refTemp;
	startTemp = myPs->testCond[bd][ch].step[advStepNo].startTemp;
	groupTemp = myCh->misc.groupTemp;

	//20171212 sch add
	refTemp_backup = myCh->misc.refTemp_backup;

	switch(myCh->op.type) {
		case STEP_CHARGE:
		case STEP_DISCHARGE:
		case STEP_OCV:
		case STEP_REST:
		case STEP_Z:
		case STEP_USER_PATTERN:
		case STEP_BALANCE:
#if MACHINE_TYPE == 1
		case STEP_SHORT:
#endif
			if(refTemp != 999000) {
			//	if(refTemp == groupTemp){
				if(refTemp == groupTemp || refTemp == refTemp_backup) {
					myCh->misc.tempDir = P0;
				} else if(refTemp > groupTemp) {
					myCh->misc.tempDir = P1;
				} else {
					myCh->misc.tempDir = P2;
				}
			}
			break;
		default:
			myCh->misc.tempDir = P0;
			break;
	}

	switch(myCh->op.type) {
		case STEP_CHARGE:		cStepCharge(bd, ch);		break;
		case STEP_DISCHARGE:	cStepDischarge(bd, ch);		break;
		case STEP_REST:			cStepRest(bd, ch);			break;
		case STEP_OCV:			cStepOcv(bd, ch);			break;
		case STEP_Z:			cStepZ(bd, ch);				break;
		case STEP_USER_PATTERN:	cStepUserPattern(bd, ch);	break;
		case STEP_BALANCE:		cStepBalance(bd, ch);		break;
#if MACHINE_TYPE == 1
		case STEP_SHORT:		cStepShort(bd, ch);			break;
#endif
		default:
			break;
	}
}

void cStepGoto(int bd, int ch)
{
	unsigned long advStepNo;

	myCh = &(myData->bData[bd].cData[ch]);

	advStepNo = myCh->misc.advStepNo;
	myCh->op.semiPreType = myCh->op.type;
	myCh->op.type = myPs->testCond[bd][ch].step[advStepNo].type;
	myCh->op.mode = myPs->testCond[bd][ch].step[advStepNo].mode;
	myCh->op.stepNo = myPs->testCond[bd][ch].step[advStepNo].stepNo;
	myCh->op.phase = P0;

//110215 kji step goto other Cycle step
	if(myCh->op.type == STEP_ADV_CYCLE
		|| myCh->op.type == STEP_PARALLEL_CYCLE) { //kjg_180521
		myCh->misc.advCycleStep = advStepNo;
		myCh->misc.advCycle = 0;
	}

#if CYCLER_TYPE == LINEAR_CYC
	switch(myCh->op.type) {
		case STEP_CHARGE:			cStepCharge(bd, ch);		break;
		case STEP_DISCHARGE:		cStepDischarge(bd, ch);		break;
		case STEP_REST:				cStepRest(bd, ch);			break;
		case STEP_OCV:				cStepOcv(bd, ch);			break;
		case STEP_Z:				cStepZ(bd, ch);				break;
		case STEP_USER_PATTERN:		cStepUserPattern(bd, ch);	break;
		case STEP_BALANCE:			cStepBalance(bd, ch);		break;
#if MACHINE_TYPE == 1
		case STEP_SHORT:			cStepShort(bd, ch);			break;
#endif
		default:	
			cStepDefault(bd, ch);
			break;
	}
#endif 
#if CYCLER_TYPE == DIGITAL_CYC
	//180903 add for digital
	switch(myCh->op.type) {
		case STEP_CHARGE:		pStepCharge(bd, ch);		break;
		case STEP_DISCHARGE:	pStepDischarge(bd, ch);		break;
		case STEP_REST:			pStepRest(bd, ch);			break;
		case STEP_OCV:			pStepOcv(bd, ch);			break;
		case STEP_Z:			pStepZ(bd, ch);				break;
		case STEP_USER_PATTERN:	pStepUserPattern(bd, ch);	break;
		case STEP_USER_MAP:		pStepUserMap(bd, ch);		break;
		case STEP_BALANCE:		cStepBalance(bd, ch);		break;
		default: //STEP_ADV_CYCLE, STEP_LOOP, STEP_END
			cStepDefault(bd, ch);
			break;
	}
#endif
#if CYCLER_TYPE == CAN_CYC
	switch(myCh->op.type) {
		case STEP_CHARGE:			cStepCharge_CAN(bd, ch);		break;
		case STEP_DISCHARGE:		cStepDischarge_CAN(bd, ch);		break;
		case STEP_REST:				cStepRest_CAN(bd, ch);			break;
		case STEP_OCV:				cStepOcv_CAN(bd, ch);			break;
		case STEP_Z:				cStepZ_CAN(bd, ch);				break;
		case STEP_USER_PATTERN:		cStepUserPattern_CAN(bd, ch);	break;
		case STEP_BALANCE:			cStepBalance_CAN(bd, ch);		break;
		default:					cStepDefault_CAN(bd, ch);		break;
	}
#endif
}

void cNextStepCheck(int bd, int ch)
{
	int i;
	long startTemp, groupTemp, refTemp, refTemp_backup;
	unsigned long advStepNo;

	myCh = &(myData->bData[bd].cData[ch]);

	myCh->op.preType = myCh->op.type;

	switch(myCh->op.type) {
		case STEP_CHARGE:
		case STEP_DISCHARGE:
		case STEP_REST:
		case STEP_OCV:
		case STEP_Z:
		case STEP_USER_PATTERN:
		case STEP_BALANCE:
#if MACHINE_TYPE == 1
		case STEP_SHORT: // <== 140407 oys add
#endif
			myCh->op.semiPreType = myCh->op.type;
			break;
		default:	
			break;
	}

	i = 0; //next
	if(myCh->op.code == C_FAULT_STOP_CMD
		|| myCh->op.code == C_STOP_TIME
		|| myCh->op.code == C_STOP_VOLTAGE
		|| myCh->op.code == C_STOP_CURRENT
		|| myCh->op.code == C_STOP_CAPACITY
		|| myCh->op.code == C_STOP_POWER
		|| myCh->op.code == C_STOP_WATTHOUR
		//#if SEC_TYPE == 1
		//|| myCh->op.code == C_END_DELTA_V
		//#endif
		//170215 SCH add for DeltaV/I
		|| myCh->op.code == C_STOP_DELTA_V
		|| myCh->op.code == C_STOP_DELTA_I
		|| myCh->op.code == C_STOP_CAPACITY_SOC
		//170518 lyh
		|| myCh->op.code == C_STOP_CYCLE_VOLTAGE
		|| myCh->op.code == C_STOP_GRADE
		|| myCh->op.code == C_FAULT_END_LIMIT_CURRENT
		|| myCh->op.code == C_FAULT_END_LIMIT_VOLTAGE//20171008
		|| myCh->op.code == C_FAULT_CELL_DIAGNOSIS_STOP
		) { 
		myCh->op.state = C_STANDBY;
		myCh->op.phase = P0;
	} else if(myCh->op.code < C_FAULT_CHECK_CODE_START
		|| myCh->op.code == C_FAULT_NEXTSTEP_CMD
		|| myCh->op.code == C_END_USERMAP_OVER_TEMP
		|| myCh->op.code == C_END_AH_SOC
		|| myCh->op.code == C_END_WH_SOC
		|| myCh->op.code == C_END_DCIR_SOC
		|| myCh->op.code == C_END_SOE 		//20190214 lyhw
		|| myCh->op.code == C_END_T_V_UPPER	//200414 ljs
		|| myCh->op.code == C_END_T_V_LOWER	//200414 ljs
		|| myCh->op.code == C_END_CYCLE_STD_CAPACITY_STEP_CAPACITY
		|| myCh->op.code == C_END_CYCLE_STD_CAPACITY_STEP_CURRENT
		|| myCh->op.code == C_END_GAS_TVOC
		|| myCh->op.code == C_END_GAS_ECO2
		|| (myCh->op.code >= C_END_AUX_TEMP
				&& myCh->op.code <= C_END_AUX_VOLTAGE_LOWER)) {

		i = AdvStepFlag(bd, ch);
		if(i == 0) { //next step
			advStepNo = myCh->misc.advStepNo;
			if(myPs->testCond[bd][ch].step[advStepNo].balanceStepCheck)
				myPs->testCond[bd][ch].step[advStepNo].type = STEP_BALANCE;
			myCh->misc.advStepNo++;
			advStepNo = myCh->misc.advStepNo;
			myCh->op.type = myPs->testCond[bd][ch].step[advStepNo].type;
			myCh->op.mode = myPs->testCond[bd][ch].step[advStepNo].mode;
			myCh->op.stepNo
				= myPs->testCond[bd][ch].step[advStepNo].stepNo;
			myCh->op.phase = P0;

			refTemp = myPs->testCond[bd][ch].step[advStepNo].refTemp;
			startTemp = myPs->testCond[bd][ch].step[advStepNo].startTemp;
			groupTemp = myCh->misc.groupTemp;
			//20171212 sch add
			refTemp_backup = myCh->misc.refTemp_backup;

			switch(myCh->op.type){
				case STEP_CHARGE:
				case STEP_DISCHARGE:
				case STEP_OCV:
				case STEP_REST:
				case STEP_Z:
				case STEP_USER_PATTERN:
				case STEP_BALANCE:
#if MACHINE_TYPE == 1
				case STEP_SHORT: // <== 140407 oys add
#endif
					if(refTemp != 999000){
//						myCh->misc.tmpCode
//							= myCh->op.code;
//						myCh->op.code = C_TEMP_WAIT_TIME;
					//	if(refTemp == groupTemp){
						if(refTemp == groupTemp
							|| refTemp == refTemp_backup){
							myCh->misc.tempDir = P0;
							myCh->misc.refTemp_backup = 999000;
						}else if(refTemp > groupTemp){
							myCh->misc.tempDir = P1;
						}else{
							myCh->misc.tempDir = P2;
						}
					}
					break;
				default:
						myCh->misc.tempDir = P0;
					break;
			}
			cNextStep(bd, ch);
		} else if(i == 1) { //stop
			myCh->op.state = C_STANDBY;
			myCh->op.phase = P0;
		} else { //pause
			myCh->op.state = C_PAUSE;
			myCh->op.phase = P0;
			myCh->signal[C_SIG_PAUSE] = P0;

			//210105
			if(myData->AppControl.config.systemType == CYCLER_CAN){
			}else{
				myCh->signal[C_SIG_OUT_SWITCH] = P0;
			}
			if(myCh->ChAttribute.opType == P1) { //pause parallel switch open
				myCh->signal[C_SIG_PARALLEL_SWITCH] = P0;
			}

			if(myPs->config.hwSpec >= S_5V_200A) { //switching
				myCh->misc.semiSwitchState = SEMI_PRE;
				cV_Range_Select(bd, ch, 0);
				cI_Range_Select(bd, ch, 0);
			}
		}
	} else {
		myCh->op.state = C_PAUSE;
		myCh->op.phase = P0;
		myCh->signal[C_SIG_PAUSE] = P0;
		//210105
		if(myData->AppControl.config.systemType == CYCLER_CAN){
		}else{
			myCh->signal[C_SIG_OUT_SWITCH] = P0;
		}
		if(myCh->ChAttribute.opType == P1) { //pause parallel switch open
			myCh->signal[C_SIG_PARALLEL_SWITCH] = P0;
		}

		if(myPs->config.hwSpec >= S_5V_200A) { //switching
			myCh->misc.semiSwitchState = SEMI_PRE;
			cV_Range_Select(bd, ch, 0);
			cI_Range_Select(bd, ch, 0);
		}
	}
}

void cCycle_p_ch_check(int bd, int ch)
{	//190318 add lyhw
	
	int parallel_ch;
		
	if((ch % 2) == 0) parallel_ch = ch + 1;
	else parallel_ch = ch - 1;
	
	myCh = &(myData->bData[bd].cData[ch]);

	if(myData->bData[bd].cData[parallel_ch].op.state == C_STANDBY) return; 
	if(myData->bData[bd].cData[parallel_ch].misc.cycle_p_sch_flag == P0){ 
		return;
	}
	if(myData->bData[bd].cData[parallel_ch].misc.chGroupNo == P0) return;
	
	myData->bData[bd].cData[parallel_ch].misc.cycle_p_sch_flag = P0;
	myData->bData[bd].cData[parallel_ch].misc.chGroupNo	= P0;
		
	if(myData->bData[bd].cData[parallel_ch].op.state == C_RUN){
		myData->bData[bd].cData[parallel_ch].misc.tmpState = 
							myData->bData[bd].cData[parallel_ch].op.state;
		if(myData->bData[bd].cData[parallel_ch].op.code != C_CYCLE_P_STEP_WAIT
		&& myData->bData[bd].cData[parallel_ch].op.code != C_TEMP_WAIT_TIME){
			myData->bData[bd].cData[parallel_ch].misc.tmpCode = 
							myData->bData[bd].cData[parallel_ch].op.code;
		}
		myData->bData[bd].cData[parallel_ch].signal[C_SIG_OUT_SWITCH] = P0;
		myData->bData[bd].cData[parallel_ch].op.state = C_PAUSE;
		myData->bData[bd].cData[parallel_ch].op.phase = P0;
	}
	myData->bData[bd].cData[parallel_ch].op.code = C_FAULT_OVEN_USE; 
}

int acir_wait_flag_check(int bd, int ch)
{
	int flag;
	unsigned long advStepNo;

	myCh = &(myData->bData[bd].cData[ch]);
	advStepNo = myCh->misc.advStepNo;
	flag = 0;

	myCh->misc.acir_wait_flag = P1;

	if(myCh->signal[C_SIG_STOP] == P1){
		myCh->op.code = C_FAULT_STOP_CMD;
		myCh->signal[C_SIG_STOP] = P0;
		cSemiSwitch_Rest(bd, ch, advStepNo, 0);
		myCh->op.phase = P100;
	}else if(myCh->signal[C_SIG_PAUSE] == P1) {
		myCh->misc.tmpState = myCh->op.state;
		myCh->op.code = C_FAULT_PAUSE_CMD;
		myCh->opSave = myCh->op;
		myCh->signal[C_SIG_PAUSE] = P0;
		cSemiSwitch_Rest(bd, ch, advStepNo, 0);
		myCh->op.phase = P100;
	}
	if(cFailCodeCheck(bd, ch) < 0){
		myCh->misc.acir_wait_flag = 0;
	}
	if(myCh->op.phase == P100) {
		cNextStepCheck(bd, ch);
		return flag;
	}
	if(myCh->misc.acir_wait_flag == P1){
		myCh->op.checkDelayTime += myPs->misc.rt_scan_time;
		if(myData->AppControl.config.systemType == CYCLER_CAN){
			if(myCh->op.checkDelayTime == 10){
				cSemiSwitch_CAN(bd, ch);
			}
			if(myCh->op.checkDelayTime == 20){
				myCh->signal[C_SIG_RANGE_SWITCH] = P0;
			}
			if(myCh->op.checkDelayTime == 30){
				myCh->signal[C_SIG_OUT_SWITCH] = P0;
			}
		}else if(myData->AppControl.config.systemType == CYCLER_PCU){
			myCh->signal[C_SIG_OUT_SWITCH] = P0;
			myCh->signal[C_SIG_OUT_SWITCH_OFF] = P1;
		}else if(myData->AppControl.config.systemType == CYCLER_LINEAR){
			myCh->signal[C_SIG_OUT_SWITCH] = P0;
			myCh->signal[C_SIG_RANGE_SWITCH] = P0;
		}
		if(myCh->op.checkDelayTime >= 200){
			myCh->op.checkDelayTime = 0;
			myCh->misc.tmpCode = myCh->op.code;
			myCh->op.code = C_ACIR_WAIT_TIME;
			flag = 1;
			return flag;
		}
	}else {
		return flag;
	}
	return flag;
}

int temp_wait_flag_check(int bd, int ch)
{
	int flag, i, cnt = 0, bd_1 = 0, ch_1 = 0;
	unsigned char noTempWaitFlag = 0;
	long refTemp, startTemp, groupTemp, opTemp;
	long chamber_dev_H, chamber_dev_L, chamber_dev; //210422
	unsigned long advStepNo;

	myCh = &(myData->bData[bd].cData[ch]);
	advStepNo = myCh->misc.advStepNo;
	refTemp = myPs->testCond[bd][ch].step[advStepNo].refTemp;
	startTemp = myPs->testCond[bd][ch].step[advStepNo].startTemp;
	groupTemp = myCh->misc.groupTemp;
	opTemp = myCh->op.temp;
	noTempWaitFlag = myPs->testCond[bd][ch].step[advStepNo].noTempWaitFlag;
	//210422
	chamber_dev = myPs->testCond[bd][ch].step[advStepNo].chamber_dev;
	chamber_dev_H = refTemp + chamber_dev;
	chamber_dev_L = refTemp - chamber_dev;
	
	flag = 0;	

	//190318 add lyhw
	if(myData->mData.config.parallelMode == P2){
		if(myCh->misc.chGroupNo == P0){
			return 1;
		}
	}

	if(myCh->signal[C_SIG_STOP] == P1) {
		myCh->op.code = C_FAULT_STOP_CMD;
		myCh->signal[C_SIG_STOP] = P0;
		cSemiSwitch_Rest(bd,ch,advStepNo,0);
		myCh->misc.chamberWaitFlag = -1;
		myCh->misc.chGroupNo = 0;
		myCh->op.phase = P100;
	} else if(myCh->signal[C_SIG_PAUSE] == P1) {
		myCh->misc.tmpState = myCh->op.state;
		myCh->op.code = C_FAULT_PAUSE_CMD;
		myCh->opSave = myCh->op;
		myCh->signal[C_SIG_PAUSE] = P0;
		cSemiSwitch_Rest(bd,ch,advStepNo,0);
		myCh->misc.chamberWaitFlag = -1;
		myCh->op.phase = P100;
	} else if(myCh->signal[C_SIG_DLL_STOP] == P1) {
		myCh->op.code = C_FAULT_CELL_DIAGNOSIS_STOP;
		myCh->op.select = SAVE_FLAG_SAVING_END;
		myCh->signal[C_SIG_DLL_STOP] = P0;
		cSemiSwitch_Rest(bd, ch, advStepNo, 0);
		myCh->misc.chamberWaitFlag = -1;
		myCh->op.phase = P100;
	}
	//140409 oys add : ChamberTempWaitFlag
	if(myData->mData.config.function[F_CHAMBER_TEMP_WAIT] == P0)
		return 1;

	//210913 chamber wait release
	if(myCh->misc.chGroupNo == 0 && myCh->misc.chamberNoWaitFlag == P1){
		return 1;
	}
	
	if(cFailCodeCheck(bd, ch) < 0) {
		myCh->misc.chamberWaitFlag = -1;
	}
	
	if(myCh->op.phase == P100) {
		cNextStepCheck(bd, ch);
		return flag;
	}
	
	//20180417 modify for step sync process
	if(myCh->misc.stepSyncFlag == P1 && myCh->misc.chamberWaitFlag >= P20){
		for(i = 0; i < myPs->config.installedCh; i++){
			bd_1 = i/myPs->config.chPerBd;
			ch_1 = i%myPs->config.chPerBd;
			if(myCh->misc.chGroupNo ==
				myData->bData[bd_1].cData[ch_1].misc.chGroupNo){
				if((myCh->misc.advStepNo != 
					myData->bData[bd_1].cData[ch_1].misc.advStepNo) ||
					(myCh->misc.totalCycle != 
					myData->bData[bd_1].cData[ch_1].misc.totalCycle)){
					if(myCh->misc.totalCycle > 
						myData->bData[bd_1].cData[ch_1].misc.totalCycle){
							cnt++;
					}else if(myCh->misc.totalCycle ==
						myData->bData[bd_1].cData[ch_1].misc.totalCycle){
						if(myCh->misc.advStepNo > 
							myData->bData[bd_1].cData[ch_1].misc.advStepNo){
								cnt++;
						}
					}
				}
			}
		}
	}
	if(cnt != 0){
		myCh->misc.chamberWaitFlag -= P10;
		cnt = 0;
	}

	//170105 oys add : ch step sync process
	if(myCh->misc.stepSyncFlag == P1){
		if(myCh->misc.chamberWaitFlag >= P20){ //chamber temp wait end run delay
			myCh->op.checkDelayTime += myPs->misc.rt_scan_time;
			if(myCh->op.type != STEP_REST) {
				myCh->signal[C_SIG_OUT_SWITCH] = P1; //run relay close
			}
			if(myCh->op.checkDelayTime >= 200){ //relay time wait
				myCh->op.checkDelayTime = 0;
				myCh->op.code = myCh->misc.tmpCode;
				myCh->misc.chamberWaitFlag = P0;
				flag = 1;
				return flag;
			}
			return flag;
		}
	}else{
		if(myCh->misc.chamberWaitFlag >= P10){ //chamber temp wait end run delay
			myCh->op.checkDelayTime += myPs->misc.rt_scan_time;
			if(myCh->op.type != STEP_REST) {
				myCh->signal[C_SIG_OUT_SWITCH] = P1; //run relay close
			}
			if(myCh->op.checkDelayTime >= 200){ //relay time wait
				myCh->op.checkDelayTime = 0;
				myCh->op.code = myCh->misc.tmpCode;
				myCh->misc.chamberWaitFlag = P0;
				flag = 1;
				return flag;
			}
			return flag;
		}
	}
	
	//20180618 sch modify for stepSync
	if(refTemp != 999000 || myCh->misc.stepSyncFlag == P1){
		if(myCh->misc.tempDir == P0
			&& myCh->misc.stepSyncFlag == P0){
			//190114 lyh add
			myCh->op.checkDelayTime += myPs->misc.rt_scan_time;
			if(myCh->op.type != STEP_REST) {
				myCh->signal[C_SIG_OUT_SWITCH] = P1; //run relay close
			}
			if(myCh->op.checkDelayTime >= 200){ //relay time wait
				myCh->op.checkDelayTime = 0;
				myCh->op.code = myCh->misc.tmpCode;
				myCh->misc.chamberWaitFlag = P0;
				flag = 1;
				return flag;
			}
			return flag;
		//	flag = 1;
		}else {
			if(myCh->misc.chamberWaitFlag == P0) {
				myCh->misc.chamberWaitFlag = P1;
				myCh->misc.tmpCode = myCh->op.code;
			}
			myCh->signal[C_SIG_NEXTSTEP] = P0; //nextstep message disable
			myCh->signal[C_SIG_STOP] = P0; //stop message disable
			myCh->signal[C_SIG_PAUSE] = P0; //pause message disable
			myCh->signal[C_SIG_DLL_STOP] = P0;
			myCh->signal[C_SIG_DLL_PAUSE] = P0;
			myCh->op.code = C_TEMP_WAIT_TIME;
			myCh->signal[C_SIG_OUT_SWITCH] = P0; //run relay open
			if(myCh->misc.tempDir == P0){
					myCh->op.checkDelayTime = 0;
					myCh->misc.chamberWaitFlag = P10; //temp dir P0
			}else if(myCh->misc.tempDir == P1){
				if(noTempWaitFlag == P1){
					myCh->op.checkDelayTime = 0;
					myCh->misc.chamberWaitFlag = P11; //temp dir P1
				}else{
					if(groupTemp >= refTemp || groupTemp >= chamber_dev_L){
						myCh->op.checkDelayTime = 0;
						myCh->misc.chamberWaitFlag = P11; //temp dir P1
					}
				}
			}else if(myCh->misc.tempDir == P2){
				if(noTempWaitFlag == P1){
					myCh->op.checkDelayTime = 0;
					myCh->misc.chamberWaitFlag = P12; //temp dir P2 
				}else{
					if(groupTemp <= refTemp || groupTemp <= chamber_dev_H ) {
						myCh->op.checkDelayTime = 0;
						myCh->misc.chamberWaitFlag = P12; //temp dir P2 
					}
				}
			}
		}
		#ifdef _SDI	//Step Sync Code Change
		if(myCh->misc.chamberWaitFlag >= P10){
			if(myCh->misc.stepSyncFlag == P1){
				myCh->op.code = C_STEP_SYNC_WAIT_TIME;
			}
		}
		#endif
	}else{
		flag = 1;
	}
	return flag;
}

//add 100312 kji add multi loop
void cStepLoop(int bd, int ch, int flag)
{
    int i, rtn = 0;
	unsigned long advStepNo, saveDt;

	myCh = &(myData->bData[bd].cData[ch]);

	advStepNo = myCh->misc.advStepNo;
	saveDt = myPs->testCond[bd][ch].step[advStepNo].saveDt;

	if(flag == 0) {
		advStepNo = myCh->misc.advStepNo;
	} else { 
		//integral Wh end, integral Ah end, cycleTime end, cycle capacity end
		while(1) {
			advStepNo = myCh->misc.advStepNo;
			if(STEP_LOOP == myPs->testCond[bd][ch].step[advStepNo].type) {
				//121205 oys add
				myCh->op.type = STEP_LOOP;
				break;
			}
			myCh->misc.advStepNo++;
		}
	}

	myCh->op.stepNo = myPs->testCond[bd][ch].step[advStepNo].stepNo;

	//120818 kji SDI mes cycle data
	if(myPs->config.function[F_SDI_MES_USE] == P1) {
		if(myCh->ChAttribute.chNo_master != P0) {
			if(myCh->op.type == STEP_LOOP) myCh->misc.mes_data_flag = 1;
			myCh->op.select = SAVE_FLAG_SAVING_END;
			if(myData->DataSave.config.save_data_type != P1){//200818
				send_save_msg(bd, ch, 0, 1);
			}
		}
	}

#if CHAMBER_TEMP_HUMIDITY == 1	//kjc_210417
	if(myCh->misc.chargeAccAh != 0){
		myCh->misc.faultEfficiencyAh
			= ((float)myCh->misc.dischargeAccAh 
				/ (float)myCh->misc.chargeAccAh) * 100.0;
	}else{
		myCh->misc.faultEfficiencyAh = 0;
	}
	if(myTestCond->safety.capacityEfficiency != 0
		&& myCh->misc.faultEfficiencyAh != 0){
		if(myCh->misc.faultEfficiencyAh	
				< myTestCond->safety.capacityEfficiency/1000){
			myCh->misc.tmpState = myCh->op.state;
			myCh->misc.tmpCode = myCh->op.code;
			send_save_msg(bd, ch, 0, 2);
			myCh->op.code = C_FAULT_CAPACITY_EFFICIENCY;
			myCh->op.state = C_PAUSE;
			myCh->misc.chGroupNo = 0;		//kjc_210825
			myCh->misc.stepSyncFlag = P0;	//kjc_210825
			myCh->op.phase = P0;
			return;
		}else{
			send_save_msg(bd, ch, 0, 2);
		}
	}else{
		send_save_msg(bd, ch, 0, 2);
	}
	if(myPs->testCond[bd][ch].step[advStepNo].advCycleCount
		<= myCh->misc.advCycle) {
		myCh->misc.efficiency_Ah[0] = 0;
	}
#endif

	i = AdvStepFlag(bd, ch);
	if(i == 0) { //next step
	} else if(i == 1) { //stop
		myCh->op.state = C_STANDBY;
		myCh->op.phase = P0;
		return;
	} else { //pause
		myCh->op.state = C_PAUSE;
		myCh->op.phase = P0;
		myCh->signal[C_SIG_PAUSE] = P0;
		myCh->signal[C_SIG_OUT_SWITCH] = P0;
		if(myPs->config.hwSpec >= S_5V_200A) { //switching
			myCh->misc.semiSwitchState = SEMI_PRE;
			cV_Range_Select(bd, ch, 0);
			cI_Range_Select(bd, ch, 0);
		}
		myCh->opSave.code = myCh->op.code;
		return;
	}

	if(flag == 0) {
		if(myPs->testCond[bd][ch].step[advStepNo].advCycleCount == 0) {
			if(myPs->testCond[bd][ch].step[advStepNo].gotoCycleCount == 0) {
				if(myPs->testCond[bd][ch].step[advStepNo].advGotoStep == 0) {
					rtn = 1; //next step
				} else {
					rtn = 3; //endless goto loop
				}
			} else if(myPs->testCond[bd][ch].step[advStepNo].gotoCycleCount
				== 1) {
				rtn = 1; //next step
			} else {
				if(myPs->testCond[bd][ch].step[advStepNo].gotoCycleCount
					<= myCh->misc.gotoCycleCount[advStepNo]) {
					rtn = 1; //next step
					myCh->misc.gotoCycleCount[advStepNo] = 0;
				} else if(myPs->testCond[bd][ch].step[advStepNo].gotoCycleCount
					> myCh->misc.gotoCycleCount[advStepNo]) {
					if(myPs->testCond[bd][ch].step[advStepNo].advGotoStep
						== 0) {
						rtn = 1; //next step
						myCh->misc.gotoCycleCount[advStepNo] = 0;
					} else {
						rtn = 3; //goto
						myCh->misc.gotoCycleCount[advStepNo]++;
					}
				}
			}
		} else {
			if(myPs->testCond[bd][ch].step[advStepNo].advCycleCount
				<= myCh->misc.advCycle) {
				if(myPs->testCond[bd][ch].step[advStepNo].gotoCycleCount == 0) {
					//111020 kji 
					if(myPs->testCond[bd][ch].step[advStepNo].advGotoStep
						== 0) {
						rtn = 1; //next step
					} else {
						rtn = 3; //endless goto loop
					}
				} else if(myPs->testCond[bd][ch].step[advStepNo].gotoCycleCount
					== 1) {
					if(myPs->testCond[bd][ch].step[advStepNo].advGotoStep
						== 0) {
						rtn = 1; //next step
					} else {
						if(myPs->testCond[bd][ch].step[advStepNo].gotoCycleCount
							== myCh->misc.gotoCycleCount[advStepNo]) {
							rtn = 1; //next step
							myCh->misc.gotoCycleCount[advStepNo] = 0;
						} else if(myPs->testCond[bd][ch].step[advStepNo]
							.gotoCycleCount
							> myCh->misc.gotoCycleCount[advStepNo])	{
							rtn = 3; //goto
							myCh->misc.gotoCycleCount[advStepNo]++;
						}
					}
				} else {
					if(myPs->testCond[bd][ch].step[advStepNo].advGotoStep
						== 0) {
						rtn = 1; //next step
					} else {
						if(myPs->testCond[bd][ch].step[advStepNo].gotoCycleCount
							<= myCh->misc.gotoCycleCount[advStepNo]) {
							rtn = 1; //next step
							myCh->misc.gotoCycleCount[advStepNo] = 0;
						} else if(myPs->testCond[bd][ch].step[advStepNo]
							.gotoCycleCount
							> myCh->misc.gotoCycleCount[advStepNo])	{
							rtn = 3; //goto
							myCh->misc.gotoCycleCount[advStepNo]++;
						}
					}
				}
			} else {
				rtn = 2; //return	
			}
		}
	} else {
		//150623 oys add 
		//integral watthour end, integral capacity end, endCycleTime end
		//capacity efficiency end, cycle step capacity end
		//170111 oys modify 
		if(myPs->testCond[bd][ch].step[advStepNo].advGotoStep == 0) {
			rtn = 1; //next step
		} else {
			if(myPs->testCond[bd][ch].step[advStepNo].advGotoStep - 1
				== myCh->misc.advCycleStep) {
				if(myPs->testCond[bd][ch].step[advStepNo].gotoCycleCount
					<= myCh->misc.gotoCycleCount[advStepNo]) {
					rtn = 1; //next step
					myCh->misc.gotoCycleCount[advStepNo] = 0;
				} else if(myPs->testCond[bd][ch].step[advStepNo].gotoCycleCount
					> myCh->misc.gotoCycleCount[advStepNo])	{
					rtn = 3; //goto
					myCh->misc.gotoCycleCount[advStepNo]++;
				}
			} else { // other Cycle Step
				if(myPs->testCond[bd][ch].step[advStepNo].advGotoStep - 1
					< myCh->misc.advCycleStep) {
					if(myPs->testCond[bd][ch].step[advStepNo].gotoCycleCount
						<= myCh->misc.gotoCycleCount[advStepNo]) {
						rtn = 1; //next step
						myCh->misc.gotoCycleCount[advStepNo] = 0;
					} else if(myPs->testCond[bd][ch].step[advStepNo]
						.gotoCycleCount
						> myCh->misc.gotoCycleCount[advStepNo])	{
						rtn = 3; //goto
						myCh->misc.gotoCycleCount[advStepNo]++;
					}
				} else {
					rtn = 3; //goto
					myCh->misc.gotoCycleCount[advStepNo] = 0;
				}
			}
		}
	}

	if(myPs->testCond[bd][ch].step[advStepNo].integralInit == 0) {
		myCh->misc.integralInit = 0; //default init
	} else { 
		myCh->misc.integralInit = 1; //not init
	}

	if(rtn == 1) {
#if VENDER != 3
		if(myCh->misc.standardC != 0) {
			//last Cycle ampareHour
			if(myCh->misc.endC_std_sel == P1) {
				myCh->misc.standardC_Flag = P1;
			}
		}
#endif
		myCh->misc.advStepNo++;
		advStepNo = myCh->misc.advStepNo;
		myCh->misc.advCycleStep = advStepNo;
		myCh->misc.advCycle = 0;
		myCh->misc.cycleRunTime = 0;
	} else if(rtn == 2) {
		advStepNo = myCh->misc.advCycleStep;
		myCh->misc.advStepNo = advStepNo;
		//rcv pc 
	} else if(rtn == 3) {
#if VENDER != 3
		if(myCh->misc.standardC != 0) {
			//last Cycle ampareHour
			if(myCh->misc.endC_std_sel == P1) {
				myCh->misc.standardC_Flag = P1;
			}
		}
#endif
		myCh->misc.advStepNo
			= (int)myPs->testCond[bd][ch].step[advStepNo].advGotoStep - 1;
		advStepNo = myCh->misc.advStepNo;
		myCh->misc.advCycleStep = advStepNo;
		myCh->misc.advCycle = 0;
		myCh->misc.cycleRunTime = 0;
	}	
//#if SEC_TYPE == 1
//	myCh->misc.standardC_Flag = P0;
//#endif

	myCh->op.type = myPs->testCond[bd][ch].step[advStepNo].type;
	myCh->op.mode = myPs->testCond[bd][ch].step[advStepNo].mode;
	myCh->op.stepNo = myPs->testCond[bd][ch].step[advStepNo].stepNo;
	myCh->op.phase = P0;
	myCh->misc.chamberStepNo = myCh->misc.advStepNo;
	
	//20180717 sch add for sbc recovery
	if(myData->mData.config.function[F_SBC_RECOVERY] == P1){
		if(myCh->ChAttribute.chNo_master == P0 && myCh->ChAttribute.opType == P0){ //slave
		}else{ //master
			send_msg(MODULE_TO_MAIN, MSG_MODULE_MAIN_GOTO_COUNT_UPDATE, bd, ch);
		}
	}

	switch(myCh->op.type) {
		case STEP_ADV_CYCLE:
			cStepAdvCycle(bd, ch);
			break;
		case STEP_PARALLEL_CYCLE: //kjg_180521
			cStepParallelCycle(bd, ch);
			break;
		case STEP_END:
			cStepEnd(bd, ch);
			break;	
		default:
			break;
	}
}

int cGoto_Type_Check(int bd, int ch)
{
	int rtn = 0;
	unsigned long advStepNo;

	myCh = &(myData->bData[bd].cData[ch]);

	advStepNo = myCh->misc.advStepNo + 1;

	if(myPs->testCond[bd][ch].step[advStepNo].advCycleCount == 0) {
		if(myPs->testCond[bd][ch].step[advStepNo].gotoCycleCount == 0) {
			if(myPs->testCond[bd][ch].step[advStepNo].advGotoStep == 0) {
				rtn = 1; //next step
			} else {
				rtn = 3; //endless goto loop
			}
		} else if(myPs->testCond[bd][ch].step[advStepNo].gotoCycleCount == 1) {
			rtn = 1; //next step
		} else {
			if(myPs->testCond[bd][ch].step[advStepNo].gotoCycleCount
				== myCh->misc.gotoCycleCount[advStepNo]) {
				rtn = 1; //next step
			} else if(myPs->testCond[bd][ch].step[advStepNo].gotoCycleCount
				> myCh->misc.gotoCycleCount[advStepNo]) {
				if(myPs->testCond[bd][ch].step[advStepNo].advGotoStep == 0) {
					rtn = 1; //next step
				} else {
					rtn = 3; //goto
				}
			}
		}
	} else {
		if(myPs->testCond[bd][ch].step[advStepNo].advCycleCount
			== myCh->misc.advCycle) {
			if(myPs->testCond[bd][ch].step[advStepNo].gotoCycleCount == 0) {
				//111020 kji 
				if(myPs->testCond[bd][ch].step[advStepNo].advGotoStep == 0) {
					rtn = 1; //next step
				} else {
					rtn = 3; //endless goto loop
				}
			} else if(myPs->testCond[bd][ch].step[advStepNo].gotoCycleCount
				== 1) {
				if(myPs->testCond[bd][ch].step[advStepNo].advGotoStep == 0) {
					rtn = 1; //next step
				} else {
					if(myPs->testCond[bd][ch].step[advStepNo].gotoCycleCount
						== myCh->misc.gotoCycleCount[advStepNo]) {
						rtn = 1; //next step
					} else if(myPs->testCond[bd][ch].step[advStepNo]
						.gotoCycleCount
						> myCh->misc.gotoCycleCount[advStepNo])	{
						rtn = 3; //goto
					}
				}
			} else {
				if(myPs->testCond[bd][ch].step[advStepNo].advGotoStep == 0) {
					rtn = 1; //next step
				} else {
					if(myPs->testCond[bd][ch].step[advStepNo].gotoCycleCount
						== myCh->misc.gotoCycleCount[advStepNo]) {
						rtn = 1; //next step
					} else if(myPs->testCond[bd][ch].step[advStepNo]
						.gotoCycleCount
						> myCh->misc.gotoCycleCount[advStepNo])	{
						rtn = 3; //goto
					}
				}
			}
		} else {
			rtn = 2; //return	
		}
	}

	return rtn;
}

void cStepEnd(int bd, int ch)
{
	int i;
	unsigned long advStepNo, saveDt;
#if CYCLER_TYPE == LINEAR_CYC
	int parallel_ch;
#endif

	myCh = &(myData->bData[bd].cData[ch]);
    advStepNo = myCh->misc.advStepNo;
	saveDt = myPs->testCond[bd][ch].step[advStepNo].saveDt;

	switch(myCh->op.phase) {
		case P0:
			myPs->signal[M_SIG_END_BUZZER] = P1;
	
		// 111212 oys w : cycleNo
		//	myCh->misc.cycleNo = myPs->testCond[bd][ch].step[advStepNo].cycleNo;
			myCh->misc.cycleNo = 0;
			myCh->misc.currentCycle = 0;
			for(i=0; i < MAX_STEP; i++){
				myCh->misc.gotoCycleCount[i] = P0;
			}
#if CYCLER_TYPE == DIGITAL_CYC
			//180611 Digital Cycler
			if(myCh->ChAttribute.chNo_master == P0){
				ch_send_cmd(bd, ch, ADDR_PCU_CLASS_MULTICAST
											, CMD_PCU_MODE_CC, 0,0);
			}else{
				if(myCh->ChAttribute.opType == P0){
					ch_send_cmd(bd, ch, ADDR_PCU_CLASS_MULTICAST
											, CMD_PCU_MODE_CC, 0,0);
				}
			}
#elif CYCLER_TYPE == LINEAR_CYC
			if(myPs->config.maxVoltage[0] >= L_10V) {
				cSemiSwitch_End(bd, ch, 2);
			} else {
				cSemiSwitch_End(bd, ch, 0);
			}
			if(myCh->ChAttribute.opType == P1) {
				myCh->signal[C_SIG_PARALLEL_SWITCH] = P0;
			}

			if(myPs->config.hwSpec >= S_5V_200A) { //switching
				myCh->signal[C_SIG_OUT_SWITCH] = P0;
		//		cV_Range_Select(bd, ch, 0);
		//		cI_Range_Select(bd, ch, 0);
			} else {
				myCh->signal[C_SIG_OUT_SWITCH] = P0;

				if(myCh->misc.parallel_cycle_phase == P50) { //kjg_180521
					if((ch % 2) == 0) parallel_ch = ch + 1;
					else parallel_ch = ch - 1;

					myData->bData[bd].cData[parallel_ch]
						.signal[C_SIG_OUT_SWITCH] = P0;
				}
			}
#endif
			if(myData->AppControl.config.systemType == CYCLER_CAN) {
		   		myCh->op.checkDelayTime = 0;
				myCh->op.phase = P4;
			}else{
				myCh->op.phase = P1;
			}
			break;
		case  P1:
		// 	myCh->op.capacitance = 0;
		//	myCh->op.z = 0;
		//  myCh->op.grade = 0;
		   	myCh->op.runTime = 0;
		   	myCh->misc.cvFlag = P0;
			#ifdef _EXTERNAL_CONTROL
			myCh->misc.chCV = P0;
			#endif								
			//210204 lyhw
   			myCh->misc.cvFaultCheckFlag = 0;
		   	myCh->misc.cycleRunTime = 0;
		   	myCh->op.checkDelayTime = 0;
			myCh->op.meanVolt = 0;
			myCh->op.meanCurr = 0;
		   	myCh->op.watt = 0;
		   	myCh->op.wattHour = 0;
			myCh->op.ampareHour = 0;
		  	myCh->op.charge_ampareHour = 0;
		  	myCh->op.discharge_ampareHour = 0;
			myCh->op.charge_wattHour = 0;
			myCh->op.discharge_wattHour = 0;
			myCh->misc.pulseDataCount = 0;
		   	myCh->misc.saveDt = 0;
		   	myCh->misc.saveDv = 0;
		   	myCh->misc.saveDi = 0;
		   	myCh->misc.saveDtemp = 0;
			myCh->misc.meanCount = 0;
			myCh->misc.meanSumVolt = 0;
			myCh->misc.meanSumCurr = 0;
			myCh->misc.ocv = 0;
			myCh->misc.actualCapacity = 0;
			myCh->misc.actualWattHour = 0; //20190214 add
			myCh->misc.sumCapacity = 0;
			myCh->misc.seedCapacity = 0;
			myCh->misc.sumChargeAmpareHour = 0;
			myCh->misc.sumDischargeAmpareHour = 0;
			myCh->misc.seedChargeAmpareHour = 0;
			myCh->misc.seedDischargeAmpareHour = 0;
		   	myCh->misc.tmpWatt = 0;
			myCh->misc.sumWattHour = 0;
			myCh->misc.seedWattHour = 0;
			myCh->misc.sumChargeWattHour = 0;
			myCh->misc.sumDischargeWattHour = 0;
			myCh->misc.seedChargeWattHour = 0;
			myCh->misc.seedDischargeWattHour = 0;
			myCh->misc.maxV = 0;
			myCh->misc.startV = 0;
			myCh->misc.startT = 0;
			myCh->misc.maxT = 0;
			myCh->misc.minT = 0;
			myCh->misc.minV = 0;
			myCh->misc.maxI = 0;
			myCh->misc.minI = 0;
			myCh->misc.c_v1 = 0;
			myCh->misc.c_v2 = 0;
			myCh->misc.c_t1 = 0;
			myCh->misc.c_t2 = 0;
			myCh->misc.pid_ui1[0] = 0.0;
			myCh->misc.pid_ui1[1] = 0.0;
			myCh->misc.pid_error1[0] = 0.0;
			myCh->misc.pid_error1[1] = 0.0;
			myCh->op.code = C_END_STEP;
			myCh->op.select = SAVE_FLAG_SAVING_END;
			myCh->misc.mes_data_flag = 1;
			//110215 kji
			myCh->misc.integralInit = 0;
			//151214 oys
			myCh->misc.completeFlag = 0;
			myCh->misc.standardC_Flag = 0;
			myCh->misc.standardP_Flag = 0;
			myCh->misc.standardZ_Flag = 0;
			//160510 oys	
			myCh->misc.socCheckCount = 0;
			myCh->misc.socCountNo[0] = 0;
			myCh->misc.socCountNo[1] = 0;
			myCh->misc.socCountNo[2] = 0;
			myCh->misc.cycleEndC = 0;
			myCh->misc.standardC = 0;
			myCh->misc.standardP = 0;
			myCh->misc.standardZ = 0;
			myCh->misc.cycleSumC = 0;
			myCh->misc.cycleSumP = 0;
			myCh->misc.endC_std_type = 0;
			myCh->misc.endP_std_type = 0;
			myCh->misc.endZ_std_type = 0;
			myCh->misc.endC_std_sel = 0;
			myCh->misc.endP_std_sel = 0;
			myCh->misc.endZ_std_sel = 0;
			myCh->misc.endC_std_cycleCount = 0;
			myCh->misc.endP_std_cycleCount = 0;
			myCh->misc.endP_std_cycleCount = 0;
			myCh->misc.pause_flag = P0;
			myCh->misc.efficiency_pause_flag = P0;
			//141208 oys SDI MES VER4 data
			myCh->op.meanTemp = 0;
			myCh->misc.meanSumTemp = 0;
			myCh->misc.cycleSumChargeWatt = 0;
			myCh->misc.cycleSumDischargeWatt = 0;
			myCh->misc.cycleStartV = 0;
			//170105 oys
			myCh->misc.chGroupNo = 0;
			myCh->misc.chGroupCheckFlag = 0;
			myCh->misc.chamberNo = 0;
			myCh->misc.stepSyncFlag = 0;
			//170728 oys
			myCh->misc.gradeProcFlag = P0;
			//190801 oys
			myCh->misc.cRateUseFlag = 0;
			//191029 oys
			myCh->misc.userDataNo = 0;
			myCh->misc.pattern_point_runTime = 0;
			myCh->misc.pattern_cross = 0;

			//20180206 sch add for capacitance iec & maxwell
			myCh->misc.delta_t_iec[0] = 0;
			myCh->misc.delta_t_iec[1] = 0;
			myCh->misc.delta_v_iec[0] = 0;
			myCh->misc.delta_v_iec[1] = 0;
			myCh->misc.delta_w_iec[0] = 0;
			myCh->misc.delta_w_iec[1] = 0;
			myCh->misc.delta_flag_iec = P0;
			myCh->misc.delta_sumI_iec = 0;
			myCh->misc.delta_cnt_iec = 0;
			myCh->misc.delta_t_maxwell[0] = 0;
			myCh->misc.delta_t_maxwell[1] = 0;
			myCh->misc.delta_v_maxwell[0] = 0;
			myCh->misc.delta_v_maxwell[1] = 0;
			myCh->misc.delta_flag_maxwell = P0;
			myCh->misc.delta_sumI_maxwell = 0;
			myCh->misc.delta_cnt_maxwell = 0;
			myCh->misc.Drop_maxV = 0;		//210915 LJS
			myCh->misc.Drop_minV = 0;		//210915 LJS
#if CAPACITY_CONTROL == 1
			myCh->misc.CycleCapaCount = 0;
			myCh->misc.CycleCapacity = 0;
			myCh->misc.Sum_C_Rate_Calc_Capacity = 0;
			for(i=0; i < MAX_STEP; i++){
				myCh->misc.C_Rate_stepCapacity[i] = 0;
				myCh->misc.c_rate_fault_flag[i] = 0;
			}
			for(i=0; i < 10; i++){
				myCh->misc.C_Rate_Calc_Capacity[i] = 0;
			}
#endif

#ifdef _TRACKING_MODE
			myCh->op.rptSOC = myCh->opSave.rptSOC;
			myCh->op.rptSOH = myCh->opSave.rptSOH; //211022
#endif
			myCh->op.phase = P2;
			break;
		case P2:
			if(myData->DataSave.config.save_data_type == P1){
				myCh->op.checkDelayTime += myPs->misc.rt_scan_time;
				//190712 oys add : End Step save wait delay
				if(myCh->op.checkDelayTime > 100) { 
					if(myCh->ChAttribute.opType == P0) {
						send_save_msg(bd, ch, saveDt, 1);
					}
					myCh->op.phase = P3;
				}
			} else {
				if(myCh->ChAttribute.opType == P0) {
					send_save_msg(bd, ch, saveDt, 1);
				}
				myCh->op.phase = P3;
			}
			break;
		case P3:
			if(CYCLER_TYPE == DIGITAL_CYC){ 
				//200825 lyhw
				myCh->misc.tmpCode = C_CODE_IDLE;
			}
			myCh->op.state = C_STANDBY;
			myCh->op.phase = P0;
			break;
		case P4:
			myCh->op.checkDelayTime += myPs->misc.rt_scan_time;
			if(myCh->op.checkDelayTime == 10){
				cSemiSwitch_End(bd, ch, 0);
			}
			if(myCh->op.checkDelayTime == 20){
				if(myCh->ChAttribute.opType == P1) {
					myCh->signal[C_SIG_PARALLEL_SWITCH] = P0;
				}
			}
			if(myCh->op.checkDelayTime == 30){
				myCh->signal[C_SIG_OUT_SWITCH] = P0;
			}
			if(myCh->op.checkDelayTime >= 50){
				myCh->op.checkDelayTime = 0;
				myCh->op.phase = P1;	
			}
			break;
		default:
			break;
	}
}

/*
int	cFindDACaliPoint(int bd, int ch, long value, int type, int range)
{
	int 	point;
	long	da;

	if(myCh->op.state == C_CALI) {
		for(point = 0; point
			< myData->cali.tmpCond[bd][ch].point[type][range].setPointNum;
			point++) {
			da = myData->cali.tmpCond[bd][ch].point[type][range].setPoint[point];
			if(value >= da) {
				if(point == 0) continue;
				else break;
			}
		}
	} else {
		for(point = 0; point < myData->cali.data[bd][ch].point[type][range]
			.setPointNum; point++) {
			da = myData->cali.data[bd][ch].point[type][range].setPoint[point];

			if(value >= da) {
				if(point == 0) continue;
				else break;
			}
		}
	}
	return point-1;
}
*/

int	cFindDACaliPoint(int bd, int ch, long value, int type, int range)
{
	int rtn;
	if(myData->AppControl.config.systemType == CYCLER_CAN) {
		if(type == 0) {
			rtn = cFindDACaliPoint_1(bd, ch, value, type, range);
		} else {
			//0724 Test lyhw
			rtn = cFindDACaliPoint_1(bd, ch, value, type, range);
		//	rtn = cFindDACaliPoint_2(bd, ch, value, type, range);
		}
		return rtn;
	}

	switch(myPs->config.hwSpec) {
		case S_5V_200A_75A_15A_AD2:
			if(type == 0) {
				rtn = cFindDACaliPoint_1(bd, ch, value, type, range);
			} else {
				rtn = cFindDACaliPoint_2(bd, ch, value, type, range);
			}
			break;
		default:
			rtn = cFindDACaliPoint_1(bd, ch, value, type, range);
			break;
	}

	return rtn;
}

int	cFindDACaliPoint_1(int bd, int ch, long value, int type, int range)
{
	int 	point, point1;
	long	da;

	myCh = &(myData->bData[bd].cData[ch]);
	if(myCh->op.state == C_CALI
		&& myData->mData.cali_meas_type != MEAS) {
		for(point=0; point
			< myData->cali.tmpCond[bd][ch].point[type][range].setPointNum;
			point++) {
			da = myData->cali.tmpCond[bd][ch].point[type][range].setPoint[point];
			if(da >= value) {
				if(point <= 0)	point = 0;
				else	point -= 1;
#if CYCLER_TYPE == DIGITAL_CYC
			   	break;
#endif
				return point;
			}
		}
		point1 = myData->cali.tmpCond[bd][ch].point[type][range].setPointNum - 1;
		da = myData->cali.tmpCond[bd][ch].point[type][range].setPoint[point1];
		if(da < value) {
			if(point1 <= 0)	point = 0;
			else point = point1-1;
		}
	} else {
		for(point=0; point < myData->cali.data[bd][ch].point[type][range]
			.setPointNum; point++) {
			da = myData->cali.data[bd][ch].point[type][range].setPoint[point];
			if(da >= value) {
				if(point <= 0)	point = 0;
				else	point -= 1;
#if CYCLER_TYPE == DIGITAL_CYC
				break;
#endif
				return point;
			}
		}
		point1 = myData->cali.data[bd][ch].point[type][range].setPointNum - 1;
		da = myData->cali.data[bd][ch].point[type][range].setPoint[point1];
		if(da < value) {
			if(point1 <= 0)	point= 0;
			else point = point1-1;
		}
	}
	return point;
}

int	cFindDACaliPoint_2(int bd, int ch, long value, int type, int range)
{
	int 	point, point1, pointNum;
	long	da;

	myCh = &(myData->bData[bd].cData[ch]);
	pointNum = 0;

	if(myCh->op.state == C_CALI) {
		pointNum = myData->cali.tmpCond[bd][ch].point[type][range]
				.discharge_pointNum;
		if(value < 0) {
			for(point=0; point < pointNum; point++) {
				da = myData->cali.tmpCond[bd][ch].point[type][range]
						.setPoint[point];
				if(da >= value) {
					if(point <= 0) point = 0;
					else point -= 1;
					return point;
				   	break;
				}
			}
			point1 = pointNum - 1;
			da = myData->cali.tmpCond[bd][ch].point[type][range]
				.setPoint[point1];
			if(da < value) {
				if(point1 <= 0) point = 0;
				else point = point1 - 1;
			}
		} else {
			for(point = pointNum+1; point
				< myData->cali.tmpCond[bd][ch].point[type][range].setPointNum;
				point++) {
				da = myData->cali.tmpCond[bd][ch].point[type][range]
					.setPoint[point];
				if(da >= value) {
					if(point <= 0) point = 0;
					else point = point - pointNum;
				   	break;
				}
			}
			point1 = myData->cali.tmpCond[bd][ch].point[type][range]
				.setPointNum - 1;
			da = myData->cali.tmpCond[bd][ch].point[type][range]
				.setPoint[point1];
			if(da < value) {
				if(point1 <= 0) point = 0;
				else point = point1 - pointNum;
			}
		}
	} else {
		pointNum = myData->cali.data[bd][ch].point[type][range]
					.discharge_pointNum;
		if(value < 0) {
			for(point=0; point < pointNum; point++) {
				da = myData->cali.data[bd][ch].point[type][range]
					.setPoint[point];
				if(da >= value) {
					if(point <= 0) point = 0;
					else point -= 1;
					return point;
				   	break;
				}
			}
			point1 = pointNum - 1;
			da = myData->cali.data[bd][ch].point[type][range].setPoint[point1];
			if(da < value) {
				if(point1 <= 0) point = 0;
				else point = point1 - 1;
			}
		} else {
			for(point = pointNum+1;
				point < myData->cali.data[bd][ch].point[type][range].setPointNum;
				point++) {
				da = myData->cali.data[bd][ch].point[type][range]
						.setPoint[point];
				if(da >= value) {
					if(point <= 0) point = 0;
					else point = point - pointNum;
					return point;
				   	break;
				}
			}
			point1 = myData->cali.data[bd][ch].point[type][range]
				.setPointNum - 1;
			da = myData->cali.data[bd][ch].point[type][range].setPoint[point1];
			if(da < value){
				if(point1 <= 0) point = 0;
				else point = point1 - pointNum;
			}
		}
	}
	return point;
}

int	cFindDACaliPoint_p(int bd, int ch, long value, int type, int range)
{ //kjg_180521
	int point, point1;
	long da;

	for(point=0; point < myData->cali.data[bd][ch].point[type][range]
		.setPointNum; point++) {
		da = myData->cali.data[bd][ch].point[type][range].setPoint[point];
		if(da >= value) {
			if(point <= 0) point = 0;
			else point -= 1;
			return point;
		}
	}

	point1 = myData->cali.data[bd][ch].point[type][range].setPointNum - 1;
	da = myData->cali.data[bd][ch].point[type][range].setPoint[point1];
	if(da < value) {
		if(point1 <= 0)	point= 0;
		else point = point1-1;
	}

	return point;
}

//20190605 KHK-----------------------------------------
void cCalCmdV(int bd, int ch, long value, int div, int range)
{
	if(myData->AppControl.config.systemType == CYCLER_CAN){
		cCalCmdV_CAN(bd, ch, value, div, range, 0);
	}else{
		cCalCmdV_Default(bd, ch, value, div, range);
	}
}
//-----------------------------------------------------

void cCalCmdV_Default(int bd, int ch, long value, int div, int range)
{
	unsigned char bd_enable;
    int point=0, bit=0, ch_select;
	int addr, base_addr, addr_step, da_bd_en, da_h_byte, dav_l, addr_div;
    double tmp=0;
	U_ADDA ref;
	const int type = 0;

#if CYCLER_TYPE == DIGITAL_CYC
	return;	//180611 add
#endif
	myCh = &(myData->bData[bd].cData[ch]);
	myCh->misc.preVref = value;
	
	if(div > 0 && div <= 10) {
		point = cFindDACaliPoint(bd, ch, value, type, range);
		if((range + 1) == RANGE1) {
			switch(myPs->config.hwSpec) {
				case S_5V_200A:
					if(myCh->op.state == C_CALI
						&& myData->mData.cali_meas_type != MEAS) {
						tmp = ((double)value * myData->cali.tmpData[bd][ch]
							.DA_A[type][range][point]
							+ myData->cali.tmpData[bd][ch]
							.DA_B[type][range][point]) * 1.01 + 2490000.0;
					} else {
						tmp = ((double)value * myData->cali.data[bd][ch]
							.DA_A[type][range][point]
							+ myData->cali.data[bd][ch]
							.DA_B[type][range][point]) * 1.01 + 2490000.0;
					}
					break;
				default:
					if(myCh->op.state == C_CALI
						&& myData->mData.cali_meas_type != MEAS) {
						tmp = (double)value * myData->cali.tmpData[bd][ch]
							.DA_A[type][range][point]
							+ myData->cali.tmpData[bd][ch]
							.DA_B[type][range][point];
					} else {
						tmp = (double)value * myData->cali.data[bd][ch]
							.DA_A[type][range][point]
							+ myData->cali.data[bd][ch]
							.DA_B[type][range][point];
					}
					break;
			}
		} else if((range + 1) == RANGE2) {
			if(myCh->op.state == C_CALI
				&& myData->mData.cali_meas_type != MEAS) {
				tmp = (double)value * myData->cali.tmpData[bd][ch]
					.DA_A[type][range][point]
					+ myData->cali.tmpData[bd][ch].DA_B[type][range][point];
			} else {
				tmp = (double)value * myData->cali.data[bd][ch]
					.DA_A[type][range][point]
					+ myData->cali.data[bd][ch].DA_B[type][range][point];
			}
		} else if((range + 1) == RANGE3) {
			if(myCh->op.state == C_CALI
				&& myData->mData.cali_meas_type != MEAS) {
				tmp = (double)value * myData->cali.tmpData[bd][ch]
					.DA_A[type][range][point]
					+ myData->cali.tmpData[bd][ch].DA_B[type][range][point];
			} else {
				tmp = (double)value * myData->cali.data[bd][ch]
					.DA_A[type][range][point]
					+ myData->cali.data[bd][ch].DA_B[type][range][point];
			}
		} else { //range4
			if(myCh->op.state == C_CALI
				&& myData->mData.cali_meas_type != MEAS) {
				tmp = (double)value * myData->cali.tmpData[bd][ch]
					.DA_A[type][range][point]
					+ myData->cali.tmpData[bd][ch].DA_B[type][range][point];
			} else {
				tmp = (double)value * myData->cali.data[bd][ch]
					.DA_A[type][range][point]
					+ myData->cali.data[bd][ch].DA_B[type][range][point];
			}
		}
	} else if(div > 10) {
		div -= 10;
		if((range + 1) == RANGE1) {
			switch(myPs->config.hwSpec) {
				case S_5V_200A:
					tmp = (double)value * 1.01 + 2490000.0;
					break;
				default:
					tmp = (double)value;
					break;
			}
		} else if((range + 1) == RANGE2) {
			tmp = (double)value;
		} else if((range + 1) == RANGE3) {
			tmp = (double)value;
		} else { //range4
			tmp = (double)value;
		}
	} else tmp = 0;

	if(myPs->config.ratioVoltage == MICRO) { //uV
		switch(myPs->config.hwSpec) {
			case L_50V_50A:
				tmp = (tmp * 0.0032767) * (7.5/50.0); //cmd 50V --> da 7.5V
				break;
			case L_20V_25A:
				tmp = (tmp * 0.0032767) * (7.0/20.0); //cmd 20V --> da 7V
				break;
			case L_20V_300A_R2:
				tmp = (tmp * 0.0032767) * (6.0/20.0); //cmd 20V --> da 7V
				break;
			case L_40V_300A_R2:
				tmp = (tmp * 0.0032767) * (6.0/40.0); //cmd 40V --> da 7V
				break;
			case L_16V_200A_R2:
				tmp = (tmp * 0.0032767) * (6.0/16.0); //cmd 20V --> da 6V
				break;
			case L_20V_110A_R2:
				tmp = (tmp * 0.0032767) * (6.0/20.0); //cmd 20V --> da 6V
				break;
			case L_20V_50A_R2_1:
				tmp = (tmp * 0.0032767) * (6.0/20.0); //cmd 20V --> da 6V
				break;
			case L_10V_50A_R2:
				tmp = (tmp * 0.0032767) * (6.0/10.0); //cmd 20V --> da 6V
				break;
			case L_10V_500A_R2:
				tmp = (tmp * 0.0032767) * (6.0/10.0); //cmd 20V --> da 6V
				break;
			case L_20V_10A_R1:
		    case L_20V_5A_R1:
			case L_20V_50A_R2:
				tmp = (tmp * 0.0032767) * (7.0/20.0); //cmd 20V --> da 7V
				break;
			case L_10V_5A_R2:
				tmp = (tmp * 0.0032767) * (5.0/10.0); //cmd 10V --> da 5V
				break;
			case L_20V_300A_R2_1:
				tmp = (tmp * 0.0032767) * (8.0/20.0); //cmd 20V --> da 7V
				break;	
			case L_30V_20A_R1_AD2:	//LG innotek
				tmp = (tmp * 0.0032767) * (5.0/30.0); //cmd 30V --> da 5V
				break;
			case L_30V_5A_R1_AD2:	//LS Mtron
				tmp = (tmp * 0.0032767) * (8.108/30.0); //cmd 30V --> da 8V
				break;
			case L_60V_100A_R1_AD2:	//LS Mtron
				tmp = (tmp * 0.0032767) * (8.0/60.0); //cmd 30V --> da 8V
				break;
			case L_15V_100A_R3_AD2:
				tmp = (tmp * 0.0032767) * (6.0/15.0); //cmd 15V --> da 6V
				break;
			case L_30V_40A_R2:	//LS Mtron
			case L_20V_6A_R3: 	//210813 ljsw LGES 20V6A
				tmp = (tmp * 0.0032767) * (8.0/(myPs->config.maxVoltage[0] /
						1000000.0)); //cmd 30V --> da 8V
				break;
			case L_30V_40A_R2_OT_20:	//LS Mtron
				tmp = (tmp * 0.0032767) * (8.0/(myPs->config.maxVoltage[0] /
						1000000.0)); //cmd 30V --> da 8V
				break;
			case L_30V_40A_R2_P_AD2:	//pms edit high voltage && parallelMode
				tmp = (tmp * 0.0032767) * (8.0/(myPs->config.maxVoltage[0] /
						1000000.0)); //cmd 30V --> da 8V
				break;
			case L_MAIN_REV11: //pms edit high voltage && parallelMode
				if(myPs->config.maxVoltage[0] > 9000000.0) {
					//cmd V -> da 8V
					tmp = (tmp * 0.0032767) * (8.0
						/ (myPs->config.maxVoltage[0] / 1000000.0));
				} else {
					//160414 oys modify
					tmp *= 0.0032767;
//					tmp = (tmp * 0.0032767) * (5.0/(myPs->config.maxVoltage[0] /
//					1000000.0)); //cmd V --> da 5V
				}
				break;
			case L_5V_600A_10A: //Pack hardware
				//AMP -> INA128UA
				//G = (50k / 18k) + 1 = 3.777777778
				//V1 = 2.5V * G = 9444444.445uV
				//1LSB = V1 / 32768 = 288.2215712uV
				//V1 * x = 32768 -> x = 0.003469552941
				tmp *= 0.003469552941;
				break;
			default:
				tmp *= 0.0032767;
				break;
		}
	} else { //nV
		tmp *= 0.0000032767;
	}

	if(div != 5) tmp = tmp / 5.0 * div;

	if(tmp > 32767) tmp = 32767;
	else if(tmp < -32767) tmp = -32767;

	if(myPs->config.DAC_type == DAC_7741) {
		ref.val = (short int)tmp ^ 0x8000;
	} else {
		ref.val = (short int)tmp;
	}

	base_addr = myPs->addr.main[BASE_ADDR];
	addr_step = myPs->addr.main[ADDR_STEP];
	da_bd_en = myPs->addr.main[DA_BD_ENABLE];
	addr_div = myPs->addr.main[ADDR_DIV];
	da_h_byte = myPs->addr.main[DA_H_BYTE];
	dav_l = myPs->addr.main[DAV_L];

	if(myPs->config.ADC_type == COMM_TYPE) {
		addr = base_addr + da_h_byte;
    	outb(ref.byte[1], addr);
		addr = base_addr + dav_l + ch;
    	outb(ref.byte[0], addr);
	} else {
		switch(myPs->config.hwSpec) {
			case L_5V_600A_10A: //Pack hardware
				bd_enable = 0x01 << ch;
				addr = base_addr + addr_step * bd + da_bd_en;
				outb(bd_enable, addr);
				addr = base_addr + addr_step * bd + da_h_byte;
		    	outb(ref.byte[1], addr);
				addr = base_addr + addr_step * bd + dav_l;
	   	 		outb(ref.byte[0], addr);
				usleep(5);
				break;
			case L_5V_30A:
				ch = myPs->config.chPerBd * bd + ch;
				addr = base_addr + da_h_byte;
		    	outb(ref.byte[1], addr);
				addr = base_addr + dav_l + ch;
   		 		outb(ref.byte[0], addr);
				break;
			case L_5V_10mA:
				bd_enable = 0x01;
				bd_enable = bd_enable << (bd * 2);
				addr = base_addr + da_bd_en;
				outb(bd_enable, addr);
				addr = base_addr + da_h_byte;
		    	outb(ref.byte[1], addr);
				addr = base_addr + dav_l + ch;
    			outb(ref.byte[0], addr);
				break;
			case L_20V_25A:
			case L_5V_100A:
				bit = ch / 8;
				bd_enable = 0x01;
				bd_enable = bd_enable << bit;
				addr = base_addr + addr_step * bd + da_bd_en;
				outb(bd_enable, addr);

				addr = base_addr + addr_step * bd + da_h_byte;
		    	outb(ref.byte[1], addr);
				addr = base_addr + addr_step * bd + addr_div;
				outb(0x04, addr);
				addr = base_addr + addr_step * bd + dav_l + (ch%8);
   		 		outb(ref.byte[0], addr);
				addr = base_addr + addr_step * bd + addr_div;
				outb(0x00, addr);
				break;
			case L_5V_200A_R2:
			case L_5V_30A_R1:
			case L_5V_100A_R1:
			case L_5V_100A_R1_EG:
			case L_5V_2A_R1:
			case L_5V_2A_R2:
			case L_5V_4A_R2:
			case L_5V_1A_R3:
			case L_5V_6A_R3:
			case L_5V_500mA_R2:
			case L_5V_10_30A_R2:
			case L_5V_5A_R2:
			case L_5V_1A_R2:
			case L_5V_500A_R1:
			case L_5V_500A_R2:
			case L_5V_200A_R4:
			case L_5V_200A_R3:
			case L_5V_400A_R3:
			case L_3V_200A_R2:
			case L_16V_200A_R2:
			case L_5V_250A_R2:
			case L_20V_300A_R2_1:
			case L_5V_220A_R2:
			case L_20V_110A_R2:
			case L_20V_50A_R2_1:
			case L_10V_50A_R2:
			case L_5V_100A_R2_1:
			case L_5V_150A_R1:
			case L_5V_150A_R3:
			case L_5V_250A_R1:
			case L_5V_50A_R1:
			case L_5V_1000A_R1:
			case L_5V_1000A_R3:
			case L_5V_300A_R1:
			case L_5V_300A_R3:
			case L_10V_500A_R2:
			case L_5V_120A_R3:
			case L_20V_300A_R2:
			case L_40V_300A_R2:
			case L_30V_40A_R2:
			case L_30V_40A_R2_OT_20:
			case L_30V_40A_R2_P_AD2:
			case L_20V_10A_R1:
		    case L_20V_5A_R1:
			case L_20V_50A_R2:
			case L_5V_50A_R2:
			case L_5V_65A_R3:
			case L_6V_60A_R2_P:
			case L_5V_50A_R2_P:
			case L_5V_50A_R2_1:
			case L_5V_20A_R3:
			case L_5V_10A_R3:
			case L_6V_60A_R2:
			case L_5V_150A_R3_AD2:
			case L_8CH_MAIN_AD2_P:
			case L_5V_30A_R3_HYUNDAI:
			case L_30V_20A_R1_AD2:
			case L_5V_200A_R3_P_AD2:
			case L_5V_200A_1CH_JIG:
			case L_5V_150A_R2_P:
			case L_5V_200A_R3_P:
			case L_5V_60A_R2_1:
			case L_30V_5A_R1_AD2:
			case L_60V_100A_R1_AD2:	//LS Mtron
			case L_15V_100A_R3_AD2:
			case S_5V_200A_75A_15A_AD2:
			case L_MAIN_REV11:
			case L_5V_20A_R3_NEW:
			case L_5V_500A_R3_1:
			case L_20V_6A_R3: 	//210813 ljsw LGES 20V6A
				bit = ch / 8;
				bd_enable = 0x01;
				bd_enable = bd_enable << bit;
				addr = base_addr + addr_step * bd + da_bd_en;
				if(myPs->config.MainBdType == CPLD_TYPE) {
					outb(bd_enable, addr);
				} else if(myPs->config.MainBdType == FPGA_TYPE) {
					outb(~bd_enable, addr);
				}
				
				addr = base_addr + addr_step * bd + da_h_byte;
		    	outb(ref.byte[1], addr);
				addr = base_addr + addr_step * bd + addr_div;
				outb(0x02, addr);
				addr = base_addr + addr_step * bd + dav_l + (ch % 8);
	   	 		outb(ref.byte[0], addr);
				addr = base_addr + addr_step * bd + addr_div;
				outb(0x00, addr);
				addr = base_addr + addr_step * bd + da_bd_en;
				if(myPs->config.MainBdType == CPLD_TYPE) {
					outb(0x00, addr);
				} else if(myPs->config.MainBdType == FPGA_TYPE) {
					outb(0xFF, addr);
				}
				break;
			case L_5V_10A_R3_NEW:
				bit = (ch / 8) * 2;
				bd_enable = 0x01;
				bd_enable = bd_enable << bit;
				addr = base_addr + addr_step * bd + da_bd_en;
				
				if(myPs->config.MainBdType == CPLD_TYPE) 
					outb(bd_enable, addr);
				else if(myPs->config.MainBdType == FPGA_TYPE)
					outb(~bd_enable, addr);
				
				addr = base_addr + addr_step * bd + da_h_byte;
		    	outb(ref.byte[1], addr);
				addr = base_addr + addr_step * bd + addr_div;
				outb(0x02, addr);
				addr = base_addr + addr_step * bd + dav_l + (ch%8);
	   	 		outb(ref.byte[0], addr);
				addr = base_addr + addr_step * bd + addr_div;
				outb(0x00, addr);
				addr = base_addr + addr_step * bd + da_bd_en;
				if(myPs->config.MainBdType == CPLD_TYPE) 
					outb(0x00, addr);
				else if(myPs->config.MainBdType == FPGA_TYPE)
					outb(0xff, addr);
				break;
			case L_MULTI:										//pms add for Multi BD
				//da bd enable			0x624
				bd_enable = 0x01;
				addr = base_addr + da_bd_en;
				outb(bd_enable, addr);
				//high byte				0x623
				addr = base_addr + da_h_byte;
				outb(ref.byte[1], addr);
				//low byte				0x630 ~ 633(1ch ~ 4ch)
				addr = base_addr + addr_step+dav_l + (ch %8);
				outb(ref.byte[0], addr);
				//da bd disable			0x624
				bd_enable = 0x00;
				addr = base_addr + da_bd_en;
				outb(bd_enable, addr);
				break;											//end of add
			case L_5V_100mA_R2:
				bit = ch / 16;
				bd_enable =0x01;
				bd_enable = bd_enable << (2 * bit);
				addr = base_addr + addr_step * bd + da_bd_en;
				outb(bd_enable, addr);//V SELECT

				addr = base_addr + addr_step * bd + da_h_byte;
		    	outb(ref.byte[1], addr);//DA H BYTE
				
				addr = base_addr + addr_step * bd + addr_div;
				ch_select = 0x02 << ((ch % 16) / 8);
				outb(ch_select, addr); //CH SELECT1(1-8,17-24 || 9-16,25-32)		
				addr = base_addr + addr_step * bd + dav_l + (ch%8);
	   	 		outb(ref.byte[0], addr);//CH SELECT2(CH ENABLE,DA L BYTE)
				
				addr = base_addr + addr_step * bd + addr_div;
				outb(0x00, addr);//CH SELECT CLOSE

				addr = base_addr + addr_step * bd + da_bd_en;
				outb(0x00, addr);//V SELECT CLOSE
				break;
			case L_10V_5A_R2:	
				bit = ch / 4;
				bd_enable = 0x01;
				bd_enable = bd_enable << bit;
				addr = base_addr + addr_step * bd + da_bd_en;
				outb(bd_enable, addr);

				addr = base_addr + addr_step * bd + da_h_byte;
		    	outb(ref.byte[1], addr);
				addr = base_addr + addr_step * bd + addr_div;
				outb(0x02, addr);
				addr = base_addr + addr_step * bd + dav_l + (ch%4);
	   	 		outb(ref.byte[0], addr);
				addr = base_addr + addr_step * bd + addr_div;
				outb(0x00, addr);
				break;
			case L_5V_20A:
				bd_enable = 0x01;
				bd_enable = bd_enable << bd;
				addr = base_addr + da_bd_en;
				outb(bd_enable, addr);
				addr = base_addr + da_h_byte;
	   		 	outb(ref.byte[1], addr);
				addr = base_addr + dav_l + ch;
   		 		outb(ref.byte[0], addr);
				break;
			case L_5V_500mA_2uA_R4:		//210526 lyhw
				//210611 lyhw for 2ua Voltage Select
				if(myCh->signal[C_SIG_I_RANGE] == RANGE4){ 
					range = RANGE1;
				}

				if(range == RANGE1){
					if(ch >= 16) bd_enable = 0x10; 
					else	bd_enable = 0x04;

					bit = ch / 8;
					bd_enable = bd_enable << bit;
				}else{
					if(ch >= 16) bd_enable = 0x04; 
					else	bd_enable = 0x01;

					bit = ch / 8;
					bd_enable = bd_enable << bit;
				}

				addr = base_addr + addr_step * bd + da_bd_en;
				outb(~bd_enable, addr);
				addr = base_addr + addr_step * bd + da_h_byte;
		    	outb(ref.byte[1], addr);
				addr = base_addr + addr_step * bd + addr_div;
				outb(0x02, addr);
				addr = base_addr + addr_step * bd + dav_l + (ch % 8);
	   	 		outb(ref.byte[0], addr);
				addr = base_addr + addr_step * bd + addr_div;
				outb(0x00, addr);
				addr = base_addr + addr_step * bd + da_bd_en;
				outb(0xFF, addr);
				break;
			default:
				bit = ch / 8;
				bd_enable = 0x01;
				bd_enable = bd_enable << bit;
				addr = base_addr + da_bd_en;
				outb(bd_enable, addr);
				addr = base_addr + da_h_byte;
	   		 	outb(ref.byte[1], addr);
				addr = base_addr + dav_l + ch;
   		 		outb(ref.byte[0], addr);
				break;
		}
	}
}

void cCalCmdV_p(int bd, int ch, long value, int div, int range)
{ //kjg_180521
	unsigned char bd_enable;
    int point=0, bit=0, ch_select;
	int addr, base_addr, addr_step, da_bd_en, da_h_byte, dav_l, addr_div;
    double tmp=0;
	U_ADDA ref;
	const int type = 0;
	
#if CYCLER_TYPE == DIGITAL_CYC
	return;	//180611 add
#endif
	//kjg_180521 myData->bData[bd].cData[ch].misc.preVref = value;
	
	if(div > 0 && div <= 10) {
		point = cFindDACaliPoint_p(bd, ch, value, type, range);
		if((range + 1) == RANGE1) {
			tmp = (double)value * myData->cali.data[bd][ch]
				.DA_A[type][range][point]
				+ myData->cali.data[bd][ch].DA_B[type][range][point];
		} else if((range + 1) == RANGE2) {
			tmp = (double)value * myData->cali.data[bd][ch]
				.DA_A[type][range][point]
				+ myData->cali.data[bd][ch].DA_B[type][range][point];
		} else if((range + 1) == RANGE3) {
			tmp = (double)value * myData->cali.data[bd][ch]
				.DA_A[type][range][point]
				+ myData->cali.data[bd][ch].DA_B[type][range][point];
		} else { //range4
			tmp = (double)value * myData->cali.data[bd][ch]
				.DA_A[type][range][point]
				+ myData->cali.data[bd][ch].DA_B[type][range][point];
		}
	} else if(div > 10) {
		div -= 10;
		if((range + 1) == RANGE1) {
			tmp = (double)value;
		} else if((range + 1) == RANGE2) {
			tmp = (double)value;
		} else if((range + 1) == RANGE3) {
			tmp = (double)value;
		} else { //range4
			tmp = (double)value;
		}
	} else tmp = 0;

	if(myPs->config.ratioVoltage == MICRO) { //uV
		switch(myPs->config.hwSpec) {
			case L_50V_50A:
				tmp = (tmp * 0.0032767) * (7.5/50.0); //cmd 50V --> da 7.5V
				break;
			case L_20V_25A:
				tmp = (tmp * 0.0032767) * (7.0/20.0); //cmd 20V --> da 7V
				break;
			case L_20V_300A_R2:
				tmp = (tmp * 0.0032767) * (6.0/20.0); //cmd 20V --> da 7V
				break;
			case L_40V_300A_R2:
				tmp = (tmp * 0.0032767) * (6.0/40.0); //cmd 40V --> da 7V
				break;
			case L_16V_200A_R2:
				tmp = (tmp * 0.0032767) * (6.0/16.0); //cmd 20V --> da 6V
				break;
			case L_20V_110A_R2:
				tmp = (tmp * 0.0032767) * (6.0/20.0); //cmd 20V --> da 6V
				break;
			case L_20V_50A_R2_1:
				tmp = (tmp * 0.0032767) * (6.0/20.0); //cmd 20V --> da 6V
				break;
			case L_10V_50A_R2:
				tmp = (tmp * 0.0032767) * (6.0/10.0); //cmd 20V --> da 6V
				break;
			case L_10V_500A_R2:
				tmp = (tmp * 0.0032767) * (6.0/10.0); //cmd 20V --> da 6V
				break;
			case L_20V_10A_R1:
		    case L_20V_5A_R1:
			case L_20V_50A_R2:
				tmp = (tmp * 0.0032767) * (7.0/20.0); //cmd 20V --> da 7V
				break;
			case L_10V_5A_R2:
				tmp = (tmp * 0.0032767) * (5.0/10.0); //cmd 10V --> da 5V
				break;
			case L_20V_300A_R2_1:
				tmp = (tmp * 0.0032767) * (8.0/20.0); //cmd 20V --> da 7V
				break;	
			case L_30V_20A_R1_AD2:	//LG innotek
				tmp = (tmp * 0.0032767) * (5.0/30.0); //cmd 30V --> da 5V
				break;
			case L_30V_5A_R1_AD2:	//LS Mtron
				tmp = (tmp * 0.0032767) * (8.108/30.0); //cmd 30V --> da 8V
				break;
			case L_60V_100A_R1_AD2:	//LS Mtron
				tmp = (tmp * 0.0032767) * (8.0/60.0); //cmd 30V --> da 8V
				break;
			case L_15V_100A_R3_AD2:
				tmp = (tmp * 0.0032767) * (6.0/15.0); //cmd 15V --> da 6V
				break;
			case L_30V_40A_R2:	//LS Mtron
			case L_20V_6A_R3: 	//210813 ljsw LGES 20V6A
				tmp = (tmp * 0.0032767) * (8.0/(myPs->config.maxVoltage[0] /
						1000000.0)); //cmd 30V --> da 8V
				break;
			case L_30V_40A_R2_OT_20: //LS Mtron
				tmp = (tmp * 0.0032767) * (8.0/(myPs->config.maxVoltage[0] /
						1000000.0)); //cmd 30V --> da 8V
				break;
			case L_30V_40A_R2_P_AD2:	//pms edit high voltage && parallelMode
				tmp = (tmp * 0.0032767) * (8.0/(myPs->config.maxVoltage[0] /
						1000000.0)); //cmd 30V --> da 8V
				break;
			case L_MAIN_REV11: //pms edit high voltage && parallelMode
				if(myPs->config.maxVoltage[0] > 9000000.0) {
					//cmd V -> da 8V
					tmp = (tmp * 0.0032767) * (8.0
						/ (myPs->config.maxVoltage[0] / 1000000.0));
				} else {
					//160414 oys modify
					tmp *= 0.0032767;
//					tmp = (tmp * 0.0032767) * (5.0/(myPs->config.maxVoltage[0] /
//					1000000.0)); //cmd V --> da 5V
				}
				break;
			case L_5V_600A_10A: //Pack hardware
				//AMP -> INA128UA
				//G = (50k / 18k) + 1 = 3.777777778
				//V1 = 2.5V * G = 9444444.445uV
				//1LSB = V1 / 32768 = 288.2215712uV
				//V1 * x = 32768 -> x = 0.003469552941
				tmp *= 0.003469552941;
				break;
			default:
				tmp *= 0.0032767;
				break;
		}
	} else { //nV
		tmp *= 0.0000032767;
	}

	if(div != 5) tmp = tmp / 5.0 * div;

	if(tmp > 32767) tmp = 32767;
	else if(tmp < -32767) tmp = -32767;

	if(myPs->config.DAC_type == DAC_7741) {
		ref.val = (short int)tmp ^ 0x8000;
	} else {
		ref.val = (short int)tmp;
	}

	base_addr = myPs->addr.main[BASE_ADDR];
	addr_step = myPs->addr.main[ADDR_STEP];
	da_bd_en = myPs->addr.main[DA_BD_ENABLE];
	addr_div = myPs->addr.main[ADDR_DIV];
	da_h_byte = myPs->addr.main[DA_H_BYTE];
	dav_l = myPs->addr.main[DAV_L];

	if(myPs->config.ADC_type == COMM_TYPE) {
		addr = base_addr + da_h_byte;
    	outb(ref.byte[1], addr);
		addr = base_addr + dav_l + ch;
    	outb(ref.byte[0], addr);
	} else {
		switch(myPs->config.hwSpec) {
			case L_5V_600A_10A: //Pack hardware
				bd_enable = 0x01 << ch;
				addr = base_addr + addr_step * bd + da_bd_en;
				outb(bd_enable, addr);
				addr = base_addr + addr_step * bd + da_h_byte;
		    	outb(ref.byte[1], addr);
				addr = base_addr + addr_step * bd + dav_l;
	   	 		outb(ref.byte[0], addr);
				usleep(5);
				break;
			case L_5V_30A:
				ch = myPs->config.chPerBd * bd + ch;
				addr = base_addr + da_h_byte;
		    	outb(ref.byte[1], addr);
				addr = base_addr + dav_l + ch;
   		 		outb(ref.byte[0], addr);
				break;
			case L_5V_10mA:
				bd_enable = 0x01;
				bd_enable = bd_enable << (bd * 2);
				addr = base_addr + da_bd_en;
				outb(bd_enable, addr);
				addr = base_addr + da_h_byte;
		    	outb(ref.byte[1], addr);
				addr = base_addr + dav_l + ch;
    			outb(ref.byte[0], addr);
				break;
			case L_20V_25A:
			case L_5V_100A:
				bit = ch / 8;
				bd_enable = 0x01;
				bd_enable = bd_enable << bit;
				addr = base_addr + addr_step * bd + da_bd_en;
				outb(bd_enable, addr);

				addr = base_addr + addr_step * bd + da_h_byte;
		    	outb(ref.byte[1], addr);
				addr = base_addr + addr_step * bd + addr_div;
				outb(0x04, addr);
				addr = base_addr + addr_step * bd + dav_l + (ch%8);
   		 		outb(ref.byte[0], addr);
				addr = base_addr + addr_step * bd + addr_div;
				outb(0x00, addr);
				break;
			case L_5V_200A_R2:
			case L_5V_30A_R1:
			case L_5V_100A_R1:
			case L_5V_100A_R1_EG:
			case L_5V_2A_R1:
			case L_5V_2A_R2:
			case L_5V_4A_R2:
			case L_5V_1A_R3:
			case L_5V_6A_R3:
			case L_5V_500mA_R2:
			case L_5V_10_30A_R2:
			case L_5V_5A_R2:
			case L_5V_1A_R2:
			case L_5V_500A_R1:
			case L_5V_500A_R2:
			case L_5V_200A_R4:
			case L_5V_200A_R3:
			case L_5V_400A_R3:
			case L_3V_200A_R2:
			case L_16V_200A_R2:
			case L_5V_250A_R2:
			case L_20V_300A_R2_1:
			case L_5V_220A_R2:
			case L_20V_110A_R2:
			case L_20V_50A_R2_1:
			case L_10V_50A_R2:
			case L_5V_100A_R2_1:
			case L_5V_150A_R1:
			case L_5V_150A_R3:
			case L_5V_250A_R1:
			case L_5V_50A_R1:
			case L_5V_1000A_R1:
			case L_5V_1000A_R3:
			case L_5V_300A_R1:
			case L_5V_300A_R3:
			case L_10V_500A_R2:
			case L_5V_120A_R3:
			case L_20V_300A_R2:
			case L_40V_300A_R2:
			case L_30V_40A_R2:
			case L_30V_40A_R2_OT_20:
			case L_30V_40A_R2_P_AD2:
			case L_20V_10A_R1:
		    case L_20V_5A_R1:
			case L_20V_50A_R2:
			case L_5V_50A_R2:
			case L_5V_65A_R3:
			case L_6V_60A_R2_P:
			case L_5V_50A_R2_P:
			case L_5V_50A_R2_1:
			case L_5V_20A_R3:
			case L_5V_10A_R3:
			case L_6V_60A_R2:
			case L_5V_150A_R3_AD2:
			case L_8CH_MAIN_AD2_P:
			case L_5V_30A_R3_HYUNDAI:
			case L_30V_20A_R1_AD2:
			case L_5V_200A_R3_P_AD2:
			case L_5V_200A_1CH_JIG:
			case L_5V_150A_R2_P:
			case L_5V_200A_R3_P:
			case L_5V_60A_R2_1:
			case L_30V_5A_R1_AD2:
			case L_60V_100A_R1_AD2:	//LS Mtron
			case L_15V_100A_R3_AD2:
			case S_5V_200A_75A_15A_AD2:
			case L_MAIN_REV11:
			case L_5V_20A_R3_NEW:
			case L_5V_500A_R3_1:
			case L_20V_6A_R3: 	//210813 ljsw LGES 20V6A
				bit = ch / 8;
				bd_enable = 0x01;
				bd_enable = bd_enable << bit;
				addr = base_addr + addr_step * bd + da_bd_en;
				if(myPs->config.MainBdType == CPLD_TYPE) {
					outb(bd_enable, addr);
				} else if(myPs->config.MainBdType == FPGA_TYPE) {
					outb(~bd_enable, addr);
				}
				
				addr = base_addr + addr_step * bd + da_h_byte;
		    	outb(ref.byte[1], addr);
				addr = base_addr + addr_step * bd + addr_div;
				outb(0x02, addr);
				addr = base_addr + addr_step * bd + dav_l + (ch % 8);
	   	 		outb(ref.byte[0], addr);
				addr = base_addr + addr_step * bd + addr_div;
				outb(0x00, addr);
				addr = base_addr + addr_step * bd + da_bd_en;
				if(myPs->config.MainBdType == CPLD_TYPE) {
					outb(0x00, addr);
				} else if(myPs->config.MainBdType == FPGA_TYPE) {
					outb(0xFF, addr);
				}
				break;
			case L_5V_10A_R3_NEW:
				bit = (ch / 8) * 2;
				bd_enable = 0x01;
				bd_enable = bd_enable << bit;
				addr = base_addr + addr_step * bd + da_bd_en;
				
				if(myPs->config.MainBdType == CPLD_TYPE) 
					outb(bd_enable, addr);
				else if(myPs->config.MainBdType == FPGA_TYPE)
					outb(~bd_enable, addr);
				
				addr = base_addr + addr_step * bd + da_h_byte;
		    	outb(ref.byte[1], addr);
				addr = base_addr + addr_step * bd + addr_div;
				outb(0x02, addr);
				addr = base_addr + addr_step * bd + dav_l + (ch%8);
	   	 		outb(ref.byte[0], addr);
				addr = base_addr + addr_step * bd + addr_div;
				outb(0x00, addr);
				addr = base_addr + addr_step * bd + da_bd_en;
				if(myPs->config.MainBdType == CPLD_TYPE) 
					outb(0x00, addr);
				else if(myPs->config.MainBdType == FPGA_TYPE)
					outb(0xff, addr);
				break;
			case L_MULTI:										//pms add for Multi BD
				//da bd enable			0x624
				bd_enable = 0x01;
				addr = base_addr + da_bd_en;
				outb(bd_enable, addr);
				//high byte				0x623
				addr = base_addr + da_h_byte;
				outb(ref.byte[1], addr);
				//low byte				0x630 ~ 633(1ch ~ 4ch)
				addr = base_addr + addr_step+dav_l + (ch %8);
				outb(ref.byte[0], addr);
				//da bd disable			0x624
				bd_enable = 0x00;
				addr = base_addr + da_bd_en;
				outb(bd_enable, addr);
				break;											//end of add
			case L_5V_100mA_R2:
				bit = ch / 16;
				bd_enable =0x01;
				bd_enable = bd_enable << (2 * bit);
				addr = base_addr + addr_step * bd + da_bd_en;
				outb(bd_enable, addr);//V SELECT

				addr = base_addr + addr_step * bd + da_h_byte;
		    	outb(ref.byte[1], addr);//DA H BYTE
				
				addr = base_addr + addr_step * bd + addr_div;
				ch_select = 0x02 << ((ch % 16) / 8);
				outb(ch_select, addr); //CH SELECT1(1-8,17-24 || 9-16,25-32)		
				addr = base_addr + addr_step * bd + dav_l + (ch%8);
	   	 		outb(ref.byte[0], addr);//CH SELECT2(CH ENABLE,DA L BYTE)
				
				addr = base_addr + addr_step * bd + addr_div;
				outb(0x00, addr);//CH SELECT CLOSE

				addr = base_addr + addr_step * bd + da_bd_en;
				outb(0x00, addr);//V SELECT CLOSE
				break;
			case L_10V_5A_R2:	
				bit = ch / 4;
				bd_enable = 0x01;
				bd_enable = bd_enable << bit;
				addr = base_addr + addr_step * bd + da_bd_en;
				outb(bd_enable, addr);

				addr = base_addr + addr_step * bd + da_h_byte;
		    	outb(ref.byte[1], addr);
				addr = base_addr + addr_step * bd + addr_div;
				outb(0x02, addr);
				addr = base_addr + addr_step * bd + dav_l + (ch%4);
	   	 		outb(ref.byte[0], addr);
				addr = base_addr + addr_step * bd + addr_div;
				outb(0x00, addr);
				break;
			case L_5V_20A:
				bd_enable = 0x01;
				bd_enable = bd_enable << bd;
				addr = base_addr + da_bd_en;
				outb(bd_enable, addr);
				addr = base_addr + da_h_byte;
	   		 	outb(ref.byte[1], addr);
				addr = base_addr + dav_l + ch;
   		 		outb(ref.byte[0], addr);
				break;
			case L_5V_500mA_2uA_R4:		//210526 lyhw
				if(range + 1 == RANGE4){
					if(ch >= 16) bd_enable = 0x10; 
					else	bd_enable = 0x04;

					bit = ch / 8;
					bd_enable = bd_enable << bit;
				}else{
					if(ch >= 16) bd_enable = 0x04; 
					else	bd_enable = 0x01;

					bit = ch / 8;
					bd_enable = bd_enable << bit;
				}
				
				addr = base_addr + addr_step * bd + da_bd_en;
				outb(~bd_enable, addr);
				addr = base_addr + addr_step * bd + da_h_byte;
		    	outb(ref.byte[1], addr);
				addr = base_addr + addr_step * bd + addr_div;
				outb(0x02, addr);
				addr = base_addr + addr_step * bd + dav_l + (ch % 8);
	   	 		outb(ref.byte[0], addr);
				addr = base_addr + addr_step * bd + addr_div;
				outb(0x00, addr);
				addr = base_addr + addr_step * bd + da_bd_en;
				outb(0xFF, addr);
				break;
			default:
				bit = ch / 8;
				bd_enable = 0x01;
				bd_enable = bd_enable << bit;
				addr = base_addr + da_bd_en;
				outb(bd_enable, addr);
				addr = base_addr + da_h_byte;
	   		 	outb(ref.byte[1], addr);
				addr = base_addr + dav_l + ch;
   		 		outb(ref.byte[0], addr);
				break;
		}
	}
}

long cCalCmdV_CAN(int bd, int ch, long value, int div, int range, int rtn)
{
    int point = 0;
    double tmp = 0;
	long rtn_val = 0;
	const int type = 0; //0: Voltage

	myCh = &(myData->bData[bd].cData[ch]);
	myCh->misc.preVref = value;
	
	if(myCh->op.state == C_CALI) {
		if(myData->CaliMeter.caliType == CALI_V) {
			if(myData->mData.cali_meas_type == MEAS) {
				div = 5;
			}
		} else {
			div = 15;
		}
	}
	if(div > 0 && div <= 10) {
		point = cFindDACaliPoint(bd, ch, value, type, range);
		if(myCh->op.state == C_CALI
			&& myData->mData.cali_meas_type != MEAS) {
			if(myData->CaliMeter.caliType == CALI_V) {
				tmp = (double)value * myData->cali.tmpData[bd][ch]
					.DA_A[type][range][point]
					+ myData->cali.tmpData[bd][ch].DA_B[type][range][point];
			} else {
				tmp = (double)value * myData->cali.data[bd][ch]
					.DA_A[type][range][point]
					+ myData->cali.data[bd][ch].DA_B[type][range][point];
			}
		} else {
			tmp = (double)value * myData->cali.data[bd][ch]
				.DA_A[type][range][point]
				+ myData->cali.data[bd][ch].DA_B[type][range][point];
		}
		rtn_val = (long)tmp;
	} else if(div > 10) {
		div -= 10;
		rtn_val = value;
	} else rtn_val = 0;

	if(rtn == 0) {
		if(rtn_val < 0) {
			rtn_val = 0;
		}
		bCan_Each_Ref_Cmd_Out(0, bd, ch, rtn_val);
		return 0;
	} else {
		return rtn_val;
	}
}

//20190605 KHK-----------------------------------------
void cCalCmdI(int bd, int ch, long value, int div, int range)
{
	if(myData->AppControl.config.systemType == CYCLER_CAN){
		cCalCmdI_CAN(bd, ch, value, div, range, 0);
	}else{
		cCalCmdI_Default(bd, ch, value, div, range);
	}
}
//-----------------------------------------------------



void cCalCmdI_Default(int bd, int ch, long value, int div, int range)
{
	unsigned char bd_enable;
    int point, bit=0, dir, ch_select, pointV=0;
	int addr, base_addr, addr_step, da_bd_en, da_h_byte, dai_l, addr_div;
	double tmp=0, shunt=0, digit, tmpV=0.0;
	U_ADDA ref;
	const int type = 1;

#if CYCLER_TYPE == DIGITAL_CYC
	return;	//180611 add
#endif
	myCh = &(myData->bData[bd].cData[ch]);

	if(myCh->op.type == STEP_USER_PATTERN){
		if(value > 0) { //charge
			if(myCh->misc.pattern_cross <= 0)
				myCh->misc.pattern_cross = 1;
		} else if(value < 0) { //discharge
			if(myCh->misc.pattern_cross >= 0)
				myCh->misc.pattern_cross = -1;
		}
	}

	myCh->misc.preIref = value;
	dir = value;

	if(div > 0 && div <= 10) {
		point = cFindDACaliPoint(bd, ch, value, type, range);
		if(myCh->op.state == C_CALI
			&& myData->mData.cali_meas_type != MEAS) {
			if(myData->CaliMeter.caliType == CALI_V) {
		 		tmp = (double)value
					* myData->cali.data[bd][ch].DA_A[type][range][point]
					+ myData->cali.data[bd][ch].DA_B[type][range][point];
			} else {
			 	tmp = (double)value
					* myData->cali.tmpData[bd][ch].DA_A[type][range][point]
					+ myData->cali.tmpData[bd][ch].DA_B[type][range][point];
			}
		} else {
			if(myData->mData.config.function[F_I_OFFSET_CALI] == P1) {
			 	tmp = (double)value
					* myData->cali.data[bd][ch].DA_A[type][range][point]
					+ myData->cali.data[bd][ch].DA_B[type][range][point];

				tmpV = myData->bData[bd].cData[ch].op.Vsens;
				pointV = cFindADCaliPoint(bd, ch, (long)tmpV, 3, 0);

//				tmpV += myData->cali.line_impedance * tmp; // 20160315 khk add

				tmp -= ((double)tmpV * myData->cali.data_caliMeter2[bd][ch]
					.AD_A[type][range][pointV]
					+ myData->cali.data_caliMeter2[bd][ch]
					.AD_B[type][range][pointV]);
			} else {
			 	tmp = (double)value
					* myData->cali.data[bd][ch].DA_A[type][range][point]
					+ myData->cali.data[bd][ch].DA_B[type][range][point];
			}
		}
	} else if(div > 10) {
		div -= 10;
		tmp = (double)value;
	} else tmp = 0;

	shunt = SelectShunt(range, value, tmp);
	digit = ConvertAmpRate(range, shunt, tmp, dir);

	if(div != 5 && div > 0) digit = digit / 5.0 * div;

	if(digit > 32767) digit = 32767;
	else if(digit < -32767) digit = -32767;
	
	if(myPs->config.DAC_type == DAC_7741) {
		ref.val = (short int)digit ^ 0x8000;
	} else {
		ref.val = (short int)digit;
	}
	
	base_addr = myPs->addr.main[BASE_ADDR];
	addr_step = myPs->addr.main[ADDR_STEP];
	da_bd_en = myPs->addr.main[DA_BD_ENABLE];
	addr_div = myPs->addr.main[ADDR_DIV];
	da_h_byte = myPs->addr.main[DA_H_BYTE];
	dai_l = myPs->addr.main[DAI_L];

	if(myPs->config.ADC_type == COMM_TYPE) {
		addr = base_addr + da_h_byte;
    	outb(ref.byte[1], addr);
		addr = base_addr + dai_l + ch;
   		outb(ref.byte[0], addr);
	} else {
		switch(myPs->config.hwSpec) {
			case L_5V_600A_10A: //Pack hardware
				bd_enable = 0x01 << ch;
				addr = base_addr + addr_step * bd + da_bd_en +1;
				outb(bd_enable, addr);
				addr = base_addr + addr_step * bd + da_h_byte;
		    	outb(ref.byte[1], addr);
				addr = base_addr + addr_step * bd + dai_l;
	   	 		outb(ref.byte[0], addr);
				usleep(5);
				break;
			case L_5V_30A:
				ch = myPs->config.chPerBd * bd + ch;
				addr = base_addr + da_h_byte;
		    	outb(ref.byte[1], addr);
				addr = base_addr + dai_l + ch;
   		 		outb(ref.byte[0], addr);
				break;
			case L_5V_10mA:
				bd_enable = 0x02;
				bd_enable = bd_enable << (bd * 2);
				addr = base_addr + da_bd_en;
				outb(bd_enable, addr);
				addr = base_addr + da_h_byte;
   		 		outb(ref.byte[1], addr);
				addr = base_addr + dai_l + ch;
   				outb(ref.byte[0], addr);
				break;
			case L_20V_25A:
			case L_5V_100A:
				bit = ch / 8;
				bd_enable = 0x01;
				bd_enable = bd_enable << bit;
				addr = base_addr + addr_step * bd + da_bd_en;
				outb(bd_enable, addr);

				addr = base_addr + addr_step * bd + da_h_byte;
   		 		outb(ref.byte[1], addr);
				addr = base_addr + addr_step * bd + addr_div;
				outb(0x08, addr);
				addr = base_addr + addr_step * bd + dai_l + (ch%8);
   				outb(ref.byte[0], addr);
				addr = base_addr + addr_step * bd + addr_div;
				outb(0x00, addr);
				break;
			case L_5V_200A_R2:
			case L_5V_30A_R1:
			case L_5V_100A_R1:
			case L_5V_100A_R1_EG:
			case L_5V_2A_R1:
			case L_5V_2A_R2:
			case L_5V_4A_R2:
			case L_5V_1A_R3:
			case L_5V_6A_R3:
			case L_5V_500mA_R2:
			case L_5V_10_30A_R2:
			case L_5V_5A_R2:
			case L_5V_1A_R2:
			case L_5V_500A_R1:
			case L_5V_500A_R2:
			case L_5V_200A_R4:
			case L_5V_200A_R3:
			case L_5V_400A_R3:
			case L_3V_200A_R2:
			case L_16V_200A_R2:
			case L_5V_250A_R2:
			case L_20V_300A_R2_1:
			case L_5V_220A_R2:
			case L_20V_110A_R2:
			case L_20V_50A_R2_1:
			case L_10V_50A_R2:
			case L_5V_100A_R2_1:
			case L_5V_150A_R1:
			case L_5V_150A_R3:
			case L_5V_250A_R1:
			case L_5V_50A_R1:
			case L_5V_1000A_R1:
			case L_5V_1000A_R3:
			case L_5V_300A_R1:
			case L_5V_300A_R3:
			case L_10V_500A_R2:
			case L_20V_10A_R1:
			case L_5V_120A_R3:
			case L_20V_300A_R2:
			case L_40V_300A_R2:
			case L_30V_40A_R2:
			case L_30V_40A_R2_OT_20:
			case L_30V_40A_R2_P_AD2:
		    case L_20V_5A_R1:
			case L_20V_50A_R2:
			case L_5V_50A_R2:
			case L_5V_65A_R3:
			case L_6V_60A_R2_P:
			case L_5V_50A_R2_P:
			case L_5V_50A_R2_1:
			case L_5V_20A_R3:
			case L_5V_10A_R3:
			case L_6V_60A_R2:
			case L_5V_150A_R3_AD2:
			case L_8CH_MAIN_AD2_P:
			case L_5V_30A_R3_HYUNDAI:
			case L_30V_20A_R1_AD2:
			case L_5V_200A_R3_P_AD2:
			case L_5V_200A_1CH_JIG:
			case L_5V_150A_R2_P:
			case L_5V_200A_R3_P:
			case L_5V_60A_R2_1:
			case L_30V_5A_R1_AD2:
			case L_60V_100A_R1_AD2:	//LS Mtron
			case L_15V_100A_R3_AD2:
			case S_5V_200A_75A_15A_AD2:
			case L_MAIN_REV11:
			case L_5V_20A_R3_NEW:
			case L_5V_500A_R3_1:
			case L_20V_6A_R3: 	//210813 ljsw LGES 20V6A
				bit = ch / 8;
				bd_enable = 0x01;
				bd_enable = bd_enable << bit;
				addr = base_addr + addr_step * bd + da_bd_en;
				if(myPs->config.MainBdType == CPLD_TYPE) {
					outb(bd_enable, addr);
				} else if(myPs->config.MainBdType == FPGA_TYPE) {
					outb(~bd_enable, addr);
				}

				addr = base_addr + addr_step * bd + da_h_byte;
   		 		outb(ref.byte[1], addr);
				addr = base_addr + addr_step * bd + addr_div;
				outb(0x04, addr);
				addr = base_addr + addr_step * bd + dai_l + (ch % 8);
   				outb(ref.byte[0], addr);
				addr = base_addr + addr_step * bd + addr_div;
				outb(0x00, addr);
				addr = base_addr + addr_step * bd + da_bd_en;
				if(myPs->config.MainBdType == CPLD_TYPE) {
					outb(0x00, addr);
				} else if(myPs->config.MainBdType == FPGA_TYPE) {
					outb(0xFF, addr);
				}
				break;
			case L_5V_10A_R3_NEW:
				bit = (ch / 8) * 2;
				bd_enable = 0x01;
				bd_enable = bd_enable << bit;
				addr = base_addr + addr_step * bd + da_bd_en;
	
				if(myPs->config.MainBdType == CPLD_TYPE) 
					outb(bd_enable, addr);
				else if(myPs->config.MainBdType == FPGA_TYPE)
					outb(~bd_enable, addr);

				addr = base_addr + addr_step * bd + da_h_byte;
   		 		outb(ref.byte[1], addr);
				addr = base_addr + addr_step * bd + addr_div;
				outb(0x04, addr);
				addr = base_addr + addr_step * bd + dai_l + (ch%8);
   				outb(ref.byte[0], addr);
				addr = base_addr + addr_step * bd + addr_div;
				outb(0x00, addr);
				addr = base_addr + addr_step * bd + da_bd_en;
				if(myPs->config.MainBdType == CPLD_TYPE) 
					outb(0x00, addr);
				else if(myPs->config.MainBdType == FPGA_TYPE)
					outb(0xff, addr);
				break;
			case L_MULTI:
				//da bd enable			0x624
				bd_enable = 0x01;
				addr = base_addr + da_bd_en;
				outb(bd_enable, addr);
				//high byte				0x623
				addr = base_addr + da_h_byte;
				outb(ref.byte[1], addr);
				//low byte				0x634 ~ 637(1ch ~ 4ch)
				addr = base_addr + addr_step + dai_l + (ch%8 );
				outb(ref.byte[0], addr);
				//da bd disable			0x624
				bd_enable = 0x00;
				addr = base_addr + da_bd_en;
				outb(bd_enable, addr);
				break;											//end of add
			case L_5V_100mA_R2:
				bit = ch / 16;
				bd_enable =0x02;
				bd_enable = bd_enable << (2 * bit);
				addr = base_addr + addr_step * bd + da_bd_en;
				outb(bd_enable, addr);//I SELECT

				addr = base_addr + addr_step * bd + da_h_byte;
		    	outb(ref.byte[1], addr);//DA H BYTE
				
				addr = base_addr + addr_step * bd + addr_div;
				ch_select = 0x02 << ((ch % 16) / 8);
				outb(ch_select, addr); //CH SELECT1(1-8,17-24 || 9-16,25-32)		
				addr = base_addr + addr_step * bd + dai_l + (ch%8);
	   	 		outb(ref.byte[0], addr);//CH SELECT2(CH ENABLE,DA L BYTE)
				
				addr = base_addr + addr_step * bd + addr_div;
				outb(0x00, addr);//CH SELECT CLOSE

				addr = base_addr + addr_step * bd + da_bd_en;
				outb(0x00, addr);//I SELECT CLOSE
				break;
			case L_10V_5A_R2:
				bit = ch / 4;
				bd_enable = 0x01;
				bd_enable = bd_enable << bit;
				addr = base_addr + addr_step * bd + da_bd_en;
				outb(bd_enable, addr);

				addr = base_addr + addr_step * bd + da_h_byte;
   		 		outb(ref.byte[1], addr);
				addr = base_addr + addr_step * bd + addr_div;
				outb(0x04, addr);
				addr = base_addr + addr_step * bd + dai_l + (ch%4);
   				outb(ref.byte[0], addr);
				addr = base_addr + addr_step * bd + addr_div;
				outb(0x00, addr);
				break;
			case L_5V_20A:
				bd_enable = 0x01;
				bd_enable = bd_enable << bd;
				addr = base_addr + da_bd_en;
				outb(bd_enable, addr);
				addr = base_addr + da_h_byte;
   	 			outb(ref.byte[1], addr);
				addr = base_addr + dai_l + ch;
   				outb(ref.byte[0], addr);
				break;
			case L_5V_500mA_2uA_R4:			//210526 lyhw
				if(range + 1 == RANGE4){
					if(ch >= 16) bd_enable = 0x10; 
					else	bd_enable = 0x04;

					bit = ch / 8;
					bd_enable = bd_enable << bit;
				}else{
					if(ch >= 16) bd_enable = 0x04; 
					else	bd_enable = 0x01;

					bit = ch / 8;
					bd_enable = bd_enable << bit;
				}
				
				addr = base_addr + addr_step * bd + da_bd_en;
				outb(~bd_enable, addr);
				addr = base_addr + addr_step * bd + da_h_byte;
   		 		outb(ref.byte[1], addr);
				addr = base_addr + addr_step * bd + addr_div;
				outb(0x04, addr);
				addr = base_addr + addr_step * bd + dai_l + (ch % 8);
   				outb(ref.byte[0], addr);
				addr = base_addr + addr_step * bd + addr_div;
				outb(0x00, addr);
				addr = base_addr + addr_step * bd + da_bd_en;
				outb(0xFF, addr);
				break;
			default:
				bit = ch / 8;
				bd_enable = 0x01;
				bd_enable = bd_enable << bit;
				addr = base_addr + da_bd_en;
				outb(bd_enable, addr);
				addr = base_addr + da_h_byte;
   	 			outb(ref.byte[1], addr);
				addr = base_addr + dai_l + ch;
   				outb(ref.byte[0], addr);
				break;
		}
	}
}

void cCalCmdI_p(int bd, int ch, long value, int div, int range)
{ //kjg_180521
	unsigned char bd_enable;
    int point, bit=0, dir, ch_select;
	int addr, base_addr, addr_step, da_bd_en, da_h_byte, dai_l, addr_div;
	double tmp=0, shunt=0, digit;
	U_ADDA ref;
	const int type = 1;
	
#if CYCLER_TYPE == DIGITAL_CYC
	return;	//180611 add
#endif
	//kjg_180521 myData->bData[bd].cData[ch].misc.preIref = value;
	dir = value;

	if(div > 0 && div <= 10) {
		point = cFindDACaliPoint_p(bd, ch, value, type, range);
	 	tmp = (double)value
			* myData->cali.data[bd][ch].DA_A[type][range][point]
			+ myData->cali.data[bd][ch].DA_B[type][range][point];
	} else if(div > 10) {
		div -=10;
		tmp = (double)value;
	} else tmp = 0;

	shunt = SelectShunt(range, value, tmp);
	digit = ConvertAmpRate(range, shunt, tmp, dir);

	if(div != 5 && div > 0) digit = digit / 5.0 * div;

	if(digit > 32767) digit = 32767;
	else if(digit < -32767) digit = -32767;
	
	if(myPs->config.DAC_type == DAC_7741) {
		ref.val = (short int)digit ^ 0x8000;
	} else {
		ref.val = (short int)digit;
	}
	
	base_addr = myPs->addr.main[BASE_ADDR];
	addr_step = myPs->addr.main[ADDR_STEP];
	da_bd_en = myPs->addr.main[DA_BD_ENABLE];
	addr_div = myPs->addr.main[ADDR_DIV];
	da_h_byte = myPs->addr.main[DA_H_BYTE];
	dai_l = myPs->addr.main[DAI_L];

	if(myPs->config.ADC_type == COMM_TYPE) {
		addr = base_addr + da_h_byte;
    	outb(ref.byte[1], addr);
		addr = base_addr + dai_l + ch;
   		outb(ref.byte[0], addr);
	} else {
		switch(myPs->config.hwSpec) {
			case L_5V_600A_10A: //Pack hardware
				bd_enable = 0x01 << ch;
				addr = base_addr + addr_step * bd + da_bd_en +1;
				outb(bd_enable, addr);
				addr = base_addr + addr_step * bd + da_h_byte;
		    	outb(ref.byte[1], addr);
				addr = base_addr + addr_step * bd + dai_l;
	   	 		outb(ref.byte[0], addr);
				usleep(5);
				break;
			case L_5V_30A:
				ch = myPs->config.chPerBd * bd + ch;
				addr = base_addr + da_h_byte;
		    	outb(ref.byte[1], addr);
				addr = base_addr + dai_l + ch;
   		 		outb(ref.byte[0], addr);
				break;
			case L_5V_10mA:
				bd_enable = 0x02;
				bd_enable = bd_enable << (bd * 2);
				addr = base_addr + da_bd_en;
				outb(bd_enable, addr);
				addr = base_addr + da_h_byte;
   		 		outb(ref.byte[1], addr);
				addr = base_addr + dai_l + ch;
   				outb(ref.byte[0], addr);
				break;
			case L_20V_25A:
			case L_5V_100A:
				bit = ch / 8;
				bd_enable = 0x01;
				bd_enable = bd_enable << bit;
				addr = base_addr + addr_step * bd + da_bd_en;
				outb(bd_enable, addr);

				addr = base_addr + addr_step * bd + da_h_byte;
   		 		outb(ref.byte[1], addr);
				addr = base_addr + addr_step * bd + addr_div;
				outb(0x08, addr);
				addr = base_addr + addr_step * bd + dai_l + (ch%8);
   				outb(ref.byte[0], addr);
				addr = base_addr + addr_step * bd + addr_div;
				outb(0x00, addr);
				break;
			case L_5V_200A_R2:
			case L_5V_30A_R1:
			case L_5V_100A_R1:
			case L_5V_100A_R1_EG:
			case L_5V_2A_R1:
			case L_5V_2A_R2:
			case L_5V_4A_R2:
			case L_5V_1A_R3:
			case L_5V_6A_R3:
			case L_5V_500mA_R2:
			case L_5V_10_30A_R2:
			case L_5V_5A_R2:
			case L_5V_1A_R2:
			case L_5V_500A_R1:
			case L_5V_500A_R2:
			case L_5V_200A_R4:
			case L_5V_200A_R3:
			case L_5V_400A_R3:
			case L_3V_200A_R2:
			case L_16V_200A_R2:
			case L_5V_250A_R2:
			case L_20V_300A_R2_1:
			case L_5V_220A_R2:
			case L_20V_110A_R2:
			case L_20V_50A_R2_1:
			case L_10V_50A_R2:
			case L_5V_100A_R2_1:
			case L_5V_150A_R1:
			case L_5V_150A_R3:
			case L_5V_250A_R1:
			case L_5V_50A_R1:
			case L_5V_1000A_R1:
			case L_5V_1000A_R3:
			case L_5V_300A_R1:
			case L_5V_300A_R3:
			case L_10V_500A_R2:
			case L_20V_10A_R1:
			case L_5V_120A_R3:
			case L_20V_300A_R2:
			case L_40V_300A_R2:
			case L_30V_40A_R2:
			case L_30V_40A_R2_OT_20:
			case L_30V_40A_R2_P_AD2:
		    case L_20V_5A_R1:
			case L_20V_50A_R2:
			case L_5V_50A_R2:
			case L_5V_65A_R3:
			case L_6V_60A_R2_P:
			case L_5V_50A_R2_P:
			case L_5V_50A_R2_1:
			case L_5V_20A_R3:
			case L_5V_10A_R3:
			case L_6V_60A_R2:
			case L_5V_150A_R3_AD2:
			case L_8CH_MAIN_AD2_P:
			case L_5V_30A_R3_HYUNDAI:
			case L_30V_20A_R1_AD2:
			case L_5V_200A_R3_P_AD2:
			case L_5V_200A_1CH_JIG:
			case L_5V_150A_R2_P:
			case L_5V_200A_R3_P:
			case L_5V_60A_R2_1:
			case L_30V_5A_R1_AD2:
			case L_60V_100A_R1_AD2:	//LS Mtron
			case L_15V_100A_R3_AD2:
			case S_5V_200A_75A_15A_AD2:
			case L_MAIN_REV11:
			case L_5V_20A_R3_NEW:
			case L_5V_500A_R3_1:
			case L_20V_6A_R3: 	//210813 ljsw LGES 20V6A
				bit = ch / 8;
				bd_enable = 0x01;
				bd_enable = bd_enable << bit;
				addr = base_addr + addr_step * bd + da_bd_en;
				if(myPs->config.MainBdType == CPLD_TYPE) {
					outb(bd_enable, addr);
				} else if(myPs->config.MainBdType == FPGA_TYPE) {
					outb(~bd_enable, addr);
				}

				addr = base_addr + addr_step * bd + da_h_byte;
   		 		outb(ref.byte[1], addr);
				addr = base_addr + addr_step * bd + addr_div;
				outb(0x04, addr);
				addr = base_addr + addr_step * bd + dai_l + (ch % 8);
   				outb(ref.byte[0], addr);
				addr = base_addr + addr_step * bd + addr_div;
				outb(0x00, addr);
				addr = base_addr + addr_step * bd + da_bd_en;
				if(myPs->config.MainBdType == CPLD_TYPE) {
					outb(0x00, addr);
				} else if(myPs->config.MainBdType == FPGA_TYPE) {
					outb(0xFF, addr);
				}
				break;
			case L_5V_10A_R3_NEW:
				bit = (ch / 8) * 2;
				bd_enable = 0x01;
				bd_enable = bd_enable << bit;
				addr = base_addr + addr_step * bd + da_bd_en;
	
				if(myPs->config.MainBdType == CPLD_TYPE) 
					outb(bd_enable, addr);
				else if(myPs->config.MainBdType == FPGA_TYPE)
					outb(~bd_enable, addr);

				addr = base_addr + addr_step * bd + da_h_byte;
   		 		outb(ref.byte[1], addr);
				addr = base_addr + addr_step * bd + addr_div;
				outb(0x04, addr);
				addr = base_addr + addr_step * bd + dai_l + (ch%8);
   				outb(ref.byte[0], addr);
				addr = base_addr + addr_step * bd + addr_div;
				outb(0x00, addr);
				addr = base_addr + addr_step * bd + da_bd_en;
				if(myPs->config.MainBdType == CPLD_TYPE) 
					outb(0x00, addr);
				else if(myPs->config.MainBdType == FPGA_TYPE)
					outb(0xff, addr);
				break;
			case L_MULTI:
				//da bd enable			0x624
				bd_enable = 0x01;
				addr = base_addr + da_bd_en;
				outb(bd_enable, addr);
				//high byte				0x623
				addr = base_addr + da_h_byte;
				outb(ref.byte[1], addr);
				//low byte				0x634 ~ 637(1ch ~ 4ch)
				addr = base_addr + addr_step + dai_l + (ch%8 );
				outb(ref.byte[0], addr);
				//da bd disable			0x624
				bd_enable = 0x00;
				addr = base_addr + da_bd_en;
				outb(bd_enable, addr);
				break;											//end of add
			case L_5V_100mA_R2:
				bit = ch / 16;
				bd_enable =0x02;
				bd_enable = bd_enable << (2 * bit);
				addr = base_addr + addr_step * bd + da_bd_en;
				outb(bd_enable, addr);//I SELECT

				addr = base_addr + addr_step * bd + da_h_byte;
		    	outb(ref.byte[1], addr);//DA H BYTE
				
				addr = base_addr + addr_step * bd + addr_div;
				ch_select = 0x02 << ((ch % 16) / 8);
				outb(ch_select, addr); //CH SELECT1(1-8,17-24 || 9-16,25-32)		
				addr = base_addr + addr_step * bd + dai_l + (ch%8);
	   	 		outb(ref.byte[0], addr);//CH SELECT2(CH ENABLE,DA L BYTE)
				
				addr = base_addr + addr_step * bd + addr_div;
				outb(0x00, addr);//CH SELECT CLOSE

				addr = base_addr + addr_step * bd + da_bd_en;
				outb(0x00, addr);//I SELECT CLOSE
				break;
			case L_10V_5A_R2:
				bit = ch / 4;
				bd_enable = 0x01;
				bd_enable = bd_enable << bit;
				addr = base_addr + addr_step * bd + da_bd_en;
				outb(bd_enable, addr);

				addr = base_addr + addr_step * bd + da_h_byte;
   		 		outb(ref.byte[1], addr);
				addr = base_addr + addr_step * bd + addr_div;
				outb(0x04, addr);
				addr = base_addr + addr_step * bd + dai_l + (ch%4);
   				outb(ref.byte[0], addr);
				addr = base_addr + addr_step * bd + addr_div;
				outb(0x00, addr);
				break;
			case L_5V_20A:
				bd_enable = 0x01;
				bd_enable = bd_enable << bd;
				addr = base_addr + da_bd_en;
				outb(bd_enable, addr);
				addr = base_addr + da_h_byte;
   	 			outb(ref.byte[1], addr);
				addr = base_addr + dai_l + ch;
   				outb(ref.byte[0], addr);
				break;
			case L_5V_500mA_2uA_R4:		//210526 lyhw
				if(range + 1 == RANGE4){
					if(ch >= 16) bd_enable = 0x10; 
					else	bd_enable = 0x04;

					bit = ch / 8;
					bd_enable = bd_enable << bit;
				}else{
					if(ch >= 16) bd_enable = 0x04; 
					else	bd_enable = 0x01;

					bit = ch / 8;
					bd_enable = bd_enable << bit;
				}

				addr = base_addr + addr_step * bd + da_bd_en;
				outb(~bd_enable, addr);
				addr = base_addr + addr_step * bd + da_h_byte;
   		 		outb(ref.byte[1], addr);
				addr = base_addr + addr_step * bd + addr_div;
				outb(0x04, addr);
				addr = base_addr + addr_step * bd + dai_l + (ch % 8);
   				outb(ref.byte[0], addr);
				addr = base_addr + addr_step * bd + addr_div;
				outb(0x00, addr);
				addr = base_addr + addr_step * bd + da_bd_en;
				outb(0xFF, addr);
				break;
			default:
				bit = ch / 8;
				bd_enable = 0x01;
				bd_enable = bd_enable << bit;
				addr = base_addr + da_bd_en;
				outb(bd_enable, addr);
				addr = base_addr + da_h_byte;
   	 			outb(ref.byte[1], addr);
				addr = base_addr + dai_l + ch;
   				outb(ref.byte[0], addr);
				break;
		}
	}
}

long cCalCmdI_CAN(int bd, int ch, long value, int div, int range, int rtn)
{
    int point, pointV = 0;
	double tmp = 0, tmpV = 0.0;
	long rtn_val = 0;
	const int type = 1; //1: Current

	myCh = &(myData->bData[bd].cData[ch]);
	myCh->misc.preIref = value;

	if(myCh->op.state == C_CALI) {
		if(myData->CaliMeter.caliType == CALI_V) {
		 	div = 15;
			value = value / 2;
		} else {
			if(myData->mData.cali_meas_type == MEAS) {
		 		div = 5;
			}
		}
	}

	if(div > 0 && div <= 10) {
		point = cFindDACaliPoint(bd, ch, value, type, range);
		if(myCh->op.state == C_CALI
			&& myData->mData.cali_meas_type != MEAS) {
			if(myData->CaliMeter.caliType == CALI_V) {
		 		tmp = (double)value
					* myData->cali.data[bd][ch].DA_A[type][range][point]
					+ myData->cali.data[bd][ch].DA_B[type][range][point];
			} else {
			 	tmp = (double)value
					* myData->cali.tmpData[bd][ch].DA_A[type][range][point]
					+ myData->cali.tmpData[bd][ch].DA_B[type][range][point];
			}
		} else {
			if(myData->mData.config.function[F_I_OFFSET_CALI] == P1) {
			 	tmp = (double)value
					* myData->cali.data[bd][ch].DA_A[type][range][point]
					+ myData->cali.data[bd][ch].DA_B[type][range][point];

				tmpV = myData->bData[bd].cData[ch].op.Vsens;
				pointV = cFindADCaliPoint(bd, ch, (long)tmpV, 3, 0);

//				tmpV += myData->cali.line_impedance * tmp; // 20160315 khk add

				tmp -= ((double)tmpV * myData->cali.data_caliMeter2[bd][ch]
					.AD_A[type][range][pointV]
					+ myData->cali.data_caliMeter2[bd][ch]
					.AD_B[type][range][pointV]);
			} else {
			 	tmp = (double)value
					* myData->cali.data[bd][ch].DA_A[type][range][point]
					+ myData->cali.data[bd][ch].DA_B[type][range][point];
			}
		}
		rtn_val = (long)tmp;
	} else if(div > 10) {
		div -= 10;
		rtn_val = value;
	} else rtn_val = 0;
		
	if(rtn == 0) {
		bCan_Each_Ref_Cmd_Out(1, bd, ch, rtn_val);
		return 0;
	} else {
		return rtn_val;
	}
}

double SelectShunt(int rangeI, long value, double ref){
	double shunt = 0;
	switch(myPs->config.hwSpec) {
		case L_5V_150A_R1:
			if((rangeI + 1) == RANGE1)
				shunt = 0.001;
			break;
		case L_10V_5A_R2:
			if((rangeI + 1) == RANGE1)
				shunt = 0.1/5.0;
			else if((rangeI + 1) == RANGE2)
				shunt = 0.2;
			break;
		case L_5V_600A_10A:
			if((rangeI + 1) == RANGE1)
				shunt = 0.1/600.0;
			else if((rangeI + 1) == RANGE2)
				shunt = 0.01;
			break;
		default:
			shunt = (double)myPs->config.shunt[rangeI];
			break;
	}
	return shunt;
}

double ConvertAmpRate(int rangeI, double shunt, double value,int dir)
{
	double gain, amp;
	switch(myPs->config.hwSpec) {
		case L_5V_150A_R1:
			amp = value * shunt
				* (90000.0/91500.0) / (1500.0/91500.0);
			break;
		case L_10V_5A_R2:
			amp = value * shunt
				* (1.0+50.0/1.0);
			break;
		case S_5V_200A_75A_15A_AD2:
			/*if(value < 0.0) {
				if(rangeI == 0) {
					amp = value * (-0.024375) + 1724635.858;
				} else if(rangeI == 1) {
					amp = value * (-0.065) + 1724635.858;
				} else {
					amp = value * (-0.325) + 1724635.858;
				}
			} else {
				if(rangeI == 0) {
					amp = value * 0.02970297 + 990099.008;
				} else if(rangeI == 1) {
					amp = value * 0.079207921 + 990099.008;
				} else {
					amp = value * 0.396039604 + 990099.008;
				}
			}*/
			/*if(value < 0.0) {
				if(rangeI == 0) {
					amp = value * (-0.02582365) + 770833.3333;
				} else if(rangeI == 1) {
					amp = value * (-0.06143611) + 770833.3333;
				} else {
					amp = value * (-0.33499256) + 770833.3333;
				}
			} else {
				if(rangeI == 0) {
					amp = value * 0.022105496 + 416666.6667;
				} else if(rangeI == 1) {
					amp = value * 0.051666667 + 416666.6667;
				} else {
					amp = value * 0.2856 + 416666.6667;
				}
			}*/
			//if(value < 0.0) {
			//120126 kji switching cali offset 
			if(dir < 0.0) {
				if(rangeI == 0) {
					//amp = value * (-0.02452562) + 770833.3333;
					amp = value * (-0.02452562);
				} else if(rangeI == 1) {
					//amp = value * (-0.06508497) + 770833.3333;
					amp = value * (-0.06508497);
				} else {
					//amp = value * (-0.34081974) + 770833.3333;
					amp = value * (-0.34081974);
				}
				amp *= 0.86; //maybe leakage current
				amp += 770833.3333;
			} else {
				if(rangeI == 0) {
					//amp = value * 0.020832916 + 416666.6667;
					amp = value * 0.020832916;
				} else if(rangeI == 1) {
					//amp = value * 0.055243984 + 416666.6667;
					amp = value * 0.055243984;
				} else {
					//amp = value * 0.291312925 + 416666.6667;
					amp = value * 0.291312925;
				}
				amp += 416666.6667;
			}
			break;
		default:
			gain = (double)myPs->config.gain[rangeI];
			amp = value * shunt * gain;
			break;
	}
	if(myPs->config.ratioCurrent == MICRO) { //uA
		switch(myPs->config.hwSpec) {
			case L_5V_600A_10A: //Pack Hardware
				//AMP -> INA128UA
				//G = (50k / 18k) + 1 = 3.777777778
				//V1 = 2.5V * G = 9444444.445uV
				//1LSB = V1 / 32768 = 288.2215712uV
				//V1 * x = 32768 -> x = 0.003469552941
				amp *= 0.003469552941;
				break;
			default:
				amp *=  0.0032767;
				break;
		}
	} else { //nA
		amp *=  0.0000032767;
	}
	return amp;
}

/*
double SelectShunt(int range, long value, double ref){
	double shunt=0;
	if((range + 1) == RANGE1) {
		switch(myPs->config.hwSpec) {
			case L_5V_10mA:
				shunt = 10.0;
				break;
			case L_5V_2A:
			case L_5V_3A:
			case L_5V_2A_R1:
			case L_5V_2A_R2:
				shunt = 0.05;
				break;
			case L_5V_5A:
			case L_6V_6A:
			case L_5V_5A_2:
				shunt = 0.022;
				break;
			case L_5V_20A:
				shunt = 0.01;
				break;
			case L_5V_30A:
			case L_5V_200A_R4:
			case L_5V_200A_R3:
				shunt = 0.1/200.0;
				break;
			case L_5V_100A_R2_1:
				shunt = 0.1/100.0;
				break;
			case L_5V_30A_R1:
				shunt = 0.0033;
				break;
			case L_5V_200A_R2:
			case L_5V_200A:
			case L_2V_100A:
			case L_5V_100A_R1:
			case L_5V_100A_R1_EG:
			case L_5V_100A_R2:
			case L_5V_150A_R1:
				shunt = 0.001;
				break;
			case L_5V_150A_R3:
				shunt = 0.1/150.0;
				break;
			case L_5V_50A:
			case L_50V_50A:
			case L_5V_50A_R1:
			case L_20V_50A_R2:
			case L_5V_50A_R2:
			case L_5V_50A_R2_1:
				shunt = 0.002;
				break;
			case L_20V_25A:
				shunt = 0.0068;
				break;
			case L_5V_250A_R1:
				shunt = 0.0004;
				break;
			case L_5V_100A:
				shunt = (0.1/300.0)*(1.0 + 49.4/25.0); //0.1V/300A*(op-amp)
				break;
			case L_5V_500A_R1:
			case L_5V_500A_R2:
				shunt = 0.1/500.0;
				break;
			case L_5V_1000A_R1:
			case L_5V_1000A_R3:
				shunt = 0.1/1000.0; //0.1V/1000A
				break;
			case L_5V_300A_R1:
				shunt = 0.000333;
				break;
			case L_5V_300A_R3:
				shunt = 0.1/300.0;
				break;
			case S_5V_200A:
				if(value >= 0) {
					shunt = (ref * 0.03901950975 + 936098.049);
				} else {
					shunt = (ref * -0.03216608304 + 1666783.392);
				}
				break;
			case L_20V_10A_R1:
				shunt = 0.01;
				break;
			case L_10V_5A_R2:
				shunt = 0.1/5.0;
				break;
			default: 
				shunt = 0;
				break;
		}
	} else if((range+1) == RANGE2) {
		switch(myPs->config.hwSpec) {
			case L_5V_10mA:
				shunt = 100.0;
				break;
			case L_5V_2A:
			case L_5V_3A:
				shunt = 0.1;
				break;
			case L_6V_6A:
				shunt = 0.05;
				break;
			case L_5V_5A_2:
				shunt = 2.0;
				break;
			case L_5V_20A:
				shunt = 0.033;
				break;
			case L_5V_200A_R4:
				shunt = 0.001;
				break;
			case L_5V_200A_R2:
			case L_5V_200A:
			case L_2V_100A:
			case L_5V_50A:
			case L_5V_100A_R2:
			case L_20V_50A_R2:
				shunt = 0.01;
				break;
			case L_20V_25A:
				shunt = 0.068;
				break;
			case S_5V_200A:
				if(value >= 0) {
					shunt = (ref * 0.39019509755 + 936098.049);
				} else {
					shunt = (ref * -0.32166083042 + 1666783.392);
				}
				break;
			case L_5V_50A_R2:
				shunt = 0.02;
				break;
			case L_5V_50A_R2_1:
				shunt = 0.005;
				break;
			case L_5V_500A_R2:
			case L_5V_200A_R3:
			case L_5V_150A_R3:
			case L_5V_300A_R3:
				shunt = 0.1/50.0;
				break;
			case L_5V_100A_R2_1:
				shunt = 0.1 / 10.0;
				break;
			case L_5V_2A_R2:
			case L_10V_5A_R2:
				shunt = 0.2;
				break;
			case L_5V_1000A_R3:
				shunt = 0.1/500.0;
				break;						
			default: 
				shunt = 0;
				break;
		}
	} else if((range+1) == RANGE3) {
		switch(myPs->config.hwSpec) {
			case L_5V_2A:
			case L_5V_3A:
				shunt = 0.2;
				break;
			case L_6V_6A:
			case L_2V_100A:
			case L_5V_50A:
				shunt = 0.1;
				break;
			case L_5V_200A:
				shunt = 0.05;
				break;
			case L_5V_200A_R4:
				shunt = 0.002;
				break;
			case L_5V_200A_R3:
			case L_5V_150A_R3:
			case L_5V_300A_R3:
				shunt = 0.1/10.0;
				break;
			case L_5V_1000A_R3:
				shunt = 0.1/100.0;
				break;
			default: 
				shunt = 0;
				break;
		}
	} else { //range4
		switch(myPs->config.hwSpec) {
			case L_5V_2A:
			case L_5V_3A:
				shunt = 0.2;
				break;
			case L_6V_6A:
			case L_2V_100A:
			case L_5V_50A:
				shunt = 0.1;
				break;
			case L_5V_200A:
				shunt = 0.05;
				break;
			case L_5V_200A_R4:
				shunt = 0.01;
				break;
			default: 
				shunt = 0;
				break;
		}
	}
	return shunt;
}

double ConvertAmpRate(int rangeI, double shunt, double value)
{
	double amp = 0;
	switch(myPs->config.hwSpec) {
		case L_5V_10mA:
			amp = value * shunt
				* (100000.0/101100.0) / (1100.0/101100.0);
			break;
		case L_5V_2A:
		case L_5V_3A:
		case L_5V_5A:
		case L_6V_6A:
		case L_5V_5A_2:
			amp = value * shunt
				* (100000.0/102200.0) / (2200.0/102200.0);
			break;
		case L_5V_30A:
			amp = value * shunt
				* (100000.0/101880.0) / (1880.0/101880.0);
			break;
		case L_5V_200A:
			amp = value * shunt
				* (10000.0/10221.0) / (221.0/10221.0);
			break;
		case L_2V_100A:
		case L_5V_50A:
		case L_5V_100A_R2:
		case L_5V_30A_R1:
		case L_5V_100A:
		case L_5V_100A_R1:
		case L_5V_100A_R1_EG:
		case L_5V_500A_R1:
		case L_5V_500A_R2:
		case L_5V_200A_R4:
		case L_5V_200A_R3:
		case L_5V_100A_R2_1:
		case L_5V_150A_R3:
		case L_5V_250A_R1:
		case L_5V_50A_R1:
		case L_5V_300A_R1:
		case L_5V_300A_R3:
		case L_5V_1000A_R3:
		case L_20V_10A_R1:
		case L_20V_50A_R2:
		case L_5V_50A_R2:
		case L_5V_50A_R2_1:
			amp = value * shunt
				* (100000.0/101250.0) / (1250.0/101250.0);
			break;
		case L_50V_50A:
			amp = value * shunt
				* (90000.0/91000.0) / (1000.0/91000.0);
			break;
		case L_5V_150A_R1:
			amp = value * shunt
				* (90000.0/91500.0) / (1500.0/91500.0);
			break;
		case L_20V_25A:
		case L_5V_2A_R1:
		case L_5V_2A_R2:
			amp = value * shunt
				* (100000.0/102000.0) / (2000.0/102000.0);
			break;
		case L_10V_5A_R2:
			amp = value * shunt
				* (1.0+50.0/1.0);
			break;
		case L_5V_20A:
		case L_5V_200A_R2:
			amp = value * shunt
				* ((100000.0/102500.0) / (2500.0/102500.0));
			break;
		case L_5V_1000A_R1:
			amp = value * shunt * (1+49.4/0.83);
			break;
		case S_5V_200A:
			amp = shunt;
			break;
		default:
			amp = 0;
			break;
	}
	if(myPs->config.ratioCurrent == MICRO) { //uA
		amp *=  0.0032767;
	} else { //nA
		amp *=  0.0000032767;
	}
	return amp;
}
*/

void cCalCmdLimitV(int bd, int ch, long value, int div)
{
	unsigned char bd_enable;
    int type;
	int	addr, base_addr, da_h_byte, dav_l, da_bd_en;
    double tmp=0;
	U_ADDA ref;

	if(myPs->config.hwSpec != S_5V_200A) return;

	type = 0;
	
	if(div == 0) { //charge
		tmp = (double)value + 2500000.0;
	} else { //discharge
		tmp = (double)value + 2500000.0 - 100000.0;
	}
	tmp *= 0.0032767;
	ref.val = (short int)tmp;

	base_addr = myPs->addr.main[BASE_ADDR];
	da_bd_en = myPs->addr.main[DA_BD_ENABLE];
	da_h_byte = myPs->addr.main[DA_H_BYTE];
	dav_l = myPs->addr.main[DAV_L];
	if(myPs->config.ADC_type == COMM_TYPE) {
		addr = base_addr + da_h_byte;
    	outb(ref.byte[1], addr);
		addr = base_addr + dav_l + ch;
    	outb(ref.byte[0], addr);
	} else {
		bd_enable = 0x01;
		bd_enable = bd_enable << bd;
		addr = base_addr + da_bd_en;
		outb(bd_enable, addr);
		addr = base_addr + da_h_byte;
    	outb(ref.byte[1], addr);
		addr = base_addr + dav_l + ch;
    	outb(ref.byte[0], addr);
	}
}

int cFailCodeCheck(int bd, int ch)
{
	int rtn = 0;
	myCh = &(myData->bData[bd].cData[ch]);
	
	if(myData->mData.config.parallelMode == P1){
		if(myCh->ChAttribute.opType == P1){ //Master Ch
			 cFailCodeCheck_parallel_master(bd, ch); 
		}else if(myCh->ChAttribute.chNo_master == P0){ //Slave Ch
			 cFailCodeCheck_parallel_slave(bd, ch); 
		}		
	}
	//hard_fault, external_fault
	if(myCh->signal[C_SIG_SMPS_FAULT] == P1) {
		myCh->signal[C_SIG_SMPS_FAULT] = P0;
		myCh->misc.tmpCode = myCh->op.code;
		myCh->op.code = C_FAULT_SMPS;
		rtn = 1;
	} else if(myCh->signal[C_SIG_OT_FAULT] == P1) {
		myCh->signal[C_SIG_OT_FAULT] = P0;
		myCh->misc.tmpCode = myCh->op.code;
		myCh->op.code = C_FAULT_OT;
		rtn = 2;
	} else if(myCh->signal[C_SIG_FORCE_POWER] == P1) {
		myCh->signal[C_SIG_FORCE_POWER] = P0;
		myCh->misc.tmpCode = myCh->op.code;
		myCh->op.code = C_FAULT_FORCE_POWER;
		rtn = 3;
	} else if(myCh->signal[C_SIG_MAIN_EMG] == P1) {
		myCh->signal[C_SIG_MAIN_EMG] = P0;
		myCh->misc.tmpCode = myCh->op.code;
		myCh->op.code = C_FAULT_MAIN_EMG;
		rtn = 4;
	} else if(myCh->signal[C_SIG_SUB_EMG] == P1) {
		myCh->signal[C_SIG_SUB_EMG] = P0;
		myCh->misc.tmpCode = myCh->op.code;
		myCh->op.code = C_FAULT_SUB_EMG;
		rtn = 5;
	} else if(myCh->signal[C_SIG_AC_POWER] == P1) {
		myCh->signal[C_SIG_AC_POWER] = P0;
		myCh->misc.tmpCode = myCh->op.code;
		myCh->op.code = C_FAULT_AC_POWER;
		rtn = 6;
	} else if(myCh->signal[C_SIG_UPS_BATTERY] == P1) {
		myCh->signal[C_SIG_UPS_BATTERY] = P0;
		myCh->misc.tmpCode = myCh->op.code;
		myCh->op.code = C_FAULT_UPS_BATTERY;
		rtn = 7;
	} else if(myCh->signal[C_SIG_FAIL_USER_PATTERN_READ] == P1) {
		myCh->signal[C_SIG_FAIL_USER_PATTERN_READ] = P0;
		myCh->misc.tmpCode = myCh->op.code;
		myCh->op.code = C_FAULT_USER_PATTERN_READ;
		rtn = 8;
	} else if(myCh->signal[C_SIG_TERMINAL_QUIT] == P1) {
		myCh->signal[C_SIG_TERMINAL_QUIT] = P0;
		myCh->misc.tmpCode = myCh->op.code;
		myCh->op.code = C_FAULT_TERMINAL_QUIT;
		rtn = 9;
	} else if(myCh->signal[C_SIG_LIMIT_ERROR] == P1) {
		myCh->signal[C_SIG_LIMIT_ERROR] = P0;
		myCh->misc.tmpCode = myCh->op.code;
		myCh->op.code = C_FAULT_LIMIT_ERROR;
		rtn = 10;
	} else if(myCh->signal[C_SIG_CHAMBER_ERROR] == P1) {
		myCh->signal[C_SIG_CHAMBER_ERROR] = P0;
		myCh->misc.tmpCode = myCh->op.code;
		myCh->op.code = C_FAULT_CHAMBER_ERROR;
		rtn = 11;
	} else if(myCh->signal[C_SIG_INV_FAULT] == P1) {
		myCh->signal[C_SIG_INV_FAULT] = P0;
		myCh->misc.tmpCode = myCh->op.code;
		myCh->op.code = C_FAULT_INVERTER;
		rtn = 12;
	} else if(myCh->signal[C_SIG_JIG_ERROR] == P1) {
		myCh->signal[C_SIG_JIG_ERROR] = P0;
		myCh->misc.tmpCode = myCh->op.code;
		myCh->op.code = C_FAULT_JIG_ERROR;
		rtn = 13;
	} else if(myCh->signal[C_SIG_VL_PLUS_FAULT] == P1) {
		myCh->signal[C_SIG_VL_PLUS_FAULT] = P0;
		myCh->misc.tmpCode = myCh->op.code;
		myCh->op.code = C_FAULT_COMPARE_LINE_PLUS;
		rtn = 14;
	} else if(myCh->signal[C_SIG_VL_MINUS_FAULT] == P1) {
		myCh->signal[C_SIG_VL_MINUS_FAULT] = P0;
		myCh->misc.tmpCode = myCh->op.code;
		myCh->op.code = C_FAULT_COMPARE_LINE_MINUS;
		rtn = 15;
	} else if(myCh->signal[C_SIG_CH_V_LEVEL_FAULT] == P1) {
		myCh->signal[C_SIG_CH_V_LEVEL_FAULT] = P0;
		myCh->misc.tmpCode = myCh->op.code;
		myCh->op.code = C_FAULT_COMPARE_LINE_FLT_CH;
		rtn = 16;
	} else if(myCh->signal[C_SIG_OV_FAULT] == P1) {
		myCh->signal[C_SIG_OV_FAULT] = P0;
		myCh->misc.tmpCode = myCh->op.code;
		myCh->op.code = C_FAULT_COMPARE_UPPER_VOLTAGE;
		rtn = 17;
	} else if(myCh->signal[C_SIG_OC_FAULT] == P1) {
		myCh->signal[C_SIG_OC_FAULT] = P0;
		myCh->misc.tmpCode = myCh->op.code;
		myCh->op.code = C_FAULT_COMPARE_UPPER_CURRENT;
		rtn = 18;
	} else if(myCh->signal[C_SIG_OT_COMPARE_FAULT] == P1) {
		myCh->signal[C_SIG_OT_COMPARE_FAULT] = P0;
		myCh->misc.tmpCode = myCh->op.code;
		myCh->op.code = C_FAULT_COMPARE_OVER_TEMP;
		rtn = 19;
	} else if(myCh->signal[C_SIG_METER_HIGH_FAULT] == P1) {
		myCh->signal[C_SIG_METER_HIGH_FAULT] = P0;
		myCh->misc.tmpCode = myCh->op.code;
		myCh->op.code = C_FAULT_COMPARE_METER_HIGH;
		rtn = 20;
	} else if(myCh->signal[C_SIG_METER_LOW_FAULT] == P1) {
		myCh->signal[C_SIG_METER_LOW_FAULT] = P0;
		myCh->misc.tmpCode = myCh->op.code;
		myCh->op.code = C_FAULT_COMPARE_METER_LOW;
		rtn = 21;
	} else if(myCh->signal[C_SIG_TEMP_CONNECT_ERROR] == P1) {
		myCh->signal[C_SIG_TEMP_CONNECT_ERROR] = P0;
		myCh->misc.tmpCode = myCh->op.code;
		myCh->op.code = C_FAULT_TEMP_CONNECT_ERROR;
		rtn = 22;
	} else if(myCh->signal[C_SIG_NETWORK_CONNECT_ERROR] == P1) {
		myCh->signal[C_SIG_NETWORK_CONNECT_ERROR] = P0;
		myCh->misc.tmpCode = myCh->op.code;
		myCh->op.code = C_FAULT_NETWORK_CONNECT_ERROR;
		rtn = 23;
	} else if(myCh->signal[C_SIG_DC_FAN_FAIL] == P1) { //151023
		myCh->signal[C_SIG_DC_FAN_FAIL] = P0;
		myCh->misc.tmpCode = myCh->op.code;
		myCh->op.code = C_FAULT_DC_FAN;
		rtn = 24;
	} else if(myCh->signal[C_SIG_DOOR_OPEN_FAIL] == P1) { //160701 SCH
		myCh->signal[C_SIG_DOOR_OPEN_FAIL] = P0;
		myCh->misc.tmpCode = myCh->op.code;
		myCh->op.code = C_FAULT_DOOR_OPEN;
		rtn = 25;
	} else if(myCh->signal[C_SIG_SMOKE_FAIL] == P1) { //160701 SCH
		myCh->signal[C_SIG_SMOKE_FAIL] = P0;
		myCh->misc.tmpCode = myCh->op.code;
		myCh->op.code = C_FAULT_SMOKE;
		rtn = 26;
	} else if(myCh->signal[C_SIG_SHUTDOWN] == P1) {
		myCh->signal[C_SIG_SHUTDOWN] = P0;
		myCh->misc.tmpCode = myCh->op.code;
		myCh->op.code = C_FAULT_SHUTDOWN;
		rtn = 27;
//190618 oys add start
	} else if(myCh->signal[C_SIG_MAIN_CAN_COMM_ERROR] == P1) {
		myCh->signal[C_SIG_MAIN_CAN_COMM_ERROR] = P0;
		myCh->misc.tmpCode = myCh->op.code;
		myCh->op.code = C_FAULT_MAIN_CAN_COMM_ERROR;
		rtn = 28;
	} else if(myCh->signal[C_SIG_INV_CAN_COMM_ERROR] == P1) {
		myCh->signal[C_SIG_INV_CAN_COMM_ERROR] = P0;
		myCh->misc.tmpCode = myCh->op.code;
		myCh->op.code = C_FAULT_INV_CAN_COMM_ERROR;
		rtn = 29;
	} else if(myCh->signal[C_SIG_IO_CAN_COMM_ERROR] == P1) {
		myCh->signal[C_SIG_IO_CAN_COMM_ERROR] = P0;
		myCh->misc.tmpCode = myCh->op.code;
		myCh->op.code = C_FAULT_IO_CAN_COMM_ERROR;
		rtn = 30;
	} else if(myCh->signal[C_SIG_M_RECIPE_CONNECT_ERROR] == P1){
		myCh->signal[C_SIG_M_RECIPE_CONNECT_ERROR] = P0;
		myCh->misc.tmpCode = myCh->op.code;
		myCh->op.code = C_FAULT_M_RECIPE_CONNECT_ERROR;
		rtn = 31;
	} else if(myCh->signal[C_SIG_READ_FAIL_SOC_TRACKING_FILE] == P1){
		myCh->signal[C_SIG_READ_FAIL_SOC_TRACKING_FILE] = P0;
		myCh->misc.tmpCode = myCh->op.code;
		myCh->op.code = C_FAULT_READ_TRACKING_FILE;
		rtn = 32;
	} else if(myCh->signal[C_SIG_DLL_PAUSE] == P1){
		myCh->signal[C_SIG_DLL_PAUSE] = P0;
		myCh->misc.tmpCode = myCh->op.code;
		myCh->op.code = C_FAULT_CELL_DIAGNOSIS_PAUSE;
		rtn = 34;
	} else if(myCh->signal[C_SIG_OVP_PAUSE] == P1){  //210901 LJS
		myCh->signal[C_SIG_OVP_PAUSE] = P0;
		myCh->misc.tmpCode = myCh->op.code;
		myCh->op.code = C_FAULT_OVP_ERROR;
		rtn = 35;
	} else if(myCh->signal[C_SIG_OTP_PAUSE] == P1){  //210901 LJS
		myCh->signal[C_SIG_OTP_PAUSE] = P0;
		myCh->misc.tmpCode = myCh->op.code;
		myCh->op.code = C_FAULT_OTP_ERROR;
		rtn = 36;
	} else if(myCh->signal[C_SIG_OVP_GROUP_PAUSE] == P1){  //211018 HUN
		myCh->signal[C_SIG_OVP_GROUP_PAUSE] = P0;
		myCh->misc.tmpCode = myCh->op.code;
		myCh->op.code = C_FAULT_OVP_GROUP_ERROR;
		rtn = 37;
	} else if(myCh->signal[C_SIG_OTP_GROUP_PAUSE] == P1){  //2111018 HUN
		myCh->signal[C_SIG_OTP_GROUP_PAUSE] = P0;
		myCh->misc.tmpCode = myCh->op.code;
		myCh->op.code = C_FAULT_OTP_GROUP_ERROR;
		rtn = 38;
	} else if(myCh->signal[C_SIG_SELECT_CH_CONNECT_ERROR] == P1){
		myCh->signal[C_SIG_SELECT_CH_CONNECT_ERROR] = P0;
		myCh->misc.tmpCode = myCh->op.code;
		myCh->op.code = C_FAULT_SELECT_CH_NETWORK_ERROR;
		rtn = 39;
	}
//190618 oys add end

	if(rtn != 0) {
		cSemiSwitch_Rest(bd, ch, 0, 0);
		myCh->misc.tmpState = myCh->op.state;
		myCh->opSave = myCh->op;
		//170106 oys add
		if(myCh->misc.tempWaitType == P0){
			myCh->misc.chGroupNo = 0;
			//20190422 add
			myCh->misc.stepSyncFlag = P0;
			myCh->misc.endState = P0;		//220203_hun
			myCh->misc.groupEndTime = 0;
			myCh->misc.groupAvgVsens = 0;	//220203_hun
			myCh->misc.group_StartVoltage_flag = 0;
		}
		myCh->op.phase = P100;
		return -1;
	} else return 0;
}

int cFailCodeCheck_parallel_master(int bd, int ch)
{	//Parallel Master Ch cFailCodeCheck Signal 220317 
	
	myCh = &(myData->bData[bd].cData[ch]);
	//hard_fault, external_fault
	if(myCh->signal[C_SIG_SMPS_FAULT] == P1) {
		myData->bData[bd].cData[ch+1].signal[C_SIG_SMPS_FAULT] = P1;
	} else if(myCh->signal[C_SIG_OT_FAULT] == P1) {
		myData->bData[bd].cData[ch+1].signal[C_SIG_OT_FAULT] = P0;
	} else if(myCh->signal[C_SIG_FORCE_POWER] == P1) {
		myData->bData[bd].cData[ch+1].signal[C_SIG_FORCE_POWER] = P0;
	} else if(myCh->signal[C_SIG_MAIN_EMG] == P1) {
		myData->bData[bd].cData[ch+1].signal[C_SIG_MAIN_EMG] = P0;
	} else if(myCh->signal[C_SIG_SUB_EMG] == P1) {
		myData->bData[bd].cData[ch+1].signal[C_SIG_SUB_EMG] = P0;
	} else if(myCh->signal[C_SIG_AC_POWER] == P1) {
		myData->bData[bd].cData[ch+1].signal[C_SIG_AC_POWER] = P0;
	} else if(myCh->signal[C_SIG_UPS_BATTERY] == P1) {
		myData->bData[bd].cData[ch+1].signal[C_SIG_UPS_BATTERY] = P0;
	} else if(myCh->signal[C_SIG_FAIL_USER_PATTERN_READ] == P1) {
		myData->bData[bd].cData[ch+1].signal[C_SIG_FAIL_USER_PATTERN_READ] = P0;
	} else if(myCh->signal[C_SIG_TERMINAL_QUIT] == P1) {
		myData->bData[bd].cData[ch+1].signal[C_SIG_TERMINAL_QUIT] = P0;
	} else if(myCh->signal[C_SIG_LIMIT_ERROR] == P1) {
		myData->bData[bd].cData[ch+1].signal[C_SIG_LIMIT_ERROR] = P0;
	} else if(myCh->signal[C_SIG_CHAMBER_ERROR] == P1) {
		myData->bData[bd].cData[ch+1].signal[C_SIG_CHAMBER_ERROR] = P0;
	} else if(myCh->signal[C_SIG_INV_FAULT] == P1) {
		myData->bData[bd].cData[ch+1].signal[C_SIG_INV_FAULT] = P0;
	} else if(myCh->signal[C_SIG_JIG_ERROR] == P1) {
		myData->bData[bd].cData[ch+1].signal[C_SIG_JIG_ERROR] = P0;
	} else if(myCh->signal[C_SIG_VL_PLUS_FAULT] == P1) {
		myData->bData[bd].cData[ch+1].signal[C_SIG_VL_PLUS_FAULT] = P0;
	} else if(myCh->signal[C_SIG_VL_MINUS_FAULT] == P1) {
		myData->bData[bd].cData[ch+1].signal[C_SIG_VL_MINUS_FAULT] = P0;
	} else if(myCh->signal[C_SIG_CH_V_LEVEL_FAULT] == P1) {
		myData->bData[bd].cData[ch+1].signal[C_SIG_CH_V_LEVEL_FAULT] = P0;
	} else if(myCh->signal[C_SIG_OV_FAULT] == P1) {
		myData->bData[bd].cData[ch+1].signal[C_SIG_OV_FAULT] = P0;
	} else if(myCh->signal[C_SIG_OC_FAULT] == P1) {
		myData->bData[bd].cData[ch+1].signal[C_SIG_OC_FAULT] = P0;
	} else if(myCh->signal[C_SIG_OT_COMPARE_FAULT] == P1) {
		myData->bData[bd].cData[ch+1].signal[C_SIG_OT_COMPARE_FAULT] = P0;
	} else if(myCh->signal[C_SIG_METER_HIGH_FAULT] == P1) {
		myData->bData[bd].cData[ch+1].signal[C_SIG_METER_HIGH_FAULT] = P0;
	} else if(myCh->signal[C_SIG_METER_LOW_FAULT] == P1) {
		myData->bData[bd].cData[ch+1].signal[C_SIG_METER_LOW_FAULT] = P0;
	} else if(myCh->signal[C_SIG_TEMP_CONNECT_ERROR] == P1) {
		myData->bData[bd].cData[ch+1].signal[C_SIG_TEMP_CONNECT_ERROR] = P0;
	} else if(myCh->signal[C_SIG_NETWORK_CONNECT_ERROR] == P1) {
		myData->bData[bd].cData[ch+1].signal[C_SIG_NETWORK_CONNECT_ERROR] = P0;
	} else if(myCh->signal[C_SIG_DC_FAN_FAIL] == P1) { //151023
		myData->bData[bd].cData[ch+1].signal[C_SIG_DC_FAN_FAIL] = P0;
	} else if(myCh->signal[C_SIG_DOOR_OPEN_FAIL] == P1) { //160701 SCH
		myData->bData[bd].cData[ch+1].signal[C_SIG_DOOR_OPEN_FAIL] = P0;
	} else if(myCh->signal[C_SIG_SMOKE_FAIL] == P1) { //160701 SCH
		myData->bData[bd].cData[ch+1].signal[C_SIG_SMOKE_FAIL] = P0;
	} else if(myCh->signal[C_SIG_SHUTDOWN] == P1) {
		myData->bData[bd].cData[ch+1].signal[C_SIG_SHUTDOWN] = P0;
	} else if(myCh->signal[C_SIG_MAIN_CAN_COMM_ERROR] == P1) {
		myData->bData[bd].cData[ch+1].signal[C_SIG_MAIN_CAN_COMM_ERROR] = P0;
	} else if(myCh->signal[C_SIG_INV_CAN_COMM_ERROR] == P1) {
		myData->bData[bd].cData[ch+1].signal[C_SIG_INV_CAN_COMM_ERROR] = P0;
	} else if(myCh->signal[C_SIG_IO_CAN_COMM_ERROR] == P1) {
		myData->bData[bd].cData[ch+1].signal[C_SIG_IO_CAN_COMM_ERROR] = P0;
	} else if(myCh->signal[C_SIG_M_RECIPE_CONNECT_ERROR] == P1){
		myData->bData[bd].cData[ch+1].signal[C_SIG_M_RECIPE_CONNECT_ERROR] = P0;
	} else if(myCh->signal[C_SIG_READ_FAIL_SOC_TRACKING_FILE] == P1){
		myData->bData[bd].cData[ch+1].signal[C_SIG_READ_FAIL_SOC_TRACKING_FILE] = P0;
	} else if(myCh->signal[C_SIG_DLL_PAUSE] == P1){
		myData->bData[bd].cData[ch+1].signal[C_SIG_DLL_PAUSE] = P0;
	} else if(myCh->signal[C_SIG_OVP_PAUSE] == P1){  //210901 LJS
		myData->bData[bd].cData[ch+1].signal[C_SIG_OVP_PAUSE] = P0;
	} else if(myCh->signal[C_SIG_OTP_PAUSE] == P1){  //210901 LJS
		myData->bData[bd].cData[ch+1].signal[C_SIG_OTP_PAUSE] = P0;
	} else if(myCh->signal[C_SIG_OVP_GROUP_PAUSE] == P1){  //211018 HUN
		myData->bData[bd].cData[ch+1].signal[C_SIG_OVP_GROUP_PAUSE] = P0;
	} else if(myCh->signal[C_SIG_OTP_GROUP_PAUSE] == P1){  //2111018 HUN
		myData->bData[bd].cData[ch+1].signal[C_SIG_OTP_GROUP_PAUSE] = P0;
	} else if(myCh->signal[C_SIG_SELECT_CH_CONNECT_ERROR] == P1){
		myData->bData[bd].cData[ch+1].signal[C_SIG_SELECT_CH_CONNECT_ERROR] = P0;
	}
	 return 0;
}

int cFailCodeCheck_parallel_slave(int bd, int ch)
{	//Parallel Slave Ch cFailCodeCheck Signal 220317 
	
	myCh = &(myData->bData[bd].cData[ch]);
	//hard_fault, external_fault
	if(myCh->signal[C_SIG_SMPS_FAULT] == P1) {
		myData->bData[bd].cData[ch-1].signal[C_SIG_SMPS_FAULT] = P1;
	} else if(myCh->signal[C_SIG_OT_FAULT] == P1) {
		myData->bData[bd].cData[ch-1].signal[C_SIG_OT_FAULT] = P0;
	} else if(myCh->signal[C_SIG_FORCE_POWER] == P1) {
		myData->bData[bd].cData[ch-1].signal[C_SIG_FORCE_POWER] = P0;
	} else if(myCh->signal[C_SIG_MAIN_EMG] == P1) {
		myData->bData[bd].cData[ch-1].signal[C_SIG_MAIN_EMG] = P0;
	} else if(myCh->signal[C_SIG_SUB_EMG] == P1) {
		myData->bData[bd].cData[ch-1].signal[C_SIG_SUB_EMG] = P0;
	} else if(myCh->signal[C_SIG_AC_POWER] == P1) {
		myData->bData[bd].cData[ch-1].signal[C_SIG_AC_POWER] = P0;
	} else if(myCh->signal[C_SIG_UPS_BATTERY] == P1) {
		myData->bData[bd].cData[ch-1].signal[C_SIG_UPS_BATTERY] = P0;
	} else if(myCh->signal[C_SIG_FAIL_USER_PATTERN_READ] == P1) {
		myData->bData[bd].cData[ch-1].signal[C_SIG_FAIL_USER_PATTERN_READ] = P0;
	} else if(myCh->signal[C_SIG_TERMINAL_QUIT] == P1) {
		myData->bData[bd].cData[ch-1].signal[C_SIG_TERMINAL_QUIT] = P0;
	} else if(myCh->signal[C_SIG_LIMIT_ERROR] == P1) {
		myData->bData[bd].cData[ch-1].signal[C_SIG_LIMIT_ERROR] = P0;
	} else if(myCh->signal[C_SIG_CHAMBER_ERROR] == P1) {
		myData->bData[bd].cData[ch-1].signal[C_SIG_CHAMBER_ERROR] = P0;
	} else if(myCh->signal[C_SIG_INV_FAULT] == P1) {
		myData->bData[bd].cData[ch-1].signal[C_SIG_INV_FAULT] = P0;
	} else if(myCh->signal[C_SIG_JIG_ERROR] == P1) {
		myData->bData[bd].cData[ch-1].signal[C_SIG_JIG_ERROR] = P0;
	} else if(myCh->signal[C_SIG_VL_PLUS_FAULT] == P1) {
		myData->bData[bd].cData[ch-1].signal[C_SIG_VL_PLUS_FAULT] = P0;
	} else if(myCh->signal[C_SIG_VL_MINUS_FAULT] == P1) {
		myData->bData[bd].cData[ch-1].signal[C_SIG_VL_MINUS_FAULT] = P0;
	} else if(myCh->signal[C_SIG_CH_V_LEVEL_FAULT] == P1) {
		myData->bData[bd].cData[ch-1].signal[C_SIG_CH_V_LEVEL_FAULT] = P0;
	} else if(myCh->signal[C_SIG_OV_FAULT] == P1) {
		myData->bData[bd].cData[ch-1].signal[C_SIG_OV_FAULT] = P0;
	} else if(myCh->signal[C_SIG_OC_FAULT] == P1) {
		myData->bData[bd].cData[ch-1].signal[C_SIG_OC_FAULT] = P0;
	} else if(myCh->signal[C_SIG_OT_COMPARE_FAULT] == P1) {
		myData->bData[bd].cData[ch-1].signal[C_SIG_OT_COMPARE_FAULT] = P0;
	} else if(myCh->signal[C_SIG_METER_HIGH_FAULT] == P1) {
		myData->bData[bd].cData[ch-1].signal[C_SIG_METER_HIGH_FAULT] = P0;
	} else if(myCh->signal[C_SIG_METER_LOW_FAULT] == P1) {
		myData->bData[bd].cData[ch-1].signal[C_SIG_METER_LOW_FAULT] = P0;
	} else if(myCh->signal[C_SIG_TEMP_CONNECT_ERROR] == P1) {
		myData->bData[bd].cData[ch-1].signal[C_SIG_TEMP_CONNECT_ERROR] = P0;
	} else if(myCh->signal[C_SIG_NETWORK_CONNECT_ERROR] == P1) {
		myData->bData[bd].cData[ch-1].signal[C_SIG_NETWORK_CONNECT_ERROR] = P0;
	} else if(myCh->signal[C_SIG_DC_FAN_FAIL] == P1) { //151023
		myData->bData[bd].cData[ch-1].signal[C_SIG_DC_FAN_FAIL] = P0;
	} else if(myCh->signal[C_SIG_DOOR_OPEN_FAIL] == P1) { //160701 SCH
		myData->bData[bd].cData[ch-1].signal[C_SIG_DOOR_OPEN_FAIL] = P0;
	} else if(myCh->signal[C_SIG_SMOKE_FAIL] == P1) { //160701 SCH
		myData->bData[bd].cData[ch-1].signal[C_SIG_SMOKE_FAIL] = P0;
	} else if(myCh->signal[C_SIG_SHUTDOWN] == P1) {
		myData->bData[bd].cData[ch-1].signal[C_SIG_SHUTDOWN] = P0;
	} else if(myCh->signal[C_SIG_MAIN_CAN_COMM_ERROR] == P1) {
		myData->bData[bd].cData[ch-1].signal[C_SIG_MAIN_CAN_COMM_ERROR] = P0;
	} else if(myCh->signal[C_SIG_INV_CAN_COMM_ERROR] == P1) {
		myData->bData[bd].cData[ch-1].signal[C_SIG_INV_CAN_COMM_ERROR] = P0;
	} else if(myCh->signal[C_SIG_IO_CAN_COMM_ERROR] == P1) {
		myData->bData[bd].cData[ch-1].signal[C_SIG_IO_CAN_COMM_ERROR] = P0;
	} else if(myCh->signal[C_SIG_M_RECIPE_CONNECT_ERROR] == P1){
		myData->bData[bd].cData[ch-1].signal[C_SIG_M_RECIPE_CONNECT_ERROR] = P0;
	} else if(myCh->signal[C_SIG_READ_FAIL_SOC_TRACKING_FILE] == P1){
		myData->bData[bd].cData[ch-1].signal[C_SIG_READ_FAIL_SOC_TRACKING_FILE] = P0;
	} else if(myCh->signal[C_SIG_DLL_PAUSE] == P1){
		myData->bData[bd].cData[ch-1].signal[C_SIG_DLL_PAUSE] = P0;
	} else if(myCh->signal[C_SIG_OVP_PAUSE] == P1){  //210901 LJS
		myData->bData[bd].cData[ch-1].signal[C_SIG_OVP_PAUSE] = P0;
	} else if(myCh->signal[C_SIG_OTP_PAUSE] == P1){  //210901 LJS
		myData->bData[bd].cData[ch-1].signal[C_SIG_OTP_PAUSE] = P0;
	} else if(myCh->signal[C_SIG_OVP_GROUP_PAUSE] == P1){  //211018 HUN
		myData->bData[bd].cData[ch-1].signal[C_SIG_OVP_GROUP_PAUSE] = P0;
	} else if(myCh->signal[C_SIG_OTP_GROUP_PAUSE] == P1){  //2111018 HUN
		myData->bData[bd].cData[ch-1].signal[C_SIG_OTP_GROUP_PAUSE] = P0;
	} else if(myCh->signal[C_SIG_SELECT_CH_CONNECT_ERROR] == P1){
		myData->bData[bd].cData[ch-1].signal[C_SIG_SELECT_CH_CONNECT_ERROR] = P0;
	}
	 return 0;
}

long cCompareTime(int bd, int ch, long val1, long val2, long val3)
{
	long value, maxCurrent;
	double tmp;

	myCh = &(myData->bData[bd].cData[ch]);
	maxCurrent = myPs->config.maxCurrent[myCh->op.rangeI];
	if(val2 < 0) val2 *= (-1);

	tmp = (double)val2 / (double)maxCurrent;
	if(myCh->op.rangeI == 0) {
		value = (long)(100.0 * 180.0 * tmp) + 100; //180sec
	} else if(myCh->op.rangeI == 1) {
		value = (long)(100.0 * 30.0 * tmp) + 100; //30sec
	} else if(myCh->op.rangeI == 2) {
		value = (long)(100.0 * 10.0 * tmp) + 100; //10sec
	} else {
		value = (long)(100.0 * 2.0 * tmp) + 100; //2sec
	}
	return value;
}

void cSoftFeedback(int bd, int ch, long val1, long val2, long val3)
{
//	cSoftFeedback_1(bd, ch, val1, val2, val3);
#if CYCLER_TYPE == DIGITAL_CYC
	return;	//180611 Digital Cycler
#endif
	myCh = &(myData->bData[bd].cData[ch]);

	if(myPs->config.SoftFeedbackFlag == P1){
		if(myData->AppControl.config.systemType == CYCLER_CAN){
			cSoftFeedback_CAN(bd, ch, val1, val2, val3);
		}else{
			if(myData->mData.config.function[F_I_OFFSET_CALI] == P1){
				cSoftFeedback_4(bd, ch, val1, val2, val3);
			} else {
				if(myCh->misc.parallel_cycle_phase == P50) {
					cSoftFeedback_3p(bd, ch, val1, val2, val3); //kjg_180530
				} else {
#ifdef _EQUATION_CURRENT
					cSoftFeedback_EQU(bd, ch, val1, val2, val3);
#else
	#ifdef _TRACKING_MODE
					cSoftFeedback_SOC(bd, ch, val1, val2, val3);
	#else	
					cSoftFeedback_3(bd, ch, val1, val2, val3);
	#endif
#endif
				}
			}
		}
	}
}

void cSoftFeedback_1(int bd, int ch, long val1, long val2, long val3)
{
	unsigned char mode, type;
	unsigned int fbCount;
	long tmpV=0, tmpI=0, maxV, maxI, deltaV=0, deltaI=0;
	unsigned long advStepNo;
	double tmp;
	int rangeV, rangeI;
	int div = 5;

	S_CH_STEP_INFO step;

	myCh = &(myData->bData[bd].cData[ch]);
	step = step_info(bd, ch);

    advStepNo = step.advStepNo;
	rangeV = step.rangeV;
	rangeI = step.rangeI;
	type = step.type;
	mode = step.mode;

	maxV = myPs->config.maxVoltage[rangeV];
	maxI = myPs->config.maxCurrent[rangeI];
	if(mode != CP)
		if(myCh->op.checkDelayTime <= 30) return;//HK.Kim 

	switch(type) {
		case STEP_CHARGE:
			if(mode == CC 
				|| mode == CV
				|| mode == CCCV
				|| mode == C_RATE) {
				if(myCh->op.checkDelayTime < 100) {
					tmpV = val1 - myCh->misc.tmpVsens;
					tmpI = val2 - myCh->misc.tmpIsens;
				}else{
					tmpV = val1 - myCh->op.Vsens;
		//			tmpI = val2 - myCh->op.Isens;
					tmpI = val2 - myCh->misc.tmpIsens;
				}
				//CC Field
				if(myPs->config.capacityType == CAPACITY_AMPARE_HOURS){
					deltaV = (long)(maxV * 0.0005);//0.05%
					deltaI = (long)(maxI * 0.0025);//0.25%
				}else{
					deltaV = (long)(maxV * 0.005);//0.5%
					deltaI = (long)(maxI * 0.0025);//0.25%
				}
				//				if(tmpV > (long)(maxV * 0.0005)) {//0.05%
				if(tmpV > deltaV) {
					if((labs(tmpI) < (long)(maxI * 0.05)) // 5%
						&& (labs(tmpI) > (long)(maxI * 0.001)))	{ // 0.1 %
						myCh->misc.fbCountI_H++;
						myCh->misc.fbSumI_H += tmpI;
						if(myCh->misc.fbCountI_H >= 2) {
							fbCount = myCh->misc.fbCountI_H;
							tmp = (double)myCh->misc.fbSumI_H / fbCount;
							myCh->misc.fbSumI_H = 0;
							myCh->misc.fbCountI_H = 0;
							myCh->misc.fbSumI_L = 0;
							myCh->misc.fbCountI_L = 0;
							myCh->misc.fbSumI_M = 0;
							myCh->misc.fbCountI_M = 0;
							if(labs(myCh->misc.fbI) < (long)(maxI * 0.05)){
								myCh->misc.fbI += (long)(tmp * 0.5);
								val2 += myCh->misc.fbI;
								cCalCmdI(bd, ch, val2, div, rangeI);
							}
						}
					}else if((labs(tmpI) <= (long)(maxI * 0.001)) // 0.1%
						&& (labs(tmpI) > (long)(maxI * 0.0005)))	{ // 0.05 %
						myCh->misc.fbCountI_L++;
						myCh->misc.fbSumI_L += tmpI;
						if(myCh->misc.fbCountI_L >= 3) {
							fbCount = myCh->misc.fbCountI_L;
							tmp = (double)myCh->misc.fbSumI_L / fbCount;
							myCh->misc.fbSumI_L = 0;
							myCh->misc.fbCountI_L = 0;
							myCh->misc.fbSumI_H = 0;
							myCh->misc.fbCountI_H = 0;
							myCh->misc.fbSumI_M = 0;
							myCh->misc.fbCountI_M = 0;
							if(labs(myCh->misc.fbI) < (long)(maxI * 0.03)){ //3%
								myCh->misc.fbI += (long)(tmp * 0.5);
								val2 += myCh->misc.fbI;
								cCalCmdI(bd, ch, val2, div, rangeI);
							}
						}
					}else{
						myCh->misc.fbCountI_M++;
						myCh->misc.fbSumI_M += tmpI;
						if(myCh->misc.fbCountI_M >= 10) {
							fbCount = myCh->misc.fbCountI_M;
							tmp = (double)myCh->misc.fbSumI_M / fbCount;
							myCh->misc.fbSumI_M = 0;
							myCh->misc.fbCountI_M = 0;
							myCh->misc.fbSumI_H = 0;
							myCh->misc.fbCountI_H = 0;
							myCh->misc.fbSumI_L = 0;
							myCh->misc.fbCountI_L = 0;
							if(labs(myCh->misc.fbI) < (long)(maxI * 0.05)){ //5%
								myCh->misc.fbI += (long)(tmp * 0.2);
								val2 += myCh->misc.fbI;
								cCalCmdI(bd, ch, val2, div, rangeI);
							}
						}
					}
					myCh->misc.ccTime += myPs->misc.rt_scan_time;
					myCh->misc.cycle_Charge_ccTime
							+= myPs->misc.rt_scan_time;
//cv 
				}else {
					if(tmpI > deltaI){
						myCh->misc.cvTime += myPs->misc.rt_scan_time;
						myCh->misc.cycle_Charge_cvTime
								+= myPs->misc.rt_scan_time;
					}
				}
			} else if(mode == CP) {
				cCalCmdI(bd, ch, val2, div, rangeI);
			}
			break;
		case STEP_DISCHARGE:
			if(mode == CC 
				|| mode == CV
				|| mode == CCCV
				|| mode == C_RATE) {
				if(myCh->op.checkDelayTime < 100) {
					tmpV = myCh->misc.tmpVsens - val1;
					tmpI = val2 - myCh->misc.tmpIsens;
				}else{
					tmpV = myCh->op.Vsens - val1;
				//	tmpI = val2 - myCh->op.Isens;
					tmpI = val2 - myCh->misc.tmpIsens;
				}
				//CC Field
				if(myPs->config.capacityType == CAPACITY_AMPARE_HOURS){
					deltaV = (long)(maxV * 0.0005);//0.05%
					deltaI = (long)(maxI * 0.0025);//0.25%
				}else{
					deltaV = (long)(maxV * 0.005);//0.5%
					deltaI = (long)(maxI * 0.0025);//0.25%
				}
//				if(tmpV > (long)(maxV * 0.0005)) {//0.05%
				if(tmpV > deltaV) {
					if((labs(tmpI) < (long)(maxI * 0.05)) // 5%
						&& (labs(tmpI) > (long)(maxI * 0.001)))	{ // 0.1 %
						myCh->misc.fbCountI_H++;
						myCh->misc.fbSumI_H += tmpI;
						if(myCh->misc.fbCountI_H >= 2) {
							fbCount = myCh->misc.fbCountI_H;
							tmp = (double)myCh->misc.fbSumI_H / fbCount;
							myCh->misc.fbSumI_H = 0;
							myCh->misc.fbCountI_H = 0;
							myCh->misc.fbSumI_L = 0;
							myCh->misc.fbCountI_L = 0;
							if(labs(myCh->misc.fbI) < (long)(maxI * 0.05)){
								myCh->misc.fbI += (long)(tmp * 0.5);
								val2 += myCh->misc.fbI;
								cCalCmdI(bd, ch, val2, div, rangeI);
							}
						}
					}else if((labs(tmpI) <= (long)(maxI * 0.001)) // 0.1%
						&& (labs(tmpI) > (long)(maxI * 0.0005)))	{ // 0.05 %
						myCh->misc.fbCountI_L++;
						myCh->misc.fbSumI_L += tmpI;
						if(myCh->misc.fbCountI_L >= 3) {
							fbCount = myCh->misc.fbCountI_L;
							tmp = (double)myCh->misc.fbSumI_L / fbCount;
							myCh->misc.fbSumI_L = 0;
							myCh->misc.fbCountI_L = 0;
							myCh->misc.fbSumI_H = 0;
							myCh->misc.fbCountI_H = 0;
							if(labs(myCh->misc.fbI) < (long)(maxI * 0.05)){
								myCh->misc.fbI += (long)(tmp * 0.3);
								val2 += myCh->misc.fbI;
								cCalCmdI(bd, ch, val2, div, rangeI);
							}
						}
					}else{
						myCh->misc.fbCountI_M++;
						myCh->misc.fbSumI_M += tmpI;
						if(myCh->misc.fbCountI_M >= 10) {
							fbCount = myCh->misc.fbCountI_M;
							tmp = (double)myCh->misc.fbSumI_M / fbCount;
							myCh->misc.fbSumI_M = 0;
							myCh->misc.fbCountI_M = 0;
							myCh->misc.fbSumI_H = 0;
							myCh->misc.fbCountI_H = 0;
							myCh->misc.fbSumI_L = 0;
							myCh->misc.fbCountI_L = 0;
							if(labs(myCh->misc.fbI) < (long)(maxI * 0.05)){ //5%
								myCh->misc.fbI += (long)(tmp * 0.2);
								val2 += myCh->misc.fbI;
								cCalCmdI(bd, ch, val2, div, rangeI);
							}
						}
					}
					myCh->misc.ccTime += myPs->misc.rt_scan_time;
					myCh->misc.cycle_Discharge_ccTime
							+= myPs->misc.rt_scan_time;
				}else {
					if(labs(tmpI) > deltaI){
						myCh->misc.cvTime += myPs->misc.rt_scan_time;
						myCh->misc.cycle_Discharge_cvTime
								+= myPs->misc.rt_scan_time;
					}
				} 
			} else if(mode == CP) {
				cCalCmdI(bd, ch, val2, div, rangeI);
			}
			break;
		case STEP_Z:
			if(myCh->op.checkDelayTime < 100) {
				tmpV = myCh->misc.tmpVsens - val1;
				tmpI = val2 - myCh->misc.tmpIsens;
			}else{
				tmpV = myCh->op.Vsens - val1;
			//	tmpI = val2 - myCh->op.Isens;
				tmpI = val2 - myCh->misc.tmpIsens;
			}
			//CC Field
			if(tmpV >  (long)(maxV * 0.0005)) {//0.05%
				if((labs(tmpI) < (long)(maxI * 0.05)) // 5%
					&& (labs(tmpI) > (long)(maxI * 0.001)))	{ // 0.1 %
					myCh->misc.fbCountI_H++;
					myCh->misc.fbSumI_H += tmpI;
					if(myCh->misc.fbCountI_H >= 3) {
						fbCount = myCh->misc.fbCountI_H;
						tmp = (double)myCh->misc.fbSumI_H / fbCount;
						myCh->misc.fbSumI_H = 0;
						myCh->misc.fbCountI_H = 0;
						myCh->misc.fbSumI_L = 0;
						myCh->misc.fbCountI_L = 0;
						myCh->misc.fbSumI_M = 0;
						myCh->misc.fbCountI_M = 0;
						if(labs(myCh->misc.fbI) < (long)(maxI * 0.05)){
							myCh->misc.fbI += (long)(tmp * 0.5);
							val2 += myCh->misc.fbI;
							cCalCmdI(bd, ch, val2, div, rangeI);
						}
					}
				}else if((labs(tmpI) <= (long)(maxI * 0.001)) // 0.1%
					&& (labs(tmpI) > (long)(maxI * 0.0005)))	{ // 0.05 %
					myCh->misc.fbCountI_L++;
					myCh->misc.fbSumI_L += tmpI;
					if(myCh->misc.fbCountI_L >= 5) {
						fbCount = myCh->misc.fbCountI_L;
						tmp = (double)myCh->misc.fbSumI_L / fbCount;
						myCh->misc.fbSumI_H = 0;
						myCh->misc.fbCountI_H = 0;
						myCh->misc.fbSumI_L = 0;
						myCh->misc.fbCountI_L = 0;
						myCh->misc.fbSumI_M = 0;
						myCh->misc.fbCountI_M = 0;
						if(labs(myCh->misc.fbI) < (long)(maxI * 0.05)){
							myCh->misc.fbI += (long)(tmp * 0.3);
							val2 += myCh->misc.fbI;
							cCalCmdI(bd, ch, val2, div, rangeI);
						}
					}
				}else{
					myCh->misc.fbCountI_M++;
					myCh->misc.fbSumI_M += tmpI;
					if(myCh->misc.fbCountI_M >= 10) {
						fbCount = myCh->misc.fbCountI_M;
						tmp = (double)myCh->misc.fbSumI_M / fbCount;
						myCh->misc.fbSumI_H = 0;
						myCh->misc.fbCountI_H = 0;
						myCh->misc.fbSumI_L = 0;
						myCh->misc.fbCountI_L = 0;
						myCh->misc.fbSumI_M = 0;
						myCh->misc.fbCountI_M = 0;
						if(labs(myCh->misc.fbI) < (long)(maxI * 0.05)){ //5%
							myCh->misc.fbI += (long)(tmp * 0.3);
							val2 += myCh->misc.fbI;
							cCalCmdI(bd, ch, val2, div, rangeI);
						}
					}
				}
			}
			break;
		case STEP_USER_PATTERN:
			if(mode == CC){
				if(val2 > 0){
					tmpV = val1 - myCh->misc.tmpVsens;
					tmpI = val2 - myCh->misc.tmpIsens;
				}else if(val2 < 0){
					tmpV = myCh->misc.tmpVsens - val1;
					tmpI = val2 - myCh->misc.tmpIsens;
				}

				//CC Field
				if(tmpV > (long)(maxV * 0.0005)) {//0.05%
					if((labs(tmpI) < (long)(maxI * 0.05)) // 5%
						&& (labs(tmpI) > (long)(maxI * 0.001)))	{ // 0.1 %
						myCh->misc.fbCountI_H++;
						myCh->misc.fbSumI_H += tmpI;
						if(myCh->misc.fbCountI_H >= 5) {
							fbCount = myCh->misc.fbCountI_H;
							tmp = (double)myCh->misc.fbSumI_H / fbCount;
							myCh->misc.fbSumI_H = 0;
							myCh->misc.fbCountI_H = 0;
							myCh->misc.fbSumI_L = 0;
							myCh->misc.fbCountI_L = 0;
							myCh->misc.fbSumI_M = 0;
							myCh->misc.fbCountI_M = 0;
							if(labs(myCh->misc.fbI) < (long)(maxI * 0.05)){
								myCh->misc.fbI += (long)(tmp * 0.5);
								val2 += myCh->misc.fbI;
								cCalCmdI(bd, ch, val2, div, rangeI);
							}
						}
					}else if((labs(tmpI) <= (long)(maxI * 0.001)) // 0.1%
						&& (labs(tmpI) > (long)(maxI * 0.0005)))	{ // 0.05 %
						myCh->misc.fbCountI_L++;
						myCh->misc.fbSumI_L += tmpI;
						if(myCh->misc.fbCountI_L >= 5) {
							fbCount = myCh->misc.fbCountI_L;
							tmp = (double)myCh->misc.fbSumI_L / fbCount;
							myCh->misc.fbSumI_L = 0;
							myCh->misc.fbCountI_L = 0;
							myCh->misc.fbSumI_H = 0;
							myCh->misc.fbCountI_H = 0;
							myCh->misc.fbSumI_M = 0;
							myCh->misc.fbCountI_M = 0;
							if(labs(myCh->misc.fbI) < (long)(maxI * 0.03)){ //3%
								myCh->misc.fbI += (long)(tmp * 0.5);
								val2 += myCh->misc.fbI;
								cCalCmdI(bd, ch, val2, div, rangeI);
							}
						}
					}else{
						myCh->misc.fbCountI_M++;
						myCh->misc.fbSumI_M += tmpI;
						if(myCh->misc.fbCountI_M >= 10) {
							fbCount = myCh->misc.fbCountI_M;
							tmp = (double)myCh->misc.fbSumI_M / fbCount;
							myCh->misc.fbSumI_M = 0;
							myCh->misc.fbCountI_M = 0;
							myCh->misc.fbSumI_H = 0;
							myCh->misc.fbCountI_H = 0;
							myCh->misc.fbSumI_L = 0;
							myCh->misc.fbCountI_L = 0;
							if(labs(myCh->misc.fbI) < (long)(maxI * 0.05)){ //5%
								myCh->misc.fbI += (long)(tmp * 0.2);
								val2 += myCh->misc.fbI;
								cCalCmdI(bd, ch, val2, div, rangeI);
							}
						}
					}
				}
			} else if(mode == CP) {
				cCalCmdI(bd, ch, val2, div, rangeI);
			}
			break;

		default: break;
	}
}

void cSoftFeedback_2(int bd, int ch, long val1, long val2, long val3)
{
	unsigned char mode;
	unsigned int fbCount;
	int rangeV, rangeI;
	long tmpV, tmpI, maxV, maxI, cmpTime;
	unsigned long advStepNo;
	double tmp;
	S_CH_STEP_INFO step;

	myCh = &(myData->bData[bd].cData[ch]);
	step = step_info(bd, ch);

    advStepNo = step.advStepNo;
	rangeV = step.rangeV;
	rangeI = step.rangeI;

	mode = myCh->op.mode;

	maxV = myPs->config.maxVoltage[rangeV];
	maxI = myPs->config.maxCurrent[rangeI];

	switch(myCh->op.type) {
		case STEP_CHARGE:
			if(mode == CC || mode == CV || mode == CCCV || mode == C_RATE) {
				tmpV = val1 - myCh->op.Vsens;
				tmpI = val2 - myCh->op.Isens;
	
				myCh->misc.cvTime += 10;
				cmpTime = cCompareTime(bd, ch, val1, val2, val3);
				if(myCh->misc.cvTime <= (unsigned long)cmpTime) {
					if(labs(tmpV) < (double)(maxV * 0.001) 
						&& labs(tmpV) > (double)(maxV * 0.0002)) {
					/*	myCh->misc.fbCountV_H++;
						myCh->misc.fbSumV_H +=tmpV;
						if(myCh->misc.fbCountV_H >= 10) {
							fbCount = myCh->misc.fbCountV_H;
							tmp = (double)myCh->misc.fbSumV_H / fbCount;
							myCh->misc.fbCountV_H = 0;
							myCh->misc.fbSumV_H = 0;
							if(myCh->misc.fbV <= 49000){
								myCh->misc.fbV += (long)(tmp * 0.8);
								val1 += myCh->misc.fbV;
								cCalCmdV(bd, ch, val1, 5, 0);
							}
						}*/
					} else {
						myCh->misc.fbCountV_H = 0;
						if(labs(tmpI) < (double)(maxI * 0.05)) {
							myCh->misc.fbCountI_H++;
							myCh->misc.fbSumI_H += tmpI;
							if(myCh->misc.fbCountI_H >= 10) {
								fbCount = myCh->misc.fbCountI_H;
								tmp = (double)myCh->misc.fbSumI_H / fbCount;
								myCh->misc.fbSumI_H = 0;
								myCh->misc.fbCountI_H = 0;
								myCh->misc.fbSumI_L = 0;
								myCh->misc.fbCountI_L = 0;
								if(labs(myCh->misc.fbI) < (double)(maxI * 0.05)){
									myCh->misc.fbI += (long)(tmp * 0.5);
									val2 += myCh->misc.fbI;
									cCalCmdI(bd, ch, val2, 5, rangeI);
								}
							}
						}
					}
				}
			} else if(mode == CP) {
				if(myCh->op.Vsens < 1000) {
					val2 = 0L;
				} else {
					if(myCh->op.checkDelayTime < 100) {
						tmp = val3;
					} else {
						tmp = val3 - myCh->op.watt;
						tmp = val3 + tmp;
					}
					tmp /= myCh->misc.tmpVsens;
					tmp *= 1000000000.0;
					val2 = (long)tmp;
					if(val2 > myPs->config.maxCurrent[rangeI])
						val2 = myPs->config.maxCurrent[rangeI];
					else if(val2 < 0) val2 = 0L;
				}
				if(val2 > myPs->testCond[bd][ch].step[advStepNo].refI)
					val2 = myPs->testCond[bd][ch].step[advStepNo].refI;
				myCh->misc.fbCountI_H++;
				if(myCh->misc.fbCountI_H >= 1) {
					myCh->misc.fbCountI_H = 0;
					cCalCmdI(bd, ch, val2, 5, rangeI);
				}
			}
			break;
		case STEP_DISCHARGE:
			if(mode == CC 
				|| mode == CV
				|| mode == CCCV
				|| mode == C_RATE) {
				if(myCh->op.checkDelayTime < 100) {
					tmpV = myCh->misc.tmpVsens - val1;
					tmpI = val2 - myCh->misc.tmpIsens;
				}else{
					tmpV = myCh->op.Vsens - val1;
					tmpI = val2 - myCh->op.Isens;
				}
				if(tmpV > maxV * 0.001) {// 0.1%
					if(labs(tmpI) < maxI * 0.05) {//5%
						myCh->misc.fbCountI_H++;
						myCh->misc.fbSumI_H += tmpI;
						if(myCh->misc.fbCountI_H >= 10) {
							fbCount = myCh->misc.fbCountI_H;
							tmp = (double)myCh->misc.fbSumI_H / fbCount;
							myCh->misc.fbSumI_H = 0;
							myCh->misc.fbCountI_H = 0;
							myCh->misc.fbSumI_L = 0;
							myCh->misc.fbCountI_L = 0;
							if(labs(myCh->misc.fbI) < (double)(maxI * 0.05)){
								myCh->misc.fbI += (long)(tmp * 0.5);
								val2 += myCh->misc.fbI;
								cCalCmdI(bd, ch, val2, 5, rangeI);
							}
						}
					}
				}
			} else if(mode == CP) {
				if(myCh->op.Vsens < 1000) {
					val2 = 0L;
				} else {
					if(myCh->op.checkDelayTime < 100) {
						tmp = val3;
					} else {
						tmp = val3 - myCh->op.watt;
						tmp = val3 + tmp;
					}
					tmp /= myCh->misc.tmpVsens;
					tmp *= 1000000000.0;
					val2 = (long)tmp * (-1);
					if(val2 < myPs->config.minCurrent[rangeI])
						val2 = myPs->config.minCurrent[rangeI];
					else if(val2 > 0) val2 = 0L;
				}
				if(val2 < myPs->testCond[bd][ch].step[advStepNo].refI)
					val2 = myPs->testCond[bd][ch].step[advStepNo].refI;
				myCh->misc.fbCountI_H++;
				if(myCh->misc.fbCountI_H >= 1) {
					myCh->misc.fbCountI_H = 0;
					cCalCmdI(bd, ch, val2, 5, rangeI);
				}
			}
			break;
		case STEP_Z:
			if(myCh->op.checkDelayTime < 100) {
				tmpV = myCh->misc.tmpVsens - val1;
				tmpI = val2 - myCh->misc.tmpIsens;
			}else{
				tmpV = myCh->op.Vsens - val1;
				tmpI = val2 - myCh->op.Isens;
			}
			if(tmpV > maxV * 0.001) {// 0.1%
				if(labs(tmpI) < maxI * 0.05) { //5%
					myCh->misc.fbCountI_H++;
					myCh->misc.fbSumI_H += tmpI;
					if(myCh->misc.fbCountI_H >= 10) {
						fbCount = myCh->misc.fbCountI_H;
						tmp = (double)myCh->misc.fbSumI_H / fbCount;
						myCh->misc.fbSumI_H = 0;
						myCh->misc.fbCountI_H = 0;
						myCh->misc.fbSumI_L = 0;
						myCh->misc.fbCountI_L = 0;
						if(labs(myCh->misc.fbI) < (double)(maxI * 0.05)){
							myCh->misc.fbI += (long)(tmp * 0.5);
							val2 += myCh->misc.fbI;
							cCalCmdI(bd, ch, val2, 5, rangeI);
						}
					}
				}
			}
			break;
		default: break;
	}
}

void cSoftFeedback_3(int bd, int ch, long val1, long val2, long val3)
{
	unsigned char mode, type, checkFlag;
	int rangeV, rangeI, div = 5;
	unsigned int fbCount;
	long tmpV=0, tmpI=0, maxV, maxI, deltaV=0, deltaI=0;
	unsigned long advStepNo, feedbackCount = 0;
	double tmp;
	S_CH_STEP_INFO step;

	step = step_info(bd, ch);

    advStepNo = step.advStepNo;
	rangeV = step.rangeV;
	rangeI = step.rangeI;
	type = step.type;
	mode = step.mode;

	maxV = myPs->config.maxVoltage[rangeV];
	maxI = myPs->config.maxCurrent[rangeI];

	switch(type) { //20180417 add for Cvtime
		case STEP_CHARGE:
			if(myCh->op.checkDelayTime < 100) {
				tmpV = val1 - myCh->misc.tmpVsens;
				tmpI = val2 - myCh->misc.tmpIsens;
			} else {
				tmpV = val1 - myCh->op.Vsens;
				tmpI = val2 - myCh->op.Isens;
			}

			//CC Field
			deltaV = (long)(maxV * 0.001);
			deltaI = (long)(maxI * 0.0025);

			//Check CV Flag
			if(tmpV < deltaV) {
				if(tmpI > deltaI) {
					myCh->misc.cvFlag = P1;
   					myCh->misc.cvFaultCheckFlag = P1; //210204
					#ifdef _EXTERNAL_CONTROL
					myCh->misc.chCV = P1;
					#endif
				}
			}
			break;
		case STEP_DISCHARGE:
			if(myCh->op.checkDelayTime < 100) {
				tmpV = myCh->misc.tmpVsens - val1;
				tmpI = val2 - myCh->misc.tmpIsens;
			} else {
				tmpV = myCh->op.Vsens - val1;
				tmpI = val2 - myCh->op.Isens;
			}

			//CC Field
			deltaV = (long)(maxV * 0.001);
			deltaI = (long)(maxI * 0.0025);

			//Check CV Flag
			if(tmpV < deltaV) {
				if(labs(tmpI) > deltaI) {
					myCh->misc.cvFlag = P1;
   					myCh->misc.cvFaultCheckFlag = P1; //210204
					#ifdef _EXTERNAL_CONTROL
					myCh->misc.chCV = P1;
					#endif
				}
			}
			break;
		default:
			break;
	}

	if(labs(val2) >= maxI * 0.05) { //5%
		checkFlag = 1;
	} else {
		checkFlag = 2;
	}

	if(myCh->misc.feedback_start == P1) {
		myCh->misc.feedback_delayTime += myPs->misc.rt_scan_time;
	} else {
		myCh->misc.feedback_delayTime = 0;
		myCh->misc.fbCountI_H = 0;
		myCh->misc.fbSumI_H = 0;
		myCh->misc.fbSumI_M = 0;
		myCh->misc.fbCountI_M = 0;
		myCh->misc.fbSumI_L = 0;
		myCh->misc.fbCountI_L = 0;
	}

	if(labs(myCh->misc.tmpIsens) >= val2 * 0.95) {
		myCh->misc.feedback_start = P1;
	}

	if(type != STEP_USER_PATTERN) {
		if(mode != CP && mode != CPCV) {
			if(checkFlag == 2) {
				if(myCh->misc.feedback_delayTime < 100) return;
			} else {
				if(myCh->misc.feedback_delayTime < 5) return;
			}
		} else {
			if(myCh->op.checkDelayTime < 2) return;
		}
	}

	switch(type) {
		case STEP_CHARGE:
			if(mode == CC || mode == CV || mode == CCCV || mode == C_RATE) {
				if(myCh->op.checkDelayTime < 100) {
					tmpV = val1 - myCh->misc.tmpVsens;
					tmpI = val2 - myCh->misc.tmpIsens;
				} else {
					tmpV = val1 - myCh->op.Vsens;
					tmpI = val2 - myCh->op.Isens;
				}

				//CC Field
				if(myPs->config.capacityType == CAPACITY_AMPARE_HOURS) {
					deltaV = (long)(maxV * 0.001); //0.1% 20180418
					deltaI = (long)(maxI * 0.0025); //0.25%
				} else {
					deltaV = (long)(maxV * 0.001); //0.1%
					deltaI = (long)(maxI * 0.0025); //0.25%
				}

				if(tmpV > deltaV) {
					if((labs(tmpI) < (long)(maxI * 0.05)) //5%
						&& (labs(tmpI) > (long)(maxI * 0.001)))	{ //0.1%
						myCh->misc.fbCountI_H++;
						myCh->misc.fbSumI_H += tmpI;
						myCh->misc.fbCountI_M = 0;
						myCh->misc.fbSumI_M = 0;
						myCh->misc.fbCountI_L = 0;
						myCh->misc.fbSumI_L = 0;
						
						feedbackCount
							= (long)((100 / myPs->misc.dio_scan_time) * 3);
						if(myCh->misc.fbCountI_H >= feedbackCount) {
							fbCount = myCh->misc.fbCountI_H;
							tmp = (double)myCh->misc.fbSumI_H / fbCount;
							myCh->misc.fbCountI_H = 0;
							myCh->misc.fbSumI_H = 0;
							if(labs(myCh->misc.fbI) < (long)(maxI * 0.05)) {
								myCh->misc.fbI += (long)(tmp * 0.5);
								val2 += myCh->misc.fbI;
								cCalCmdI(bd, ch, val2, div, rangeI);
							}
						}
					} else if((labs(tmpI) <= (long)(maxI * 0.001)) //0.1%
						&& (labs(tmpI) > (long)(maxI * 0.0005))) { //0.05%
						myCh->misc.fbCountI_H = 0;
						myCh->misc.fbSumI_H = 0;
						myCh->misc.fbCountI_M++;
						myCh->misc.fbSumI_M += tmpI;
						myCh->misc.fbCountI_L = 0;
						myCh->misc.fbSumI_L = 0;
					
						feedbackCount
							= (long)((100 / myPs->misc.dio_scan_time) * 3);
						if(myCh->misc.fbCountI_M >= feedbackCount) {
							fbCount = myCh->misc.fbCountI_M;
							tmp = (double)myCh->misc.fbSumI_M / fbCount;
							myCh->misc.fbCountI_M = 0;
							myCh->misc.fbSumI_M = 0;
							if(labs(myCh->misc.fbI) < (long)(maxI * 0.05)) {//3%
								myCh->misc.fbI += (long)(tmp * 0.3);
								val2 += myCh->misc.fbI;
								cCalCmdI(bd, ch, val2, div, rangeI);
							}
						}
					} else if((labs(tmpI) <= (long)(maxI * 0.0005))) { //0.05%
						myCh->misc.fbCountI_M = 0;
						myCh->misc.fbSumI_M = 0;
						myCh->misc.fbCountI_H = 0;
						myCh->misc.fbSumI_H = 0;
						myCh->misc.fbCountI_L++;
						myCh->misc.fbSumI_L += tmpI;
					
						feedbackCount
							= (long)((100 / myPs->misc.dio_scan_time) * 5);
						if(myCh->misc.fbCountI_L >= feedbackCount) {
							fbCount = myCh->misc.fbCountI_L;
							tmp = (double)myCh->misc.fbSumI_L / fbCount;
							myCh->misc.fbCountI_L = 0;
							myCh->misc.fbSumI_L = 0;
							if(labs(myCh->misc.fbI) < (long)(maxI * 0.05)) {//5%
								myCh->misc.fbI += (long)(tmp * 0.1);
								val2 += myCh->misc.fbI;
								cCalCmdI(bd, ch, val2, div, rangeI);
							}
						}
					} else {
						myCh->misc.fbCountI_H = 0;
						myCh->misc.fbSumI_H = 0;
						myCh->misc.fbCountI_M = 0;
						myCh->misc.fbSumI_M = 0;
						myCh->misc.fbCountI_L = 0;
						myCh->misc.fbSumI_L = 0;
					}
   					myCh->misc.cvFlag = P0;
					#ifdef _EXTERNAL_CONTROL
					myCh->misc.chCV = P0;
					#endif					
				}
			} else if(mode == CP || mode == CR) {
				//131108 oys add : CP,CR mode cvTime
				if(myCh->op.checkDelayTime < 100) {
					tmpV = val1 - myCh->misc.tmpVsens;
					tmpI = val2 - myCh->misc.tmpIsens;
				} else {
					tmpV = val1 - myCh->op.Vsens;
					tmpI = val2 - myCh->op.Isens;
				}

				if(myPs->config.capacityType == CAPACITY_AMPARE_HOURS) {
					deltaV = (long)(maxV * 0.001); //0.1%
					deltaI = (long)(maxI * 0.0025); //0.25%
				} else {
					deltaV = (long)(maxV * 0.001); //0.1%
					deltaI = (long)(maxI * 0.0025); //0.25%
				}
				if(tmpV > deltaV) {
					cCalCmdI(bd, ch, val2, div, rangeI);
   					myCh->misc.cvFlag = P0;
					#ifdef _EXTERNAL_CONTROL
					myCh->misc.chCV = P0;
					#endif					
					
				}
			}
			break;
		case STEP_DISCHARGE:
			if(mode == CC || mode == CV || mode == CCCV || mode == C_RATE) {
				if(myCh->op.checkDelayTime < 100) {
					tmpV = myCh->misc.tmpVsens - val1;
					tmpI = val2 - myCh->misc.tmpIsens;
				} else {
					tmpV = myCh->op.Vsens - val1;
					tmpI = val2 - myCh->op.Isens;
				}

				//CC Field
				if(myPs->config.capacityType == CAPACITY_AMPARE_HOURS) {
					deltaV = (long)(maxV * 0.001); //0.1%
					deltaI = (long)(maxI * 0.0025); //0.25%
				} else {
					deltaV = (long)(maxV * 0.001); //0.1%
					deltaI = (long)(maxI * 0.0025); //0.25%
				}
				if(tmpV > deltaV) {
					if((labs(tmpI) < (long)(maxI * 0.05)) //5%
						&& (labs(tmpI) > (long)(maxI * 0.001)))	{ //0.1 %
						myCh->misc.fbCountI_H++;
						myCh->misc.fbSumI_H += tmpI;
						myCh->misc.fbCountI_M = 0;
						myCh->misc.fbSumI_M = 0;
						myCh->misc.fbCountI_L = 0;
						myCh->misc.fbSumI_L = 0;

						feedbackCount
							= (long)((100 / myPs->misc.dio_scan_time) * 3);
						if(myCh->misc.fbCountI_H >= feedbackCount) {
							fbCount = myCh->misc.fbCountI_H;
							tmp = (double)myCh->misc.fbSumI_H / fbCount;
							myCh->misc.fbCountI_H = 0;
							myCh->misc.fbSumI_H = 0;
							if(labs(myCh->misc.fbI) < (long)(maxI * 0.05)) {
								myCh->misc.fbI += (long)(tmp * 0.5);
								val2 += myCh->misc.fbI;
								cCalCmdI(bd, ch, val2, div, rangeI);
							}
						}
					} else if((labs(tmpI) <= (long)(maxI * 0.001)) //0.1%
						&& (labs(tmpI) > (long)(maxI * 0.0005))) { //0.05%
						myCh->misc.fbCountI_H = 0;
						myCh->misc.fbSumI_H = 0;
						myCh->misc.fbCountI_M++;
						myCh->misc.fbSumI_M += tmpI;
						myCh->misc.fbCountI_L = 0;
						myCh->misc.fbSumI_L = 0;

						feedbackCount
							= (long)((100 / myPs->misc.dio_scan_time) * 3);
						if(myCh->misc.fbCountI_M >= feedbackCount) {
							fbCount = myCh->misc.fbCountI_M;
							tmp = (double)myCh->misc.fbSumI_M / fbCount;
							myCh->misc.fbCountI_M = 0;
							myCh->misc.fbSumI_M = 0;
							if(labs(myCh->misc.fbI) < (long)(maxI * 0.05)) {
								myCh->misc.fbI += (long)(tmp * 0.3);
								val2 += myCh->misc.fbI;
								cCalCmdI(bd, ch, val2, div, rangeI);
							}
						}
					} else if((labs(tmpI) <= (long)(maxI * 0.0005))) { //0.05%
						myCh->misc.fbCountI_H = 0;
						myCh->misc.fbSumI_H = 0;
						myCh->misc.fbCountI_M = 0;
						myCh->misc.fbSumI_M = 0;
						myCh->misc.fbCountI_L++;
						myCh->misc.fbSumI_L += tmpI;

						feedbackCount
							= (long)((100 / myPs->misc.dio_scan_time) * 5);
						if(myCh->misc.fbCountI_L >= feedbackCount) {
							fbCount = myCh->misc.fbCountI_L;
							tmp = (double)myCh->misc.fbSumI_L / fbCount;
							myCh->misc.fbCountI_L = 0;
							myCh->misc.fbSumI_L = 0;
							if(labs(myCh->misc.fbI) < (long)(maxI * 0.05)) {//5%
								myCh->misc.fbI += (long)(tmp * 0.1);
								val2 += myCh->misc.fbI;
								cCalCmdI(bd, ch, val2, div, rangeI);
							}
						}
					} else {
						myCh->misc.fbCountI_H = 0;
						myCh->misc.fbSumI_H = 0;
						myCh->misc.fbCountI_M = 0;
						myCh->misc.fbSumI_M = 0;
						myCh->misc.fbCountI_L = 0;
						myCh->misc.fbSumI_L = 0;
					}

   					myCh->misc.cvFlag = P0;
					#ifdef _EXTERNAL_CONTROL
					myCh->misc.chCV = P0;
					#endif					
					
				}
			} else if(mode == CP || mode == CR) {
				//131108 oys add : CP,CR mode cvTime
				if(myCh->op.checkDelayTime < 100) {
					tmpV = myCh->misc.tmpVsens - val1;
					tmpI = val2 - myCh->misc.tmpIsens;
				} else {
					tmpV = myCh->op.Vsens - val1;
					tmpI = val2 - myCh->op.Isens;
				}

				if(myPs->config.capacityType == CAPACITY_AMPARE_HOURS) {
					deltaV = (long)(maxV * 0.001); //0.1%
					deltaI = (long)(maxI * 0.0025); //0.25%
				} else {
					deltaV = (long)(maxV * 0.001); //0.1%
					deltaI = (long)(maxI * 0.0025); //0.25%
				}
				if(tmpV > deltaV) {
					cCalCmdI(bd, ch, val2, div, rangeI);
   					myCh->misc.cvFlag = P0;
					#ifdef _EXTERNAL_CONTROL
					myCh->misc.chCV = P0;
					#endif					
					
				}
			}
			break;
		case STEP_Z:
			if(myCh->op.checkDelayTime < 100) {
				tmpV = myCh->misc.tmpVsens - val1;
				tmpI = val2 - myCh->misc.tmpIsens;
			} else {
				tmpV = myCh->op.Vsens - val1;
				tmpI = val2 - myCh->op.Isens;
			}

			//CC Field
			if(tmpV > (long)(maxV * 0.0005)) { //0.05%
				if((labs(tmpI) < (long)(maxI * 0.05)) //5%
					&& (labs(tmpI) > (long)(maxI * 0.001)))	{ //0.1 %
					myCh->misc.fbCountI_H++;
					myCh->misc.fbSumI_H += tmpI;
					myCh->misc.fbCountI_M = 0;
					myCh->misc.fbSumI_M = 0;
					myCh->misc.fbCountI_L = 0;
					myCh->misc.fbSumI_L = 0;

					feedbackCount
						= (long)((100 / myPs->misc.dio_scan_time) * 3);
					if(myCh->misc.fbCountI_H >= feedbackCount) {
						fbCount = myCh->misc.fbCountI_H;
						tmp = (double)myCh->misc.fbSumI_H / fbCount;
						myCh->misc.fbCountI_H = 0;
						myCh->misc.fbSumI_H = 0;
						if(labs(myCh->misc.fbI) < (long)(maxI * 0.05)) {
							myCh->misc.fbI += (long)(tmp * 0.5);
							val2 += myCh->misc.fbI;
							cCalCmdI(bd, ch, val2, div, rangeI);
						}
					}
				} else if((labs(tmpI) <= (long)(maxI * 0.001)) //0.1%
					&& (labs(tmpI) > (long)(maxI * 0.0005))) { //0.05%
					myCh->misc.fbCountI_H = 0;
					myCh->misc.fbSumI_H = 0;
					myCh->misc.fbCountI_M++;
					myCh->misc.fbSumI_M += tmpI;
					myCh->misc.fbCountI_L = 0;
					myCh->misc.fbSumI_L = 0;

					feedbackCount
						= (long)((100 / myPs->misc.dio_scan_time) * 3);
					if(myCh->misc.fbCountI_M >= feedbackCount) {
						fbCount = myCh->misc.fbCountI_M;
						tmp = (double)myCh->misc.fbSumI_M / fbCount;
						myCh->misc.fbCountI_M = 0;
						myCh->misc.fbSumI_M = 0;
						if(labs(myCh->misc.fbI) < (long)(maxI * 0.05)) {
							myCh->misc.fbI += (long)(tmp * 0.3);
							val2 += myCh->misc.fbI;
							cCalCmdI(bd, ch, val2, div, rangeI);
						}
					}
				} else if((labs(tmpI) <= (long)(maxI * 0.0005))) { //0.05%
					myCh->misc.fbCountI_H = 0;
					myCh->misc.fbSumI_H = 0;
					myCh->misc.fbCountI_M = 0;
					myCh->misc.fbSumI_M = 0;
					myCh->misc.fbCountI_L++;
					myCh->misc.fbSumI_L += tmpI;

					feedbackCount
						= (long)((100 / myPs->misc.dio_scan_time) * 5);
					if(myCh->misc.fbCountI_L >= feedbackCount) {
						fbCount = myCh->misc.fbCountI_L;
						tmp = (double)myCh->misc.fbSumI_L / fbCount;
						myCh->misc.fbCountI_L = 0;
						myCh->misc.fbSumI_L = 0;
						if(labs(myCh->misc.fbI) < (long)(maxI * 0.05)) { //5%
							myCh->misc.fbI += (long)(tmp * 0.3);
							val2 += myCh->misc.fbI;
							cCalCmdI(bd, ch, val2, div, rangeI);
						}
					}
				} else {
					myCh->misc.fbCountI_H = 0;
					myCh->misc.fbSumI_H = 0;
					myCh->misc.fbCountI_M = 0;
					myCh->misc.fbSumI_M = 0;
					myCh->misc.fbCountI_L = 0;
					myCh->misc.fbSumI_L = 0;
				}
			}
			break;
		case STEP_USER_PATTERN:
			if(mode == CC || mode == CP) {
				if(myCh->misc.patternPhase != P0) return;
				if(myPs->misc.rt_scan_time <= 2) { //rt_scan_time : 20ms, 10ms
					if(labs(val2) <= (long)(maxI * 0.05)){
						if(myCh->misc.pattern_point_runTime
							<= myPs->misc.rt_scan_time) {
							return;
						} else if(myCh->misc.pattern_point_runTime
									== myPs->misc.rt_scan_time*2) {
					 		cCalCmdI(bd, ch, val2, div, rangeI);
							return;
						}
					}
				}

				if(val2 > 0) {
					tmpV = val1 - myCh->misc.tmpVsens;
					tmpI = val2 - myCh->misc.tmpIsens;
				} else if(val2 < 0) {
					tmpV = myCh->misc.tmpVsens - val1;
					tmpI = val2 - myCh->misc.tmpIsens;
				}

				//CC Field
				if(tmpV > (long)(maxV * 0.0005)) { //0.05%
					if((labs(tmpI) < (long)(maxI * 0.05)) //5%
						&& (labs(tmpI) > (long)(maxI * 0.001)))	{ //0.1%
						myCh->misc.fbCountI_H++;
						myCh->misc.fbSumI_H += tmpI;
						myCh->misc.fbCountI_M = 0;
						myCh->misc.fbSumI_M = 0;
						myCh->misc.fbCountI_L = 0;
						myCh->misc.fbSumI_L = 0;

						feedbackCount
							= (long)((100 / myPs->misc.dio_scan_time) * 3);
						if(myCh->misc.fbCountI_H >= feedbackCount) {
							fbCount = myCh->misc.fbCountI_H;
							tmp = (double)myCh->misc.fbSumI_H / fbCount;
							myCh->misc.fbCountI_H = 0;
							myCh->misc.fbSumI_H = 0;
							if(labs(myCh->misc.fbI) < (long)(maxI * 0.05)) {
								myCh->misc.fbI += (long)(tmp * 0.5);
								val2 += myCh->misc.fbI;
								cCalCmdI(bd, ch, val2, div, rangeI);
							}
						}
					} else if((labs(tmpI) <= (long)(maxI * 0.001)) //0.1%
						&& (labs(tmpI) > (long)(maxI * 0.0005))) { //0.05%
						myCh->misc.fbCountI_H = 0;
						myCh->misc.fbSumI_H = 0;
						myCh->misc.fbCountI_M++;
						myCh->misc.fbSumI_M += tmpI;
						myCh->misc.fbCountI_L = 0;
						myCh->misc.fbSumI_L = 0;

						feedbackCount
							= (long)((100 / myPs->misc.dio_scan_time) * 3);
						if(myCh->misc.fbCountI_M >= feedbackCount) {
							fbCount = myCh->misc.fbCountI_M;
							tmp = (double)myCh->misc.fbSumI_M / fbCount;
							myCh->misc.fbCountI_M = 0;
							myCh->misc.fbSumI_M = 0;
							if(labs(myCh->misc.fbI) < (long)(maxI * 0.05)) {//5%
								myCh->misc.fbI += (long)(tmp * 0.3);
								val2 += myCh->misc.fbI;
								cCalCmdI(bd, ch, val2, div, rangeI);
							}
						}
					} else if((labs(tmpI) <= (long)(maxI * 0.0005))) { //0.05%
						myCh->misc.fbCountI_H = 0;
						myCh->misc.fbSumI_H = 0;
						myCh->misc.fbCountI_M = 0;
						myCh->misc.fbSumI_M = 0;
						myCh->misc.fbCountI_L++;
						myCh->misc.fbSumI_L += tmpI;
						
						feedbackCount
							= (long)((100 / myPs->misc.dio_scan_time) * 5);
						if(myCh->misc.fbCountI_L >= feedbackCount) {
							fbCount = myCh->misc.fbCountI_L;
							tmp = (double)myCh->misc.fbSumI_L / fbCount;
							myCh->misc.fbCountI_L = 0;
							myCh->misc.fbSumI_L = 0;
							if(labs(myCh->misc.fbI) < (long)(maxI * 0.05)) {//5%
								myCh->misc.fbI += (long)(tmp * 0.1);
								val2 += myCh->misc.fbI;
				 				cCalCmdI(bd, ch, val2, div, rangeI);
							}
						}
					} else {
						myCh->misc.fbCountI_H = 0;
						myCh->misc.fbSumI_H = 0;
						myCh->misc.fbCountI_M = 0;
						myCh->misc.fbSumI_M = 0;
						myCh->misc.fbCountI_L = 0;
						myCh->misc.fbSumI_L = 0;
					}
				}
			}
			break;
		case STEP_USER_MAP: //111215 kji add
			if(mode == CC) {
				if(val2 > 0) {
					tmpV = val1 - myCh->misc.tmpVsens;
					tmpI = val2 - myCh->misc.tmpIsens;
				} else if(val2 < 0) {
					tmpV = myCh->misc.tmpVsens - val1;
					tmpI = val2 - myCh->misc.tmpIsens;
				}

				//CC Field
				if(tmpV > (long)(maxV * 0.0005)) { //0.05%
					if((labs(tmpI) < (long)(maxI * 0.05)) //5%
						&& (labs(tmpI) > (long)(maxI * 0.001)))	{ //0.1%
						myCh->misc.fbCountI_H++;
						myCh->misc.fbSumI_H += tmpI;
						myCh->misc.fbCountI_L = 0;
						myCh->misc.fbSumI_L = 0;
						myCh->misc.fbCountI_M = 0;
						myCh->misc.fbSumI_M = 0;

						feedbackCount
							= (long)((100 / myPs->misc.dio_scan_time) * 3);
						if(myCh->misc.fbCountI_H >= feedbackCount) {
							fbCount = myCh->misc.fbCountI_H;
							tmp = (double)myCh->misc.fbSumI_H / fbCount;
							myCh->misc.fbCountI_H = 0;
							myCh->misc.fbSumI_H = 0;
							if(labs(myCh->misc.fbI) < (long)(maxI * 0.05)) {
								myCh->misc.fbI += (long)(tmp * 0.5);
								val2 += myCh->misc.fbI;
			 					cCalCmdI(bd, ch, val2, div, rangeI);
							}
						}
					} else if((labs(tmpI) <= (long)(maxI * 0.001)) //0.1%
						&& (labs(tmpI) > (long)(maxI * 0.0005))) { //0.05%
						myCh->misc.fbCountI_H = 0;
						myCh->misc.fbSumI_H = 0;
						myCh->misc.fbCountI_M++;
						myCh->misc.fbSumI_M += tmpI;
						myCh->misc.fbCountI_L = 0;
						myCh->misc.fbSumI_L = 0;

						feedbackCount
							= (long)((100 / myPs->misc.dio_scan_time) * 3);
						if(myCh->misc.fbCountI_M >= feedbackCount) {
							fbCount = myCh->misc.fbCountI_M;
							tmp = (double)myCh->misc.fbSumI_M / fbCount;
							myCh->misc.fbCountI_M = 0;
							myCh->misc.fbSumI_M = 0;
							if(labs(myCh->misc.fbI) < (long)(maxI * 0.05)) {//5%
								myCh->misc.fbI += (long)(tmp * 0.3);
								val2 += myCh->misc.fbI;
								cCalCmdI(bd, ch, val2, div, rangeI);
							}
						}
					} else if((labs(tmpI) <= (long)(maxI * 0.0005))) { //0.05%
						myCh->misc.fbCountI_H = 0;
						myCh->misc.fbSumI_H = 0;
						myCh->misc.fbCountI_M = 0;
						myCh->misc.fbSumI_M = 0;
						myCh->misc.fbCountI_L++;
						myCh->misc.fbSumI_L += tmpI;
						
						feedbackCount
							= (long)((100 / myPs->misc.dio_scan_time) * 5);
						if(myCh->misc.fbCountI_L >= feedbackCount) {
							fbCount = myCh->misc.fbCountI_L;
							tmp = (double)myCh->misc.fbSumI_L / fbCount;
							myCh->misc.fbCountI_L = 0;
							myCh->misc.fbSumI_L = 0;
							if(labs(myCh->misc.fbI) < (long)(maxI * 0.05)) {//5%
								myCh->misc.fbI += (long)(tmp * 0.1);
								val2 += myCh->misc.fbI;
								cCalCmdI(bd, ch, val2, div, rangeI);
							}
						}
					} else {
						myCh->misc.fbCountI_H = 0;
						myCh->misc.fbSumI_H = 0;
						myCh->misc.fbCountI_M = 0;
						myCh->misc.fbSumI_M = 0;
						myCh->misc.fbCountI_L = 0;
						myCh->misc.fbSumI_L = 0;
					}
				}
			} else if(mode == CP) {
				cCalCmdI(bd, ch, val2, div, rangeI);
			}
			break;
		default:
			break;
	}
}

void cSoftFeedback_3p(int bd, int ch, long val1, long val2, long val3)
{ //kjg_180530
	unsigned char mode, type, checkFlag;
	int rangeV, rangeI, div = 5, parallel_ch;
	unsigned int fbCount;
	long tmpV=0, tmpI=0, maxV, maxI, deltaV=0, deltaI=0, parallel_val2;
	long p_val2;
	unsigned long advStepNo, feedbackCount = 0;
	double tmp;
	S_CH_STEP_INFO step;

	step = step_info(bd, ch);

    advStepNo = step.advStepNo;
	rangeV = step.rangeV;
	rangeI = step.rangeI;
	type = step.type;
	mode = step.mode;

	maxV = myPs->config.maxVoltage[rangeV];
//	maxI = myPs->config.maxCurrent[rangeI];
	maxI = myPs->config.maxCurrent[rangeI] * 2;
	p_val2 = val2 * 2;	//200819 lyhw

	if((ch % 2) == 0) {
		parallel_ch = ch + 1;
	} else {
		parallel_ch = ch - 1;
	}
	parallel_val2 = myData->bData[bd].cData[ch].misc.parallel_val2;

	switch(type) { //20180417 add for Cvtime
		case STEP_CHARGE:
			if(myCh->op.checkDelayTime < 100) {
				tmpV = val1 - myCh->misc.tmpVsens;
				tmpI = p_val2 - myCh->misc.tmpIsens;
			} else {
				tmpV = val1 - myCh->op.Vsens;
				tmpI = p_val2 - myCh->op.Isens;
			}

			//CC Field
			deltaV = (long)(maxV * 0.001);
			deltaI = (long)(maxI * 0.0025);

			//Check CV Flag
			if(tmpV < deltaV) {
				if(tmpI > deltaI) {
					myCh->misc.cvFlag = P1;
   					myCh->misc.cvFaultCheckFlag = P1; //210204
					#ifdef _EXTERNAL_CONTROL
					myCh->misc.chCV = P1;
					#endif					
				}
			}
			break;
		case STEP_DISCHARGE:
			if(myCh->op.checkDelayTime < 100) {
				tmpV = myCh->misc.tmpVsens - val1;
				tmpI = p_val2 - myCh->misc.tmpIsens;
			} else {
				tmpV = myCh->op.Vsens - val1;
				tmpI = p_val2 - myCh->op.Isens;
			}

			//CC Field
			deltaV = (long)(maxV * 0.001);
			deltaI = (long)(maxI * 0.0025);

			//Check CV Flag
			if(tmpV < deltaV) {
				if(labs(tmpI) > deltaI) {
					myCh->misc.cvFlag = P1;
   					myCh->misc.cvFaultCheckFlag = P1; //210204
					#ifdef _EXTERNAL_CONTROL
					myCh->misc.chCV = P1;
					#endif					
				}
			}
			break;
		default:
			break;
	}

	if(labs(val2) >= maxI * 0.05) { //5%
		checkFlag = 1;
	} else {
		checkFlag = 2;
	}

	if(myCh->misc.feedback_start == P1) {
		myCh->misc.feedback_delayTime += myPs->misc.rt_scan_time;
	} else {
		myCh->misc.feedback_delayTime = 0;
		myCh->misc.fbCountI_H = 0;
		myCh->misc.fbSumI_H = 0;
		myCh->misc.fbSumI_M = 0;
		myCh->misc.fbCountI_M = 0;
		myCh->misc.fbSumI_L = 0;
		myCh->misc.fbCountI_L = 0;
	}

	if(labs(myCh->misc.tmpIsens) >= val2 * 0.95) {
		myCh->misc.feedback_start = P1;
	}

	if(type != STEP_USER_PATTERN) {
		if(mode != CP && mode != CPCV) {
			if(checkFlag == 2) {
				if(myCh->misc.feedback_delayTime < 100) return;
			} else {
				if(myCh->misc.feedback_delayTime < 5) return;
			}
		} else {
			if(myCh->op.checkDelayTime < 2) return;
		}
	}

	switch(type) {
		case STEP_CHARGE:
			if(mode == CC || mode == CV || mode == CCCV || mode == C_RATE) {
				if(myCh->op.checkDelayTime < 100) {
					tmpV = val1 - myCh->misc.tmpVsens;
					tmpI = p_val2 - myCh->misc.tmpIsens;
				} else {
					tmpV = val1 - myCh->op.Vsens;
					tmpI = p_val2 - myCh->op.Isens;
				}

				//CC Field
				if(myPs->config.capacityType == CAPACITY_AMPARE_HOURS) {
					deltaV = (long)(maxV * 0.001); //0.1% 20180418
					deltaI = (long)(maxI * 0.0025); //0.25%
				} else {
					deltaV = (long)(maxV * 0.001); //0.1%
					deltaI = (long)(maxI * 0.0025); //0.25%
				}

				if(tmpV > deltaV) {
					if((labs(tmpI) < (long)(maxI * 0.05)) //5%
						&& (labs(tmpI) > (long)(maxI * 0.001)))	{ //0.1%
						myCh->misc.fbCountI_H++;
						myCh->misc.fbSumI_H += tmpI;
						myCh->misc.fbCountI_M = 0;
						myCh->misc.fbSumI_M = 0;
						myCh->misc.fbCountI_L = 0;
						myCh->misc.fbSumI_L = 0;
						
						feedbackCount
							= (long)((100 / myPs->misc.dio_scan_time) * 3);
						if(myCh->misc.fbCountI_H >= feedbackCount) {
							fbCount = myCh->misc.fbCountI_H;
							tmp = (double)myCh->misc.fbSumI_H / fbCount;
							myCh->misc.fbCountI_H = 0;
							myCh->misc.fbSumI_H = 0;
							if(labs(myCh->misc.fbI) < (long)(maxI * 0.05)) {
								myCh->misc.fbI += (long)(tmp * 0.5);
								val2 += myCh->misc.fbI;
								cCalCmdI(bd, ch, val2, div, rangeI);
							}
						}
					} else if((labs(tmpI) <= (long)(maxI * 0.001)) //0.1%
						&& (labs(tmpI) > (long)(maxI * 0.0005))) { //0.05%
						myCh->misc.fbCountI_H = 0;
						myCh->misc.fbSumI_H = 0;
						myCh->misc.fbCountI_M++;
						myCh->misc.fbSumI_M += tmpI;
						myCh->misc.fbCountI_L = 0;
						myCh->misc.fbSumI_L = 0;
					
						feedbackCount
							= (long)((100 / myPs->misc.dio_scan_time) * 3);
						if(myCh->misc.fbCountI_M >= feedbackCount) {
							fbCount = myCh->misc.fbCountI_M;
							tmp = (double)myCh->misc.fbSumI_M / fbCount;
							myCh->misc.fbCountI_M = 0;
							myCh->misc.fbSumI_M = 0;
							if(labs(myCh->misc.fbI) < (long)(maxI * 0.05)) {//3%
								myCh->misc.fbI += (long)(tmp * 0.3);
								val2 += myCh->misc.fbI;
								cCalCmdI(bd, ch, val2, div, rangeI);
							}
						}
					} else if((labs(tmpI) <= (long)(maxI * 0.0005))) { //0.05%
						myCh->misc.fbCountI_M = 0;
						myCh->misc.fbSumI_M = 0;
						myCh->misc.fbCountI_H = 0;
						myCh->misc.fbSumI_H = 0;
						myCh->misc.fbCountI_L++;
						myCh->misc.fbSumI_L += tmpI;
					
						feedbackCount
							= (long)((100 / myPs->misc.dio_scan_time) * 5);
						if(myCh->misc.fbCountI_L >= feedbackCount) {
							fbCount = myCh->misc.fbCountI_L;
							tmp = (double)myCh->misc.fbSumI_L / fbCount;
							myCh->misc.fbCountI_L = 0;
							myCh->misc.fbSumI_L = 0;
							if(labs(myCh->misc.fbI) < (long)(maxI * 0.05)) {//5%
								myCh->misc.fbI += (long)(tmp * 0.1);
								val2 += myCh->misc.fbI;
								cCalCmdI(bd, ch, val2, div, rangeI);
							}
						}
					} else {
						myCh->misc.fbCountI_H = 0;
						myCh->misc.fbSumI_H = 0;
						myCh->misc.fbCountI_M = 0;
						myCh->misc.fbSumI_M = 0;
						myCh->misc.fbCountI_L = 0;
						myCh->misc.fbSumI_L = 0;
					}
   					myCh->misc.cvFlag = P0;
					#ifdef _EXTERNAL_CONTROL
					myCh->misc.chCV = P0;
					#endif					
					
				}
			} else if(mode == CP || mode == CR) {
				//131108 oys add : CP,CR mode cvTime
				if(myCh->op.checkDelayTime < 100) {
					tmpV = val1 - myCh->misc.tmpVsens;
					tmpI = p_val2 - myCh->misc.tmpIsens;
				} else {
					tmpV = val1 - myCh->op.Vsens;
					tmpI = p_val2 - myCh->op.Isens;
				}

				if(myPs->config.capacityType == CAPACITY_AMPARE_HOURS) {
					deltaV = (long)(maxV * 0.001); //0.1%
					deltaI = (long)(maxI * 0.0025); //0.25%
				} else {
					deltaV = (long)(maxV * 0.001); //0.1%
					deltaI = (long)(maxI * 0.0025); //0.25%
				}
				if(tmpV > deltaV) {
					cCalCmdI(bd, ch, val2, div, rangeI);
					cCalCmdI_p(bd, parallel_ch, parallel_val2, div, rangeI);
   					myCh->misc.cvFlag = P0;
					#ifdef _EXTERNAL_CONTROL
					myCh->misc.chCV = P0;
					#endif					
					
				}
			}
			break;
		case STEP_DISCHARGE:
			if(mode == CC || mode == CV || mode == CCCV || mode == C_RATE) {
				if(myCh->op.checkDelayTime < 100) {
					tmpV = myCh->misc.tmpVsens - val1;
					tmpI = p_val2 - myCh->misc.tmpIsens;
				} else {
					tmpV = myCh->op.Vsens - val1;
					tmpI = p_val2 - myCh->op.Isens;
				}

				//CC Field
				if(myPs->config.capacityType == CAPACITY_AMPARE_HOURS) {
					deltaV = (long)(maxV * 0.001); //0.1%
					deltaI = (long)(maxI * 0.0025); //0.25%
				} else {
					deltaV = (long)(maxV * 0.001); //0.1%
					deltaI = (long)(maxI * 0.0025); //0.25%
				}
				if(tmpV > deltaV) {
					if((labs(tmpI) < (long)(maxI * 0.05)) //5%
						&& (labs(tmpI) > (long)(maxI * 0.001)))	{ //0.1 %
						myCh->misc.fbCountI_H++;
						myCh->misc.fbSumI_H += tmpI;
						myCh->misc.fbCountI_M = 0;
						myCh->misc.fbSumI_M = 0;
						myCh->misc.fbCountI_L = 0;
						myCh->misc.fbSumI_L = 0;

						feedbackCount
							= (long)((100 / myPs->misc.dio_scan_time) * 3);
						if(myCh->misc.fbCountI_H >= feedbackCount) {
							fbCount = myCh->misc.fbCountI_H;
							tmp = (double)myCh->misc.fbSumI_H / fbCount;
							myCh->misc.fbCountI_H = 0;
							myCh->misc.fbSumI_H = 0;
							if(labs(myCh->misc.fbI) < (long)(maxI * 0.05)) {
								myCh->misc.fbI += (long)(tmp * 0.5);
								val2 += myCh->misc.fbI;
								cCalCmdI(bd, ch, val2, div, rangeI);
							}
						}
					} else if((labs(tmpI) <= (long)(maxI * 0.001)) //0.1%
						&& (labs(tmpI) > (long)(maxI * 0.0005))) { //0.05%
						myCh->misc.fbCountI_H = 0;
						myCh->misc.fbSumI_H = 0;
						myCh->misc.fbCountI_M++;
						myCh->misc.fbSumI_M += tmpI;
						myCh->misc.fbCountI_L = 0;
						myCh->misc.fbSumI_L = 0;

						feedbackCount
							= (long)((100 / myPs->misc.dio_scan_time) * 3);
						if(myCh->misc.fbCountI_M >= feedbackCount) {
							fbCount = myCh->misc.fbCountI_M;
							tmp = (double)myCh->misc.fbSumI_M / fbCount;
							myCh->misc.fbCountI_M = 0;
							myCh->misc.fbSumI_M = 0;
							if(labs(myCh->misc.fbI) < (long)(maxI * 0.05)) {
								myCh->misc.fbI += (long)(tmp * 0.3);
								val2 += myCh->misc.fbI;
								cCalCmdI(bd, ch, val2, div, rangeI);
							}
						}
					} else if((labs(tmpI) <= (long)(maxI * 0.0005))) { //0.05%
						myCh->misc.fbCountI_H = 0;
						myCh->misc.fbSumI_H = 0;
						myCh->misc.fbCountI_M = 0;
						myCh->misc.fbSumI_M = 0;
						myCh->misc.fbCountI_L++;
						myCh->misc.fbSumI_L += tmpI;

						feedbackCount
							= (long)((100 / myPs->misc.dio_scan_time) * 5);
						if(myCh->misc.fbCountI_L >= feedbackCount) {
							fbCount = myCh->misc.fbCountI_L;
							tmp = (double)myCh->misc.fbSumI_L / fbCount;
							myCh->misc.fbCountI_L = 0;
							myCh->misc.fbSumI_L = 0;
							if(labs(myCh->misc.fbI) < (long)(maxI * 0.05)) {//5%
								myCh->misc.fbI += (long)(tmp * 0.1);
								val2 += myCh->misc.fbI;
								cCalCmdI(bd, ch, val2, div, rangeI);
							}
						}
					} else {
						myCh->misc.fbCountI_H = 0;
						myCh->misc.fbSumI_H = 0;
						myCh->misc.fbCountI_M = 0;
						myCh->misc.fbSumI_M = 0;
						myCh->misc.fbCountI_L = 0;
						myCh->misc.fbSumI_L = 0;
					}

   					myCh->misc.cvFlag = P0;
					#ifdef _EXTERNAL_CONTROL
					myCh->misc.chCV = P0;
					#endif					
					
				}
			} else if(mode == CP || mode == CR) {
				//131108 oys add : CP,CR mode cvTime
				if(myCh->op.checkDelayTime < 100) {
					tmpV = myCh->misc.tmpVsens - val1;
					tmpI = p_val2 - myCh->misc.tmpIsens;
				} else {
					tmpV = myCh->op.Vsens - val1;
					tmpI = p_val2 - myCh->op.Isens;
				}

				if(myPs->config.capacityType == CAPACITY_AMPARE_HOURS) {
					deltaV = (long)(maxV * 0.001); //0.1%
					deltaI = (long)(maxI * 0.0025); //0.25%
				} else {
					deltaV = (long)(maxV * 0.001); //0.1%
					deltaI = (long)(maxI * 0.0025); //0.25%
				}
				if(tmpV > deltaV) {
					cCalCmdI(bd, ch, val2, div, rangeI);
					cCalCmdI_p(bd, parallel_ch, parallel_val2, div, rangeI);
   					myCh->misc.cvFlag = P0;
					#ifdef _EXTERNAL_CONTROL
					myCh->misc.chCV = P0;
					#endif					
					
				}
			}
			break;
		case STEP_Z:
			if(myCh->op.checkDelayTime < 100) {
				tmpV = myCh->misc.tmpVsens - val1;
				tmpI = p_val2 - myCh->misc.tmpIsens;
			} else {
				tmpV = myCh->op.Vsens - val1;
				tmpI = p_val2 - myCh->op.Isens;
			}

			//CC Field
			if(tmpV > (long)(maxV * 0.0005)) { //0.05%
				if((labs(tmpI) < (long)(maxI * 0.05)) //5%
					&& (labs(tmpI) > (long)(maxI * 0.001)))	{ //0.1 %
					myCh->misc.fbCountI_H++;
					myCh->misc.fbSumI_H += tmpI;
					myCh->misc.fbCountI_M = 0;
					myCh->misc.fbSumI_M = 0;
					myCh->misc.fbCountI_L = 0;
					myCh->misc.fbSumI_L = 0;

					feedbackCount
						= (long)((100 / myPs->misc.dio_scan_time) * 3);
					if(myCh->misc.fbCountI_H >= feedbackCount) {
						fbCount = myCh->misc.fbCountI_H;
						tmp = (double)myCh->misc.fbSumI_H / fbCount;
						myCh->misc.fbCountI_H = 0;
						myCh->misc.fbSumI_H = 0;
						if(labs(myCh->misc.fbI) < (long)(maxI * 0.05)) {
							myCh->misc.fbI += (long)(tmp * 0.5);
							val2 += myCh->misc.fbI;
							cCalCmdI(bd, ch, val2, div, rangeI);
						}
					}
				} else if((labs(tmpI) <= (long)(maxI * 0.001)) //0.1%
					&& (labs(tmpI) > (long)(maxI * 0.0005))) { //0.05%
					myCh->misc.fbCountI_H = 0;
					myCh->misc.fbSumI_H = 0;
					myCh->misc.fbCountI_M++;
					myCh->misc.fbSumI_M += tmpI;
					myCh->misc.fbCountI_L = 0;
					myCh->misc.fbSumI_L = 0;

					feedbackCount
						= (long)((100 / myPs->misc.dio_scan_time) * 3);
					if(myCh->misc.fbCountI_M >= feedbackCount) {
						fbCount = myCh->misc.fbCountI_M;
						tmp = (double)myCh->misc.fbSumI_M / fbCount;
						myCh->misc.fbCountI_M = 0;
						myCh->misc.fbSumI_M = 0;
						if(labs(myCh->misc.fbI) < (long)(maxI * 0.05)) {
							myCh->misc.fbI += (long)(tmp * 0.3);
							val2 += myCh->misc.fbI;
							cCalCmdI(bd, ch, val2, div, rangeI);
						}
					}
				} else if((labs(tmpI) <= (long)(maxI * 0.0005))) { //0.05%
					myCh->misc.fbCountI_H = 0;
					myCh->misc.fbSumI_H = 0;
					myCh->misc.fbCountI_M = 0;
					myCh->misc.fbSumI_M = 0;
					myCh->misc.fbCountI_L++;
					myCh->misc.fbSumI_L += tmpI;

					feedbackCount
						= (long)((100 / myPs->misc.dio_scan_time) * 5);
					if(myCh->misc.fbCountI_L >= feedbackCount) {
						fbCount = myCh->misc.fbCountI_L;
						tmp = (double)myCh->misc.fbSumI_L / fbCount;
						myCh->misc.fbCountI_L = 0;
						myCh->misc.fbSumI_L = 0;
						if(labs(myCh->misc.fbI) < (long)(maxI * 0.05)) { //5%
							myCh->misc.fbI += (long)(tmp * 0.3);
							val2 += myCh->misc.fbI;
							cCalCmdI(bd, ch, val2, div, rangeI);
						}
					}
				} else {
					myCh->misc.fbCountI_H = 0;
					myCh->misc.fbSumI_H = 0;
					myCh->misc.fbCountI_M = 0;
					myCh->misc.fbSumI_M = 0;
					myCh->misc.fbCountI_L = 0;
					myCh->misc.fbSumI_L = 0;
				}
			}
			break;
		case STEP_USER_PATTERN:
			if(mode == CC || mode == CP) {
				if(myCh->misc.patternPhase != P0) return;
				if(myPs->misc.rt_scan_time <= 2) { //rt_scan_time : 20ms, 10ms
					if(labs(val2) <= (long)(maxI * 0.05)){
						if(myCh->misc.pattern_point_runTime
							<= myPs->misc.rt_scan_time) {
							return;
						} else if(myCh->misc.pattern_point_runTime
									== myPs->misc.rt_scan_time*2) {
					 		cCalCmdI(bd, ch, val2, div, rangeI);
							cCalCmdI_p(bd, parallel_ch, parallel_val2, div, rangeI);
							return;
						}
					}
				}

				if(val2 > 0) {
					tmpV = val1 - myCh->misc.tmpVsens;
					tmpI = val2 - myCh->misc.tmpIsens;
				} else if(val2 < 0) {
					tmpV = myCh->misc.tmpVsens - val1;
					tmpI = val2 - myCh->misc.tmpIsens;
				}

				//CC Field
				if(tmpV > (long)(maxV * 0.0005)) { //0.05%
					if((labs(tmpI) < (long)(maxI * 0.05)) //5%
						&& (labs(tmpI) > (long)(maxI * 0.001)))	{ //0.1%
						myCh->misc.fbCountI_H++;
						myCh->misc.fbSumI_H += tmpI;
						myCh->misc.fbCountI_M = 0;
						myCh->misc.fbSumI_M = 0;
						myCh->misc.fbCountI_L = 0;
						myCh->misc.fbSumI_L = 0;

						feedbackCount
							= (long)((100 / myPs->misc.dio_scan_time) * 3);
						if(myCh->misc.fbCountI_H >= feedbackCount) {
							fbCount = myCh->misc.fbCountI_H;
							tmp = (double)myCh->misc.fbSumI_H / fbCount;
							myCh->misc.fbCountI_H = 0;
							myCh->misc.fbSumI_H = 0;
							if(labs(myCh->misc.fbI) < (long)(maxI * 0.05)) {
								myCh->misc.fbI += (long)(tmp * 0.5);
								val2 += myCh->misc.fbI;
								cCalCmdI(bd, ch, val2, div, rangeI);
								cCalCmdI_p(bd, parallel_ch, parallel_val2, div, rangeI);
							}
						}
					} else if((labs(tmpI) <= (long)(maxI * 0.001)) //0.1%
						&& (labs(tmpI) > (long)(maxI * 0.0005))) { //0.05%
						myCh->misc.fbCountI_H = 0;
						myCh->misc.fbSumI_H = 0;
						myCh->misc.fbCountI_M++;
						myCh->misc.fbSumI_M += tmpI;
						myCh->misc.fbCountI_L = 0;
						myCh->misc.fbSumI_L = 0;

						feedbackCount
							= (long)((100 / myPs->misc.dio_scan_time) * 3);
						if(myCh->misc.fbCountI_M >= feedbackCount) {
							fbCount = myCh->misc.fbCountI_M;
							tmp = (double)myCh->misc.fbSumI_M / fbCount;
							myCh->misc.fbCountI_M = 0;
							myCh->misc.fbSumI_M = 0;
							if(labs(myCh->misc.fbI) < (long)(maxI * 0.05)) {//5%
								myCh->misc.fbI += (long)(tmp * 0.3);
								val2 += myCh->misc.fbI;
								cCalCmdI(bd, ch, val2, div, rangeI);
								cCalCmdI_p(bd, parallel_ch, parallel_val2, div, rangeI);
							}
						}
					} else if((labs(tmpI) <= (long)(maxI * 0.0005))) { //0.05%
						myCh->misc.fbCountI_H = 0;
						myCh->misc.fbSumI_H = 0;
						myCh->misc.fbCountI_M = 0;
						myCh->misc.fbSumI_M = 0;
						myCh->misc.fbCountI_L++;
						myCh->misc.fbSumI_L += tmpI;
						
						feedbackCount
							= (long)((100 / myPs->misc.dio_scan_time) * 5);
						if(myCh->misc.fbCountI_L >= feedbackCount) {
							fbCount = myCh->misc.fbCountI_L;
							tmp = (double)myCh->misc.fbSumI_L / fbCount;
							myCh->misc.fbCountI_L = 0;
							myCh->misc.fbSumI_L = 0;
							if(labs(myCh->misc.fbI) < (long)(maxI * 0.05)) {//5%
								myCh->misc.fbI += (long)(tmp * 0.1);
								val2 += myCh->misc.fbI;
				 				cCalCmdI(bd, ch, val2, div, rangeI);
								cCalCmdI_p(bd, parallel_ch, parallel_val2, div, rangeI);
							}
						}
					} else {
						myCh->misc.fbCountI_H = 0;
						myCh->misc.fbSumI_H = 0;
						myCh->misc.fbCountI_M = 0;
						myCh->misc.fbSumI_M = 0;
						myCh->misc.fbCountI_L = 0;
						myCh->misc.fbSumI_L = 0;
					}
				}
			}
			break;
		case STEP_USER_MAP: //111215 kji add
			if(mode == CC) {
				if(val2 > 0) {
					tmpV = val1 - myCh->misc.tmpVsens;
					tmpI = val2 - myCh->misc.tmpIsens;
				} else if(val2 < 0) {
					tmpV = myCh->misc.tmpVsens - val1;
					tmpI = val2 - myCh->misc.tmpIsens;
				}

				//CC Field
				if(tmpV > (long)(maxV * 0.0005)) { //0.05%
					if((labs(tmpI) < (long)(maxI * 0.05)) //5%
						&& (labs(tmpI) > (long)(maxI * 0.001)))	{ //0.1%
						myCh->misc.fbCountI_H++;
						myCh->misc.fbSumI_H += tmpI;
						myCh->misc.fbCountI_L = 0;
						myCh->misc.fbSumI_L = 0;
						myCh->misc.fbCountI_M = 0;
						myCh->misc.fbSumI_M = 0;

						feedbackCount
							= (long)((100 / myPs->misc.dio_scan_time) * 3);
						if(myCh->misc.fbCountI_H >= feedbackCount) {
							fbCount = myCh->misc.fbCountI_H;
							tmp = (double)myCh->misc.fbSumI_H / fbCount;
							myCh->misc.fbCountI_H = 0;
							myCh->misc.fbSumI_H = 0;
							if(labs(myCh->misc.fbI) < (long)(maxI * 0.05)) {
								myCh->misc.fbI += (long)(tmp * 0.5);
								val2 += myCh->misc.fbI;
			 					cCalCmdI(bd, ch, val2, div, rangeI);
							}
						}
					} else if((labs(tmpI) <= (long)(maxI * 0.001)) //0.1%
						&& (labs(tmpI) > (long)(maxI * 0.0005))) { //0.05%
						myCh->misc.fbCountI_H = 0;
						myCh->misc.fbSumI_H = 0;
						myCh->misc.fbCountI_M++;
						myCh->misc.fbSumI_M += tmpI;
						myCh->misc.fbCountI_L = 0;
						myCh->misc.fbSumI_L = 0;

						feedbackCount
							= (long)((100 / myPs->misc.dio_scan_time) * 3);
						if(myCh->misc.fbCountI_M >= feedbackCount) {
							fbCount = myCh->misc.fbCountI_M;
							tmp = (double)myCh->misc.fbSumI_M / fbCount;
							myCh->misc.fbCountI_M = 0;
							myCh->misc.fbSumI_M = 0;
							if(labs(myCh->misc.fbI) < (long)(maxI * 0.05)) {//5%
								myCh->misc.fbI += (long)(tmp * 0.3);
								val2 += myCh->misc.fbI;
								cCalCmdI(bd, ch, val2, div, rangeI);
							}
						}
					} else if((labs(tmpI) <= (long)(maxI * 0.0005))) { //0.05%
						myCh->misc.fbCountI_H = 0;
						myCh->misc.fbSumI_H = 0;
						myCh->misc.fbCountI_M = 0;
						myCh->misc.fbSumI_M = 0;
						myCh->misc.fbCountI_L++;
						myCh->misc.fbSumI_L += tmpI;
						
						feedbackCount
							= (long)((100 / myPs->misc.dio_scan_time) * 5);
						if(myCh->misc.fbCountI_L >= feedbackCount) {
							fbCount = myCh->misc.fbCountI_L;
							tmp = (double)myCh->misc.fbSumI_L / fbCount;
							myCh->misc.fbCountI_L = 0;
							myCh->misc.fbSumI_L = 0;
							if(labs(myCh->misc.fbI) < (long)(maxI * 0.05)) {//5%
								myCh->misc.fbI += (long)(tmp * 0.1);
								val2 += myCh->misc.fbI;
								cCalCmdI(bd, ch, val2, div, rangeI);
							}
						}
					} else {
						myCh->misc.fbCountI_H = 0;
						myCh->misc.fbSumI_H = 0;
						myCh->misc.fbCountI_M = 0;
						myCh->misc.fbSumI_M = 0;
						myCh->misc.fbCountI_L = 0;
						myCh->misc.fbSumI_L = 0;
					}
				}
			} else if(mode == CP) {
				cCalCmdI(bd, ch, val2, div, rangeI);
				cCalCmdI_p(bd, parallel_ch, parallel_val2, div, rangeI);
			}
			break;
		default:
			break;
	}
}

void cSoftFeedback_4(int bd, int ch, long val1, long val2, long val3)
{
	unsigned char mode, type, checkFlag;
	int rangeV, rangeI, div = 5;
	unsigned int fbCount;
	long tmpV=0, tmpI=0, maxV, maxI, deltaV=0, deltaI=0;
	unsigned long advStepNo, feedbackCount = 0;
	double tmp;
	S_CH_STEP_INFO step;

	step = step_info(bd, ch);

    advStepNo = step.advStepNo;
	rangeV = step.rangeV;
	rangeI = step.rangeI;
	type = step.type;
	mode = step.mode;

	maxV = myPs->config.maxVoltage[rangeV];
	maxI = myPs->config.maxCurrent[rangeI];

	if(labs(val2) >= maxI * 0.1) { //10%
		checkFlag = 1;
	} else {
		checkFlag = 2;
	}

	if(myCh->misc.feedback_start == P1) {
		myCh->misc.feedback_delayTime += myPs->misc.rt_scan_time;
	} else {
		myCh->misc.feedback_delayTime = 0;
		myCh->misc.fbCountI_H = 0;
		myCh->misc.fbSumI_H = 0;
		myCh->misc.fbSumI_M = 0;
		myCh->misc.fbCountI_M = 0;
		myCh->misc.fbSumI_L = 0;
		myCh->misc.fbCountI_L = 0;
	}

	if(labs(myCh->misc.tmpIsens) >= labs(val2 * 0.95)) {
		myCh->misc.feedback_start = P1;
	}

	if(type != STEP_USER_PATTERN) {
		if(mode != CP && mode != CPCV) {
			if(checkFlag == 2) {
				if(myCh->misc.feedback_delayTime < 100) return;
			} else {
				if(myCh->misc.feedback_delayTime < 5) return;
			}
		} else {
			if(myCh->op.checkDelayTime < 2) return;
		}
	}

	switch(type) {
		case STEP_CHARGE:
			if(mode == CC || mode == CV || mode == CCCV || mode == C_RATE) {
				if(myCh->op.checkDelayTime < 300) {
					tmpV = val1 - myCh->misc.tmpVsens;
					tmpI = val2 - myCh->misc.tmpIsens;
				} else {
					tmpV = val1 - myCh->op.Vsens;
					tmpI = val2 - myCh->op.Isens;
				}

				//CC Field
				if(myPs->config.capacityType == CAPACITY_AMPARE_HOURS) {
					deltaV = (long)(maxV * 0.001); //0.1% 20180418
					deltaI = (long)(maxI * 0.0025); //0.25%
				} else {
					deltaV = (long)(maxV * 0.001); //0.1% 20180418
					deltaI = (long)(maxI * 0.0025); //0.25%
				}
				if(tmpV > deltaV) {
					if((labs(tmpI) < (long)(maxI * 0.05)) //5%
						&& (labs(tmpI) > (long)(maxI * 0.001)))	{ //0.1%
						myCh->misc.fbCountI_H++;
						myCh->misc.fbSumI_H += tmpI;
						myCh->misc.fbCountI_M = 0;
						myCh->misc.fbSumI_M = 0;
						myCh->misc.fbCountI_L = 0;
						myCh->misc.fbSumI_L = 0;
						
						feedbackCount
							= (long)((100 / myPs->misc.dio_scan_time) * 3);
						if(myCh->misc.fbCountI_H >= feedbackCount) {
							fbCount = myCh->misc.fbCountI_H;
							tmp = (double)myCh->misc.fbSumI_H / fbCount;
							myCh->misc.fbCountI_H = 0;
							myCh->misc.fbSumI_H = 0;
							if(labs(myCh->misc.fbI) < (long)(maxI * 0.05)) {
								myCh->misc.fbI += (long)(tmp * 0.2);
								val2 += myCh->misc.fbI;
								cCalCmdI(bd, ch, val2, div, rangeI);
							}
						}
					} else if((labs(tmpI) <= (long)(maxI * 0.001)) //0.1%
						&& (labs(tmpI) > (long)(maxI * 0.0005))) { //0.05 %
						myCh->misc.fbCountI_H = 0;
						myCh->misc.fbSumI_H = 0;
						myCh->misc.fbCountI_M++;
						myCh->misc.fbSumI_M += tmpI;
						myCh->misc.fbCountI_L = 0;
						myCh->misc.fbSumI_L = 0;
					
						feedbackCount
							= (long)((100 / myPs->misc.dio_scan_time) * 1);
						if(myCh->misc.fbCountI_M >= feedbackCount) {
							fbCount = myCh->misc.fbCountI_M;
							tmp = (double)myCh->misc.fbSumI_M / fbCount;
							myCh->misc.fbCountI_M = 0;
							myCh->misc.fbSumI_M = 0;
							if(labs(myCh->misc.fbI) < (long)(maxI * 0.05)) {//3%
								myCh->misc.fbI += (long)(tmp * 0.3);
								val2 += myCh->misc.fbI;
								cCalCmdI(bd, ch, val2, div, rangeI);
							}
						}
					} else if((labs(tmpI) <= (long)(maxI * 0.0005))) { //0.05%
						myCh->misc.fbCountI_H = 0;
						myCh->misc.fbSumI_H = 0;
						myCh->misc.fbCountI_M = 0;
						myCh->misc.fbSumI_M = 0;
						myCh->misc.fbCountI_L++;
						myCh->misc.fbSumI_L += tmpI;

						feedbackCount
							= (long)((100 / myPs->misc.dio_scan_time) * 1);
						if(myCh->misc.fbCountI_L >= feedbackCount) {
							fbCount = myCh->misc.fbCountI_L;
							tmp = (double)myCh->misc.fbSumI_L / fbCount;
							myCh->misc.fbCountI_L = 0;
							myCh->misc.fbSumI_L = 0;
							if(labs(myCh->misc.fbI) < (long)(maxI * 0.05)) {//5%
								myCh->misc.fbI += (long)(tmp * 0.5);
								val2 += myCh->misc.fbI;
								cCalCmdI(bd, ch, val2, div, rangeI);
							}
						}
					} else {
						myCh->misc.fbCountI_H = 0;
						myCh->misc.fbSumI_H = 0;
						myCh->misc.fbCountI_M = 0;
						myCh->misc.fbSumI_M = 0;
						myCh->misc.fbCountI_L = 0;
						myCh->misc.fbSumI_L = 0;
					}

   					myCh->misc.cvFlag = P0;
					#ifdef _EXTERNAL_CONTROL
					myCh->misc.chCV = P0;
					#endif					
					
				} else {
					if(tmpI > deltaI) {
   						myCh->misc.cvFlag = P1;
						#ifdef _EXTERNAL_CONTROL
						myCh->misc.chCV = P1;
						#endif						
					}
				}
			} else if(mode == CP || mode == CR) {
				//131108 oys add : CP, CR mode cvTime
				if(myCh->op.checkDelayTime < 100) {
					tmpV = val1 - myCh->misc.tmpVsens;
					tmpI = val2 - myCh->misc.tmpIsens;
				} else {
					tmpV = val1 - myCh->op.Vsens;
					tmpI = val2 - myCh->op.Isens;
				}

				if(myPs->config.capacityType == CAPACITY_AMPARE_HOURS) {
					deltaV = (long)(maxV * 0.001); //0.1% 20180418
					deltaI = (long)(maxI * 0.0025); //0.25%
				} else {
					deltaV = (long)(maxV * 0.001); //0.1% 20180418
					deltaI = (long)(maxI * 0.0025); //0.25%
				}
				if(tmpV > deltaV) {
					cCalCmdI(bd, ch, val2, div, rangeI);
   					myCh->misc.cvFlag = P0;
					#ifdef _EXTERNAL_CONTROL
					myCh->misc.chCV = P0;
					#endif										
				} else {
					if(tmpI > deltaI) {
   						myCh->misc.cvFlag = P1;
						#ifdef _EXTERNAL_CONTROL
						myCh->misc.chCV = P1;
						#endif						
					}
				}
			}
			break;
		case STEP_DISCHARGE:
			if(mode == CC || mode == CV || mode == CCCV || mode == C_RATE) {
				if(myCh->op.checkDelayTime < 300) {
					tmpV = myCh->misc.tmpVsens - val1;
					tmpI = val2 - myCh->misc.tmpIsens;
				} else {
					tmpV = myCh->op.Vsens - val1;
					tmpI = val2 - myCh->op.Isens;
				}

				//CC Field
				if(myPs->config.capacityType == CAPACITY_AMPARE_HOURS) {
					deltaV = (long)(maxV * 0.001); //0.1% 20180418
					deltaI = (long)(maxI * 0.0025); //0.25%
				} else {
					deltaV = (long)(maxV * 0.001); //0.1% 20180418
					deltaI = (long)(maxI * 0.0025); //0.25%
				}
				if(tmpV > deltaV) {
					if((labs(tmpI) < (long)(maxI * 0.05)) //5%
						&& (labs(tmpI) > (long)(maxI * 0.001)))	{ //0.1%
						myCh->misc.fbCountI_H++;
						myCh->misc.fbSumI_H += tmpI;
						myCh->misc.fbCountI_M = 0;
						myCh->misc.fbSumI_M = 0;
						myCh->misc.fbCountI_L = 0;
						myCh->misc.fbSumI_L = 0;

						feedbackCount
							= (long)((100 / myPs->misc.dio_scan_time) * 3);
						if(myCh->misc.fbCountI_H >= feedbackCount) {
							fbCount = myCh->misc.fbCountI_H;
							tmp = (double)myCh->misc.fbSumI_H / fbCount;
							myCh->misc.fbCountI_H = 0;
							myCh->misc.fbSumI_H = 0;
							if(labs(myCh->misc.fbI) < (long)(maxI * 0.05)) {
								myCh->misc.fbI += (long)(tmp * 0.2);
								val2 += myCh->misc.fbI;
								cCalCmdI(bd, ch, val2, div, rangeI);
							}
						}
					} else if((labs(tmpI) <= (long)(maxI * 0.001)) //0.1%
						&& (labs(tmpI) > (long)(maxI * 0.0005))) { //0.05%
						myCh->misc.fbCountI_H = 0;
						myCh->misc.fbSumI_H = 0;
						myCh->misc.fbCountI_M++;
						myCh->misc.fbSumI_M += tmpI;
						myCh->misc.fbCountI_L = 0;
						myCh->misc.fbSumI_L = 0;

						feedbackCount
							= (long)((100 / myPs->misc.dio_scan_time) * 1);
						if(myCh->misc.fbCountI_M >= feedbackCount) {
							fbCount = myCh->misc.fbCountI_M;
							tmp = (double)myCh->misc.fbSumI_M / fbCount;
							myCh->misc.fbSumI_M = 0;
							myCh->misc.fbCountI_M = 0;
							if(labs(myCh->misc.fbI) < (long)(maxI * 0.05)) {
								myCh->misc.fbI += (long)(tmp * 0.3);
								val2 += myCh->misc.fbI;
								cCalCmdI(bd, ch, val2, div, rangeI);
							}
						}
					} else if((labs(tmpI) <= (long)(maxI * 0.0005))) { //0.05%
						myCh->misc.fbCountI_H = 0;
						myCh->misc.fbSumI_H = 0;
						myCh->misc.fbCountI_M = 0;
						myCh->misc.fbSumI_M = 0;
						myCh->misc.fbCountI_L++;
						myCh->misc.fbSumI_L += tmpI;

						feedbackCount
							= (long)((100 / myPs->misc.dio_scan_time) * 1);
						if(myCh->misc.fbCountI_L >= feedbackCount) {
							fbCount = myCh->misc.fbCountI_L;
							tmp = (double)myCh->misc.fbSumI_L / fbCount;
							myCh->misc.fbSumI_L = 0;
							myCh->misc.fbCountI_L = 0;
							if(labs(myCh->misc.fbI) < (long)(maxI * 0.05)) {//5%
								myCh->misc.fbI += (long)(tmp * 0.5);
								val2 += myCh->misc.fbI;
								cCalCmdI(bd, ch, val2, div, rangeI);
							}
						}
					} else {
						myCh->misc.fbCountI_H = 0;
						myCh->misc.fbSumI_H = 0;
						myCh->misc.fbCountI_M = 0;
						myCh->misc.fbSumI_M = 0;
						myCh->misc.fbCountI_L = 0;
						myCh->misc.fbSumI_L = 0;
					}

   					myCh->misc.cvFlag = P0;
					#ifdef _EXTERNAL_CONTROL
					myCh->misc.chCV = P0;
					#endif					
					
				} else {
					if(labs(tmpI) > deltaI) {
   						myCh->misc.cvFlag = P1;
						#ifdef _EXTERNAL_CONTROL
						myCh->misc.chCV = P1;
						#endif						
					}
				} 
			} else if(mode == CP || mode == CR) {
				//131108 oys add : CP,CR mode cvTime
				if(myCh->op.checkDelayTime < 100) {
					tmpV = myCh->misc.tmpVsens - val1;
					tmpI = val2 - myCh->misc.tmpIsens;
				} else {
					tmpV = myCh->op.Vsens - val1;
					tmpI = val2 - myCh->op.Isens;
				}

				if(myPs->config.capacityType == CAPACITY_AMPARE_HOURS) {
					deltaV = (long)(maxV * 0.001); //0.1% 20180418
					deltaI = (long)(maxI * 0.0025); //0.25%
				} else {
					deltaV = (long)(maxV * 0.001); //0.1% 20180418
					deltaI = (long)(maxI * 0.0025); //0.25%
				}
				if(tmpV > deltaV) {
					cCalCmdI(bd, ch, val2, div, rangeI);
   					myCh->misc.cvFlag = P0;
					#ifdef _EXTERNAL_CONTROL
					myCh->misc.chCV = P0;
					#endif					
					
				} else {
					if(labs(tmpI) > deltaI) {
   						myCh->misc.cvFlag = P1;
						#ifdef _EXTERNAL_CONTROL
						myCh->misc.chCV = P1;
						#endif						
					}
				}
			}
			break;
		case STEP_Z:
			if(myCh->op.checkDelayTime < 300) {
				tmpV = myCh->misc.tmpVsens - val1;
				tmpI = val2 - myCh->misc.tmpIsens;
			} else {
				tmpV = myCh->op.Vsens - val1;
				tmpI = val2 - myCh->op.Isens;
			}

			//CC Field
			if(tmpV >  (long)(maxV * 0.0005)) { //0.05%
				if((labs(tmpI) < (long)(maxI * 0.05)) //5%
					&& (labs(tmpI) > (long)(maxI * 0.001)))	{ //0.1%
					myCh->misc.fbCountI_H++;
					myCh->misc.fbSumI_H += tmpI;
					myCh->misc.fbCountI_M = 0;
					myCh->misc.fbSumI_M = 0;
					myCh->misc.fbCountI_L = 0;
					myCh->misc.fbSumI_L = 0;

					feedbackCount
						= (long)((100 / myPs->misc.dio_scan_time) * 1);
					if(myCh->misc.fbCountI_H >= feedbackCount) {
						fbCount = myCh->misc.fbCountI_H;
						tmp = (double)myCh->misc.fbSumI_H / fbCount;
						myCh->misc.fbCountI_H = 0;
						myCh->misc.fbSumI_H = 0;
						if(labs(myCh->misc.fbI) < (long)(maxI * 0.05)) {
							myCh->misc.fbI += (long)(tmp * 0.2);
							val2 += myCh->misc.fbI;
							cCalCmdI(bd, ch, val2, div, rangeI);
						}
					}
				} else if((labs(tmpI) <= (long)(maxI * 0.001)) //0.1%
					&& (labs(tmpI) > (long)(maxI * 0.0005))) { //0.05%
					myCh->misc.fbCountI_H = 0;
					myCh->misc.fbSumI_H = 0;
					myCh->misc.fbCountI_M++;
					myCh->misc.fbSumI_M += tmpI;
					myCh->misc.fbCountI_L = 0;
					myCh->misc.fbSumI_L = 0;

					feedbackCount
						= (long)((100 / myPs->misc.dio_scan_time) * 3);
					if(myCh->misc.fbCountI_M >= feedbackCount) {
						fbCount = myCh->misc.fbCountI_M;
						tmp = (double)myCh->misc.fbSumI_M / fbCount;
						myCh->misc.fbCountI_M = 0;
						myCh->misc.fbSumI_M = 0;
						if(labs(myCh->misc.fbI) < (long)(maxI * 0.05)) {
							myCh->misc.fbI += (long)(tmp * 0.3);
							val2 += myCh->misc.fbI;
							cCalCmdI(bd, ch, val2, div, rangeI);
						}
					}
				} else if((labs(tmpI) <= (long)(maxI * 0.0005))) { //0.05%
					myCh->misc.fbCountI_H = 0;
					myCh->misc.fbSumI_H = 0;
					myCh->misc.fbCountI_M = 0;
					myCh->misc.fbSumI_M = 0;
					myCh->misc.fbCountI_L++;
					myCh->misc.fbSumI_L += tmpI;

					feedbackCount
						= (long)((100 / myPs->misc.dio_scan_time) * 5);
					if(myCh->misc.fbCountI_L >= feedbackCount) {
						fbCount = myCh->misc.fbCountI_L;
						tmp = (double)myCh->misc.fbSumI_L / fbCount;
						myCh->misc.fbCountI_L = 0;
						myCh->misc.fbSumI_L = 0;
						if(labs(myCh->misc.fbI) < (long)(maxI * 0.05)) { //5%
							myCh->misc.fbI += (long)(tmp * 0.5);
							val2 += myCh->misc.fbI;
							cCalCmdI(bd, ch, val2, div, rangeI);
						}
					}
				} else {
					myCh->misc.fbCountI_H = 0;
					myCh->misc.fbSumI_H = 0;
					myCh->misc.fbCountI_M = 0;
					myCh->misc.fbSumI_M = 0;
					myCh->misc.fbCountI_L = 0;
					myCh->misc.fbSumI_L = 0;
				}
			}
			break;
		case STEP_USER_PATTERN:
			if(mode == CC || mode == CP) {
				if(myCh->misc.patternPhase != P0) return;
				if(myPs->misc.rt_scan_time <= 2) { //rt_scan_time : 20ms, 10ms
					if(labs(val2) <= (long)(maxI * 0.05)){
						if(myCh->misc.pattern_point_runTime
							<= myPs->misc.rt_scan_time) {
							return;
						} else if(myCh->misc.pattern_point_runTime
									== myPs->misc.rt_scan_time*2) {
					 		cCalCmdI(bd, ch, val2, div, rangeI);
							return;
						}
					}
				}

				if(val2 > 0) {
					tmpV = val1 - myCh->misc.tmpVsens;
					tmpI = val2 - myCh->misc.tmpIsens;
				} else if(val2 < 0) {
					tmpV = myCh->misc.tmpVsens - val1;
					tmpI = val2 - myCh->misc.tmpIsens;
				}

				//CC Field
				if(tmpV > (long)(maxV * 0.0005)) { //0.05%
					if((labs(tmpI) < (long)(maxI * 0.05)) //5%
						&& (labs(tmpI) > (long)(maxI * 0.001)))	{ //0.1%
						myCh->misc.fbCountI_H++;
						myCh->misc.fbSumI_H += tmpI;
						myCh->misc.fbCountI_M = 0;
						myCh->misc.fbSumI_M = 0;
						myCh->misc.fbCountI_L = 0;
						myCh->misc.fbSumI_L = 0;

						feedbackCount
							= (long)((100 / myPs->misc.dio_scan_time) * 1);
						if(myCh->misc.fbCountI_H >= feedbackCount) {
							fbCount = myCh->misc.fbCountI_H;
							tmp = (double)myCh->misc.fbSumI_H / fbCount;
							myCh->misc.fbCountI_H = 0;
							myCh->misc.fbSumI_H = 0;
							if(labs(myCh->misc.fbI) < (long)(maxI * 0.05)) {
								myCh->misc.fbI += (long)(tmp * 0.2);
								val2 += myCh->misc.fbI;
								cCalCmdI(bd, ch, val2, div, rangeI);
							}
						}
					} else if((labs(tmpI) <= (long)(maxI * 0.001)) //0.1%
						&& (labs(tmpI) > (long)(maxI * 0.0005))) { //0.05%
						myCh->misc.fbCountI_H = 0;
						myCh->misc.fbSumI_H = 0;
						myCh->misc.fbCountI_M++;
						myCh->misc.fbSumI_M += tmpI;
						myCh->misc.fbCountI_L = 0;
						myCh->misc.fbSumI_L = 0;

						feedbackCount
							= (long)((100 / myPs->misc.dio_scan_time) * 3);
						if(myCh->misc.fbCountI_M >= feedbackCount) {
							fbCount = myCh->misc.fbCountI_M;
							tmp = (double)myCh->misc.fbSumI_M / fbCount;
							myCh->misc.fbCountI_M = 0;
							myCh->misc.fbSumI_M = 0;
							if(labs(myCh->misc.fbI) < (long)(maxI * 0.05)) {//5%
								myCh->misc.fbI += (long)(tmp * 0.3);
								val2 += myCh->misc.fbI;
								cCalCmdI(bd, ch, val2, div, rangeI);
							}
						}
					} else if((labs(tmpI) <= (long)(maxI * 0.0005))) { //0.05%
						myCh->misc.fbCountI_H = 0;
						myCh->misc.fbSumI_H = 0;
						myCh->misc.fbCountI_M = 0;
						myCh->misc.fbSumI_M = 0;
						myCh->misc.fbCountI_L++;
						myCh->misc.fbSumI_L += tmpI;

						feedbackCount
							= (long)((100 / myPs->misc.dio_scan_time) * 5);
						if(myCh->misc.fbCountI_L >= feedbackCount) {
							fbCount = myCh->misc.fbCountI_L;
							tmp = (double)myCh->misc.fbSumI_L / fbCount;
							myCh->misc.fbCountI_L = 0;
							myCh->misc.fbSumI_L = 0;
							if(labs(myCh->misc.fbI) < (long)(maxI * 0.05)) {//5%
								myCh->misc.fbI += (long)(tmp * 0.5);
								val2 += myCh->misc.fbI;
				 				cCalCmdI(bd, ch, val2, div, rangeI);
							}
						}
					} else {
						myCh->misc.fbCountI_H = 0;
						myCh->misc.fbSumI_H = 0;
						myCh->misc.fbCountI_M = 0;
						myCh->misc.fbSumI_M = 0;
						myCh->misc.fbCountI_L = 0;
						myCh->misc.fbSumI_L = 0;
					}
				}
			}
			break;
		case STEP_USER_MAP: //111215 kji add
			if(mode == CC) {
				if(val2 > 0) {
					tmpV = val1 - myCh->misc.tmpVsens;
					tmpI = val2 - myCh->misc.tmpIsens;
				} else if(val2 < 0) {
					tmpV = myCh->misc.tmpVsens - val1;
					tmpI = val2 - myCh->misc.tmpIsens;
				}

				//CC Field
				if(tmpV > (long)(maxV * 0.0005)) { //0.05%
					if((labs(tmpI) < (long)(maxI * 0.05)) //5%
						&& (labs(tmpI) > (long)(maxI * 0.001)))	{ //0.1%
						myCh->misc.fbCountI_H++;
						myCh->misc.fbSumI_H += tmpI;
						myCh->misc.fbCountI_M = 0;
						myCh->misc.fbSumI_M = 0;
						myCh->misc.fbCountI_L = 0;
						myCh->misc.fbSumI_L = 0;

						feedbackCount
							= (long)((100 / myPs->misc.dio_scan_time) * 1);
						if(myCh->misc.fbCountI_H >= feedbackCount) {
							fbCount = myCh->misc.fbCountI_H;
							tmp = (double)myCh->misc.fbSumI_H / fbCount;
							myCh->misc.fbCountI_H = 0;
							myCh->misc.fbSumI_H = 0;
							if(labs(myCh->misc.fbI) < (long)(maxI * 0.05)) {
								myCh->misc.fbI += (long)(tmp * 0.2);
								val2 += myCh->misc.fbI;
			 					cCalCmdI(bd, ch, val2, div, rangeI);
							}
						}
					} else if((labs(tmpI) <= (long)(maxI * 0.001)) //0.1%
						&& (labs(tmpI) > (long)(maxI * 0.0005))) { //0.05%
						myCh->misc.fbCountI_H = 0;
						myCh->misc.fbSumI_H = 0;
						myCh->misc.fbCountI_M++;
						myCh->misc.fbSumI_M += tmpI;
						myCh->misc.fbCountI_L = 0;
						myCh->misc.fbSumI_L = 0;

						feedbackCount
							= (long)((100 / myPs->misc.dio_scan_time) * 3);
						if(myCh->misc.fbCountI_M >= feedbackCount) {
							fbCount = myCh->misc.fbCountI_M;
							tmp = (double)myCh->misc.fbSumI_M / fbCount;
							myCh->misc.fbCountI_M = 0;
							myCh->misc.fbSumI_M = 0;
							if(labs(myCh->misc.fbI) < (long)(maxI * 0.05)) {//5%
								myCh->misc.fbI += (long)(tmp * 0.3);
								val2 += myCh->misc.fbI;
								cCalCmdI(bd, ch, val2, div, rangeI);
							}
						}
					} else if((labs(tmpI) <= (long)(maxI * 0.0005))) { //0.05%
						myCh->misc.fbCountI_H = 0;
						myCh->misc.fbSumI_H = 0;
						myCh->misc.fbCountI_M = 0;
						myCh->misc.fbSumI_M = 0;
						myCh->misc.fbCountI_L++;
						myCh->misc.fbSumI_L += tmpI;

						feedbackCount
							= (long)((100 / myPs->misc.dio_scan_time) * 5);
						if(myCh->misc.fbCountI_L >= feedbackCount) {
							fbCount = myCh->misc.fbCountI_L;
							tmp = (double)myCh->misc.fbSumI_L / fbCount;
							myCh->misc.fbCountI_L = 0;
							myCh->misc.fbSumI_L = 0;
							if(labs(myCh->misc.fbI) < (long)(maxI * 0.05)) {//5%
								myCh->misc.fbI += (long)(tmp * 0.5);
								val2 += myCh->misc.fbI;
								cCalCmdI(bd, ch, val2, div, rangeI);
							}
						}
					} else {
						myCh->misc.fbCountI_H = 0;
						myCh->misc.fbSumI_H = 0;
						myCh->misc.fbCountI_M = 0;
						myCh->misc.fbSumI_M = 0;
						myCh->misc.fbCountI_L = 0;
						myCh->misc.fbSumI_L = 0;
					}
				}
			} else if(mode == CP) {
				cCalCmdI(bd, ch, val2, div, rangeI);
			}
			break;
		default:
			break;
	}
}

void cSoftFeedback_CAN(int bd, int ch, long val1, long val2, long val3)
{	//210126
	unsigned char mode, type, checkFlag;
	int rangeV, rangeI, div = 5;
	unsigned int fbCount;
	long tmpV=0, tmpI=0, maxV, maxI, deltaV=0, deltaI=0;
	unsigned long advStepNo, feedbackCount = 0;
	double tmp;
	S_CH_STEP_INFO step;

	step = step_info(bd, ch);

    advStepNo = step.advStepNo;
	rangeV = step.rangeV;
	rangeI = step.rangeI;
	type = step.type;
	mode = step.mode;

	maxV = myPs->config.maxVoltage[rangeV];
	maxI = myPs->config.maxCurrent[rangeI];

	switch(type) { //20180417 add for Cvtime
		case STEP_CHARGE:
			if(myCh->op.checkDelayTime < 100) {
				tmpV = val1 - myCh->misc.tmpVsens;
				tmpI = val2 - myCh->misc.tmpIsens;
			} else {
				tmpV = val1 - myCh->op.Vsens;
				tmpI = val2 - myCh->op.Isens;
			}

			//CC Field
			deltaV = (long)(maxV * 0.001);
			deltaI = (long)(maxI * 0.0025);

			//Check CV Flag
			if(tmpV < deltaV) {
				if(tmpI > deltaI) {
					myCh->misc.cvFlag = P1;
					#ifdef _EXTERNAL_CONTROL
					myCh->misc.chCV = P1;
					#endif					
				}
			}
			break;
		case STEP_DISCHARGE:
			if(myCh->op.checkDelayTime < 100) {
				tmpV = myCh->misc.tmpVsens - val1;
				tmpI = val2 - myCh->misc.tmpIsens;
			} else {
				tmpV = myCh->op.Vsens - val1;
				tmpI = val2 - myCh->op.Isens;
			}

			//CC Field
			deltaV = (long)(maxV * 0.001);
			deltaI = (long)(maxI * 0.0025);

			//Check CV Flag
			if(tmpV < deltaV) {
				if(labs(tmpI) > deltaI) {
					myCh->misc.cvFlag = P1;
					#ifdef _EXTERNAL_CONTROL
					myCh->misc.chCV = P1;
					#endif					
				}
			}
			break;
		default:
			break;
	}

	if(labs(val2) >= maxI * 0.05) { //5%
		checkFlag = 1;
	} else {
		checkFlag = 2;
	}

	if(myCh->misc.feedback_start == P1) {
		myCh->misc.feedback_delayTime += myPs->misc.rt_scan_time;
	} else {
		myCh->misc.feedback_delayTime = 0;
		myCh->misc.fbCountI_H = 0;
		myCh->misc.fbSumI_H = 0;
		myCh->misc.fbSumI_M = 0;
		myCh->misc.fbCountI_M = 0;
		myCh->misc.fbSumI_L = 0;
		myCh->misc.fbCountI_L = 0;
	}

	if(labs(myCh->misc.tmpIsens) >= val2 * 0.95) {
		myCh->misc.feedback_start = P1;
	}

	if(type != STEP_USER_PATTERN) {
		if(mode != CP && mode != CPCV) {
			if(checkFlag == 2) {
				if(myCh->misc.feedback_delayTime < 100) return;
			} else {
				if(myCh->misc.feedback_delayTime < 5) return;
			}
		} else {
			if(myCh->op.checkDelayTime < 2) return;
		}
	}

	switch(type) {
		case STEP_CHARGE:
			if(mode == CP || mode == CR) {
				//131108 oys add : CP,CR mode cvTime
				if(myCh->op.checkDelayTime < 100) {
					tmpV = val1 - myCh->misc.tmpVsens;
					tmpI = val2 - myCh->misc.tmpIsens;
				} else {
					tmpV = val1 - myCh->op.Vsens;
					tmpI = val2 - myCh->op.Isens;
				}

				if(myPs->config.capacityType == CAPACITY_AMPARE_HOURS) {
					deltaV = (long)(maxV * 0.001); //0.1%
					deltaI = (long)(maxI * 0.0025); //0.25%
				} else {
					deltaV = (long)(maxV * 0.001); //0.1%
					deltaI = (long)(maxI * 0.0025); //0.25%
				}
				if(tmpV > deltaV) {
					cCalCmdI(bd, ch, val2, div, rangeI);
   					myCh->misc.cvFlag = P0;
					#ifdef _EXTERNAL_CONTROL
					myCh->misc.chCV = P0;
					#endif					
					
				}
			}
			break;
		case STEP_DISCHARGE:
			if(mode == CP || mode == CR) {
				//131108 oys add : CP,CR mode cvTime
				if(myCh->op.checkDelayTime < 100) {
					tmpV = myCh->misc.tmpVsens - val1;
					tmpI = val2 - myCh->misc.tmpIsens;
				} else {
					tmpV = myCh->op.Vsens - val1;
					tmpI = val2 - myCh->op.Isens;
				}

				if(myPs->config.capacityType == CAPACITY_AMPARE_HOURS) {
					deltaV = (long)(maxV * 0.001); //0.1%
					deltaI = (long)(maxI * 0.0025); //0.25%
				} else {
					deltaV = (long)(maxV * 0.001); //0.1%
					deltaI = (long)(maxI * 0.0025); //0.25%
				}
				if(tmpV > deltaV) {
					cCalCmdI(bd, ch, val2, div, rangeI);
   					myCh->misc.cvFlag = P0;
					#ifdef _EXTERNAL_CONTROL
					myCh->misc.chCV = P0;
					#endif					
					
				}
			}
			break;
		case STEP_Z:
			if(myCh->op.checkDelayTime < 100) {
				tmpV = myCh->misc.tmpVsens - val1;
				tmpI = val2 - myCh->misc.tmpIsens;
			} else {
				tmpV = myCh->op.Vsens - val1;
				tmpI = val2 - myCh->op.Isens;
			}

			//CC Field
			if(tmpV > (long)(maxV * 0.0005)) { //0.05%
				if((labs(tmpI) < (long)(maxI * 0.05)) //5%
					&& (labs(tmpI) > (long)(maxI * 0.001)))	{ //0.1 %
					myCh->misc.fbCountI_H++;
					myCh->misc.fbSumI_H += tmpI;
					myCh->misc.fbCountI_M = 0;
					myCh->misc.fbSumI_M = 0;
					myCh->misc.fbCountI_L = 0;
					myCh->misc.fbSumI_L = 0;

					feedbackCount
						= (long)((100 / myPs->misc.dio_scan_time) * 3);
					if(myCh->misc.fbCountI_H >= feedbackCount) {
						fbCount = myCh->misc.fbCountI_H;
						tmp = (double)myCh->misc.fbSumI_H / fbCount;
						myCh->misc.fbCountI_H = 0;
						myCh->misc.fbSumI_H = 0;
						if(labs(myCh->misc.fbI) < (long)(maxI * 0.05)) {
							myCh->misc.fbI += (long)(tmp * 0.5);
							val2 += myCh->misc.fbI;
							cCalCmdI(bd, ch, val2, div, rangeI);
						}
					}
				} else if((labs(tmpI) <= (long)(maxI * 0.001)) //0.1%
					&& (labs(tmpI) > (long)(maxI * 0.0005))) { //0.05%
					myCh->misc.fbCountI_H = 0;
					myCh->misc.fbSumI_H = 0;
					myCh->misc.fbCountI_M++;
					myCh->misc.fbSumI_M += tmpI;
					myCh->misc.fbCountI_L = 0;
					myCh->misc.fbSumI_L = 0;

					feedbackCount
						= (long)((100 / myPs->misc.dio_scan_time) * 3);
					if(myCh->misc.fbCountI_M >= feedbackCount) {
						fbCount = myCh->misc.fbCountI_M;
						tmp = (double)myCh->misc.fbSumI_M / fbCount;
						myCh->misc.fbCountI_M = 0;
						myCh->misc.fbSumI_M = 0;
						if(labs(myCh->misc.fbI) < (long)(maxI * 0.05)) {
							myCh->misc.fbI += (long)(tmp * 0.3);
							val2 += myCh->misc.fbI;
							cCalCmdI(bd, ch, val2, div, rangeI);
						}
					}
				} else if((labs(tmpI) <= (long)(maxI * 0.0005))) { //0.05%
					myCh->misc.fbCountI_H = 0;
					myCh->misc.fbSumI_H = 0;
					myCh->misc.fbCountI_M = 0;
					myCh->misc.fbSumI_M = 0;
					myCh->misc.fbCountI_L++;
					myCh->misc.fbSumI_L += tmpI;

					feedbackCount
						= (long)((100 / myPs->misc.dio_scan_time) * 5);
					if(myCh->misc.fbCountI_L >= feedbackCount) {
						fbCount = myCh->misc.fbCountI_L;
						tmp = (double)myCh->misc.fbSumI_L / fbCount;
						myCh->misc.fbCountI_L = 0;
						myCh->misc.fbSumI_L = 0;
						if(labs(myCh->misc.fbI) < (long)(maxI * 0.05)) { //5%
							myCh->misc.fbI += (long)(tmp * 0.3);
							val2 += myCh->misc.fbI;
							cCalCmdI(bd, ch, val2, div, rangeI);
						}
					}
				} else {
					myCh->misc.fbCountI_H = 0;
					myCh->misc.fbSumI_H = 0;
					myCh->misc.fbCountI_M = 0;
					myCh->misc.fbSumI_M = 0;
					myCh->misc.fbCountI_L = 0;
					myCh->misc.fbSumI_L = 0;
				}
			}
			break;
		case STEP_USER_PATTERN:
			if(mode == CC || mode == CP) {
				if(myCh->misc.patternPhase != P0) return;
				if(myPs->misc.rt_scan_time <= 2) { //rt_scan_time : 20ms, 10ms
					if(labs(val2) <= (long)(maxI * 0.05)){
						if(myCh->misc.pattern_point_runTime
							<= myPs->misc.rt_scan_time) {
							return;
						} else if(myCh->misc.pattern_point_runTime
									== myPs->misc.rt_scan_time*2) {
					 		cCalCmdI(bd, ch, val2, div, rangeI);
							return;
						}
					}
				}

				if(val2 > 0) {
					tmpV = val1 - myCh->misc.tmpVsens;
					tmpI = val2 - myCh->misc.tmpIsens;
				} else if(val2 < 0) {
					tmpV = myCh->misc.tmpVsens - val1;
					tmpI = val2 - myCh->misc.tmpIsens;
				}

				//CC Field
				if(tmpV > (long)(maxV * 0.0005)) { //0.05%
					if((labs(tmpI) < (long)(maxI * 0.05)) //5%
						&& (labs(tmpI) > (long)(maxI * 0.001)))	{ //0.1%
						myCh->misc.fbCountI_H++;
						myCh->misc.fbSumI_H += tmpI;
						myCh->misc.fbCountI_M = 0;
						myCh->misc.fbSumI_M = 0;
						myCh->misc.fbCountI_L = 0;
						myCh->misc.fbSumI_L = 0;

						feedbackCount
							= (long)((100 / myPs->misc.dio_scan_time) * 3);
						if(myCh->misc.fbCountI_H >= feedbackCount) {
							fbCount = myCh->misc.fbCountI_H;
							tmp = (double)myCh->misc.fbSumI_H / fbCount;
							myCh->misc.fbCountI_H = 0;
							myCh->misc.fbSumI_H = 0;
							if(labs(myCh->misc.fbI) < (long)(maxI * 0.05)) {
								myCh->misc.fbI += (long)(tmp * 0.5);
								val2 += myCh->misc.fbI;
								cCalCmdI(bd, ch, val2, div, rangeI);
							}
						}
					} else if((labs(tmpI) <= (long)(maxI * 0.001)) //0.1%
						&& (labs(tmpI) > (long)(maxI * 0.0005))) { //0.05%
						myCh->misc.fbCountI_H = 0;
						myCh->misc.fbSumI_H = 0;
						myCh->misc.fbCountI_M++;
						myCh->misc.fbSumI_M += tmpI;
						myCh->misc.fbCountI_L = 0;
						myCh->misc.fbSumI_L = 0;

						feedbackCount
							= (long)((100 / myPs->misc.dio_scan_time) * 3);
						if(myCh->misc.fbCountI_M >= feedbackCount) {
							fbCount = myCh->misc.fbCountI_M;
							tmp = (double)myCh->misc.fbSumI_M / fbCount;
							myCh->misc.fbCountI_M = 0;
							myCh->misc.fbSumI_M = 0;
							if(labs(myCh->misc.fbI) < (long)(maxI * 0.05)) {//5%
								myCh->misc.fbI += (long)(tmp * 0.3);
								val2 += myCh->misc.fbI;
								cCalCmdI(bd, ch, val2, div, rangeI);
							}
						}
					} else if((labs(tmpI) <= (long)(maxI * 0.0005))) { //0.05%
						myCh->misc.fbCountI_H = 0;
						myCh->misc.fbSumI_H = 0;
						myCh->misc.fbCountI_M = 0;
						myCh->misc.fbSumI_M = 0;
						myCh->misc.fbCountI_L++;
						myCh->misc.fbSumI_L += tmpI;
						
						feedbackCount
							= (long)((100 / myPs->misc.dio_scan_time) * 5);
						if(myCh->misc.fbCountI_L >= feedbackCount) {
							fbCount = myCh->misc.fbCountI_L;
							tmp = (double)myCh->misc.fbSumI_L / fbCount;
							myCh->misc.fbCountI_L = 0;
							myCh->misc.fbSumI_L = 0;
							if(labs(myCh->misc.fbI) < (long)(maxI * 0.05)) {//5%
								myCh->misc.fbI += (long)(tmp * 0.1);
								val2 += myCh->misc.fbI;
				 				cCalCmdI(bd, ch, val2, div, rangeI);
							}
						}
					} else {
						myCh->misc.fbCountI_H = 0;
						myCh->misc.fbSumI_H = 0;
						myCh->misc.fbCountI_M = 0;
						myCh->misc.fbSumI_M = 0;
						myCh->misc.fbCountI_L = 0;
						myCh->misc.fbSumI_L = 0;
					}
				}
			}
			break;
		case STEP_USER_MAP: //111215 kji add
			if(mode == CC) {
				if(val2 > 0) {
					tmpV = val1 - myCh->misc.tmpVsens;
					tmpI = val2 - myCh->misc.tmpIsens;
				} else if(val2 < 0) {
					tmpV = myCh->misc.tmpVsens - val1;
					tmpI = val2 - myCh->misc.tmpIsens;
				}

				//CC Field
				if(tmpV > (long)(maxV * 0.0005)) { //0.05%
					if((labs(tmpI) < (long)(maxI * 0.05)) //5%
						&& (labs(tmpI) > (long)(maxI * 0.001)))	{ //0.1%
						myCh->misc.fbCountI_H++;
						myCh->misc.fbSumI_H += tmpI;
						myCh->misc.fbCountI_L = 0;
						myCh->misc.fbSumI_L = 0;
						myCh->misc.fbCountI_M = 0;
						myCh->misc.fbSumI_M = 0;

						feedbackCount
							= (long)((100 / myPs->misc.dio_scan_time) * 3);
						if(myCh->misc.fbCountI_H >= feedbackCount) {
							fbCount = myCh->misc.fbCountI_H;
							tmp = (double)myCh->misc.fbSumI_H / fbCount;
							myCh->misc.fbCountI_H = 0;
							myCh->misc.fbSumI_H = 0;
							if(labs(myCh->misc.fbI) < (long)(maxI * 0.05)) {
								myCh->misc.fbI += (long)(tmp * 0.5);
								val2 += myCh->misc.fbI;
			 					cCalCmdI(bd, ch, val2, div, rangeI);
							}
						}
					} else if((labs(tmpI) <= (long)(maxI * 0.001)) //0.1%
						&& (labs(tmpI) > (long)(maxI * 0.0005))) { //0.05%
						myCh->misc.fbCountI_H = 0;
						myCh->misc.fbSumI_H = 0;
						myCh->misc.fbCountI_M++;
						myCh->misc.fbSumI_M += tmpI;
						myCh->misc.fbCountI_L = 0;
						myCh->misc.fbSumI_L = 0;

						feedbackCount
							= (long)((100 / myPs->misc.dio_scan_time) * 3);
						if(myCh->misc.fbCountI_M >= feedbackCount) {
							fbCount = myCh->misc.fbCountI_M;
							tmp = (double)myCh->misc.fbSumI_M / fbCount;
							myCh->misc.fbCountI_M = 0;
							myCh->misc.fbSumI_M = 0;
							if(labs(myCh->misc.fbI) < (long)(maxI * 0.05)) {//5%
								myCh->misc.fbI += (long)(tmp * 0.3);
								val2 += myCh->misc.fbI;
								cCalCmdI(bd, ch, val2, div, rangeI);
							}
						}
					} else if((labs(tmpI) <= (long)(maxI * 0.0005))) { //0.05%
						myCh->misc.fbCountI_H = 0;
						myCh->misc.fbSumI_H = 0;
						myCh->misc.fbCountI_M = 0;
						myCh->misc.fbSumI_M = 0;
						myCh->misc.fbCountI_L++;
						myCh->misc.fbSumI_L += tmpI;
						
						feedbackCount
							= (long)((100 / myPs->misc.dio_scan_time) * 5);
						if(myCh->misc.fbCountI_L >= feedbackCount) {
							fbCount = myCh->misc.fbCountI_L;
							tmp = (double)myCh->misc.fbSumI_L / fbCount;
							myCh->misc.fbCountI_L = 0;
							myCh->misc.fbSumI_L = 0;
							if(labs(myCh->misc.fbI) < (long)(maxI * 0.05)) {//5%
								myCh->misc.fbI += (long)(tmp * 0.1);
								val2 += myCh->misc.fbI;
								cCalCmdI(bd, ch, val2, div, rangeI);
							}
						}
					} else {
						myCh->misc.fbCountI_H = 0;
						myCh->misc.fbSumI_H = 0;
						myCh->misc.fbCountI_M = 0;
						myCh->misc.fbSumI_M = 0;
						myCh->misc.fbCountI_L = 0;
						myCh->misc.fbSumI_L = 0;
					}
				}
			} else if(mode == CP) {
				cCalCmdI(bd, ch, val2, div, rangeI);
			}
			break;
		default:
			break;
	}
}
#ifdef _TRACKING_MODE
void cSoftFeedback_SOC(int bd, int ch, long val1, long val2, long val3)
{
	unsigned char mode, type, checkFlag;
	int rangeV, rangeI, div = 5;
	unsigned int fbCount;
	long tmpV=0, tmpI=0, maxV, maxI, deltaV=0, deltaI=0;
	unsigned long advStepNo, feedbackCount = 0;
	double tmp;
	S_CH_STEP_INFO step;

	step = step_info(bd, ch);

    advStepNo = step.advStepNo;
	rangeV = step.rangeV;
	rangeI = step.rangeI;
	type = step.type;
	mode = step.mode;

	maxV = myPs->config.maxVoltage[rangeV];
	maxI = myPs->config.maxCurrent[rangeI];

	switch(type) { //20180417 add for Cvtime
		case STEP_CHARGE:
			if(myCh->op.checkDelayTime < 100) {
				tmpV = val1 - myCh->misc.tmpVsens;
				tmpI = val2 - myCh->misc.tmpIsens;
			} else {
				tmpV = val1 - myCh->op.Vsens;
				tmpI = val2 - myCh->op.Isens;
			}

			//CC Field
			deltaV = (long)(maxV * 0.001);
			deltaI = (long)(maxI * 0.0025);

			//Check CV Flag
			if(tmpV < deltaV) {
				if(tmpI > deltaI) {
					myCh->misc.cvFlag = P1;
   					myCh->misc.cvFaultCheckFlag = P1; //210204
					#ifdef _EXTERNAL_CONTROL
					myCh->misc.chCV = P1;
					#endif					
				}
			}
			break;
		case STEP_DISCHARGE:
			if(myCh->op.checkDelayTime < 100) {
				tmpV = myCh->misc.tmpVsens - val1;
				tmpI = val2 - myCh->misc.tmpIsens;
			} else {
				tmpV = myCh->op.Vsens - val1;
				tmpI = val2 - myCh->op.Isens;
			}

			//CC Field
			deltaV = (long)(maxV * 0.001);
			deltaI = (long)(maxI * 0.0025);

			//Check CV Flag
			if(tmpV < deltaV) {
				if(labs(tmpI) > deltaI) {
					myCh->misc.cvFlag = P1;
   					myCh->misc.cvFaultCheckFlag = P1; //210204
					#ifdef _EXTERNAL_CONTROL
					myCh->misc.chCV = P1;
					#endif					
				}
			}
			break;
		default:
			break;
	}

	if(labs(val2) >= maxI * 0.05) { //5%
		checkFlag = 1;
	} else {
		checkFlag = 2;
	}

	if(myCh->misc.feedback_start == P1) {
		myCh->misc.feedback_delayTime += myPs->misc.rt_scan_time;
	} else {
		myCh->misc.feedback_delayTime = 0;
		myCh->misc.fbCountI_H = 0;
		myCh->misc.fbSumI_H = 0;
		myCh->misc.fbSumI_M = 0;
		myCh->misc.fbCountI_M = 0;
		myCh->misc.fbSumI_L = 0;
		myCh->misc.fbCountI_L = 0;
	}

	if(labs(myCh->misc.tmpIsens) >= val2 * 0.95) {
		myCh->misc.feedback_start = P1;
	}

	if(type != STEP_USER_PATTERN) {
		if(mode != CP && mode != CPCV) {
			//210609 hun_t
			if(myPs->testCond[bd][ch].step[advStepNo].SOC_Tracking_flag == P1){
				if(myCh->op.checkDelayTime < 2) return;
			}else{
				if(checkFlag == 2) {
					if(myCh->misc.feedback_delayTime < 100) return;
				} else {
					if(myCh->misc.feedback_delayTime < 5) return;
				}
			}
		} else {
			if(myCh->op.checkDelayTime < 2) return;
		}
	}

	switch(type) {
		case STEP_CHARGE:
			if(myPs->testCond[bd][ch].step[advStepNo].SOC_Tracking_flag == P1){
				if(myCh->op.checkDelayTime < 100) {
					tmpV = val1 - myCh->misc.tmpVsens;
					tmpI = val2 - myCh->misc.tmpIsens;
				} else {
					tmpV = val1 - myCh->op.Vsens;
					tmpI = val2 - myCh->op.Isens;
				}

				if(myPs->config.capacityType == CAPACITY_AMPARE_HOURS) {
					deltaV = (long)(maxV * 0.001); //0.1%
					deltaI = (long)(maxI * 0.0025); //0.25%
				} else {
					deltaV = (long)(maxV * 0.001); //0.1%
					deltaI = (long)(maxI * 0.0025); //0.25%
				}
				if(tmpV > deltaV) {
					cCalCmdI(bd, ch, val2, div, rangeI);
   					myCh->misc.cvFlag = P0;
					#ifdef _EXTERNAL_CONTROL
					myCh->misc.chCV = P0;
					#endif					
					
				}
			}else{
				if(mode == CC || mode == CV || mode == CCCV || mode == C_RATE) {
					if(myCh->op.checkDelayTime < 100) {
						tmpV = val1 - myCh->misc.tmpVsens;
						tmpI = val2 - myCh->misc.tmpIsens;
					} else {
						tmpV = val1 - myCh->op.Vsens;
						tmpI = val2 - myCh->op.Isens;
					}

					//CC Field
					if(myPs->config.capacityType == CAPACITY_AMPARE_HOURS) {
						deltaV = (long)(maxV * 0.001); //0.1% 20180418
						deltaI = (long)(maxI * 0.0025); //0.25%
					} else {
						deltaV = (long)(maxV * 0.001); //0.1%
						deltaI = (long)(maxI * 0.0025); //0.25%
					}

					if(tmpV > deltaV) {
						if((labs(tmpI) < (long)(maxI * 0.05)) //5%
							&& (labs(tmpI) > (long)(maxI * 0.001)))	{ //0.1%
							myCh->misc.fbCountI_H++;
							myCh->misc.fbSumI_H += tmpI;
							myCh->misc.fbCountI_M = 0;
							myCh->misc.fbSumI_M = 0;
							myCh->misc.fbCountI_L = 0;
							myCh->misc.fbSumI_L = 0;
							
							feedbackCount
								= (long)((100 / myPs->misc.dio_scan_time) * 3);
							if(myCh->misc.fbCountI_H >= feedbackCount) {
								fbCount = myCh->misc.fbCountI_H;
								tmp = (double)myCh->misc.fbSumI_H / fbCount;
								myCh->misc.fbCountI_H = 0;
								myCh->misc.fbSumI_H = 0;
								if(labs(myCh->misc.fbI) < (long)(maxI * 0.05)) {
									myCh->misc.fbI += (long)(tmp * 0.5);
									val2 += myCh->misc.fbI;
									cCalCmdI(bd, ch, val2, div, rangeI);
								}
							}
						} else if((labs(tmpI) <= (long)(maxI * 0.001)) //0.1%
							&& (labs(tmpI) > (long)(maxI * 0.0005))) { //0.05%
							myCh->misc.fbCountI_H = 0;
							myCh->misc.fbSumI_H = 0;
							myCh->misc.fbCountI_M++;
							myCh->misc.fbSumI_M += tmpI;
							myCh->misc.fbCountI_L = 0;
							myCh->misc.fbSumI_L = 0;
						
							feedbackCount
								= (long)((100 / myPs->misc.dio_scan_time) * 3);
							if(myCh->misc.fbCountI_M >= feedbackCount) {
								fbCount = myCh->misc.fbCountI_M;
								tmp = (double)myCh->misc.fbSumI_M / fbCount;
								myCh->misc.fbCountI_M = 0;
								myCh->misc.fbSumI_M = 0;
								if(labs(myCh->misc.fbI) < (long)(maxI * 0.05)) {//3%
									myCh->misc.fbI += (long)(tmp * 0.3);
									val2 += myCh->misc.fbI;
									cCalCmdI(bd, ch, val2, div, rangeI);
								}
							}
						} else if((labs(tmpI) <= (long)(maxI * 0.0005))) { //0.05%
							myCh->misc.fbCountI_M = 0;
							myCh->misc.fbSumI_M = 0;
							myCh->misc.fbCountI_H = 0;
							myCh->misc.fbSumI_H = 0;
							myCh->misc.fbCountI_L++;
							myCh->misc.fbSumI_L += tmpI;
						
							feedbackCount
								= (long)((100 / myPs->misc.dio_scan_time) * 5);
							if(myCh->misc.fbCountI_L >= feedbackCount) {
								fbCount = myCh->misc.fbCountI_L;
								tmp = (double)myCh->misc.fbSumI_L / fbCount;
								myCh->misc.fbCountI_L = 0;
								myCh->misc.fbSumI_L = 0;
								if(labs(myCh->misc.fbI) < (long)(maxI * 0.05)) {//5%
									myCh->misc.fbI += (long)(tmp * 0.1);
									val2 += myCh->misc.fbI;
									cCalCmdI(bd, ch, val2, div, rangeI);
								}
							}
						} else {
							myCh->misc.fbCountI_H = 0;
							myCh->misc.fbSumI_H = 0;
							myCh->misc.fbCountI_M = 0;
							myCh->misc.fbSumI_M = 0;
							myCh->misc.fbCountI_L = 0;
							myCh->misc.fbSumI_L = 0;
						}
   						myCh->misc.cvFlag = P0;
						#ifdef _EXTERNAL_CONTROL
						myCh->misc.chCV = P0;
						#endif					
						
					}
				} else if(mode == CP || mode == CR) {
					//131108 oys add : CP,CR mode cvTime
					if(myCh->op.checkDelayTime < 100) {
						tmpV = val1 - myCh->misc.tmpVsens;
						tmpI = val2 - myCh->misc.tmpIsens;
					} else {
						tmpV = val1 - myCh->op.Vsens;
						tmpI = val2 - myCh->op.Isens;
					}

					if(myPs->config.capacityType == CAPACITY_AMPARE_HOURS) {
						deltaV = (long)(maxV * 0.001); //0.1%
						deltaI = (long)(maxI * 0.0025); //0.25%
					} else {
						deltaV = (long)(maxV * 0.001); //0.1%
						deltaI = (long)(maxI * 0.0025); //0.25%
					}
					if(tmpV > deltaV) {
						cCalCmdI(bd, ch, val2, div, rangeI);
   						myCh->misc.cvFlag = P0;
						#ifdef _EXTERNAL_CONTROL
						myCh->misc.chCV = P0;
						#endif					
						
					}
				}
			}
			break;
		case STEP_DISCHARGE:
			if(mode == CC || mode == CV || mode == CCCV || mode == C_RATE) {
				if(myCh->op.checkDelayTime < 100) {
					tmpV = myCh->misc.tmpVsens - val1;
					tmpI = val2 - myCh->misc.tmpIsens;
				} else {
					tmpV = myCh->op.Vsens - val1;
					tmpI = val2 - myCh->op.Isens;
				}

				//CC Field
				if(myPs->config.capacityType == CAPACITY_AMPARE_HOURS) {
					deltaV = (long)(maxV * 0.001); //0.1%
					deltaI = (long)(maxI * 0.0025); //0.25%
				} else {
					deltaV = (long)(maxV * 0.001); //0.1%
					deltaI = (long)(maxI * 0.0025); //0.25%
				}
				if(tmpV > deltaV) {
					if((labs(tmpI) < (long)(maxI * 0.05)) //5%
						&& (labs(tmpI) > (long)(maxI * 0.001)))	{ //0.1 %
						myCh->misc.fbCountI_H++;
						myCh->misc.fbSumI_H += tmpI;
						myCh->misc.fbCountI_M = 0;
						myCh->misc.fbSumI_M = 0;
						myCh->misc.fbCountI_L = 0;
						myCh->misc.fbSumI_L = 0;

						feedbackCount
							= (long)((100 / myPs->misc.dio_scan_time) * 3);
						if(myCh->misc.fbCountI_H >= feedbackCount) {
							fbCount = myCh->misc.fbCountI_H;
							tmp = (double)myCh->misc.fbSumI_H / fbCount;
							myCh->misc.fbCountI_H = 0;
							myCh->misc.fbSumI_H = 0;
							if(labs(myCh->misc.fbI) < (long)(maxI * 0.05)) {
								myCh->misc.fbI += (long)(tmp * 0.5);
								val2 += myCh->misc.fbI;
								cCalCmdI(bd, ch, val2, div, rangeI);
							}
						}
					} else if((labs(tmpI) <= (long)(maxI * 0.001)) //0.1%
						&& (labs(tmpI) > (long)(maxI * 0.0005))) { //0.05%
						myCh->misc.fbCountI_H = 0;
						myCh->misc.fbSumI_H = 0;
						myCh->misc.fbCountI_M++;
						myCh->misc.fbSumI_M += tmpI;
						myCh->misc.fbCountI_L = 0;
						myCh->misc.fbSumI_L = 0;

						feedbackCount
							= (long)((100 / myPs->misc.dio_scan_time) * 3);
						if(myCh->misc.fbCountI_M >= feedbackCount) {
							fbCount = myCh->misc.fbCountI_M;
							tmp = (double)myCh->misc.fbSumI_M / fbCount;
							myCh->misc.fbCountI_M = 0;
							myCh->misc.fbSumI_M = 0;
							if(labs(myCh->misc.fbI) < (long)(maxI * 0.05)) {
								myCh->misc.fbI += (long)(tmp * 0.3);
								val2 += myCh->misc.fbI;
								cCalCmdI(bd, ch, val2, div, rangeI);
							}
						}
					} else if((labs(tmpI) <= (long)(maxI * 0.0005))) { //0.05%
						myCh->misc.fbCountI_H = 0;
						myCh->misc.fbSumI_H = 0;
						myCh->misc.fbCountI_M = 0;
						myCh->misc.fbSumI_M = 0;
						myCh->misc.fbCountI_L++;
						myCh->misc.fbSumI_L += tmpI;

						feedbackCount
							= (long)((100 / myPs->misc.dio_scan_time) * 5);
						if(myCh->misc.fbCountI_L >= feedbackCount) {
							fbCount = myCh->misc.fbCountI_L;
							tmp = (double)myCh->misc.fbSumI_L / fbCount;
							myCh->misc.fbCountI_L = 0;
							myCh->misc.fbSumI_L = 0;
							if(labs(myCh->misc.fbI) < (long)(maxI * 0.05)) {//5%
								myCh->misc.fbI += (long)(tmp * 0.1);
								val2 += myCh->misc.fbI;
								cCalCmdI(bd, ch, val2, div, rangeI);
							}
						}
					} else {
						myCh->misc.fbCountI_H = 0;
						myCh->misc.fbSumI_H = 0;
						myCh->misc.fbCountI_M = 0;
						myCh->misc.fbSumI_M = 0;
						myCh->misc.fbCountI_L = 0;
						myCh->misc.fbSumI_L = 0;
					}

   					myCh->misc.cvFlag = P0;
					#ifdef _EXTERNAL_CONTROL
					myCh->misc.chCV = P0;
					#endif					
					
				}
			} else if(mode == CP || mode == CR) {
				//131108 oys add : CP,CR mode cvTime
				if(myCh->op.checkDelayTime < 100) {
					tmpV = myCh->misc.tmpVsens - val1;
					tmpI = val2 - myCh->misc.tmpIsens;
				} else {
					tmpV = myCh->op.Vsens - val1;
					tmpI = val2 - myCh->op.Isens;
				}

				if(myPs->config.capacityType == CAPACITY_AMPARE_HOURS) {
					deltaV = (long)(maxV * 0.001); //0.1%
					deltaI = (long)(maxI * 0.0025); //0.25%
				} else {
					deltaV = (long)(maxV * 0.001); //0.1%
					deltaI = (long)(maxI * 0.0025); //0.25%
				}
				if(tmpV > deltaV) {
					cCalCmdI(bd, ch, val2, div, rangeI);
   					myCh->misc.cvFlag = P0;
					#ifdef _EXTERNAL_CONTROL
					myCh->misc.chCV = P0;
					#endif					
					
				}
			}
			break;
		case STEP_Z:
			if(myCh->op.checkDelayTime < 100) {
				tmpV = myCh->misc.tmpVsens - val1;
				tmpI = val2 - myCh->misc.tmpIsens;
			} else {
				tmpV = myCh->op.Vsens - val1;
				tmpI = val2 - myCh->op.Isens;
			}

			//CC Field
			if(tmpV > (long)(maxV * 0.0005)) { //0.05%
				if((labs(tmpI) < (long)(maxI * 0.05)) //5%
					&& (labs(tmpI) > (long)(maxI * 0.001)))	{ //0.1 %
					myCh->misc.fbCountI_H++;
					myCh->misc.fbSumI_H += tmpI;
					myCh->misc.fbCountI_M = 0;
					myCh->misc.fbSumI_M = 0;
					myCh->misc.fbCountI_L = 0;
					myCh->misc.fbSumI_L = 0;

					feedbackCount
						= (long)((100 / myPs->misc.dio_scan_time) * 3);
					if(myCh->misc.fbCountI_H >= feedbackCount) {
						fbCount = myCh->misc.fbCountI_H;
						tmp = (double)myCh->misc.fbSumI_H / fbCount;
						myCh->misc.fbCountI_H = 0;
						myCh->misc.fbSumI_H = 0;
						if(labs(myCh->misc.fbI) < (long)(maxI * 0.05)) {
							myCh->misc.fbI += (long)(tmp * 0.5);
							val2 += myCh->misc.fbI;
							cCalCmdI(bd, ch, val2, div, rangeI);
						}
					}
				} else if((labs(tmpI) <= (long)(maxI * 0.001)) //0.1%
					&& (labs(tmpI) > (long)(maxI * 0.0005))) { //0.05%
					myCh->misc.fbCountI_H = 0;
					myCh->misc.fbSumI_H = 0;
					myCh->misc.fbCountI_M++;
					myCh->misc.fbSumI_M += tmpI;
					myCh->misc.fbCountI_L = 0;
					myCh->misc.fbSumI_L = 0;

					feedbackCount
						= (long)((100 / myPs->misc.dio_scan_time) * 3);
					if(myCh->misc.fbCountI_M >= feedbackCount) {
						fbCount = myCh->misc.fbCountI_M;
						tmp = (double)myCh->misc.fbSumI_M / fbCount;
						myCh->misc.fbCountI_M = 0;
						myCh->misc.fbSumI_M = 0;
						if(labs(myCh->misc.fbI) < (long)(maxI * 0.05)) {
							myCh->misc.fbI += (long)(tmp * 0.3);
							val2 += myCh->misc.fbI;
							cCalCmdI(bd, ch, val2, div, rangeI);
						}
					}
				} else if((labs(tmpI) <= (long)(maxI * 0.0005))) { //0.05%
					myCh->misc.fbCountI_H = 0;
					myCh->misc.fbSumI_H = 0;
					myCh->misc.fbCountI_M = 0;
					myCh->misc.fbSumI_M = 0;
					myCh->misc.fbCountI_L++;
					myCh->misc.fbSumI_L += tmpI;

					feedbackCount
						= (long)((100 / myPs->misc.dio_scan_time) * 5);
					if(myCh->misc.fbCountI_L >= feedbackCount) {
						fbCount = myCh->misc.fbCountI_L;
						tmp = (double)myCh->misc.fbSumI_L / fbCount;
						myCh->misc.fbCountI_L = 0;
						myCh->misc.fbSumI_L = 0;
						if(labs(myCh->misc.fbI) < (long)(maxI * 0.05)) { //5%
							myCh->misc.fbI += (long)(tmp * 0.3);
							val2 += myCh->misc.fbI;
							cCalCmdI(bd, ch, val2, div, rangeI);
						}
					}
				} else {
					myCh->misc.fbCountI_H = 0;
					myCh->misc.fbSumI_H = 0;
					myCh->misc.fbCountI_M = 0;
					myCh->misc.fbSumI_M = 0;
					myCh->misc.fbCountI_L = 0;
					myCh->misc.fbSumI_L = 0;
				}
			}
			break;
		case STEP_USER_PATTERN:
			if(mode == CC || mode == CP) {
				if(myCh->misc.patternPhase != P0) return;
				if(myPs->misc.rt_scan_time <= 2) { //rt_scan_time : 20ms, 10ms
					if(labs(val2) <= (long)(maxI * 0.05)){
						if(myCh->misc.pattern_point_runTime
							<= myPs->misc.rt_scan_time) {
							return;
						} else if(myCh->misc.pattern_point_runTime
									== myPs->misc.rt_scan_time*2) {
					 		cCalCmdI(bd, ch, val2, div, rangeI);
							return;
						}
					}
				}

				if(val2 > 0) {
					tmpV = val1 - myCh->misc.tmpVsens;
					tmpI = val2 - myCh->misc.tmpIsens;
				} else if(val2 < 0) {
					tmpV = myCh->misc.tmpVsens - val1;
					tmpI = val2 - myCh->misc.tmpIsens;
				}

				//CC Field
				if(tmpV > (long)(maxV * 0.0005)) { //0.05%
					if((labs(tmpI) < (long)(maxI * 0.05)) //5%
						&& (labs(tmpI) > (long)(maxI * 0.001)))	{ //0.1%
						myCh->misc.fbCountI_H++;
						myCh->misc.fbSumI_H += tmpI;
						myCh->misc.fbCountI_M = 0;
						myCh->misc.fbSumI_M = 0;
						myCh->misc.fbCountI_L = 0;
						myCh->misc.fbSumI_L = 0;

						feedbackCount
							= (long)((100 / myPs->misc.dio_scan_time) * 3);
						if(myCh->misc.fbCountI_H >= feedbackCount) {
							fbCount = myCh->misc.fbCountI_H;
							tmp = (double)myCh->misc.fbSumI_H / fbCount;
							myCh->misc.fbCountI_H = 0;
							myCh->misc.fbSumI_H = 0;
							if(labs(myCh->misc.fbI) < (long)(maxI * 0.05)) {
								myCh->misc.fbI += (long)(tmp * 0.5);
								val2 += myCh->misc.fbI;
								cCalCmdI(bd, ch, val2, div, rangeI);
							}
						}
					} else if((labs(tmpI) <= (long)(maxI * 0.001)) //0.1%
						&& (labs(tmpI) > (long)(maxI * 0.0005))) { //0.05%
						myCh->misc.fbCountI_H = 0;
						myCh->misc.fbSumI_H = 0;
						myCh->misc.fbCountI_M++;
						myCh->misc.fbSumI_M += tmpI;
						myCh->misc.fbCountI_L = 0;
						myCh->misc.fbSumI_L = 0;

						feedbackCount
							= (long)((100 / myPs->misc.dio_scan_time) * 3);
						if(myCh->misc.fbCountI_M >= feedbackCount) {
							fbCount = myCh->misc.fbCountI_M;
							tmp = (double)myCh->misc.fbSumI_M / fbCount;
							myCh->misc.fbCountI_M = 0;
							myCh->misc.fbSumI_M = 0;
							if(labs(myCh->misc.fbI) < (long)(maxI * 0.05)) {//5%
								myCh->misc.fbI += (long)(tmp * 0.3);
								val2 += myCh->misc.fbI;
								cCalCmdI(bd, ch, val2, div, rangeI);
							}
						}
					} else if((labs(tmpI) <= (long)(maxI * 0.0005))) { //0.05%
						myCh->misc.fbCountI_H = 0;
						myCh->misc.fbSumI_H = 0;
						myCh->misc.fbCountI_M = 0;
						myCh->misc.fbSumI_M = 0;
						myCh->misc.fbCountI_L++;
						myCh->misc.fbSumI_L += tmpI;
						
						feedbackCount
							= (long)((100 / myPs->misc.dio_scan_time) * 5);
						if(myCh->misc.fbCountI_L >= feedbackCount) {
							fbCount = myCh->misc.fbCountI_L;
							tmp = (double)myCh->misc.fbSumI_L / fbCount;
							myCh->misc.fbCountI_L = 0;
							myCh->misc.fbSumI_L = 0;
							if(labs(myCh->misc.fbI) < (long)(maxI * 0.05)) {//5%
								myCh->misc.fbI += (long)(tmp * 0.1);
								val2 += myCh->misc.fbI;
				 				cCalCmdI(bd, ch, val2, div, rangeI);
							}
						}
					} else {
						myCh->misc.fbCountI_H = 0;
						myCh->misc.fbSumI_H = 0;
						myCh->misc.fbCountI_M = 0;
						myCh->misc.fbSumI_M = 0;
						myCh->misc.fbCountI_L = 0;
						myCh->misc.fbSumI_L = 0;
					}
				}
			}
			break;
		case STEP_USER_MAP: //111215 kji add
			if(mode == CC) {
				if(val2 > 0) {
					tmpV = val1 - myCh->misc.tmpVsens;
					tmpI = val2 - myCh->misc.tmpIsens;
				} else if(val2 < 0) {
					tmpV = myCh->misc.tmpVsens - val1;
					tmpI = val2 - myCh->misc.tmpIsens;
				}

				//CC Field
				if(tmpV > (long)(maxV * 0.0005)) { //0.05%
					if((labs(tmpI) < (long)(maxI * 0.05)) //5%
						&& (labs(tmpI) > (long)(maxI * 0.001)))	{ //0.1%
						myCh->misc.fbCountI_H++;
						myCh->misc.fbSumI_H += tmpI;
						myCh->misc.fbCountI_L = 0;
						myCh->misc.fbSumI_L = 0;
						myCh->misc.fbCountI_M = 0;
						myCh->misc.fbSumI_M = 0;

						feedbackCount
							= (long)((100 / myPs->misc.dio_scan_time) * 3);
						if(myCh->misc.fbCountI_H >= feedbackCount) {
							fbCount = myCh->misc.fbCountI_H;
							tmp = (double)myCh->misc.fbSumI_H / fbCount;
							myCh->misc.fbCountI_H = 0;
							myCh->misc.fbSumI_H = 0;
							if(labs(myCh->misc.fbI) < (long)(maxI * 0.05)) {
								myCh->misc.fbI += (long)(tmp * 0.5);
								val2 += myCh->misc.fbI;
			 					cCalCmdI(bd, ch, val2, div, rangeI);
							}
						}
					} else if((labs(tmpI) <= (long)(maxI * 0.001)) //0.1%
						&& (labs(tmpI) > (long)(maxI * 0.0005))) { //0.05%
						myCh->misc.fbCountI_H = 0;
						myCh->misc.fbSumI_H = 0;
						myCh->misc.fbCountI_M++;
						myCh->misc.fbSumI_M += tmpI;
						myCh->misc.fbCountI_L = 0;
						myCh->misc.fbSumI_L = 0;

						feedbackCount
							= (long)((100 / myPs->misc.dio_scan_time) * 3);
						if(myCh->misc.fbCountI_M >= feedbackCount) {
							fbCount = myCh->misc.fbCountI_M;
							tmp = (double)myCh->misc.fbSumI_M / fbCount;
							myCh->misc.fbCountI_M = 0;
							myCh->misc.fbSumI_M = 0;
							if(labs(myCh->misc.fbI) < (long)(maxI * 0.05)) {//5%
								myCh->misc.fbI += (long)(tmp * 0.3);
								val2 += myCh->misc.fbI;
								cCalCmdI(bd, ch, val2, div, rangeI);
							}
						}
					} else if((labs(tmpI) <= (long)(maxI * 0.0005))) { //0.05%
						myCh->misc.fbCountI_H = 0;
						myCh->misc.fbSumI_H = 0;
						myCh->misc.fbCountI_M = 0;
						myCh->misc.fbSumI_M = 0;
						myCh->misc.fbCountI_L++;
						myCh->misc.fbSumI_L += tmpI;
						
						feedbackCount
							= (long)((100 / myPs->misc.dio_scan_time) * 5);
						if(myCh->misc.fbCountI_L >= feedbackCount) {
							fbCount = myCh->misc.fbCountI_L;
							tmp = (double)myCh->misc.fbSumI_L / fbCount;
							myCh->misc.fbCountI_L = 0;
							myCh->misc.fbSumI_L = 0;
							if(labs(myCh->misc.fbI) < (long)(maxI * 0.05)) {//5%
								myCh->misc.fbI += (long)(tmp * 0.1);
								val2 += myCh->misc.fbI;
								cCalCmdI(bd, ch, val2, div, rangeI);
							}
						}
					} else {
						myCh->misc.fbCountI_H = 0;
						myCh->misc.fbSumI_H = 0;
						myCh->misc.fbCountI_M = 0;
						myCh->misc.fbSumI_M = 0;
						myCh->misc.fbCountI_L = 0;
						myCh->misc.fbSumI_L = 0;
					}
				}
			} else if(mode == CP) {
				cCalCmdI(bd, ch, val2, div, rangeI);
			}
			break;
		default:
			break;
	}
}
#endif
#ifdef _EQUATION_CURRENT
void cSoftFeedback_EQU(int bd, int ch, long val1, long val2, long val3)
{
	unsigned char mode, type, checkFlag;
	int rangeV, rangeI, div = 5;
	unsigned int fbCount;
	long tmpV=0, tmpI=0, maxV, maxI, deltaV=0, deltaI=0;
	unsigned long advStepNo, feedbackCount = 0;
	double tmp;
	S_CH_STEP_INFO step;

	step = step_info(bd, ch);

    advStepNo = step.advStepNo;
	rangeV = step.rangeV;
	rangeI = step.rangeI;
	type = step.type;
	mode = step.mode;

	maxV = myPs->config.maxVoltage[rangeV];
	maxI = myPs->config.maxCurrent[rangeI];

	switch(type) { //20180417 add for Cvtime
		case STEP_CHARGE:
			if(myCh->op.checkDelayTime < 100) {
				tmpV = val1 - myCh->misc.tmpVsens;
				tmpI = val2 - myCh->misc.tmpIsens;
			} else {
				tmpV = val1 - myCh->op.Vsens;
				tmpI = val2 - myCh->op.Isens;
			}

			//CC Field
			deltaV = (long)(maxV * 0.001);
			deltaI = (long)(maxI * 0.0025);

			//Check CV Flag
			if(tmpV < deltaV) {
				if(tmpI > deltaI) {
					myCh->misc.cvFlag = P1;
   					myCh->misc.cvFaultCheckFlag = P1; //210204
					#ifdef _EXTERNAL_CONTROL
					myCh->misc.chCV = P1;
					#endif					
				}
			}
			break;
		case STEP_DISCHARGE:
			if(myCh->op.checkDelayTime < 100) {
				tmpV = myCh->misc.tmpVsens - val1;
				tmpI = val2 - myCh->misc.tmpIsens;
			} else {
				tmpV = myCh->op.Vsens - val1;
				tmpI = val2 - myCh->op.Isens;
			}

			//CC Field
			deltaV = (long)(maxV * 0.001);
			deltaI = (long)(maxI * 0.0025);

			//Check CV Flag
			if(tmpV < deltaV) {
				if(labs(tmpI) > deltaI) {
					myCh->misc.cvFlag = P1;
   					myCh->misc.cvFaultCheckFlag = P1; //210204
					#ifdef _EXTERNAL_CONTROL
					myCh->misc.chCV = P1;
					#endif					
				}
			}
			break;
		default:
			break;
	}

	if(labs(val2) >= maxI * 0.05) { //5%
		checkFlag = 1;
	} else {
		checkFlag = 2;
	}

	if(myCh->misc.feedback_start == P1) {
		myCh->misc.feedback_delayTime += myPs->misc.rt_scan_time;
	} else {
		myCh->misc.feedback_delayTime = 0;
		myCh->misc.fbCountI_H = 0;
		myCh->misc.fbSumI_H = 0;
		myCh->misc.fbSumI_M = 0;
		myCh->misc.fbCountI_M = 0;
		myCh->misc.fbSumI_L = 0;
		myCh->misc.fbCountI_L = 0;
	}

	if(labs(myCh->misc.tmpIsens) >= val2 * 0.95) {
		myCh->misc.feedback_start = P1;
	}

	if(type != STEP_USER_PATTERN) {
		if(mode != CP && mode != CPCV) {
			//210609 hun_t
			if(myPs->testCond[bd][ch].step[advStepNo].equation_current_flag == P1){

				if(myCh->op.checkDelayTime < 2) return;
			}else{
				if(checkFlag == 2) {
					if(myCh->misc.feedback_delayTime < 100) return;
				} else {
					if(myCh->misc.feedback_delayTime < 5) return;
				}
			}
		} else {
			if(myCh->op.checkDelayTime < 2) return;
		}
	}

	switch(type) {
		case STEP_CHARGE:
			if(myPs->testCond[bd][ch].step[advStepNo].equation_current_flag == P1){
				if(myCh->op.checkDelayTime < 100) {
					tmpV = val1 - myCh->misc.tmpVsens;
					tmpI = val2 - myCh->misc.tmpIsens;
				} else {
					tmpV = val1 - myCh->op.Vsens;
					tmpI = val2 - myCh->op.Isens;
				}

				if(myPs->config.capacityType == CAPACITY_AMPARE_HOURS) {
					deltaV = (long)(maxV * 0.001); //0.1%
					deltaI = (long)(maxI * 0.0025); //0.25%
				} else {
					deltaV = (long)(maxV * 0.001); //0.1%
					deltaI = (long)(maxI * 0.0025); //0.25%
				}
				if(tmpV > deltaV) {
					cCalCmdI(bd, ch, val2, div, rangeI);
   					myCh->misc.cvFlag = P0;
					#ifdef _EXTERNAL_CONTRO
					myCh->misc.chCV = P0;
					#endif					
					
				}
			}else{
				if(mode == CC || mode == CV || mode == CCCV || mode == C_RATE) {
					if(myCh->op.checkDelayTime < 100) {
						tmpV = val1 - myCh->misc.tmpVsens;
						tmpI = val2 - myCh->misc.tmpIsens;
					} else {
						tmpV = val1 - myCh->op.Vsens;
						tmpI = val2 - myCh->op.Isens;
					}

					//CC Field
					if(myPs->config.capacityType == CAPACITY_AMPARE_HOURS) {
						deltaV = (long)(maxV * 0.001); //0.1% 20180418
						deltaI = (long)(maxI * 0.0025); //0.25%
					} else {
						deltaV = (long)(maxV * 0.001); //0.1%
						deltaI = (long)(maxI * 0.0025); //0.25%
					}

					if(tmpV > deltaV) {
						if((labs(tmpI) < (long)(maxI * 0.05)) //5%
							&& (labs(tmpI) > (long)(maxI * 0.001)))	{ //0.1%
							myCh->misc.fbCountI_H++;
							myCh->misc.fbSumI_H += tmpI;
							myCh->misc.fbCountI_M = 0;
							myCh->misc.fbSumI_M = 0;
							myCh->misc.fbCountI_L = 0;
							myCh->misc.fbSumI_L = 0;
							
							feedbackCount
								= (long)((100 / myPs->misc.dio_scan_time) * 3);
							if(myCh->misc.fbCountI_H >= feedbackCount) {
								fbCount = myCh->misc.fbCountI_H;
								tmp = (double)myCh->misc.fbSumI_H / fbCount;
								myCh->misc.fbCountI_H = 0;
								myCh->misc.fbSumI_H = 0;
								if(labs(myCh->misc.fbI) < (long)(maxI * 0.05)) {
									myCh->misc.fbI += (long)(tmp * 0.5);
									val2 += myCh->misc.fbI;
									cCalCmdI(bd, ch, val2, div, rangeI);
								}
							}
						} else if((labs(tmpI) <= (long)(maxI * 0.001)) //0.1%
							&& (labs(tmpI) > (long)(maxI * 0.0005))) { //0.05%
							myCh->misc.fbCountI_H = 0;
							myCh->misc.fbSumI_H = 0;
							myCh->misc.fbCountI_M++;
							myCh->misc.fbSumI_M += tmpI;
							myCh->misc.fbCountI_L = 0;
							myCh->misc.fbSumI_L = 0;
						
							feedbackCount
								= (long)((100 / myPs->misc.dio_scan_time) * 3);
							if(myCh->misc.fbCountI_M >= feedbackCount) {
								fbCount = myCh->misc.fbCountI_M;
								tmp = (double)myCh->misc.fbSumI_M / fbCount;
								myCh->misc.fbCountI_M = 0;
								myCh->misc.fbSumI_M = 0;
								if(labs(myCh->misc.fbI) < (long)(maxI * 0.05)) {//3%
									myCh->misc.fbI += (long)(tmp * 0.3);
									val2 += myCh->misc.fbI;
									cCalCmdI(bd, ch, val2, div, rangeI);
								}
							}
						} else if((labs(tmpI) <= (long)(maxI * 0.0005))) { //0.05%
							myCh->misc.fbCountI_M = 0;
							myCh->misc.fbSumI_M = 0;
							myCh->misc.fbCountI_H = 0;
							myCh->misc.fbSumI_H = 0;
							myCh->misc.fbCountI_L++;
							myCh->misc.fbSumI_L += tmpI;
						
							feedbackCount
								= (long)((100 / myPs->misc.dio_scan_time) * 5);
							if(myCh->misc.fbCountI_L >= feedbackCount) {
								fbCount = myCh->misc.fbCountI_L;
								tmp = (double)myCh->misc.fbSumI_L / fbCount;
								myCh->misc.fbCountI_L = 0;
								myCh->misc.fbSumI_L = 0;
								if(labs(myCh->misc.fbI) < (long)(maxI * 0.05)) {//5%
									myCh->misc.fbI += (long)(tmp * 0.1);
									val2 += myCh->misc.fbI;
									cCalCmdI(bd, ch, val2, div, rangeI);
								}
							}
						} else {
							myCh->misc.fbCountI_H = 0;
							myCh->misc.fbSumI_H = 0;
							myCh->misc.fbCountI_M = 0;
							myCh->misc.fbSumI_M = 0;
							myCh->misc.fbCountI_L = 0;
							myCh->misc.fbSumI_L = 0;
						}
   						myCh->misc.cvFlag = P0;
						#ifdef _EXTERNAL_CONTROL
						myCh->misc.chCV = P0;
						#endif					
						
					}
				} else if(mode == CP || mode == CR) {
					//131108 oys add : CP,CR mode cvTime
					if(myCh->op.checkDelayTime < 100) {
						tmpV = val1 - myCh->misc.tmpVsens;
						tmpI = val2 - myCh->misc.tmpIsens;
					} else {
						tmpV = val1 - myCh->op.Vsens;
						tmpI = val2 - myCh->op.Isens;
					}

					if(myPs->config.capacityType == CAPACITY_AMPARE_HOURS) {
						deltaV = (long)(maxV * 0.001); //0.1%
						deltaI = (long)(maxI * 0.0025); //0.25%
					} else {
						deltaV = (long)(maxV * 0.001); //0.1%
						deltaI = (long)(maxI * 0.0025); //0.25%
					}
					if(tmpV > deltaV) {
						cCalCmdI(bd, ch, val2, div, rangeI);
   						myCh->misc.cvFlag = P0;
						#ifdef _EXTERNAL_CONTROL
						myCh->misc.chCV = P0;
						#endif					
						
					}
				}
			}
			break;
		case STEP_DISCHARGE:
			if(mode == CC || mode == CV || mode == CCCV || mode == C_RATE) {
				if(myCh->op.checkDelayTime < 100) {
					tmpV = myCh->misc.tmpVsens - val1;
					tmpI = val2 - myCh->misc.tmpIsens;
				} else {
					tmpV = myCh->op.Vsens - val1;
					tmpI = val2 - myCh->op.Isens;
				}

				//CC Field
				if(myPs->config.capacityType == CAPACITY_AMPARE_HOURS) {
					deltaV = (long)(maxV * 0.001); //0.1%
					deltaI = (long)(maxI * 0.0025); //0.25%
				} else {
					deltaV = (long)(maxV * 0.001); //0.1%
					deltaI = (long)(maxI * 0.0025); //0.25%
				}
				if(tmpV > deltaV) {
					if((labs(tmpI) < (long)(maxI * 0.05)) //5%
						&& (labs(tmpI) > (long)(maxI * 0.001)))	{ //0.1 %
						myCh->misc.fbCountI_H++;
						myCh->misc.fbSumI_H += tmpI;
						myCh->misc.fbCountI_M = 0;
						myCh->misc.fbSumI_M = 0;
						myCh->misc.fbCountI_L = 0;
						myCh->misc.fbSumI_L = 0;

						feedbackCount
							= (long)((100 / myPs->misc.dio_scan_time) * 3);
						if(myCh->misc.fbCountI_H >= feedbackCount) {
							fbCount = myCh->misc.fbCountI_H;
							tmp = (double)myCh->misc.fbSumI_H / fbCount;
							myCh->misc.fbCountI_H = 0;
							myCh->misc.fbSumI_H = 0;
							if(labs(myCh->misc.fbI) < (long)(maxI * 0.05)) {
								myCh->misc.fbI += (long)(tmp * 0.5);
								val2 += myCh->misc.fbI;
								cCalCmdI(bd, ch, val2, div, rangeI);
							}
						}
					} else if((labs(tmpI) <= (long)(maxI * 0.001)) //0.1%
						&& (labs(tmpI) > (long)(maxI * 0.0005))) { //0.05%
						myCh->misc.fbCountI_H = 0;
						myCh->misc.fbSumI_H = 0;
						myCh->misc.fbCountI_M++;
						myCh->misc.fbSumI_M += tmpI;
						myCh->misc.fbCountI_L = 0;
						myCh->misc.fbSumI_L = 0;

						feedbackCount
							= (long)((100 / myPs->misc.dio_scan_time) * 3);
						if(myCh->misc.fbCountI_M >= feedbackCount) {
							fbCount = myCh->misc.fbCountI_M;
							tmp = (double)myCh->misc.fbSumI_M / fbCount;
							myCh->misc.fbCountI_M = 0;
							myCh->misc.fbSumI_M = 0;
							if(labs(myCh->misc.fbI) < (long)(maxI * 0.05)) {
								myCh->misc.fbI += (long)(tmp * 0.3);
								val2 += myCh->misc.fbI;
								cCalCmdI(bd, ch, val2, div, rangeI);
							}
						}
					} else if((labs(tmpI) <= (long)(maxI * 0.0005))) { //0.05%
						myCh->misc.fbCountI_H = 0;
						myCh->misc.fbSumI_H = 0;
						myCh->misc.fbCountI_M = 0;
						myCh->misc.fbSumI_M = 0;
						myCh->misc.fbCountI_L++;
						myCh->misc.fbSumI_L += tmpI;

						feedbackCount
							= (long)((100 / myPs->misc.dio_scan_time) * 5);
						if(myCh->misc.fbCountI_L >= feedbackCount) {
							fbCount = myCh->misc.fbCountI_L;
							tmp = (double)myCh->misc.fbSumI_L / fbCount;
							myCh->misc.fbCountI_L = 0;
							myCh->misc.fbSumI_L = 0;
							if(labs(myCh->misc.fbI) < (long)(maxI * 0.05)) {//5%
								myCh->misc.fbI += (long)(tmp * 0.1);
								val2 += myCh->misc.fbI;
								cCalCmdI(bd, ch, val2, div, rangeI);
							}
						}
					} else {
						myCh->misc.fbCountI_H = 0;
						myCh->misc.fbSumI_H = 0;
						myCh->misc.fbCountI_M = 0;
						myCh->misc.fbSumI_M = 0;
						myCh->misc.fbCountI_L = 0;
						myCh->misc.fbSumI_L = 0;
					}

   					myCh->misc.cvFlag = P0;
					#ifdef _EXTERNAL_CONTROL
					myCh->misc.chCV = P0;
					#endif					
					
				}
			} else if(mode == CP || mode == CR) {
				//131108 oys add : CP,CR mode cvTime
				if(myCh->op.checkDelayTime < 100) {
					tmpV = myCh->misc.tmpVsens - val1;
					tmpI = val2 - myCh->misc.tmpIsens;
				} else {
					tmpV = myCh->op.Vsens - val1;
					tmpI = val2 - myCh->op.Isens;
				}

				if(myPs->config.capacityType == CAPACITY_AMPARE_HOURS) {
					deltaV = (long)(maxV * 0.001); //0.1%
					deltaI = (long)(maxI * 0.0025); //0.25%
				} else {
					deltaV = (long)(maxV * 0.001); //0.1%
					deltaI = (long)(maxI * 0.0025); //0.25%
				}
				if(tmpV > deltaV) {
					cCalCmdI(bd, ch, val2, div, rangeI);
   					myCh->misc.cvFlag = P0;
					#ifdef _EXTERNAL_CONTROL
					myCh->misc.chCV = P0;
					#endif					
					
				}
			}
			break;
		case STEP_Z:
			if(myCh->op.checkDelayTime < 100) {
				tmpV = myCh->misc.tmpVsens - val1;
				tmpI = val2 - myCh->misc.tmpIsens;
			} else {
				tmpV = myCh->op.Vsens - val1;
				tmpI = val2 - myCh->op.Isens;
			}

			//CC Field
			if(tmpV > (long)(maxV * 0.0005)) { //0.05%
				if((labs(tmpI) < (long)(maxI * 0.05)) //5%
					&& (labs(tmpI) > (long)(maxI * 0.001)))	{ //0.1 %
					myCh->misc.fbCountI_H++;
					myCh->misc.fbSumI_H += tmpI;
					myCh->misc.fbCountI_M = 0;
					myCh->misc.fbSumI_M = 0;
					myCh->misc.fbCountI_L = 0;
					myCh->misc.fbSumI_L = 0;

					feedbackCount
						= (long)((100 / myPs->misc.dio_scan_time) * 3);
					if(myCh->misc.fbCountI_H >= feedbackCount) {
						fbCount = myCh->misc.fbCountI_H;
						tmp = (double)myCh->misc.fbSumI_H / fbCount;
						myCh->misc.fbCountI_H = 0;
						myCh->misc.fbSumI_H = 0;
						if(labs(myCh->misc.fbI) < (long)(maxI * 0.05)) {
							myCh->misc.fbI += (long)(tmp * 0.5);
							val2 += myCh->misc.fbI;
							cCalCmdI(bd, ch, val2, div, rangeI);
						}
					}
				} else if((labs(tmpI) <= (long)(maxI * 0.001)) //0.1%
					&& (labs(tmpI) > (long)(maxI * 0.0005))) { //0.05%
					myCh->misc.fbCountI_H = 0;
					myCh->misc.fbSumI_H = 0;
					myCh->misc.fbCountI_M++;
					myCh->misc.fbSumI_M += tmpI;
					myCh->misc.fbCountI_L = 0;
					myCh->misc.fbSumI_L = 0;

					feedbackCount
						= (long)((100 / myPs->misc.dio_scan_time) * 3);
					if(myCh->misc.fbCountI_M >= feedbackCount) {
						fbCount = myCh->misc.fbCountI_M;
						tmp = (double)myCh->misc.fbSumI_M / fbCount;
						myCh->misc.fbCountI_M = 0;
						myCh->misc.fbSumI_M = 0;
						if(labs(myCh->misc.fbI) < (long)(maxI * 0.05)) {
							myCh->misc.fbI += (long)(tmp * 0.3);
							val2 += myCh->misc.fbI;
							cCalCmdI(bd, ch, val2, div, rangeI);
						}
					}
				} else if((labs(tmpI) <= (long)(maxI * 0.0005))) { //0.05%
					myCh->misc.fbCountI_H = 0;
					myCh->misc.fbSumI_H = 0;
					myCh->misc.fbCountI_M = 0;
					myCh->misc.fbSumI_M = 0;
					myCh->misc.fbCountI_L++;
					myCh->misc.fbSumI_L += tmpI;

					feedbackCount
						= (long)((100 / myPs->misc.dio_scan_time) * 5);
					if(myCh->misc.fbCountI_L >= feedbackCount) {
						fbCount = myCh->misc.fbCountI_L;
						tmp = (double)myCh->misc.fbSumI_L / fbCount;
						myCh->misc.fbCountI_L = 0;
						myCh->misc.fbSumI_L = 0;
						if(labs(myCh->misc.fbI) < (long)(maxI * 0.05)) { //5%
							myCh->misc.fbI += (long)(tmp * 0.3);
							val2 += myCh->misc.fbI;
							cCalCmdI(bd, ch, val2, div, rangeI);
						}
					}
				} else {
					myCh->misc.fbCountI_H = 0;
					myCh->misc.fbSumI_H = 0;
					myCh->misc.fbCountI_M = 0;
					myCh->misc.fbSumI_M = 0;
					myCh->misc.fbCountI_L = 0;
					myCh->misc.fbSumI_L = 0;
				}
			}
			break;
		case STEP_USER_PATTERN:
			if(mode == CC || mode == CP) {
				if(myCh->misc.patternPhase != P0) return;
				if(myPs->misc.rt_scan_time <= 2) { //rt_scan_time : 20ms, 10ms
					if(labs(val2) <= (long)(maxI * 0.05)){
						if(myCh->misc.pattern_point_runTime
							<= myPs->misc.rt_scan_time) {
							return;
						} else if(myCh->misc.pattern_point_runTime
									== myPs->misc.rt_scan_time*2) {
					 		cCalCmdI(bd, ch, val2, div, rangeI);
							return;
						}
					}
				}

				if(val2 > 0) {
					tmpV = val1 - myCh->misc.tmpVsens;
					tmpI = val2 - myCh->misc.tmpIsens;
				} else if(val2 < 0) {
					tmpV = myCh->misc.tmpVsens - val1;
					tmpI = val2 - myCh->misc.tmpIsens;
				}

				//CC Field
				if(tmpV > (long)(maxV * 0.0005)) { //0.05%
					if((labs(tmpI) < (long)(maxI * 0.05)) //5%
						&& (labs(tmpI) > (long)(maxI * 0.001)))	{ //0.1%
						myCh->misc.fbCountI_H++;
						myCh->misc.fbSumI_H += tmpI;
						myCh->misc.fbCountI_M = 0;
						myCh->misc.fbSumI_M = 0;
						myCh->misc.fbCountI_L = 0;
						myCh->misc.fbSumI_L = 0;

						feedbackCount
							= (long)((100 / myPs->misc.dio_scan_time) * 3);
						if(myCh->misc.fbCountI_H >= feedbackCount) {
							fbCount = myCh->misc.fbCountI_H;
							tmp = (double)myCh->misc.fbSumI_H / fbCount;
							myCh->misc.fbCountI_H = 0;
							myCh->misc.fbSumI_H = 0;
							if(labs(myCh->misc.fbI) < (long)(maxI * 0.05)) {
								myCh->misc.fbI += (long)(tmp * 0.5);
								val2 += myCh->misc.fbI;
								cCalCmdI(bd, ch, val2, div, rangeI);
							}
						}
					} else if((labs(tmpI) <= (long)(maxI * 0.001)) //0.1%
						&& (labs(tmpI) > (long)(maxI * 0.0005))) { //0.05%
						myCh->misc.fbCountI_H = 0;
						myCh->misc.fbSumI_H = 0;
						myCh->misc.fbCountI_M++;
						myCh->misc.fbSumI_M += tmpI;
						myCh->misc.fbCountI_L = 0;
						myCh->misc.fbSumI_L = 0;

						feedbackCount
							= (long)((100 / myPs->misc.dio_scan_time) * 3);
						if(myCh->misc.fbCountI_M >= feedbackCount) {
							fbCount = myCh->misc.fbCountI_M;
							tmp = (double)myCh->misc.fbSumI_M / fbCount;
							myCh->misc.fbCountI_M = 0;
							myCh->misc.fbSumI_M = 0;
							if(labs(myCh->misc.fbI) < (long)(maxI * 0.05)) {//5%
								myCh->misc.fbI += (long)(tmp * 0.3);
								val2 += myCh->misc.fbI;
								cCalCmdI(bd, ch, val2, div, rangeI);
							}
						}
					} else if((labs(tmpI) <= (long)(maxI * 0.0005))) { //0.05%
						myCh->misc.fbCountI_H = 0;
						myCh->misc.fbSumI_H = 0;
						myCh->misc.fbCountI_M = 0;
						myCh->misc.fbSumI_M = 0;
						myCh->misc.fbCountI_L++;
						myCh->misc.fbSumI_L += tmpI;
						
						feedbackCount
							= (long)((100 / myPs->misc.dio_scan_time) * 5);
						if(myCh->misc.fbCountI_L >= feedbackCount) {
							fbCount = myCh->misc.fbCountI_L;
							tmp = (double)myCh->misc.fbSumI_L / fbCount;
							myCh->misc.fbCountI_L = 0;
							myCh->misc.fbSumI_L = 0;
							if(labs(myCh->misc.fbI) < (long)(maxI * 0.05)) {//5%
								myCh->misc.fbI += (long)(tmp * 0.1);
								val2 += myCh->misc.fbI;
				 				cCalCmdI(bd, ch, val2, div, rangeI);
							}
						}
					} else {
						myCh->misc.fbCountI_H = 0;
						myCh->misc.fbSumI_H = 0;
						myCh->misc.fbCountI_M = 0;
						myCh->misc.fbSumI_M = 0;
						myCh->misc.fbCountI_L = 0;
						myCh->misc.fbSumI_L = 0;
					}
				}
			}
			break;
		case STEP_USER_MAP: //111215 kji add
			if(mode == CC) {
				if(val2 > 0) {
					tmpV = val1 - myCh->misc.tmpVsens;
					tmpI = val2 - myCh->misc.tmpIsens;
				} else if(val2 < 0) {
					tmpV = myCh->misc.tmpVsens - val1;
					tmpI = val2 - myCh->misc.tmpIsens;
				}

				//CC Field
				if(tmpV > (long)(maxV * 0.0005)) { //0.05%
					if((labs(tmpI) < (long)(maxI * 0.05)) //5%
						&& (labs(tmpI) > (long)(maxI * 0.001)))	{ //0.1%
						myCh->misc.fbCountI_H++;
						myCh->misc.fbSumI_H += tmpI;
						myCh->misc.fbCountI_L = 0;
						myCh->misc.fbSumI_L = 0;
						myCh->misc.fbCountI_M = 0;
						myCh->misc.fbSumI_M = 0;

						feedbackCount
							= (long)((100 / myPs->misc.dio_scan_time) * 3);
						if(myCh->misc.fbCountI_H >= feedbackCount) {
							fbCount = myCh->misc.fbCountI_H;
							tmp = (double)myCh->misc.fbSumI_H / fbCount;
							myCh->misc.fbCountI_H = 0;
							myCh->misc.fbSumI_H = 0;
							if(labs(myCh->misc.fbI) < (long)(maxI * 0.05)) {
								myCh->misc.fbI += (long)(tmp * 0.5);
								val2 += myCh->misc.fbI;
			 					cCalCmdI(bd, ch, val2, div, rangeI);
							}
						}
					} else if((labs(tmpI) <= (long)(maxI * 0.001)) //0.1%
						&& (labs(tmpI) > (long)(maxI * 0.0005))) { //0.05%
						myCh->misc.fbCountI_H = 0;
						myCh->misc.fbSumI_H = 0;
						myCh->misc.fbCountI_M++;
						myCh->misc.fbSumI_M += tmpI;
						myCh->misc.fbCountI_L = 0;
						myCh->misc.fbSumI_L = 0;

						feedbackCount
							= (long)((100 / myPs->misc.dio_scan_time) * 3);
						if(myCh->misc.fbCountI_M >= feedbackCount) {
							fbCount = myCh->misc.fbCountI_M;
							tmp = (double)myCh->misc.fbSumI_M / fbCount;
							myCh->misc.fbCountI_M = 0;
							myCh->misc.fbSumI_M = 0;
							if(labs(myCh->misc.fbI) < (long)(maxI * 0.05)) {//5%
								myCh->misc.fbI += (long)(tmp * 0.3);
								val2 += myCh->misc.fbI;
								cCalCmdI(bd, ch, val2, div, rangeI);
							}
						}
					} else if((labs(tmpI) <= (long)(maxI * 0.0005))) { //0.05%
						myCh->misc.fbCountI_H = 0;
						myCh->misc.fbSumI_H = 0;
						myCh->misc.fbCountI_M = 0;
						myCh->misc.fbSumI_M = 0;
						myCh->misc.fbCountI_L++;
						myCh->misc.fbSumI_L += tmpI;
						
						feedbackCount
							= (long)((100 / myPs->misc.dio_scan_time) * 5);
						if(myCh->misc.fbCountI_L >= feedbackCount) {
							fbCount = myCh->misc.fbCountI_L;
							tmp = (double)myCh->misc.fbSumI_L / fbCount;
							myCh->misc.fbCountI_L = 0;
							myCh->misc.fbSumI_L = 0;
							if(labs(myCh->misc.fbI) < (long)(maxI * 0.05)) {//5%
								myCh->misc.fbI += (long)(tmp * 0.1);
								val2 += myCh->misc.fbI;
								cCalCmdI(bd, ch, val2, div, rangeI);
							}
						}
					} else {
						myCh->misc.fbCountI_H = 0;
						myCh->misc.fbSumI_H = 0;
						myCh->misc.fbCountI_M = 0;
						myCh->misc.fbSumI_M = 0;
						myCh->misc.fbCountI_L = 0;
						myCh->misc.fbSumI_L = 0;
					}
				}
			} else if(mode == CP) {
				cCalCmdI(bd, ch, val2, div, rangeI);
			}
			break;
		default:
			break;
	}
}
#endif


void RangeSelectV(int bd)
{
	unsigned char flag = 0x01;
	int ch, tmp, range, addr, base_addr, range_v;
	
	if(myPs->config.rangeV <= RANGE1) return;

	for(ch=0; ch < myPs->config.chPerBd; ch++) {
		flag = 0x01;
		flag = flag << (ch % 8);
		tmp = ch / 8;
		range = (int)myCh->signal[C_SIG_V_RANGE];
		switch(range) {
			case RANGE0:
				myData->bData[bd].rangeSelectV[0][tmp] &= ~flag;
				myData->bData[bd].rangeSelectV[1][tmp] &= ~flag;
				myData->bData[bd].rangeSelectV[2][tmp] &= ~flag;
				myData->bData[bd].rangeSelectV[3][tmp] &= ~flag;
				break;
			case RANGE1:
				myData->bData[bd].rangeSelectV[0][tmp] |= flag;
				myData->bData[bd].rangeSelectV[1][tmp] &= ~flag;
				myData->bData[bd].rangeSelectV[2][tmp] &= ~flag;
				myData->bData[bd].rangeSelectV[3][tmp] &= ~flag;
				break;
			case RANGE2:
				myData->bData[bd].rangeSelectV[0][tmp] &= ~flag;
				myData->bData[bd].rangeSelectV[1][tmp] |= flag;
				myData->bData[bd].rangeSelectV[2][tmp] &= ~flag;
				myData->bData[bd].rangeSelectV[3][tmp] &= ~flag;
				break;
			case RANGE3:
				myData->bData[bd].rangeSelectV[0][tmp] &= ~flag;
				myData->bData[bd].rangeSelectV[1][tmp] &= ~flag;
				myData->bData[bd].rangeSelectV[2][tmp] |= flag;
				myData->bData[bd].rangeSelectV[3][tmp] &= ~flag;
				break;
			case RANGE4:
				myData->bData[bd].rangeSelectV[0][tmp] &= ~flag;
				myData->bData[bd].rangeSelectV[1][tmp] &= ~flag;
				myData->bData[bd].rangeSelectV[2][tmp] &= ~flag;
				myData->bData[bd].rangeSelectV[3][tmp] |= flag;
				break;
		}
	}
	base_addr = myPs->addr.main[BASE_ADDR];

	if(myPs->config.ADC_type == COMM_TYPE) {
		range_v = myPs->addr.main[RANGE_V_CS];
		addr =base_addr + range_v + bd;
	} else {
		range_v = myPs->addr.main[RANGE_V_CS];
		addr =base_addr + range_v + bd;
	}

	if(myPs->config.hwSpec == L_6V_6A) {
		return;
	} else if(myPs->config.hwSpec == L_5V_10mA) {
		return;
	} else {
		return;
	}

	for(range=0; range < MAX_RANGE; range++) {
		tmp = range * 2;
		outb(myData->bData[bd].rangeSelectV[range][0], addr + tmp);
		outb(myData->bData[bd].rangeSelectV[range][1], addr + tmp + 1);
	}
}

void RangeSelectV_Ch(int bd, int ch)
{
	int tmp, range;
	int	addr, base_addr, range_v;
	unsigned char flag = 0x01;
	
	myCh = &(myData->bData[bd].cData[ch]);
#if CYCLER_TYPE == DIGITAL_CYC
	return;	//180611 add
#endif
	if(myPs->config.rangeV <= RANGE1)	return;
	
	flag = 0x01;
	flag = flag << (ch % 8);
	tmp = ch / 8;
	range = (int)myCh->signal[C_SIG_V_RANGE];
	switch(range) {
		case RANGE0:
			myData->bData[bd].rangeSelectV[0][tmp] &= ~flag;
			myData->bData[bd].rangeSelectV[1][tmp] &= ~flag;
			myData->bData[bd].rangeSelectV[2][tmp] &= ~flag;
			myData->bData[bd].rangeSelectV[3][tmp] &= ~flag;
			break;
		case RANGE1:
			myData->bData[bd].rangeSelectV[0][tmp] |= flag;
			myData->bData[bd].rangeSelectV[1][tmp] &= ~flag;
			myData->bData[bd].rangeSelectV[2][tmp] &= ~flag;
			myData->bData[bd].rangeSelectV[3][tmp] &= ~flag;
			break;
		case RANGE2:
			myData->bData[bd].rangeSelectV[0][tmp] &= ~flag;
			myData->bData[bd].rangeSelectV[1][tmp] |= flag;
			myData->bData[bd].rangeSelectV[2][tmp] &= ~flag;
			myData->bData[bd].rangeSelectV[3][tmp] &= ~flag;
			break;
		case RANGE3:
			myData->bData[bd].rangeSelectV[0][tmp] &= ~flag;
			myData->bData[bd].rangeSelectV[1][tmp] &= ~flag;
			myData->bData[bd].rangeSelectV[2][tmp] |= flag;
			myData->bData[bd].rangeSelectV[3][tmp] &= ~flag;
			break;
		case RANGE4:
			myData->bData[bd].rangeSelectV[0][tmp] &= ~flag;
			myData->bData[bd].rangeSelectV[1][tmp] &= ~flag;
			myData->bData[bd].rangeSelectV[2][tmp] &= ~flag;
			myData->bData[bd].rangeSelectV[3][tmp] |= flag;
			break;
	}

	base_addr = myPs->addr.main[BASE_ADDR];

	if(myPs->config.ADC_type == COMM_TYPE) {
		range_v = myPs->addr.main[RANGE_V_CS];
		addr =base_addr + range_v + bd;
	} else {
		range_v = myPs->addr.main[RANGE_V_CS];
		addr =base_addr + range_v + bd;
	}

	if(myPs->config.hwSpec == L_6V_6A) {
		return;
	} else if(myPs->config.hwSpec == L_5V_10mA) {
		return;
	} else {
		return;
	}

	for(range=0; range < MAX_RANGE; range++) {
		tmp = range * 2;
		outb(myData->bData[bd].rangeSelectV[range][0], addr + tmp);
		outb(myData->bData[bd].rangeSelectV[range][1], addr + tmp + 1);
	}
}

void RangeSelectI(int bd)
{
	switch(myPs->config.hwSpec) {
		case L_5V_10mA:
			RangeSelectI_1(bd);
			break;
		case S_5V_200A:
		case L_2V_100A:
		case L_5V_100A_R2:
			RangeSelectI_2(bd);
			break;
		case L_5V_5A_2:
		case L_5V_50A:
			RangeSelectI_3(bd);
			break;
		case L_20V_25A:
			RangeSelectI_5(bd);
			break;
		case L_5V_200A_R2:
		case L_5V_200A_R4:
		case L_20V_50A_R2:
		case L_5V_500A_R2:
		case L_5V_300A_R3:
		case L_5V_200A_R3:
		case L_5V_400A_R3:
		case L_3V_200A_R2:
		case L_16V_200A_R2:
		case L_5V_250A_R2:
		case L_20V_300A_R2_1:
		case L_5V_220A_R2:
		case L_20V_110A_R2:
		case L_20V_50A_R2_1:
		case L_5V_120A_R3:
		case L_20V_300A_R2:
		case L_5V_100A_R2_1:
		case L_5V_150A_R3:
		case L_5V_65A_R3:
		case L_5V_50A_R2_1:
		case L_5V_100mA_R2:
		case L_5V_150A_R3_AD2:
		case L_15V_100A_R3_AD2:
		case L_8CH_MAIN_AD2_P:
		case L_5V_30A_R3_HYUNDAI:
		case L_30V_20A_R1_AD2:
		case L_5V_200A_R3_P:
		case L_5V_200A_R3_P_AD2:
		case L_MAIN_REV11:
			RangeSelectI_6(bd);
			break;
		case L_5V_50A_R2:
		case L_5V_2A_R2:
		case L_5V_4A_R2:
		case L_5V_6A_R3:
		case L_5V_500mA_R2:
		case L_5V_10_30A_R2:
		case L_5V_5A_R2:
		case L_5V_1A_R2:
		case L_6V_60A_R2_P:
		case L_6V_60A_R2:   //add for SK 50A K1 5floor
			RangeSelectI_7(bd);
			break;
		case L_10V_5A_R2:
			RangeSelectI_8(bd);
			break;
		case L_5V_1000A_R3:
		case L_10V_50A_R2:
			RangeSelectI_9(bd);
			break;
		case L_5V_20A_R3:
		case L_5V_10A_R3:
			RangeSelectI_10(bd);
			break;
		default:
			break;
	}
}

void RangeSelectI_Ch(int bd, int ch)
{
	if(myData->AppControl.config.systemType == CYCLER_CAN){
		RangeSelectI_Ch_CAN(bd, ch);
	}else{
		RangeSelectI_Ch_Default(bd, ch);
	}
}

void RangeSelectI_Ch_CAN(int bd, int ch)
{
	int range;
	
	range = (int)myCh->signal[C_SIG_I_RANGE];

	if(myCh->signal[C_SIG_RANGE_SWITCH] == P1){
		if(myCh->signal[C_SIG_RANGE_SWITCH_ON] != P2){
			myCh->signal[C_SIG_RANGE_SWITCH_ON] = P1;
		}
		myCh->signal[C_SIG_RANGE_SWITCH_OFF] = P0;
	}else{
		if(myCh->signal[C_SIG_RANGE_SWITCH_OFF] != P2){
			myCh->signal[C_SIG_RANGE_SWITCH_OFF] = P1;
		}
		//210104 lyhw
		if(myCh->signal[C_SIG_RANGE_SWITCH] == P2){
			myCh->signal[C_SIG_RANGE_SWITCH_OFF] = P2;
		}
		myCh->signal[C_SIG_RANGE_SWITCH_ON] = P0;
	}

	if(myCh->signal[C_SIG_RANGE_SWITCH] == P1){
		if(myCh->signal[C_SIG_RANGE_SWITCH_ON] == P1){
			myCh->signal[C_SIG_RANGE_SWITCH_ON] = P2;
			switch(range) {
				case RANGE0:			
					bCan_Each_Range_Out(bd, ch, HIGH_RANGE);
					break;
				case RANGE1:			
					bCan_Each_Range_Out(bd, ch, HIGH_RANGE);
					break;
				case RANGE2:			
					bCan_Each_Range_Out(bd, ch, MIDDLE_RANGE);
					break;
				case RANGE3:			
					bCan_Each_Range_Out(bd, ch, LOW_RANGE);
					break;
				case RANGE4:			
					bCan_Each_Range_Out(bd, ch, BOTTOM_RANGE);
					break;
			}
		}
	}else{
		if(myCh->signal[C_SIG_RANGE_SWITCH] == P0){
			if(myCh->signal[C_SIG_RANGE_SWITCH_OFF] == P1){
				myCh->signal[C_SIG_RANGE_SWITCH_OFF] = P2;
				bCan_Each_Range_Out(bd, ch, HIGH_RANGE);
			}
		}else{ 
			if(myCh->signal[C_SIG_RANGE_SWITCH_OFF] == P2){
				//210104 lyhw
				myCh->signal[C_SIG_RANGE_SWITCH_OFF] = P3;
			}
		}
	}
}

void RangeSelectI_Ch_Default(int bd, int ch)
{
#if CYCLER_TYPE == DIGITAL_CYC
	return;	//180611 add
#endif
	switch(myPs->config.hwSpec) {
		case L_5V_10mA:
			RangeSelectI_1(bd);
			break;
		case S_5V_200A:
		case L_2V_100A:
		case L_5V_100A_R2:
			RangeSelectI_2(bd);
			break;
		case L_5V_5A_2:
		case L_5V_50A:
			RangeSelectI_3(bd);
			break;
		case L_5V_20A:
			RangeSelectI_4_Ch(bd, ch);
			break;
		case L_20V_25A:
			RangeSelectI_5(bd);
			break;
		case L_5V_200A_R2:
		case L_5V_200A_R4:
		case L_20V_50A_R2:
		case L_5V_500A_R2:
		case L_5V_300A_R3:
		case L_5V_200A_R3:
		case L_5V_400A_R3:
		case L_3V_200A_R2:
		case L_16V_200A_R2:
		case L_5V_250A_R2:
		case L_20V_300A_R2_1:
		case L_5V_220A_R2:
		case L_20V_110A_R2:
		case L_20V_50A_R2_1:
		case L_5V_120A_R3:
		case L_20V_300A_R2:
		case L_40V_300A_R2:
		case L_30V_40A_R2:
		case L_30V_40A_R2_OT_20:
		case L_30V_40A_R2_P_AD2:
		case L_5V_100A_R2_1:
		case L_5V_150A_R3:
		case L_5V_65A_R3:
		case L_5V_50A_R2_1:
		case L_5V_100mA_R2:
		case L_5V_150A_R3_AD2:
		case L_8CH_MAIN_AD2_P:
		case L_5V_30A_R3_HYUNDAI:
		case L_30V_20A_R1_AD2:
		case L_30V_5A_R1_AD2:	
		case L_60V_100A_R1_AD2:	//LS Mtron
		case L_15V_100A_R3_AD2:
		case L_5V_200A_R3_P_AD2:
		case L_5V_200A_1CH_JIG:
		case L_5V_150A_R2_P:
		case L_5V_200A_R3_P:
		case L_5V_1A_R3:
		case L_MAIN_REV11:
		case L_5V_50A_R2_P:
		case L_5V_500A_R3_1:
		case L_20V_6A_R3: 	//210813 ljsw LGES 20V6A
			if(myData->AppControl.config.versionNo >= 20110701) {
				RangeSelectI_20_Ch(bd, ch);
			} else {
				RangeSelectI_6_Ch(bd, ch);
			}
			break;
		case L_5V_10A_R3_NEW:
			RangeSelectI_24_Ch(bd, ch);
			break;
		case L_5V_50A_R2:
		case L_5V_2A_R2:
		case L_5V_4A_R2:
		case L_5V_6A_R3:
		case L_5V_500mA_R2:
		case L_5V_10_30A_R2:
		case L_6V_60A_R2:
		case L_5V_5A_R2:
		case L_5V_1A_R2:
		case L_5V_60A_R2_1:			
		case L_5V_20A_R3_NEW:
		case L_5V_10A_R3:
			if(myData->AppControl.config.versionNo >= 20110701) {
				RangeSelectI_21_Ch(bd, ch);
			} else {
				RangeSelectI_7_Ch(bd, ch);
			}
			break;
		case L_10V_5A_R2:
			RangeSelectI_8_Ch(bd, ch);
			break;
		case L_5V_1000A_R3:	
		case L_10V_50A_R2:
			RangeSelectI_9_Ch(bd, ch);
			break;
		case L_5V_20A_R3:
			RangeSelectI_10_Ch(bd, ch);
			break;
		case L_6V_60A_R2_P:
			RangeSelectI_11_Ch(bd, ch);
			break;
		case L_MULTI:
			//RangeSelectI_23_Ch(bd,ch);
			RangeSelectI_22_Ch(bd,ch);
			break;
		case L_5V_500mA_2uA_R4:		//210512 lyhw
			RangeSelectI_25_Ch(bd,ch);
			break;
		default:
			break;
	}
}

/*
 *	Date: 7.6.2011			editor	:	pjy
 *	comment
 * 	This code is original source code
 *
void RangeSelectI_Ch(int bd, int ch)
{
	int hwSpec;

	hwSpec = myPs->config.hwSpec;
	
	switch(hwSpec){
		case L_5V_10mA:
			RangeSelectI_1(bd);
			break;
		case S_5V_200A:
		case L_2V_100A:
		case L_5V_100A_R2:
			RangeSelectI_2(bd);
			break;
		case L_5V_5A_2:
		case L_5V_50A:
			RangeSelectI_3(bd);
			break;
		case L_5V_20A:
			RangeSelectI_4_Ch(bd, ch);
			break;
		case L_20V_25A:
			RangeSelectI_5(bd);
			break;
		case L_5V_200A_R2:
		case L_5V_200A_R4:
		case L_20V_50A_R2:
		case L_5V_500A_R2:
		case L_5V_300A_R3:
		case L_5V_200A_R3:
		case L_5V_400A_R3:
		case L_3V_200A_R2:
		case L_16V_200A_R2:
		case L_5V_250A_R2:
		case L_20V_300A_R2_1:
		case L_5V_220A_R2:
		case L_20V_110A_R2:
		case L_20V_50A_R2_1:
		case L_5V_120A_R3:
		case L_20V_300A_R2:
		case L_5V_100A_R2_1:
		case L_5V_150A_R3:
		case L_5V_65A_R3:
		case L_5V_50A_R2_1:
		case L_5V_100mA_R2:
		case L_5V_150A_R3_AD2:
		case L_8CH_MAIN_AD2_P:
		case L_30V_20A_R1_AD2:
		case L_30V_5A_R1_AD2:	
		case L_60V_100A_R1_AD2:	//LS Mtron
		case L_5V_200A_R3_P_AD2:
		case L_5V_200A_R3_P:
			RangeSelectI_6_Ch(bd, ch);
			break;
		case L_5V_50A_R2:
		case L_5V_2A_R2:
		case L_5V_4A_R2:
		case L_5V_6A_R3:
		case L_5V_500mA_R2:
		case L_5V_10_30A_R2:
		case L_5V_5A_R2:
		case L_5V_1A_R2:
		case L_5V_60A_R2_1:
			RangeSelectI_7_Ch(bd, ch);
			break;
		case L_10V_5A_R2:
			RangeSelectI_8_Ch(bd, ch);
			break;
		case L_5V_1000A_R3:	
		case L_10V_50A_R2:
			RangeSelectI_9_Ch(bd, ch);
			break;
		case L_5V_20A_R3:
		case L_5V_10A_R3:
			RangeSelectI_10_Ch(bd, ch);
			break;
		case L_6V_60A_R2_P:
			RangeSelectI_11_Ch(bd, ch);
			break;
		default: break;
	}
}
*/
void RangeSelectI_1(int bd)
{
	int tmp, ch, range;
	int addr, base_addr, range_i;
	unsigned char flag = 0x01;

	for(ch=0; ch < myPs->config.chPerBd; ch++) {
		flag = 0x01;
		flag = flag << (ch % 8);
		tmp = ch / 8;
		range = (int)myCh->signal[C_SIG_I_RANGE];
		switch(range) {
			case RANGE0:
				myData->bData[bd].rangeSelectI[0][tmp] &= ~flag;
				myData->bData[bd].rangeSelectI[1][tmp] &= ~flag;
				myData->bData[bd].rangeSelectI[2][tmp] &= ~flag;
				myData->bData[bd].rangeSelectI[3][tmp] &= ~flag;
				break;
			case RANGE1:
				myData->bData[bd].rangeSelectI[0][tmp] |= flag;
				myData->bData[bd].rangeSelectI[1][tmp] &= ~flag;
				myData->bData[bd].rangeSelectI[2][tmp] &= ~flag;
				myData->bData[bd].rangeSelectI[3][tmp] &= ~flag;
				break;
			case RANGE2:
				myData->bData[bd].rangeSelectI[0][tmp] &= ~flag;
				myData->bData[bd].rangeSelectI[1][tmp] |= flag;
				myData->bData[bd].rangeSelectI[2][tmp] &= ~flag;
				myData->bData[bd].rangeSelectI[3][tmp] &= ~flag;
				break;
			case RANGE3:
				myData->bData[bd].rangeSelectI[0][tmp] &= ~flag;
				myData->bData[bd].rangeSelectI[1][tmp] &= ~flag;
				myData->bData[bd].rangeSelectI[2][tmp] |= flag;
				myData->bData[bd].rangeSelectI[3][tmp] &= ~flag;
				break;
			case RANGE4:
				myData->bData[bd].rangeSelectI[0][tmp] &= ~flag;
				myData->bData[bd].rangeSelectI[1][tmp] &= ~flag;
				myData->bData[bd].rangeSelectI[2][tmp] &= ~flag;
				myData->bData[bd].rangeSelectI[3][tmp] |= flag;
				break;
		}
	}

	base_addr = myPs->addr.main[BASE_ADDR];
	range_i = myPs->addr.main[RANGE_I_CS];
	if(myPs->config.ADC_type == COMM_TYPE) {
		addr = base_addr + range_i + bd;
	} else {
		addr = base_addr + range_i + bd * 2;
		outb(myData->bData[bd].rangeSelectI[0][0], addr);
		outb(myData->bData[bd].rangeSelectI[0][1], addr + 1);
	}
}

void RangeSelectI_2(int bd)
{
	int tmp, ch, range;
	int	addr, base_addr, range_i;
	unsigned char flag = 0x01;

	for(ch=0; ch < myPs->config.chPerBd; ch++) {
		flag = 0x01;
		flag = flag << (ch % 8);
		tmp = ch / 8;
		range = (int)myCh->signal[C_SIG_I_RANGE];
		switch(range) {
			case RANGE0:
				myData->bData[bd].rangeSelectI[0][tmp] &= ~flag;
				myData->bData[bd].rangeSelectI[1][tmp] &= ~flag;
				myData->bData[bd].rangeSelectI[2][tmp] &= ~flag;
				myData->bData[bd].rangeSelectI[3][tmp] &= ~flag;
				break;
			case RANGE1:
				myData->bData[bd].rangeSelectI[0][tmp] |= flag;
				myData->bData[bd].rangeSelectI[1][tmp] &= ~flag;
				myData->bData[bd].rangeSelectI[2][tmp] &= ~flag;
				myData->bData[bd].rangeSelectI[3][tmp] &= ~flag;
				break;
			case RANGE2:
				myData->bData[bd].rangeSelectI[0][tmp] &= ~flag;
				myData->bData[bd].rangeSelectI[1][tmp] |= flag;
				myData->bData[bd].rangeSelectI[2][tmp] &= ~flag;
				myData->bData[bd].rangeSelectI[3][tmp] &= ~flag;
				break;
			case RANGE3:
				myData->bData[bd].rangeSelectI[0][tmp] &= ~flag;
				myData->bData[bd].rangeSelectI[1][tmp] &= ~flag;
				myData->bData[bd].rangeSelectI[2][tmp] |= flag;
				myData->bData[bd].rangeSelectI[3][tmp] &= ~flag;
				break;
			case RANGE4:
				myData->bData[bd].rangeSelectI[0][tmp] &= ~flag;
				myData->bData[bd].rangeSelectI[1][tmp] &= ~flag;
				myData->bData[bd].rangeSelectI[2][tmp] &= ~flag;
				myData->bData[bd].rangeSelectI[3][tmp] |= flag;
				break;
		}
	}

	base_addr = myPs->addr.main[BASE_ADDR];
	range_i = myPs->addr.main[RANGE_I_CS];
	if(myPs->config.ADC_type == COMM_TYPE) {
		addr = base_addr + range_i + bd;
	} else {
		addr = base_addr + range_i + bd * 2;
		outb(myData->bData[bd].rangeSelectI[0][0], addr);
		outb(myData->bData[bd].rangeSelectI[1][0], addr + 2);
	}
}

void RangeSelectI_3(int bd)
{
	int tmp, ch, range;
	int	addr, base_addr, range_i;
	unsigned char flag = 0x01;
	for(ch=0; ch < myPs->config.chPerBd; ch++) {
		flag = 0x01;
		flag = flag << (ch % 8);
		tmp = ch / 8;
		range = (int)myCh->signal[C_SIG_I_RANGE];
		switch(range) {
			case RANGE0:
				myData->bData[bd].rangeSelectI[0][tmp] &= ~flag;
				myData->bData[bd].rangeSelectI[1][tmp] &= ~flag;
				myData->bData[bd].rangeSelectI[2][tmp] &= ~flag;
				myData->bData[bd].rangeSelectI[3][tmp] &= ~flag;
				break;
			case RANGE1:
				myData->bData[bd].rangeSelectI[0][tmp] |= flag;
				myData->bData[bd].rangeSelectI[1][tmp] &= ~flag;
				myData->bData[bd].rangeSelectI[2][tmp] &= ~flag;
				myData->bData[bd].rangeSelectI[3][tmp] &= ~flag;
				break;
			case RANGE2:
				myData->bData[bd].rangeSelectI[0][tmp] &= ~flag;
				myData->bData[bd].rangeSelectI[1][tmp] |= flag;
				myData->bData[bd].rangeSelectI[2][tmp] &= ~flag;
				myData->bData[bd].rangeSelectI[3][tmp] &= ~flag;
				break;
			case RANGE3:
				myData->bData[bd].rangeSelectI[0][tmp] &= ~flag;
				myData->bData[bd].rangeSelectI[1][tmp] &= ~flag;
				myData->bData[bd].rangeSelectI[2][tmp] |= flag;
				myData->bData[bd].rangeSelectI[3][tmp] &= ~flag;
				break;
			case RANGE4:
				myData->bData[bd].rangeSelectI[0][tmp] &= ~flag;
				myData->bData[bd].rangeSelectI[1][tmp] &= ~flag;
				myData->bData[bd].rangeSelectI[2][tmp] &= ~flag;
				myData->bData[bd].rangeSelectI[3][tmp] |= flag;
				break;
		}
	}

	base_addr = myPs->addr.main[BASE_ADDR];
	range_i = myPs->addr.main[RANGE_I_CS];
	if(myPs->config.ADC_type == COMM_TYPE) {
		addr = base_addr + range_i + bd;
	} else {
		addr = base_addr + range_i + bd;
		outb(myData->bData[bd].rangeSelectI[0][0], addr);
		outb(myData->bData[bd].rangeSelectI[1][0], addr + 4);
	}
}

void RangeSelectI_4(int bd)
{
	int tmp, ch, range, virtualBd, virtualCh, wr;
	int	addr, base_addr, range_i;
	unsigned char flag = 0x01;

	for(ch=0; ch < myPs->config.chPerBd; ch++) {
		virtualBd = (myPs->config.chPerBd * bd + ch)/8;
		flag = 0x01;
		virtualCh = myPs->config.chPerBd * bd + ch;
		flag = flag << (virtualCh % 8);
		tmp = 0;
		range = (int)myCh->signal[C_SIG_I_RANGE];
		switch(range) {
			case RANGE0:
				myData->bData[virtualBd].rangeSelectI[0][tmp] &= ~flag;
				myData->bData[virtualBd].rangeSelectI[1][tmp] &= ~flag;
				myData->bData[virtualBd].rangeSelectI[2][tmp] &= ~flag;
				myData->bData[virtualBd].rangeSelectI[3][tmp] &= ~flag;
				break;
			case RANGE1:
				myData->bData[virtualBd].rangeSelectI[0][tmp] |= flag;
				myData->bData[virtualBd].rangeSelectI[1][tmp] &= ~flag;
				myData->bData[virtualBd].rangeSelectI[2][tmp] &= ~flag;
				myData->bData[virtualBd].rangeSelectI[3][tmp] &= ~flag;
				break;
			case RANGE2:
				myData->bData[virtualBd].rangeSelectI[0][tmp] &= ~flag;
				myData->bData[virtualBd].rangeSelectI[1][tmp] |= flag;
				myData->bData[virtualBd].rangeSelectI[2][tmp] &= ~flag;
				myData->bData[virtualBd].rangeSelectI[3][tmp] &= ~flag;
				break;
			case RANGE3:
				myData->bData[virtualBd].rangeSelectI[0][tmp] &= ~flag;
				myData->bData[virtualBd].rangeSelectI[1][tmp] &= ~flag;
				myData->bData[virtualBd].rangeSelectI[2][tmp] |= flag;
				myData->bData[virtualBd].rangeSelectI[3][tmp] &= ~flag;
				break;
			case RANGE4:
				myData->bData[virtualBd].rangeSelectI[0][tmp] &= ~flag;
				myData->bData[virtualBd].rangeSelectI[1][tmp] &= ~flag;
				myData->bData[virtualBd].rangeSelectI[2][tmp] &= ~flag;
				myData->bData[virtualBd].rangeSelectI[3][tmp] |= flag;
				break;
		}
	}
	base_addr = myPs->addr.main[BASE_ADDR];
	range_i = myPs->addr.main[RANGE_I_CS];
	for(wr = 0; wr < 2; wr ++){
		virtualBd = bd + wr;
		if(myPs->config.ADC_type == COMM_TYPE) {
			addr = base_addr + range_i + virtualBd;
		} else {
			addr = base_addr + range_i + virtualBd;
			outb(myData->bData[virtualBd].rangeSelectI[0][0], addr);
			outb(myData->bData[virtualBd].rangeSelectI[1][0], addr + 5);
		}
	}
}

void RangeSelectI_4_Ch(int bd, int ch)
{
	int tmp, range, virtualBd, virtualCh, wr;
	int	addr, base_addr, range_i;
	unsigned char flag = 0x01;

	virtualBd = (myPs->config.chPerBd * bd + ch)/8;
	flag = 0x01;
	virtualCh = myPs->config.chPerBd * bd + ch;
	flag = flag << (virtualCh % 8);
	tmp = 0;
	range = (int)myCh->signal[C_SIG_I_RANGE];
	switch(range) {
		case RANGE0:
			myData->bData[virtualBd].rangeSelectI[0][tmp] &= ~flag;
			myData->bData[virtualBd].rangeSelectI[1][tmp] &= ~flag;
			myData->bData[virtualBd].rangeSelectI[2][tmp] &= ~flag;
			myData->bData[virtualBd].rangeSelectI[3][tmp] &= ~flag;
			break;
		case RANGE1:
			myData->bData[virtualBd].rangeSelectI[0][tmp] |= flag;
			myData->bData[virtualBd].rangeSelectI[1][tmp] &= ~flag;
			myData->bData[virtualBd].rangeSelectI[2][tmp] &= ~flag;
			myData->bData[virtualBd].rangeSelectI[3][tmp] &= ~flag;
			break;
		case RANGE2:
			myData->bData[virtualBd].rangeSelectI[0][tmp] &= ~flag;
			myData->bData[virtualBd].rangeSelectI[1][tmp] |= flag;
			myData->bData[virtualBd].rangeSelectI[2][tmp] &= ~flag;
			myData->bData[virtualBd].rangeSelectI[3][tmp] &= ~flag;
			break;
		case RANGE3:
			myData->bData[virtualBd].rangeSelectI[0][tmp] &= ~flag;
			myData->bData[virtualBd].rangeSelectI[1][tmp] &= ~flag;
			myData->bData[virtualBd].rangeSelectI[2][tmp] |= flag;
			myData->bData[virtualBd].rangeSelectI[3][tmp] &= ~flag;
			break;
		case RANGE4:
			myData->bData[virtualBd].rangeSelectI[0][tmp] &= ~flag;
			myData->bData[virtualBd].rangeSelectI[1][tmp] &= ~flag;
			myData->bData[virtualBd].rangeSelectI[2][tmp] &= ~flag;
			myData->bData[virtualBd].rangeSelectI[3][tmp] |= flag;
			break;
	}
	base_addr = myPs->addr.main[BASE_ADDR];
	range_i = myPs->addr.main[RANGE_I_CS];
	for(wr = 0; wr < 2; wr ++){
		virtualBd = bd + wr;
		if(myPs->config.ADC_type == COMM_TYPE) {
			addr = base_addr + range_i + virtualBd;
		} else {
			addr = base_addr + range_i + virtualBd;
			outb(myData->bData[virtualBd].rangeSelectI[0][0], addr);
			outb(myData->bData[virtualBd].rangeSelectI[1][0], addr + 5);
		}
	}
}


void RangeSelectI_5(int bd)
{
	int tmp = 0, ch, range;
	int	addr, base_addr, addr_step, range_i, addr_div, index;
	unsigned char flag = 0x01;
	for(ch=0; ch < myPs->config.chPerBd; ch++) {
		flag = 0x01;
		flag = flag << (ch % 8);
		tmp = ch / 8;
		range = (int)myCh->signal[C_SIG_I_RANGE];
		switch(range) {
			case RANGE0:
				myData->bData[bd].rangeSelectI[0][tmp] &= ~flag;
				myData->bData[bd].rangeSelectI[1][tmp] &= ~flag;
				myData->bData[bd].rangeSelectI[2][tmp] &= ~flag;
				myData->bData[bd].rangeSelectI[3][tmp] &= ~flag;
				break;
			case RANGE1:
				myData->bData[bd].rangeSelectI[0][tmp] |= flag;
				myData->bData[bd].rangeSelectI[1][tmp] &= ~flag;
				myData->bData[bd].rangeSelectI[2][tmp] &= ~flag;
				myData->bData[bd].rangeSelectI[3][tmp] &= ~flag;
				break;
			case RANGE2:
				myData->bData[bd].rangeSelectI[0][tmp] &= ~flag;
				myData->bData[bd].rangeSelectI[1][tmp] |= flag;
				myData->bData[bd].rangeSelectI[2][tmp] &= ~flag;
				myData->bData[bd].rangeSelectI[3][tmp] &= ~flag;
				break;
			case RANGE3:
				myData->bData[bd].rangeSelectI[0][tmp] &= ~flag;
				myData->bData[bd].rangeSelectI[1][tmp] &= ~flag;
				myData->bData[bd].rangeSelectI[2][tmp] |= flag;
				myData->bData[bd].rangeSelectI[3][tmp] &= ~flag;
				break;
			case RANGE4:
				myData->bData[bd].rangeSelectI[0][tmp] &= ~flag;
				myData->bData[bd].rangeSelectI[1][tmp] &= ~flag;
				myData->bData[bd].rangeSelectI[2][tmp] &= ~flag;
				myData->bData[bd].rangeSelectI[3][tmp] |= flag;
				break;
		}
	}

	base_addr = myPs->addr.main[BASE_ADDR];
	addr_step = myPs->addr.main[ADDR_STEP];
	range_i = myPs->addr.main[RANGE_I_CS];
	addr_div = myPs->addr.main[ADDR_DIV];

	if(myPs->config.ADC_type == COMM_TYPE) {
		addr = base_addr + range_i + tmp;
	} else {
		addr = base_addr + addr_step * bd + addr_div;
		outb(0x02, addr);
		
		addr = base_addr + addr_step * bd + range_i;
		for(index=0; index <= (myPs->config.chPerBd-1)/8; index++) {
			outb(myData->bData[bd].rangeSelectI[0][index], addr + index);
		}
		addr = base_addr + addr_step * bd + addr_div;
		outb(0x00, addr);
	}
}

void RangeSelectI_6(int bd)
{
	int tmp = 0, ch, range, i;
	int	addr, base_addr, addr_step, range_i, addr_div, index;
	unsigned char flag = 0x01, div;
	for(ch=0; ch < myPs->config.chPerBd; ch++) {
		flag = 0x01;
		flag = flag << (ch % 8);
		tmp = ch / 8;
		range = (int)myCh->signal[C_SIG_I_RANGE];
		switch(range) {
			case RANGE0:
				myData->bData[bd].rangeSelectI[0][tmp] &= ~flag;
				myData->bData[bd].rangeSelectI[1][tmp] &= ~flag;
				myData->bData[bd].rangeSelectI[2][tmp] &= ~flag;
				myData->bData[bd].rangeSelectI[3][tmp] &= ~flag;
				break;
			case RANGE1:
				myData->bData[bd].rangeSelectI[0][tmp] |= flag;
				myData->bData[bd].rangeSelectI[1][tmp] &= ~flag;
				myData->bData[bd].rangeSelectI[2][tmp] &= ~flag;
				myData->bData[bd].rangeSelectI[3][tmp] &= ~flag;
				break;
			case RANGE2:
				myData->bData[bd].rangeSelectI[0][tmp] &= ~flag;
				myData->bData[bd].rangeSelectI[1][tmp] |= flag;
				myData->bData[bd].rangeSelectI[2][tmp] &= ~flag;
				myData->bData[bd].rangeSelectI[3][tmp] &= ~flag;
				break;
			case RANGE3:
				myData->bData[bd].rangeSelectI[0][tmp] &= ~flag;
				myData->bData[bd].rangeSelectI[1][tmp] &= ~flag;
				myData->bData[bd].rangeSelectI[2][tmp] |= flag;
				myData->bData[bd].rangeSelectI[3][tmp] &= ~flag;
				break;
			case RANGE4:
				myData->bData[bd].rangeSelectI[0][tmp] &= ~flag;
				myData->bData[bd].rangeSelectI[1][tmp] &= ~flag;
				myData->bData[bd].rangeSelectI[2][tmp] &= ~flag;
				myData->bData[bd].rangeSelectI[3][tmp] |= flag;
				break;
		}
	}

	base_addr = myPs->addr.main[BASE_ADDR];
	addr_step = myPs->addr.main[ADDR_STEP];
	range_i = myPs->addr.main[RANGE_I_CS];
	addr_div = myPs->addr.main[ADDR_DIV];

	if(myPs->config.ADC_type == COMM_TYPE) {
		addr = base_addr + range_i + tmp;
	} else {
		for( i = 0; i < myPs->config.rangeI; i++){
			div = 0x10 << i;
			addr = base_addr + addr_step * bd + addr_div;
			outb(div, addr);
		
			addr = base_addr + addr_step * bd + range_i;
			for(index=0; index <= (myPs->config.chPerBd-1) / 8; index++) {
				outb(myData->bData[bd].rangeSelectI[i][index], addr + index);
			}
		}
		addr = base_addr + addr_step * bd + addr_div;
		outb(0x00, addr);
	}
}

void RangeSelectI_6_Ch(int bd, int ch)
{
	int tmp = 0, range, i;
	int	addr, base_addr, addr_step, range_i, addr_div, index;
	unsigned char flag = 0x01, div;

	myCh = &(myData->bData[bd].cData[ch]);
	flag = 0x01;
	flag = flag << (ch % 8);
	tmp = ch / 8;
	range = (int)myCh->signal[C_SIG_I_RANGE];
	switch(range) {
		case RANGE0:
			myData->bData[bd].rangeSelectI[0][tmp] &= ~flag;
			myData->bData[bd].rangeSelectI[1][tmp] &= ~flag;
			myData->bData[bd].rangeSelectI[2][tmp] &= ~flag;
			myData->bData[bd].rangeSelectI[3][tmp] &= ~flag;
			break;
		case RANGE1:
			myData->bData[bd].rangeSelectI[0][tmp] |= flag;
			myData->bData[bd].rangeSelectI[1][tmp] &= ~flag;
			myData->bData[bd].rangeSelectI[2][tmp] &= ~flag;
			myData->bData[bd].rangeSelectI[3][tmp] &= ~flag;
			break;
		case RANGE2:
			myData->bData[bd].rangeSelectI[0][tmp] &= ~flag;
			myData->bData[bd].rangeSelectI[1][tmp] |= flag;
			myData->bData[bd].rangeSelectI[2][tmp] &= ~flag;
			myData->bData[bd].rangeSelectI[3][tmp] &= ~flag;
			break;
		case RANGE3:
			myData->bData[bd].rangeSelectI[0][tmp] &= ~flag;
			myData->bData[bd].rangeSelectI[1][tmp] &= ~flag;
			myData->bData[bd].rangeSelectI[2][tmp] |= flag;
			myData->bData[bd].rangeSelectI[3][tmp] &= ~flag;
			break;
		case RANGE4:
			myData->bData[bd].rangeSelectI[0][tmp] &= ~flag;
			myData->bData[bd].rangeSelectI[1][tmp] &= ~flag;
			myData->bData[bd].rangeSelectI[2][tmp] &= ~flag;
			myData->bData[bd].rangeSelectI[3][tmp] |= flag;
			break;
	}

	base_addr = myPs->addr.main[BASE_ADDR];
	addr_step = myPs->addr.main[ADDR_STEP];
	range_i = myPs->addr.main[RANGE_I_CS];
	addr_div = myPs->addr.main[ADDR_DIV];

	if(myPs->config.ADC_type == COMM_TYPE) {
		addr = base_addr + range_i + tmp;
	} else {
		for( i = 0; i < myPs->config.rangeI; i++){
			div = 0x10 << i;
			addr = base_addr + addr_step * bd + addr_div;
			outb(div, addr);
		
			addr = base_addr + addr_step * bd + range_i;
			for(index=0; index <= (myPs->config.chPerBd-1) / 8; index++) {
				outb(myData->bData[bd].rangeSelectI[i][index], addr + index);
			}
		}
		addr = base_addr + addr_step * bd + addr_div;
		outb(0x00, addr);
	}
}


void RangeSelectI_7(int bd)
{
	int tmp = 0, ch, range, i;
	int	addr, base_addr, addr_step, range_i, addr_div, index;
	unsigned char flag = 0x01, div;
	for(ch=0; ch < myPs->config.chPerBd; ch++) {
		flag = 0x01;
		flag = flag << (ch % 8);
		tmp = ch / 8;
		range = (int)myCh->signal[C_SIG_I_RANGE];
		if(myCh->signal[C_SIG_RANGE_SWITCH] == P1){
			switch(range) {
				case RANGE0:
					myData->bData[bd].rangeSelectI[0][tmp] &= ~flag;
					myData->bData[bd].rangeSelectI[1][tmp] &= ~flag;
					myData->bData[bd].rangeSelectI[2][tmp] &= ~flag;
					myData->bData[bd].rangeSelectI[3][tmp] &= ~flag;
					break;
				case RANGE1:
					myData->bData[bd].rangeSelectI[0][tmp] |= flag;
					myData->bData[bd].rangeSelectI[1][tmp] &= ~flag;
					myData->bData[bd].rangeSelectI[2][tmp] &= ~flag;
					myData->bData[bd].rangeSelectI[3][tmp] &= ~flag;
					break;
				case RANGE2:
					myData->bData[bd].rangeSelectI[0][tmp] &= ~flag;
					myData->bData[bd].rangeSelectI[1][tmp] |= flag;
					myData->bData[bd].rangeSelectI[2][tmp] &= ~flag;
					myData->bData[bd].rangeSelectI[3][tmp] &= ~flag;
					break;
				case RANGE3:
					myData->bData[bd].rangeSelectI[0][tmp] &= ~flag;
					myData->bData[bd].rangeSelectI[1][tmp] &= ~flag;
					myData->bData[bd].rangeSelectI[2][tmp] |= flag;
					myData->bData[bd].rangeSelectI[3][tmp] &= ~flag;
					break;
				case RANGE4:
					myData->bData[bd].rangeSelectI[0][tmp] &= ~flag;
					myData->bData[bd].rangeSelectI[1][tmp] &= ~flag;
					myData->bData[bd].rangeSelectI[2][tmp] &= ~flag;
					myData->bData[bd].rangeSelectI[3][tmp] |= flag;
					break;
			}
		}else{
			myData->bData[bd].rangeSelectI[0][tmp] &= ~flag;
			myData->bData[bd].rangeSelectI[1][tmp] &= ~flag;
			myData->bData[bd].rangeSelectI[2][tmp] &= ~flag;
			myData->bData[bd].rangeSelectI[3][tmp] &= ~flag;
		}
	}

	base_addr = myPs->addr.main[BASE_ADDR];
	addr_step = myPs->addr.main[ADDR_STEP];
	range_i = myPs->addr.main[RANGE_I_CS];
	addr_div = myPs->addr.main[ADDR_DIV];

	if(myPs->config.ADC_type == COMM_TYPE) {
		addr = base_addr + range_i + tmp;
	} else {
		for( i = 0; i < myPs->config.rangeI; i++){
			div = 0x10 << i;
			addr = base_addr + addr_step * bd + addr_div;
			outb(div, addr);
		
			addr = base_addr + addr_step * bd + range_i;
			for(index=0; index <= (myPs->config.chPerBd-1) / 8; index++) {
				outb(myData->bData[bd].rangeSelectI[i][index], addr + index);
			}
		}
		addr = base_addr + addr_step * bd + addr_div;
		outb(0x00, addr);
	}
}
void RangeSelectI_7_Ch(int bd, int ch)
{
	int tmp = 0, range, i;
	int	addr, base_addr, addr_step, range_i, addr_div, index;
	unsigned char flag = 0x01, div;
	
	myCh = &(myData->bData[bd].cData[ch]);
	flag = 0x01;
	flag = flag << (ch % 8);
	tmp = ch / 8;
	range = (int)myCh->signal[C_SIG_I_RANGE];
	if(myCh->signal[C_SIG_RANGE_SWITCH] == P1){
		switch(range) {
			case RANGE0:
				myData->bData[bd].rangeSelectI[0][tmp] &= ~flag;
				myData->bData[bd].rangeSelectI[1][tmp] &= ~flag;
				myData->bData[bd].rangeSelectI[2][tmp] &= ~flag;
				myData->bData[bd].rangeSelectI[3][tmp] &= ~flag;
				break;
			case RANGE1:
				myData->bData[bd].rangeSelectI[0][tmp] |= flag;
				myData->bData[bd].rangeSelectI[1][tmp] &= ~flag;
				myData->bData[bd].rangeSelectI[2][tmp] &= ~flag;
				myData->bData[bd].rangeSelectI[3][tmp] &= ~flag;
				break;
			case RANGE2:
				myData->bData[bd].rangeSelectI[0][tmp] &= ~flag;
				myData->bData[bd].rangeSelectI[1][tmp] |= flag;
				myData->bData[bd].rangeSelectI[2][tmp] &= ~flag;
				myData->bData[bd].rangeSelectI[3][tmp] &= ~flag;
				break;
			case RANGE3:
				myData->bData[bd].rangeSelectI[0][tmp] &= ~flag;
				myData->bData[bd].rangeSelectI[1][tmp] &= ~flag;
				myData->bData[bd].rangeSelectI[2][tmp] |= flag;
				myData->bData[bd].rangeSelectI[3][tmp] &= ~flag;
				break;
			case RANGE4:
				myData->bData[bd].rangeSelectI[0][tmp] &= ~flag;
				myData->bData[bd].rangeSelectI[1][tmp] &= ~flag;
				myData->bData[bd].rangeSelectI[2][tmp] &= ~flag;
				myData->bData[bd].rangeSelectI[3][tmp] |= flag;
				break;
		}
	}else{
		myData->bData[bd].rangeSelectI[0][tmp] &= ~flag;
		myData->bData[bd].rangeSelectI[1][tmp] &= ~flag;
		myData->bData[bd].rangeSelectI[2][tmp] &= ~flag;
		myData->bData[bd].rangeSelectI[3][tmp] &= ~flag;
	}
	

	base_addr = myPs->addr.main[BASE_ADDR];
	addr_step = myPs->addr.main[ADDR_STEP];
	range_i = myPs->addr.main[RANGE_I_CS];
	addr_div = myPs->addr.main[ADDR_DIV];

	if(myPs->config.ADC_type == COMM_TYPE) {
		addr = base_addr + range_i + tmp;
	} else {
		for( i = 0; i < myPs->config.rangeI; i++){
			div = 0x10 << i;
			addr = base_addr + addr_step * bd + addr_div;
			outb(div, addr);
		
			addr = base_addr + addr_step * bd + range_i;
			for(index=0; index <= (myPs->config.chPerBd-1) / 8; index++) {
				outb(myData->bData[bd].rangeSelectI[i][index], addr + index);
			}
		}
		addr = base_addr + addr_step * bd + addr_div;
		outb(0x00, addr);
	}
}

void RangeSelectI_8(int bd)
{
	int tmp = 0, ch, range, i;
	int	addr, base_addr, addr_step, range_i, addr_div, index;
	unsigned char flag = 0x01, div;
	for(ch=0; ch < myPs->config.chPerBd; ch++) {
		flag = 0x01;
		flag = flag << (ch % 4);
		tmp = ch / 4;
		range = (int)myCh->signal[C_SIG_I_RANGE];
		if(myCh->signal[C_SIG_RANGE_SWITCH] == P1){
			switch(range) {
				case RANGE0:
					myData->bData[bd].rangeSelectI[0][tmp] &= ~flag;
					myData->bData[bd].rangeSelectI[1][tmp] &= ~flag;
					myData->bData[bd].rangeSelectI[2][tmp] &= ~flag;
					myData->bData[bd].rangeSelectI[3][tmp] &= ~flag;
					break;
				case RANGE1:
					myData->bData[bd].rangeSelectI[0][tmp] |= flag;
					myData->bData[bd].rangeSelectI[1][tmp] &= ~flag;
					myData->bData[bd].rangeSelectI[2][tmp] &= ~flag;
					myData->bData[bd].rangeSelectI[3][tmp] &= ~flag;
					break;
				case RANGE2:
					myData->bData[bd].rangeSelectI[0][tmp] &= ~flag;
					myData->bData[bd].rangeSelectI[1][tmp] |= flag;
					myData->bData[bd].rangeSelectI[2][tmp] &= ~flag;
					myData->bData[bd].rangeSelectI[3][tmp] &= ~flag;
					break;
				case RANGE3:
					myData->bData[bd].rangeSelectI[0][tmp] &= ~flag;
					myData->bData[bd].rangeSelectI[1][tmp] &= ~flag;
					myData->bData[bd].rangeSelectI[2][tmp] |= flag;
					myData->bData[bd].rangeSelectI[3][tmp] &= ~flag;
					break;
				case RANGE4:
					myData->bData[bd].rangeSelectI[0][tmp] &= ~flag;
					myData->bData[bd].rangeSelectI[1][tmp] &= ~flag;
					myData->bData[bd].rangeSelectI[2][tmp] &= ~flag;
					myData->bData[bd].rangeSelectI[3][tmp] |= flag;
					break;
			}
		}else{
			myData->bData[bd].rangeSelectI[0][tmp] &= ~flag;
			myData->bData[bd].rangeSelectI[1][tmp] &= ~flag;
			myData->bData[bd].rangeSelectI[2][tmp] &= ~flag;
			myData->bData[bd].rangeSelectI[3][tmp] &= ~flag;
		}
	}

	base_addr = myPs->addr.main[BASE_ADDR];
	addr_step = myPs->addr.main[ADDR_STEP];
	range_i = myPs->addr.main[RANGE_I_CS];
	addr_div = myPs->addr.main[ADDR_DIV];

	if(myPs->config.ADC_type == COMM_TYPE) {
		addr = base_addr + range_i + tmp;
	} else {
		for( i = 0; i < myPs->config.rangeI; i++){
			div = 0x10 << i;
			addr = base_addr + addr_step * bd + addr_div;
			outb(div, addr);
		
			addr = base_addr + addr_step * bd + range_i;
			for(index=0; index <= (myPs->config.chPerBd-1) / 4; index++) {
				outb(myData->bData[bd].rangeSelectI[i][index], addr + index);
			}
		}
		addr = base_addr + addr_step * bd + addr_div;
		outb(0x00, addr);
	}
}

void RangeSelectI_8_Ch(int bd, int ch)
{
	int tmp = 0, range, i;
	int	addr, base_addr, addr_step, range_i, addr_div, index;
	unsigned char flag = 0x01, div;

	myCh = &(myData->bData[bd].cData[ch]);
	flag = 0x01;
	flag = flag << (ch % 4);
	tmp = ch / 4;
	range = (int)myCh->signal[C_SIG_I_RANGE];
	if(myCh->signal[C_SIG_RANGE_SWITCH] == P1){
		switch(range) {
			case RANGE0:
				myData->bData[bd].rangeSelectI[0][tmp] &= ~flag;
				myData->bData[bd].rangeSelectI[1][tmp] &= ~flag;
				myData->bData[bd].rangeSelectI[2][tmp] &= ~flag;
				myData->bData[bd].rangeSelectI[3][tmp] &= ~flag;
			break;
			case RANGE1:
				myData->bData[bd].rangeSelectI[0][tmp] |= flag;
				myData->bData[bd].rangeSelectI[1][tmp] &= ~flag;
				myData->bData[bd].rangeSelectI[2][tmp] &= ~flag;
				myData->bData[bd].rangeSelectI[3][tmp] &= ~flag;
				break;
			case RANGE2:
				myData->bData[bd].rangeSelectI[0][tmp] &= ~flag;
				myData->bData[bd].rangeSelectI[1][tmp] |= flag;
				myData->bData[bd].rangeSelectI[2][tmp] &= ~flag;
				myData->bData[bd].rangeSelectI[3][tmp] &= ~flag;
				break;
			case RANGE3:
				myData->bData[bd].rangeSelectI[0][tmp] &= ~flag;
				myData->bData[bd].rangeSelectI[1][tmp] &= ~flag;
				myData->bData[bd].rangeSelectI[2][tmp] |= flag;
				myData->bData[bd].rangeSelectI[3][tmp] &= ~flag;
				break;
			case RANGE4:
				myData->bData[bd].rangeSelectI[0][tmp] &= ~flag;
				myData->bData[bd].rangeSelectI[1][tmp] &= ~flag;
				myData->bData[bd].rangeSelectI[2][tmp] &= ~flag;
				myData->bData[bd].rangeSelectI[3][tmp] |= flag;
				break;
		}
	}else{
		myData->bData[bd].rangeSelectI[0][tmp] &= ~flag;
		myData->bData[bd].rangeSelectI[1][tmp] &= ~flag;
		myData->bData[bd].rangeSelectI[2][tmp] &= ~flag;
		myData->bData[bd].rangeSelectI[3][tmp] &= ~flag;
	}

	base_addr = myPs->addr.main[BASE_ADDR];
	addr_step = myPs->addr.main[ADDR_STEP];
	range_i = myPs->addr.main[RANGE_I_CS];
	addr_div = myPs->addr.main[ADDR_DIV];

	if(myPs->config.ADC_type == COMM_TYPE) {
		addr = base_addr + range_i + tmp;
	} else {
		for( i = 0; i < myPs->config.rangeI; i++){
			div = 0x10 << i;
			addr = base_addr + addr_step * bd + addr_div;
			outb(div, addr);
		
			addr = base_addr + addr_step * bd + range_i;
			for(index=0; index <= (myPs->config.chPerBd-1) / 4; index++) {
				outb(myData->bData[bd].rangeSelectI[i][index], addr + index);
			}
		}
		addr = base_addr + addr_step * bd + addr_div;
		outb(0x00, addr);
	}
}

//Idle state Range4 select
void RangeSelectI_9(int bd) 
{
	int tmp = 0, ch, range, i;
	int	addr, base_addr, addr_step, range_i, addr_div, index;
	unsigned char flag = 0x01, div;
	for(ch=0; ch < myPs->config.chPerBd; ch++) {
		flag = 0x01;
		flag = flag << (ch % 8);
		tmp = ch / 8;
		range = (int)myCh->signal[C_SIG_I_RANGE];
		switch(range) {
			case RANGE0:
				myData->bData[bd].rangeSelectI[0][tmp] &= ~flag;
				myData->bData[bd].rangeSelectI[1][tmp] &= ~flag;
				myData->bData[bd].rangeSelectI[2][tmp] &= ~flag;
				myData->bData[bd].rangeSelectI[3][tmp] |= flag;
				break;
			case RANGE1:
				myData->bData[bd].rangeSelectI[0][tmp] |= flag;
				myData->bData[bd].rangeSelectI[1][tmp] &= ~flag;
				myData->bData[bd].rangeSelectI[2][tmp] &= ~flag;
				myData->bData[bd].rangeSelectI[3][tmp] &= ~flag;
				break;
			case RANGE2:
				myData->bData[bd].rangeSelectI[0][tmp] &= ~flag;
				myData->bData[bd].rangeSelectI[1][tmp] |= flag;
				myData->bData[bd].rangeSelectI[2][tmp] &= ~flag;
				myData->bData[bd].rangeSelectI[3][tmp] &= ~flag;
				break;
			case RANGE3:
				myData->bData[bd].rangeSelectI[0][tmp] &= ~flag;
				myData->bData[bd].rangeSelectI[1][tmp] &= ~flag;
				myData->bData[bd].rangeSelectI[2][tmp] |= flag;
				myData->bData[bd].rangeSelectI[3][tmp] &= ~flag;
				break;
			case RANGE4:
				myData->bData[bd].rangeSelectI[0][tmp] &= ~flag;
				myData->bData[bd].rangeSelectI[1][tmp] &= ~flag;
				myData->bData[bd].rangeSelectI[2][tmp] &= ~flag;
				myData->bData[bd].rangeSelectI[3][tmp] |= flag;
				break;
		}
	}

	base_addr = myPs->addr.main[BASE_ADDR];
	addr_step = myPs->addr.main[ADDR_STEP];
	range_i = myPs->addr.main[RANGE_I_CS];
	addr_div = myPs->addr.main[ADDR_DIV];

	if(myPs->config.ADC_type == COMM_TYPE) {
		addr = base_addr + range_i + tmp;
	} else {
		for( i = 0; i < MAX_RANGE; i++){
			div = 0x10 << i;
			addr = base_addr + addr_step * bd + addr_div;
			outb(div, addr);
		
			addr = base_addr + addr_step * bd + range_i;
			for(index=0; index <= (myPs->config.chPerBd-1) / 8; index++) {
				outb(myData->bData[bd].rangeSelectI[i][index], addr + index);
			}
		}
		addr = base_addr + addr_step * bd + addr_div;
		outb(0x00, addr);
	}
}
void RangeSelectI_9_Ch(int bd, int ch)
{
	int tmp = 0, range, i;
	int	addr, base_addr, addr_step, range_i, addr_div, index;
	unsigned char flag = 0x01, div;

	myCh = &(myData->bData[bd].cData[ch]);
	flag = 0x01;
	flag = flag << (ch % 8);
	tmp = ch / 8;
	range = (int)myCh->signal[C_SIG_I_RANGE];
	switch(range) {
		case RANGE0:
			myData->bData[bd].rangeSelectI[0][tmp] &= ~flag;
			myData->bData[bd].rangeSelectI[1][tmp] &= ~flag;
			myData->bData[bd].rangeSelectI[2][tmp] &= ~flag;
			myData->bData[bd].rangeSelectI[3][tmp] |= flag;
			break;
		case RANGE1:
			myData->bData[bd].rangeSelectI[0][tmp] |= flag;
			myData->bData[bd].rangeSelectI[1][tmp] &= ~flag;
			myData->bData[bd].rangeSelectI[2][tmp] &= ~flag;
			myData->bData[bd].rangeSelectI[3][tmp] &= ~flag;
			break;
		case RANGE2:
			myData->bData[bd].rangeSelectI[0][tmp] &= ~flag;
			myData->bData[bd].rangeSelectI[1][tmp] |= flag;
			myData->bData[bd].rangeSelectI[2][tmp] &= ~flag;
			myData->bData[bd].rangeSelectI[3][tmp] &= ~flag;
			break;
		case RANGE3:
			myData->bData[bd].rangeSelectI[0][tmp] &= ~flag;
			myData->bData[bd].rangeSelectI[1][tmp] &= ~flag;
			myData->bData[bd].rangeSelectI[2][tmp] |= flag;
			myData->bData[bd].rangeSelectI[3][tmp] &= ~flag;
			break;
		case RANGE4:
			myData->bData[bd].rangeSelectI[0][tmp] &= ~flag;
			myData->bData[bd].rangeSelectI[1][tmp] &= ~flag;
			myData->bData[bd].rangeSelectI[2][tmp] &= ~flag;
			myData->bData[bd].rangeSelectI[3][tmp] |= flag;
			break;
	}

	base_addr = myPs->addr.main[BASE_ADDR];
	addr_step = myPs->addr.main[ADDR_STEP];
	range_i = myPs->addr.main[RANGE_I_CS];
	addr_div = myPs->addr.main[ADDR_DIV];

	if(myPs->config.ADC_type == COMM_TYPE) {
		addr = base_addr + range_i + tmp;
	} else {
		for( i = 0; i < MAX_RANGE; i++){
			div = 0x10 << i;
			addr = base_addr + addr_step * bd + addr_div;
			outb(div, addr);
		
			addr = base_addr + addr_step * bd + range_i;
			for(index=0; index <= (myPs->config.chPerBd-1) / 8; index++) {
				outb(myData->bData[bd].rangeSelectI[i][index], addr + index);
			}
		}
		addr = base_addr + addr_step * bd + addr_div;
		outb(0x00, addr);
	}
}

void RangeSelectI_10(int bd)
{
	int tmp = 0, ch, range, i;
	int	addr, base_addr, addr_step, range_i, addr_div, index;
	unsigned char flag = 0x01, div;
	for(ch=0; ch < myPs->config.chPerBd; ch++) {
		flag = 0x01;
		flag = flag << (ch % 8);
		tmp = ch / 8;
		range = (int)myCh->signal[C_SIG_I_RANGE];
		if(myCh->signal[C_SIG_RANGE_SWITCH] == P1){
			switch(range) {
				case RANGE0:
					myData->bData[bd].rangeSelectI[0][tmp] &= ~flag;
					myData->bData[bd].rangeSelectI[1][tmp] &= ~flag;
					myData->bData[bd].rangeSelectI[2][tmp] &= ~flag;
					myData->bData[bd].rangeSelectI[3][tmp] &= ~flag;
					break;
				case RANGE1:
					myData->bData[bd].rangeSelectI[0][tmp] |= flag;
					myData->bData[bd].rangeSelectI[1][tmp] |= flag;
					myData->bData[bd].rangeSelectI[2][tmp] &= ~flag;
					myData->bData[bd].rangeSelectI[3][tmp] &= ~flag;
					break;
				case RANGE2:
					myData->bData[bd].rangeSelectI[0][tmp] &= ~flag;
					myData->bData[bd].rangeSelectI[1][tmp] |= flag;
					myData->bData[bd].rangeSelectI[2][tmp] &= ~flag;
					myData->bData[bd].rangeSelectI[3][tmp] &= ~flag;
					break;
				case RANGE3:
					myData->bData[bd].rangeSelectI[0][tmp] |= flag;
					myData->bData[bd].rangeSelectI[1][tmp] &= ~flag;
					myData->bData[bd].rangeSelectI[2][tmp] &= ~flag;
					myData->bData[bd].rangeSelectI[3][tmp] &= ~flag;
					break;
				case RANGE4:
					myData->bData[bd].rangeSelectI[0][tmp] &= ~flag;
					myData->bData[bd].rangeSelectI[1][tmp] &= ~flag;
					myData->bData[bd].rangeSelectI[2][tmp] &= ~flag;
					myData->bData[bd].rangeSelectI[3][tmp] |= flag;
					break;
			}
		}else{
			myData->bData[bd].rangeSelectI[0][tmp] &= ~flag;
			myData->bData[bd].rangeSelectI[1][tmp] &= ~flag;
			myData->bData[bd].rangeSelectI[2][tmp] &= ~flag;
			myData->bData[bd].rangeSelectI[3][tmp] &= ~flag;
		}
	}

	base_addr = myPs->addr.main[BASE_ADDR];
	addr_step = myPs->addr.main[ADDR_STEP];
	range_i = myPs->addr.main[RANGE_I_CS];
	addr_div = myPs->addr.main[ADDR_DIV];

	if(myPs->config.ADC_type == COMM_TYPE) {
		addr = base_addr + range_i + tmp;
	} else {
		for( i = 0; i < myPs->config.rangeI; i++){
			div = 0x10 << i;
			addr = base_addr + addr_step * bd + addr_div;
			outb(div, addr);
		
			addr = base_addr + addr_step * bd + range_i;
			for(index=0; index <= (myPs->config.chPerBd-1) / 8; index++) {
				outb(myData->bData[bd].rangeSelectI[i][index], addr + index);
			}
		}
		addr = base_addr + addr_step * bd + addr_div;
		outb(0x00, addr);
	}
}
void RangeSelectI_10_Ch(int bd, int ch)
{
	int tmp = 0, range, i;
	int	addr, base_addr, addr_step, range_i, addr_div, index;
	unsigned char flag = 0x01, div;
	
	myCh = &(myData->bData[bd].cData[ch]);
	flag = 0x01;
	flag = flag << (ch % 8);
	tmp = ch / 8;
	range = (int)myCh->signal[C_SIG_I_RANGE];
	if(myCh->signal[C_SIG_RANGE_SWITCH] == P1){
		switch(range) {
			case RANGE0:
				myData->bData[bd].rangeSelectI[0][tmp] &= ~flag;
				myData->bData[bd].rangeSelectI[1][tmp] &= ~flag;
				myData->bData[bd].rangeSelectI[2][tmp] &= ~flag;
				myData->bData[bd].rangeSelectI[3][tmp] &= ~flag;
				break;
			case RANGE1:
				myData->bData[bd].rangeSelectI[0][tmp] |= flag;
				myData->bData[bd].rangeSelectI[1][tmp] |= flag;
				myData->bData[bd].rangeSelectI[2][tmp] &= ~flag;
				myData->bData[bd].rangeSelectI[3][tmp] &= ~flag;
				break;
			case RANGE2:
				myData->bData[bd].rangeSelectI[0][tmp] &= ~flag;
				myData->bData[bd].rangeSelectI[1][tmp] |= flag;
				myData->bData[bd].rangeSelectI[2][tmp] &= ~flag;
				myData->bData[bd].rangeSelectI[3][tmp] &= ~flag;
				break;
			case RANGE3:
				myData->bData[bd].rangeSelectI[0][tmp] |= flag;
				myData->bData[bd].rangeSelectI[1][tmp] &= ~flag;
				myData->bData[bd].rangeSelectI[2][tmp] &= ~flag;
				myData->bData[bd].rangeSelectI[3][tmp] &= ~flag;
				break;
			case RANGE4:
				myData->bData[bd].rangeSelectI[0][tmp] &= ~flag;
				myData->bData[bd].rangeSelectI[1][tmp] &= ~flag;
				myData->bData[bd].rangeSelectI[2][tmp] &= ~flag;
				myData->bData[bd].rangeSelectI[3][tmp] |= flag;
				break;
		}
	}else{
		myData->bData[bd].rangeSelectI[0][tmp] &= ~flag;
		myData->bData[bd].rangeSelectI[1][tmp] &= ~flag;
		myData->bData[bd].rangeSelectI[2][tmp] &= ~flag;
		myData->bData[bd].rangeSelectI[3][tmp] &= ~flag;
	}
	

	base_addr = myPs->addr.main[BASE_ADDR];
	addr_step = myPs->addr.main[ADDR_STEP];
	range_i = myPs->addr.main[RANGE_I_CS];
	addr_div = myPs->addr.main[ADDR_DIV];

	if(myPs->config.ADC_type == COMM_TYPE) {
		addr = base_addr + range_i + tmp;
	} else {
		for( i = 0; i < myPs->config.rangeI; i++){
			div = 0x10 << i;
			addr = base_addr + addr_step * bd + addr_div;
			outb(div, addr);
		
			addr = base_addr + addr_step * bd + range_i;
			for(index=0; index <= (myPs->config.chPerBd-1) / 8; index++) {
				outb(myData->bData[bd].rangeSelectI[i][index], addr + index);
			}
		}
		addr = base_addr + addr_step * bd + addr_div;
		outb(0x00, addr);
	}
}

void RangeSelectI_11_Ch(int bd, int ch)
{
	int tmp = 0, range, i;
	int	addr, base_addr, addr_step, range_i, addr_div, index;
	unsigned char flag = 0x01, div;
	
	myCh = &(myData->bData[bd].cData[ch]);
	flag = 0x01;
	flag = flag << (ch % 8);
	tmp = ch / 8;
	range = (int)myCh->signal[C_SIG_I_RANGE];
	if(myCh->signal[C_SIG_RANGE_SWITCH] == P1){
		switch(range) {
			case RANGE0:
				myData->bData[bd].rangeSelectI[0][tmp] &= ~flag;
				myData->bData[bd].rangeSelectI[1][tmp] &= ~flag;
				myData->bData[bd].rangeSelectI[2][tmp] &= ~flag;
				myData->bData[bd].rangeSelectI[3][tmp] &= ~flag;
				break;
			case RANGE1:
				myData->bData[bd].rangeSelectI[0][tmp] &= ~flag;
				myData->bData[bd].rangeSelectI[1][tmp] |= flag;
				myData->bData[bd].rangeSelectI[2][tmp] &= ~flag;
				myData->bData[bd].rangeSelectI[3][tmp] &= ~flag;
				break;
			case RANGE2:
				myData->bData[bd].rangeSelectI[0][tmp] |= flag;
				myData->bData[bd].rangeSelectI[1][tmp] &= ~flag;
				myData->bData[bd].rangeSelectI[2][tmp] &= ~flag;
				myData->bData[bd].rangeSelectI[3][tmp] &= ~flag;
				break;
			case RANGE3:
				myData->bData[bd].rangeSelectI[0][tmp] &= ~flag;
				myData->bData[bd].rangeSelectI[1][tmp] &= ~flag;
				myData->bData[bd].rangeSelectI[2][tmp] |= flag;
				myData->bData[bd].rangeSelectI[3][tmp] &= ~flag;
				break;
			case RANGE4:
				myData->bData[bd].rangeSelectI[0][tmp] &= ~flag;
				myData->bData[bd].rangeSelectI[1][tmp] &= ~flag;
				myData->bData[bd].rangeSelectI[2][tmp] &= ~flag;
				myData->bData[bd].rangeSelectI[3][tmp] |= flag;
				break;
		}
	}else{
		myData->bData[bd].rangeSelectI[0][tmp] &= ~flag;
		myData->bData[bd].rangeSelectI[1][tmp] &= ~flag;
		myData->bData[bd].rangeSelectI[2][tmp] &= ~flag;
		myData->bData[bd].rangeSelectI[3][tmp] &= ~flag;
	}
	

	base_addr = myPs->addr.main[BASE_ADDR];
	addr_step = myPs->addr.main[ADDR_STEP];
	range_i = myPs->addr.main[RANGE_I_CS];
	addr_div = myPs->addr.main[ADDR_DIV];

	if(myPs->config.ADC_type == COMM_TYPE) {
		addr = base_addr + range_i + tmp;
	} else {
		for( i = 0; i < myPs->config.rangeI; i++){
			div = 0x10 << i;
			addr = base_addr + addr_step * bd + addr_div;
			outb(div, addr);
		
			addr = base_addr + addr_step * bd + range_i;
			for(index=0; index <= (myPs->config.chPerBd-1) / 8; index++) {
				outb(myData->bData[bd].rangeSelectI[i][index], addr + index);
			}
		}
		addr = base_addr + addr_step * bd + addr_div;
		outb(0x00, addr);
	}
}

void RangeSelectI_12_Ch(int bd, int ch)
{
	int tmp = 0, range, i;
	int	addr, base_addr, addr_step, range_i, addr_div, index;
	unsigned char flag = 0x01, div;

	myCh = &(myData->bData[bd].cData[ch]);
	flag = 0x01;
	flag = flag << (ch % 8);
	tmp = ch / 8;
	range = (int)myCh->signal[C_SIG_I_RANGE];
	switch(range) {
		case RANGE0:
			myData->bData[bd].rangeSelectI[0][tmp] &= ~flag;
			myData->bData[bd].rangeSelectI[1][tmp] &= ~flag;
			myData->bData[bd].rangeSelectI[2][tmp] &= ~flag;
			myData->bData[bd].rangeSelectI[3][tmp] &= ~flag;
			break;
		case RANGE1:
			myData->bData[bd].rangeSelectI[0][tmp] &= ~flag;
			myData->bData[bd].rangeSelectI[1][tmp] &= ~flag;
			myData->bData[bd].rangeSelectI[2][tmp] |= flag;
			myData->bData[bd].rangeSelectI[3][tmp] &= ~flag;
			break;
		case RANGE2:
			myData->bData[bd].rangeSelectI[0][tmp] &= ~flag;
			myData->bData[bd].rangeSelectI[1][tmp] |= flag;
			myData->bData[bd].rangeSelectI[2][tmp] &= ~flag;
			myData->bData[bd].rangeSelectI[3][tmp] &= ~flag;
			break;
		case RANGE3:
			myData->bData[bd].rangeSelectI[0][tmp] &= ~flag;
			myData->bData[bd].rangeSelectI[1][tmp] &= ~flag;
			myData->bData[bd].rangeSelectI[2][tmp] |= flag;
			myData->bData[bd].rangeSelectI[3][tmp] &= ~flag;
			break;
		case RANGE4:
			myData->bData[bd].rangeSelectI[0][tmp] &= ~flag;
			myData->bData[bd].rangeSelectI[1][tmp] &= ~flag;
			myData->bData[bd].rangeSelectI[2][tmp] &= ~flag;
			myData->bData[bd].rangeSelectI[3][tmp] |= flag;
			break;
	}

	base_addr = myPs->addr.main[BASE_ADDR];
	addr_step = myPs->addr.main[ADDR_STEP];
	range_i = myPs->addr.main[RANGE_I_CS];
	addr_div = myPs->addr.main[ADDR_DIV];

	if(myPs->config.ADC_type == COMM_TYPE) {
		addr = base_addr + range_i + tmp;
	} else {
		for( i = 0; i < 4; i++){
			div = 0x10 << i;
			addr = base_addr + addr_step * bd + addr_div;
			outb(div, addr);
		
			addr = base_addr + addr_step * bd + range_i;
			for(index=0; index <= (myPs->config.chPerBd-1) / 8; index++) {
				outb(myData->bData[bd].rangeSelectI[i][index], addr + index);
			}
		}
		addr = base_addr + addr_step * bd + addr_div;
		outb(0x00, addr);
	}
}

/*	editer		:	pjy			Date:	5.30 2011
 *	parameter	:	bd - board number
 *					ch - channel number
 *	discription
 *	런신호가 있고 파라미터 폴더의 mControl file내에 range 에 대한 내용이
 *	내용이 정의 되어있으면 사용가능
 */	
void RangeSelectI_20_Ch(int bd, int ch)
{
	unsigned char flag = 0x01, div;
	int tmp = 0, range, i, addr, base_addr, addr_step, range_i, addr_div, index;
	int parallel_ch;

	myCh = &(myData->bData[bd].cData[ch]);

	//kjg_180521
	if((ch % 2) == 0) {
		parallel_ch = ch + 1;
	} else {
		parallel_ch = ch - 1;
	}
	if(myCh->misc.parallel_cycle_phase == P50) {
		myCh->signal[C_SIG_I_RANGE] = RANGE1;
		myData->bData[bd].cData[parallel_ch].signal[C_SIG_I_RANGE] = RANGE1;
	}

	flag = 0x01;
	flag = flag << (ch % 8);
	tmp = ch / 8;

	range = (int)myCh->signal[C_SIG_I_RANGE];
	switch(range) {
		case RANGE0:
			for(i=0; i < 4; i++) {
				if(myData->mData.config.range[0][i] == 1) {
					myData->bData[bd].rangeSelectI[i][tmp] |= flag;
				} else {
					myData->bData[bd].rangeSelectI[i][tmp] &= ~flag;
				}
			}
			break;
		case RANGE1:		
			for(i=0; i < 4; i++) {
				if(myData->mData.config.range[1][i] == 1) {
					myData->bData[bd].rangeSelectI[i][tmp] |= flag;
				} else {
					myData->bData[bd].rangeSelectI[i][tmp] &= ~flag;
				}
			}
			break;
		case RANGE2:
			for(i=0; i < 4; i++) {
				if(myData->mData.config.range[2][i] == 1) {
					myData->bData[bd].rangeSelectI[i][tmp] |= flag;
				} else {
					myData->bData[bd].rangeSelectI[i][tmp] &= ~flag;
				}
			}
			break;
		case RANGE3:
			for(i=0; i < 4; i++) {
				if(myData->mData.config.range[3][i] == 1) {
					myData->bData[bd].rangeSelectI[i][tmp] |= flag;
				} else {
					myData->bData[bd].rangeSelectI[i][tmp] &= ~flag;
				}
			}
			break;
		case RANGE4:
			for(i=0; i < 4; i++) {
				if(myData->mData.config.range[4][i] == 1) {
					myData->bData[bd].rangeSelectI[i][tmp] |= flag;
				} else {
					myData->bData[bd].rangeSelectI[i][tmp] &= ~flag;
				}
			}
			break;
		default:
			break;
	}

	base_addr = myPs->addr.main[BASE_ADDR];
	addr_step = myPs->addr.main[ADDR_STEP];
	range_i = myPs->addr.main[RANGE_I_CS];
	addr_div = myPs->addr.main[ADDR_DIV];

	if(myPs->config.ADC_type == COMM_TYPE) {
		addr = base_addr + range_i + tmp;
	} else {
		for(i=0; i < MAX_RANGE; i++) {
			div = 0x10 << i;
			addr = base_addr + addr_step * bd + addr_div;
			outb(div, addr);
		
			addr = base_addr + addr_step * bd + range_i;
			for(index=0; index <= (myPs->config.chPerBd - 1) / 8; index++) {
				outb(myData->bData[bd].rangeSelectI[i][index], addr + index);
			}
		}

		addr = base_addr + addr_step * bd + addr_div;
		outb(0x00, addr);
	}
}

/*	editer		:	pjy			Date:	5.30 2011
 *	parameter	:	bd - board number
 *					ch - channel number
 *	discription
 *	런신호가 없고    파라미터 폴더의 mControl file내에 range 에 대한
 *	내용이 정의 되어있으면 사용가능
 */	
void RangeSelectI_21_Ch(int bd, int ch)
{
	int tmp = 0, range, i;
	int	addr, base_addr, addr_step, range_i, addr_div, index;
	unsigned char flag = 0x01, div;
	
	myCh = &(myData->bData[bd].cData[ch]);
	flag = 0x01;
	flag = flag << (ch % 8);
	tmp = ch / 8;
	range = (int)myCh->signal[C_SIG_I_RANGE];
	if(myCh->signal[C_SIG_RANGE_SWITCH] == P1){
		switch(range) {
			case RANGE0:			
				for( i = 0; i < 4; i++){
					if(myData->mData.config.range[0][i] == 1){
						myData->bData[bd].rangeSelectI[i][tmp] |= flag;
					}else{
						myData->bData[bd].rangeSelectI[i][tmp] &= ~flag;
					}
				}
				break;
			case RANGE1:			
				for( i = 0; i < 4; i++){
					if(myData->mData.config.range[1][i] == 1){
						myData->bData[bd].rangeSelectI[i][tmp] |= flag;
					}else{
						myData->bData[bd].rangeSelectI[i][tmp] &= ~flag;
					}
				}
				break;
			case RANGE2:			
				for( i = 0; i < 4; i++){
					if(myData->mData.config.range[2][i] == 1){
						myData->bData[bd].rangeSelectI[i][tmp] |= flag;
					}else{
						myData->bData[bd].rangeSelectI[i][tmp] &= ~flag;
					}
				}
				break;
			case RANGE3:			
				for( i = 0; i < 4; i++){
					if(myData->mData.config.range[3][i] == 1){
						myData->bData[bd].rangeSelectI[i][tmp] |= flag;
					}else{
						myData->bData[bd].rangeSelectI[i][tmp] &= ~flag;
					}
				}
				break;
			case RANGE4:			
				for( i = 0; i < 4; i++){
					if(myData->mData.config.range[4][i] == 1){
						myData->bData[bd].rangeSelectI[i][tmp] |= flag;
					}else{
						myData->bData[bd].rangeSelectI[i][tmp] &= ~flag;
					}
				}
				break;
		}
	}else{
		myData->bData[bd].rangeSelectI[0][tmp] &= ~flag;
		myData->bData[bd].rangeSelectI[1][tmp] &= ~flag;
		myData->bData[bd].rangeSelectI[2][tmp] &= ~flag;
		myData->bData[bd].rangeSelectI[3][tmp] &= ~flag;
	}
	

	base_addr = myPs->addr.main[BASE_ADDR];
	addr_step = myPs->addr.main[ADDR_STEP];
	range_i = myPs->addr.main[RANGE_I_CS];
	addr_div = myPs->addr.main[ADDR_DIV];

	if(myPs->config.ADC_type == COMM_TYPE) {
		addr = base_addr + range_i + tmp;
	} else {
		for( i = 0; i < MAX_RANGE; i++){
			div = 0x10 << i;
			addr = base_addr + addr_step * bd + addr_div;
			outb(div, addr);
		
			addr = base_addr + addr_step * bd + range_i;
			for(index=0; index <= (myPs->config.chPerBd-1) / 8; index++) {
				outb(myData->bData[bd].rangeSelectI[i][index], addr + index);
			}
		}
		addr = base_addr + addr_step * bd + addr_div;
		outb(0x00, addr);
	}
}

//pms add for multi bd
//Run signal is none
void RangeSelectI_22_Ch(int bd, int ch)
{
	int range, i, chStep, addr, flag, base_addr, range_i;
	myCh = &(myData->bData[bd].cData[ch]); 
	
	chStep =(ch) / 2;

	//check the chNumber (even or odd)
	if( 0 ==  ((ch+1) %2)){
		flag = 0x01 << 4;
	}else{
		flag = 0x01;
	}

	range = (int)myCh->signal[C_SIG_I_RANGE];

	switch(range){
		case RANGE0:
			for(i = 0; i < 4; i++){
				if(myData->mData.config.range[0][i] == 1){
					myData->bData[bd].rangeSelectI[0][chStep] |= flag;
				}else{
					myData->bData[bd].rangeSelectI[0][chStep] &= ~flag;
				}
				flag = flag << 1;
			}
			break;
		case RANGE1:
			for(i = 0; i < 4; i++){
				if(myData->mData.config.range[1][i] == 1){
					myData->bData[bd].rangeSelectI[0][chStep] |= flag;
				}else{
					myData->bData[bd].rangeSelectI[0][chStep] &= ~flag;
				}
				flag = flag << 1;
			}
			break;
		case RANGE2:
			for(i = 0; i < 4; i++){
				if(myData->mData.config.range[2][i] == 1){
					myData->bData[bd].rangeSelectI[0][chStep] |= flag;
				}else{
					myData->bData[bd].rangeSelectI[0][chStep] &= ~flag;
				}
				flag = flag << 1;
			}
			break;
		case RANGE3:
			for(i = 0; i < 4; i++){
				if(myData->mData.config.range[3][i] == 1){
					myData->bData[bd].rangeSelectI[0][chStep] |= flag;
				}else{
					myData->bData[bd].rangeSelectI[0][chStep] &= ~flag;
				}
				flag = flag << 1;
			}
			break;
		case RANGE4:
			for(i = 0; i <4; i++){
				if(myData->mData.config.range[4][i] == 1){
					myData->bData[bd].rangeSelectI[0][chStep] |= flag;
				}else{
					myData->bData[bd].rangeSelectI[0][chStep] &= ~flag;
				}
				flag = flag << 1;
			}
			break;
	}
	base_addr = myPs->addr.main[BASE_ADDR];
	range_i = myPs->addr.main[RANGE_I_CS];

	addr = base_addr + (range_i + chStep);
	outb(myData->bData[bd].rangeSelectI[0][chStep], addr);

}

void RangeSelectI_23_Ch(int bd, int ch)
{
	int range, i, chStep, addr, evenFlag, flag, base_addr, range_i;
	myCh = &(myData->bData[bd].cData[ch]); 
	
	chStep =( ch-1) / 2;

	//check the chNumber ( even or odd)
	if( 0 ==  ((ch+1) %2)){
		flag = 0x01 << 4;
		evenFlag = 1;
	}else{
		flag = 0x01;
		evenFlag = 0;
	}

	range = (int)myCh->signal[C_SIG_I_RANGE];

	if(myCh->signal[C_SIG_RANGE_SWITCH] == P1){
		switch(range){
			case RANGE0:
				for(i = 0; i < 4; i++){
					if(myData->mData.config.range[0][i] == 1){
						myData->bData[bd].rangeSelectI[0][chStep] |= flag;
					}else{
						myData->bData[bd].rangeSelectI[0][chStep] &= ~flag;
					}
					flag = flag << 1;
				}
				break;
			case RANGE1:
				for(i = 0; i < 4; i++){
					if(myData->mData.config.range[1][i] == 1){
						myData->bData[bd].rangeSelectI[0][chStep] |= flag;
					}else{
						myData->bData[bd].rangeSelectI[0][chStep] &= ~flag;
					}
					flag = flag << 1;
				}
				break;
			case RANGE2:
				for(i = 0; i < 4; i++){
					if(myData->mData.config.range[2][i] == 1){
						myData->bData[bd].rangeSelectI[0][chStep] |= flag;
					}else{
						myData->bData[bd].rangeSelectI[0][chStep] &= ~flag;
					}
					flag = flag << 1;
				}
				break;
			case RANGE3:
				for(i = 0; i < 4; i++){
					if(myData->mData.config.range[3][i] == 1){
						myData->bData[bd].rangeSelectI[0][chStep] |= flag;
					}else{
						myData->bData[bd].rangeSelectI[0][chStep] &= ~flag;
					}
					flag = flag << 1;
				}
				break;
			case RANGE4:
				for(i = 0; i <4; i++){
					if(myData->mData.config.range[4][i] == 1){
						myData->bData[bd].rangeSelectI[0][chStep] |= flag;
					}else{
						myData->bData[bd].rangeSelectI[0][chStep] &= ~flag;
					}
					flag = flag << 1;
				}
				break;
		}
	}else{
		if(evenFlag == 1){
			flag = 0xF0;
		   	myData->bData[bd].rangeSelectI[0][chStep] &= ~flag;
		}else{
			flag = 0x0F;
			myData->bData[bd].rangeSelectI[0][chStep] &= ~flag;
		}
	}
	base_addr = myPs->addr.main[BASE_ADDR];
	range_i = myPs->addr.main[RANGE_I_CS];

	addr = base_addr + (range_i << chStep);
	outb(myData->bData[bd].rangeSelectI[0][chStep], addr);

}
//end of add
void RangeSelectI_24_Ch(int bd, int ch)
{
	int tmp = 0, range, i;
	int	addr, base_addr, addr_step, range_i, addr_div, index;
	unsigned char flag = 0x01, div;

	myCh = &(myData->bData[bd].cData[ch]);
	flag = 0x01;
	flag = flag << (ch % 8);
	tmp = ch / 8;
	range = (int)myCh->signal[C_SIG_I_RANGE];
	switch(range) {
		case RANGE0:
			for( i = 0; i < 4; i++){
				if(myData->mData.config.range[0][i] == 1){
					myData->bData[bd].rangeSelectI[i][tmp] |= flag;
				}else{
					myData->bData[bd].rangeSelectI[i][tmp] &= ~flag;
				}
			}
			break;
		case RANGE1:		
			for( i = 0; i < 4; i++){
				if(myData->mData.config.range[1][i] == 1){
					myData->bData[bd].rangeSelectI[i][tmp] |= flag;
				}else{
					myData->bData[bd].rangeSelectI[i][tmp] &= ~flag;
				}
			}
			break;
		case RANGE2:
			for( i = 0; i < 4; i++){
				if(myData->mData.config.range[2][i] == 1){
					myData->bData[bd].rangeSelectI[i][tmp] |= flag;
				}else{
					myData->bData[bd].rangeSelectI[i][tmp] &= ~flag;
				}
			}
			break;
		case RANGE3:
			for( i = 0; i < 4; i++){
				if(myData->mData.config.range[3][i] == 1){
					myData->bData[bd].rangeSelectI[i][tmp] |= flag;
				}else{
					myData->bData[bd].rangeSelectI[i][tmp] &= ~flag;
				}
			}
			break;
		case RANGE4:
			for( i = 0; i < 4; i++){
				if(myData->mData.config.range[4][i] == 1){
					myData->bData[bd].rangeSelectI[i][tmp] |= flag;
				}else{
					myData->bData[bd].rangeSelectI[i][tmp] &= ~flag;
				}
			}
			break;
	}

	base_addr = myPs->addr.main[BASE_ADDR];
	addr_step = myPs->addr.main[ADDR_STEP];
	range_i = myPs->addr.main[RANGE_I_CS];
	addr_div = myPs->addr.main[ADDR_DIV];

	if(myPs->config.ADC_type == COMM_TYPE) {
		addr = base_addr + range_i + tmp;
	} else {
		for( i = 1; i < MAX_RANGE; i++){
			div = 0x10 << i;
			addr = base_addr + addr_step * bd + addr_div;
			outb(div, addr);
		
			addr = base_addr + addr_step * bd + range_i;
			for(index=0; index <= (myPs->config.chPerBd-1) / 8; index++) {
				outb(myData->bData[bd].rangeSelectI[i][index], addr +(index*2));
			}
		}
		addr = base_addr + addr_step * bd + addr_div;
		outb(0x00, addr);
	}
}

/*	editer		:	lyh			Date:	5.12 2021
 *	parameter	:	bd - board number
 *					ch - channel number
 *	210512
 *	discription
 *	add for Use 500mA / 2uA Range Select 
 */	
void RangeSelectI_25_Ch(int bd, int ch)
{
	unsigned char flag, div;
	int range, i, addr, base_addr, addr_step;
	int range_i, addr_div, index, selectNum = 0;

	myCh = &(myData->bData[bd].cData[ch]);

	flag = 0x01;
	flag = flag << (ch % 8);
	
	if(ch >= 16){ 
		selectNum = (ch /8) + 2;
	}else{
		selectNum = ch / 8;
	}

	//500mA Use Range1 ~ range3
	//2uA Use Range4
	range = (int)myCh->signal[C_SIG_I_RANGE];
	
	switch(range) {
		case RANGE0:
			for(i=0; i < 4; i++) {
				if(myData->mData.config.range[0][i] == 1) {
					myData->bData[bd].rangeSelectI[i][selectNum] |= flag;
					myData->bData[bd].rangeSelectI[i][selectNum + 2] &= ~flag;
				} else {
					myData->bData[bd].rangeSelectI[i][selectNum] &= ~flag;
					myData->bData[bd].rangeSelectI[i][selectNum + 2] &= ~flag;
				}
			}
			break;
		case RANGE1:		
			for(i=0; i < 4; i++) {
				if(myData->mData.config.range[1][i] == 1) {
					myData->bData[bd].rangeSelectI[i][selectNum] |= flag;
					myData->bData[bd].rangeSelectI[i][selectNum + 2] &= ~flag;
				} else {
					myData->bData[bd].rangeSelectI[i][selectNum] &= ~flag;
					myData->bData[bd].rangeSelectI[i][selectNum + 2] &= ~flag;
				}
			}
			break;
		case RANGE2:
			for(i=0; i < 4; i++) {
				if(myData->mData.config.range[2][i] == 1) {
					myData->bData[bd].rangeSelectI[i][selectNum] |= flag;
					myData->bData[bd].rangeSelectI[i][selectNum + 2] &= ~flag;
				} else {
					myData->bData[bd].rangeSelectI[i][selectNum] &= ~flag;
					myData->bData[bd].rangeSelectI[i][selectNum + 2] &= ~flag;
				}
			}
			break;
		case RANGE3:
			for(i=0; i < 4; i++) {
				if(myData->mData.config.range[3][i] == 1) {
					myData->bData[bd].rangeSelectI[i][selectNum] |= flag;
					myData->bData[bd].rangeSelectI[i][selectNum + 2] &= ~flag;
				} else {
					myData->bData[bd].rangeSelectI[i][selectNum] &= ~flag;
					myData->bData[bd].rangeSelectI[i][selectNum + 2] &= ~flag;
				}
			}
			break;
		case RANGE4:	//2uA Use
			for(i=0; i < 4; i++) {
				if(myData->mData.config.range[4][i] == 1) {
					myData->bData[bd].rangeSelectI[i][selectNum] &= ~flag;
					myData->bData[bd].rangeSelectI[i][selectNum + 2] |= flag;
				} else {
					myData->bData[bd].rangeSelectI[i][selectNum] &= ~flag;
					myData->bData[bd].rangeSelectI[i][selectNum + 2] &= ~flag;
				}
			}
			break;
		default:
			break;
	}
	
	base_addr = myPs->addr.main[BASE_ADDR];
	addr_step = myPs->addr.main[ADDR_STEP];
	range_i = myPs->addr.main[RANGE_I_CS];
	addr_div = myPs->addr.main[ADDR_DIV];

	for(i = 0; i < MAX_RANGE; i++) {
		div = 0x10 << i;
		if(range == RANGE4){
			div = 0x10;
		}
		addr = base_addr + addr_step * bd + addr_div;
		outb(div, addr);

		addr = base_addr + addr_step * bd + range_i;
		for(index = 0; index < (myPs->config.chPerBd - 1) / 4; index++) {
			outb(myData->bData[bd].rangeSelectI[i][index],addr + index);
		}
	}

	//addr 0x63f
	addr = base_addr + addr_step * bd + addr_div;
	outb(0x00, addr);
}

void OutputTrigger(int bd)
{
	int rtn, index, ch, totalCycle, stepNo, i;
	int base_addr, addr_step, fad_cs, addr_div, addr;
	unsigned char flag;
	unsigned long chFlag;
	S_MSG_CH_FLAG ch_flag;

	switch(myPs->config.hwSpec) {
		case L_5V_100A_R1:
		case L_5V_250A_R1:
		case L_5V_220A_R2:
		case L_20V_110A_R2:
		case L_20V_50A_R2_1:
		case L_5V_5A_R2:
		case L_5V_1A_R2:
		case L_5V_10_30A_R2:
		case L_5V_100A_R2_1:
			rtn = 1;
			break;
		default:	
			rtn = 0;
			break;
	}
	if(rtn == 0) return;

	for(ch=0; ch < myPs->config.chPerBd; ch++) {
		flag = 0x01;
		flag = flag << (ch % 8);
		index = ch / 8;
		if(myCh->signal[C_SIG_TRIGGER] == P1) {
			myCh->signal[C_SIG_TRIGGER] = P0;
			if(myCh->op.type == STEP_Z) {
				myData->bData[bd].outputTrigger[index] |= flag;
				i = myData->mData.config.chPerBd * bd + ch;
				rtn = myData->CellArray2[i].number1 - 1;

				chFlag = 0x00000001;
				memset((char *)&ch_flag, 0, sizeof(S_MSG_CH_FLAG));
				for(i=0; i < myData->mData.config.installedCh; i++) {
					if(i < 32) {
						if(rtn == i) {
							ch_flag.bit_32[0] = (chFlag << i);
							break;
						}
					} else {
						if(rtn == i) {
							ch_flag.bit_32[1] = (chFlag << i);
							break;
						}
					}
				}
				send_msg_ch_flag(MODULE_TO_METER2, (char *)&ch_flag);

				totalCycle = (int)myCh->misc.totalCycle;
				stepNo = (int)myCh->op.stepNo;
				send_msg(MODULE_TO_METER2, MSG_MODULE_METER2_MEASURE,
					totalCycle, stepNo);
			} else {
				myData->bData[bd].outputTrigger[index] &= ~flag;
			}
		} else {
			myData->bData[bd].outputTrigger[index] &= ~flag;
		}
	}

	base_addr = myPs->addr.main[BASE_ADDR];
	addr_step = myPs->addr.main[ADDR_STEP];
	fad_cs = myPs->addr.main[FAD_CS];
	addr_div = myPs->addr.main[ADDR_DIV];

	addr = base_addr + addr_step * bd + addr_div;
	outb(0x08, addr);
	addr = base_addr + addr_step * bd + fad_cs;

	for(index=0; index <= (myPs->config.chPerBd-1)/ 8; index++) {
		outb(myData->bData[bd].outputTrigger[index], addr + index);
	}
	addr = base_addr + addr_step * bd + addr_div;
	outb(0x00, addr);
}

void OutputTrigger_Ch(int bd, int ch)
{
	int rtn, index, totalCycle, stepNo, i;
	int base_addr, addr_step, fad_cs, addr_div, addr, fad_ch;
	unsigned char flag;
	unsigned long chFlag;
	S_MSG_CH_FLAG ch_flag;
	
#if CYCLER_TYPE == DIGITAL_CYC
	return;	//180611 add
#endif
	if(myPs->config.FadBdUse == P0) return;

	myCh = &(myData->bData[bd].cData[ch]);
	switch(myPs->config.hwSpec) {
		case L_5V_100A_R1:
		case L_5V_250A_R1:
		case L_5V_220A_R2:
		case L_20V_110A_R2:
		case L_20V_50A_R2_1:
		case L_5V_5A_R2:
		case L_5V_1A_R2:
		case L_5V_10_30A_R2:
		case L_5V_100A_R2_1:
		case L_5V_500A_R2:
		case L_50V_50A:
			rtn = 1; //Micom FAD BD
			break;
		case L_30V_5A_R1_AD2:
		case L_60V_100A_R1_AD2:	//LS Mtron
		case L_5V_150A_R3_AD2:
		case L_8CH_MAIN_AD2_P:
			rtn = 2; //FPGA FAD BD
			break;
		default:	
			rtn = 0;
			break;
	}
	if(rtn == 0) return;

	flag = 0x01;
	flag = flag << (ch % 8);
	index = ch / 8;
	if(myCh->signal[C_SIG_TRIGGER] == P1) {
		myCh->signal[C_SIG_TRIGGER] = P0;
		//100426 kjiw 고속 AD range 적용
		myData->FADM.pulse_ad[bd][ch].rangeI = myCh->op.rangeI;
		if(myCh->op.type == STEP_Z 
			|| myCh->op.state == C_CALI) {
			if(rtn == 1) {
				myData->bData[bd].outputTrigger[index] |= flag;
				i = myData->mData.config.chPerBd * bd + ch;
				rtn = myData->CellArray2[i].number1 - 1;

				chFlag = 0x00000001;
				memset((char *)&ch_flag, 0, sizeof(S_MSG_CH_FLAG));
				for(i=0; i < myData->mData.config.installedCh; i++) {
					if(i < 32) {
						if(rtn == i) {
							ch_flag.bit_32[0] = (chFlag << i);
							break;
						}
					} else {
						if(rtn == i) {
							ch_flag.bit_32[1] = (chFlag << i);
							break;
						}
					}
				}
				send_msg_ch_flag(MODULE_TO_METER2, (char *)&ch_flag);
	
				totalCycle = (int)myCh->misc.totalCycle;
				stepNo = (int)myCh->op.stepNo;
				send_msg(MODULE_TO_METER2, MSG_MODULE_METER2_MEASURE,
					totalCycle, stepNo);
			}else if (rtn == 2) {
				if(myCh->ChAttribute.opType == P1){
					myData->FADM.pulse_ad[bd][ch+1].rangeI
						= myCh->op.rangeI;
					myCh->misc.fadTotalCycle = myCh->misc.totalCycle;
					myCh->misc.fadStepNo = myCh->op.stepNo;
					myData->bData[bd].cData[ch+1].misc.fadTotalCycle
						= myCh->misc.totalCycle;
					myData->bData[bd].cData[ch+1].misc.fadStepNo
						= myCh->op.stepNo;
	
					base_addr = myPs->addr.main[BASE_ADDR];
					addr_step = myPs->addr.main[ADDR_STEP];
					fad_ch = myPs->addr.main[FAD_CH];

					base_addr = 0x700; //jyk
					addr = base_addr + addr_step * bd + ch; //jyk
					outb(0x00,addr);
					addr = base_addr + addr_step * bd + ch+1; //jyk
					outb(0x00,addr);
					myCh->misc.fadFlag = 1;
					myCh->misc.fadTimer = 1500;
					myData->bData[bd].cData[ch+1].misc.fadFlag = 1;
					myData->bData[bd].cData[ch+1].misc.fadTimer = 1500;
				}else if(myCh->ChAttribute.opType == P0
						 && myCh->ChAttribute.chNo_master == P0){
				}else{
					myCh->misc.fadTotalCycle = myCh->misc.totalCycle;
					myCh->misc.fadStepNo = myCh->op.stepNo;
	
					base_addr = myPs->addr.main[BASE_ADDR];
					addr_step = myPs->addr.main[ADDR_STEP];
					fad_ch = myPs->addr.main[FAD_CH];

					base_addr = 0x700; //jyk
					addr = base_addr + addr_step * bd + ch; //jyk
					outb(0x00,addr);
					myCh->misc.fadFlag = 1;
					myCh->misc.fadTimer = 1500;
				}
				return ;		
			}
		} else {
			myData->bData[bd].outputTrigger[index] &= ~flag;
		}
	} else {
		myData->bData[bd].outputTrigger[index] &= ~flag;
	}
	if(myPs->config.hwSpec == L_50V_50A) {
		base_addr = myPs->addr.main[BASE_ADDR];
		addr_step = myPs->addr.main[ADDR_STEP];
		fad_cs = myPs->addr.main[FAD_CS];

		addr = base_addr + addr_step * bd + fad_cs;

		for(index=0; index <= (myPs->config.chPerBd-1)/ 8; index++) {
			outb(myData->bData[bd].outputTrigger[index], addr + index);
		}
	} else {
		base_addr = myPs->addr.main[BASE_ADDR];
		addr_step = myPs->addr.main[ADDR_STEP];
		fad_cs = myPs->addr.main[FAD_CS];
		addr_div = myPs->addr.main[ADDR_DIV];

		addr = base_addr + addr_step * bd + addr_div;
		outb(0x08, addr);
		addr = base_addr + addr_step * bd + fad_cs;

		for(index=0; index <= (myPs->config.chPerBd-1)/ 8; index++) {
			outb(myData->bData[bd].outputTrigger[index], addr + index);
		}
		addr = base_addr + addr_step * bd + addr_div;
		outb(0x00, addr);
	}
}

void OutputSwitch_OnOff(int bd)
{
	switch(myPs->config.hwSpec) {
		case L_6V_6A:
		case L_5V_5A:
		case S_5V_200A:
			OutputSwitch_1(bd);
			break;
		case L_5V_30A:
			OutputSwitch_2(bd);
			break;
		case L_5V_10mA:
			OutputSwitch_3(bd);
			break;
		case L_50V_50A:
			OutputSwitch_4(bd);
			break;
		case L_20V_25A:
		case L_5V_100A:
		case L_5V_200A_R2:
		case L_5V_30A_R1:
		case L_5V_100A_R1:
		case L_5V_100A_R1_EG:
		case L_5V_2A_R1:
		case L_5V_500A_R1:
		case L_5V_200A_R4:
		case L_5V_150A_R1:
		case L_5V_250A_R1:
		case L_5V_50A_R1:
		case L_5V_1000A_R1:
		case L_5V_1000A_R3:
		case L_5V_300A_R1:
		case L_5V_300A_R3:
		case L_5V_200A_R3:
		case L_5V_400A_R3:
		case L_5V_250A_R2:
		case L_20V_300A_R2_1:
		case L_5V_220A_R2:
		case L_20V_110A_R2:
		case L_20V_50A_R2_1:
		case L_10V_50A_R2:
		case L_5V_120A_R3:
		case L_20V_300A_R2:
		case L_5V_100A_R2_1:
		case L_5V_150A_R3:
		case L_20V_10A_R1:
		case L_20V_5A_R1:
		case L_20V_50A_R2:
		case L_5V_65A_R3:
		case L_5V_50A_R2_1:
		case L_5V_100mA_R2:
		case L_3V_200A_R2:
		case L_16V_200A_R2:
		case L_5V_500A_R2:
		case L_5V_150A_R3_AD2:
		case L_15V_100A_R3_AD2:
		case L_8CH_MAIN_AD2_P:
		case L_5V_30A_R3_HYUNDAI:
		case L_30V_20A_R1_AD2:
		case L_MAIN_REV11:
			OutputSwitch_5(bd);
			break;
		default:	break;
	}
}

void OutputSwitch_OnOff_Ch(int bd, int ch)
{
#if CYCLER_TYPE == DIGITAL_CYC
	return;	//180611 add
#endif
	if(myData->AppControl.config.systemType == CYCLER_CAN){
		OutputSwitch_OnOff_Ch_CAN(bd, ch);
	}else{
		OutputSwitch_OnOff_Ch_Default(bd, ch);
	}
}

void OutputSwitch_OnOff_Ch_CAN(int bd, int ch)
{
	if(myCh->signal[C_SIG_OUT_SWITCH] == P1){
		if(myCh->signal[C_SIG_OUT_SWITCH_ON] != P2){
			myCh->signal[C_SIG_OUT_SWITCH_ON] = P1;
		}
		myCh->signal[C_SIG_OUT_SWITCH_OFF] = P0;
	}else{
		if(myCh->signal[C_SIG_OUT_SWITCH_OFF] != P2){
			myCh->signal[C_SIG_OUT_SWITCH_OFF] = P1;
		}
		//210104 lyhw
		if(myCh->signal[C_SIG_OUT_SWITCH] == P2) {
			myCh->signal[C_SIG_OUT_SWITCH_OFF] = P2;
		}
		myCh->signal[C_SIG_OUT_SWITCH_ON] = P0;
	}

	if(myCh->signal[C_SIG_OUT_SWITCH] == P1){
		if(myCh->signal[C_SIG_OUT_SWITCH_ON] == P1){
			myCh->signal[C_SIG_OUT_SWITCH_ON] = P2;
			bCan_Each_Run_Out(bd, ch, RUN_ON);
		}
	}else{
		if(myCh->signal[C_SIG_OUT_SWITCH] == P0){
			if(myCh->signal[C_SIG_OUT_SWITCH_OFF] == P1){
				myCh->signal[C_SIG_OUT_SWITCH_OFF] = P2;
				bCan_Each_Run_Out(bd, ch, RUN_OFF);
			}
		}else{
			//210104 lyhw
			if(myCh->signal[C_SIG_OUT_SWITCH_OFF] == P2){
				myCh->signal[C_SIG_OUT_SWITCH_OFF] = P3;
			}	
		}
	}
}

void OutputSwitch_OnOff_Ch_Default(int bd, int ch)
{
	switch(myPs->config.hwSpec) {
		case L_6V_6A:
		case L_5V_5A:
		case S_5V_200A:
			OutputSwitch_1(bd);
			break;
		case L_5V_30A:
			OutputSwitch_2(bd);
			break;
		case L_5V_10mA:
			OutputSwitch_3(bd);
			break;
		case L_50V_50A:
			OutputSwitch_4(bd);
			break;
		case L_20V_25A:
		case L_5V_100A:
		case L_5V_200A_R2:
		case L_5V_30A_R1:
		case L_5V_100A_R1:
		case L_5V_100A_R1_EG:
		case L_5V_2A_R1:
		case L_5V_500A_R1:
		case L_5V_200A_R4:
		case L_5V_150A_R1:
		case L_5V_250A_R1:
		case L_5V_50A_R1:
		case L_5V_1000A_R1:
		case L_5V_1000A_R3:
		case L_5V_300A_R1:
		case L_5V_300A_R3:
		case L_5V_200A_R3:
		case L_5V_400A_R3:
		case L_3V_200A_R2:
		case L_16V_200A_R2:
		case L_5V_250A_R2:
		case L_20V_300A_R2_1:
		case L_5V_220A_R2:
		case L_20V_110A_R2:
		case L_20V_50A_R2_1:
		case L_10V_50A_R2:
		case L_5V_120A_R3:
		case L_20V_300A_R2:
		case L_40V_300A_R2:
		case L_30V_40A_R2:
		case L_30V_40A_R2_OT_20:
		case L_30V_40A_R2_P_AD2:
		case L_5V_100A_R2_1:
		case L_5V_150A_R3:
		case L_20V_10A_R1:
		case L_20V_5A_R1:
		case L_20V_50A_R2:
		case L_5V_65A_R3:
		case L_5V_50A_R2_1:
		case L_5V_100mA_R2:
		case L_5V_500A_R2:
		case L_5V_150A_R3_AD2:
		case L_15V_100A_R3_AD2:
		case L_8CH_MAIN_AD2_P:
		case L_5V_30A_R3_HYUNDAI:
		case L_30V_20A_R1_AD2:
		case L_30V_5A_R1_AD2:	
		case L_60V_100A_R1_AD2:	//LS Mtron
		case L_5V_200A_R3_P_AD2:
		case L_5V_1A_R3:
		case L_5V_200A_1CH_JIG:
		case L_5V_200A_R3_P:
		case L_5V_50A_R2_P:
		case S_5V_200A_75A_15A_AD2:
		case L_MAIN_REV11:
		case L_5V_500A_R3_1:
		case L_20V_6A_R3: 	//210813 ljsw LGES 20V6A
			OutputSwitch_5_Ch(bd, ch);
			break;
		case L_5V_600A_10A: //Pack Hardware
			OutputSwitch_6_Ch(bd, ch);
			break;
		case L_10V_500A_R2:
			OutputSwitch_7_Ch(bd, ch);
			break;
		case L_5V_150A_R2_P:
			OutputSwitch_8_Ch(bd, ch);
			break;
		case L_MULTI:
			OutputSwitch_9_Ch(bd, ch);
			break;
		case L_5V_10A_R3_NEW:
			OutputSwitch_10_Ch(bd, ch);
			break;
		case L_5V_500mA_2uA_R4:	//210512 lyhw
			OutputSwitch_11_Ch(bd, ch);
			break;
		default:
			break;
	}
}

void OutputSwitch_1(int bd)
{
	int addr, base_addr, run_cs, ch, index;
	unsigned char flag;

	base_addr = myPs->addr.main[BASE_ADDR];
	run_cs = myPs->addr.main[RUN_CS];
	for(ch=0; ch < myPs->config.chPerBd; ch++) {
		flag = 0x01;
		flag = flag << (ch % 8);
		if(myCh->signal[C_SIG_OUT_SWITCH] == P1) {
			myData->bData[bd].outputSwitch[ch/8] |= flag;
		} else {
			myData->bData[bd].outputSwitch[ch/8] &= ~flag;
		}
	}

	addr = base_addr + run_cs + bd;
	for(index=0; index <= (myPs->config.chPerBd-1)/8; index++) {
		outb(myData->bData[bd].outputSwitch[index], addr + index);
	}
}

void OutputSwitch_2(int bd)
{
	int addr, base_addr, run_cs, ch, index;
	unsigned char flag;

	base_addr = myPs->addr.main[BASE_ADDR];
	run_cs = myPs->addr.main[RUN_CS];
	for(index=0; index < myPs->config.installedCh; index++) {
		bd = index / myPs->config.chPerBd;
		ch = index % myPs->config.chPerBd;
		if(index < 8) {
			flag = 0x01;
			flag = flag << (index % 8);
			if(myCh->signal[C_SIG_OUT_SWITCH]
				== P1) {
				myData->bData[0].outputSwitch[0] |= flag;
			} else {
				myData->bData[0].outputSwitch[0] &= ~flag;
			}
		} else {
			flag = 0x01;
			flag = flag << (index % 8);
			if(myCh->signal[C_SIG_OUT_SWITCH]
				== P1) {
				myData->bData[0].outputSwitch[1] |= flag;
			} else {
				myData->bData[0].outputSwitch[1] &= ~flag;
			}
		}
	}

	addr = base_addr + run_cs;
	for(index=0; index < 2; index++) {
		outb(myData->bData[0].outputSwitch[index], addr + index);
	}
}

void OutputSwitch_3(int bd)
{
	int addr, base_addr, run_cs, ch, index;
	unsigned char flag;

	base_addr = myPs->addr.main[BASE_ADDR];
	run_cs = myPs->addr.main[RUN_CS];
	for(ch=0; ch < myPs->config.chPerBd; ch++) {
		flag = 0x01;
		flag = flag << (ch % 8);
		if(myCh->signal[C_SIG_OUT_SWITCH] == P1) {
			myData->bData[bd].outputSwitch[ch/8] |= flag;
		} else {
			myData->bData[bd].outputSwitch[ch/8] &= ~flag;
		}
	}

	addr = base_addr + run_cs + bd *2;
	for(index=0; index <= (myPs->config.chPerBd-1)/8; index++) {
		outb(myData->bData[bd].outputSwitch[index], addr + index);
	}
}

void OutputSwitch_4(int bd)
{
	int addr, base_addr, run_cs, ch;
	unsigned char flag;

	base_addr = myPs->addr.main[BASE_ADDR];
	run_cs = myPs->addr.main[RUN_CS];
	for(ch=0; ch < myPs->config.chPerBd; ch++) {
		flag = 0x01;
		flag = flag << (ch % 8);
		if(myCh->signal[C_SIG_OUT_SWITCH] == P1) {
			myData->bData[bd].outputSwitch[ch/8] |= flag;
		} else {
			myData->bData[bd].outputSwitch[ch/8] &= ~flag;
		}
	}

	addr = base_addr + run_cs;
	outb(myData->bData[bd].outputSwitch[ch/8], addr);
}

void OutputSwitch_4_Ch(int bd,int ch)
{
	int addr, base_addr, run_cs;
	unsigned char flag;

	base_addr = myPs->addr.main[BASE_ADDR];
	run_cs = myPs->addr.main[RUN_CS];

	flag = 0x01;
	flag = flag << (ch % 8);
	
	if(myCh->signal[C_SIG_OUT_SWITCH] == P1) {
		myData->bData[bd].outputSwitch[ch/8] |= flag;
	} else {
		myData->bData[bd].outputSwitch[ch/8] &= ~flag;
	}

	addr = base_addr + run_cs;
	outb(myData->bData[bd].outputSwitch[ch/8], addr);
}

void OutputSwitch_5(int bd)
{
	int addr, base_addr, addr_step, run_cs, addr_div, ch, index;
	unsigned char flag;

	base_addr = myPs->addr.main[BASE_ADDR];
	addr_step = myPs->addr.main[ADDR_STEP];
	run_cs = myPs->addr.main[RUN_CS];
	addr_div = myPs->addr.main[ADDR_DIV];
	for(ch=0; ch < myPs->config.chPerBd; ch++) {
		flag = 0x01;
		flag = flag << (ch % 8);
		if(myCh->signal[C_SIG_OUT_SWITCH] == P1) {
			myData->bData[bd].outputSwitch[ch/8] |= flag;
		} else {
			myData->bData[bd].outputSwitch[ch/8] &= ~flag;
		}
	}

	addr = base_addr + addr_step * bd + addr_div;
	switch(myPs->config.hwSpec){
		case L_5V_30A_R1:
		case L_5V_2A_R1:
			outb(0x10, addr);
			break;
		default:
			outb(0x01, addr);
			break;
	}

	addr = base_addr + addr_step * bd + run_cs;

	for(index=0; index <= (myPs->config.chPerBd-1)/8; index++) {
		outb(myData->bData[bd].outputSwitch[index], addr + index);
	}

	addr = base_addr + addr_step * bd + addr_div;
	outb(0x00, addr);
#if MACHINE_TYPE == 1
// 140407 oys add -I Relay On, Off
	for(ch = 0; ch < 2; ch ++){
		if(myData->bData[bd].cData[ch].signal[C_SIG_OUT_SWITCH] == P1) {
			if(myData->bData[bd].cData[ch].op.type != STEP_SHORT){
				if(ch == 0){
					myData->bData[bd].ch_relay_do[0].io.v_relay1 = P1;
					myData->bData[bd].ch_relay_do[0].io.i_relay1 = P1;
				}else{
					myData->bData[bd].ch_relay_do[0].io.v_relay2 = P1;
					myData->bData[bd].ch_relay_do[0].io.i_relay2 = P1;
				}
			}else{
				if(ch == 0){
					myData->bData[bd].ch_relay_do[0].io.v_relay1 = P0;
					myData->bData[bd].ch_relay_do[0].io.i_relay1 = P0;
				}else{
					myData->bData[bd].ch_relay_do[0].io.v_relay2 = P0;
					myData->bData[bd].ch_relay_do[0].io.i_relay2 = P0;
				}
			}
		}else{
			if(myData->bData[bd].cData[ch].op.type != STEP_SHORT){
				if(ch == 0){
					myData->bData[bd].ch_relay_do[0].io.v_relay1 = P1;
					myData->bData[bd].ch_relay_do[0].io.i_relay1 = P0;
				}else{
					myData->bData[bd].ch_relay_do[0].io.v_relay2 = P1;
					myData->bData[bd].ch_relay_do[0].io.i_relay2 = P0;
				}
			}else{
				if(ch == 0){
					myData->bData[bd].ch_relay_do[0].io.v_relay1 = P0;
					myData->bData[bd].ch_relay_do[0].io.i_relay1 = P0;
				}else{
					myData->bData[bd].ch_relay_do[0].io.v_relay2 = P0;
					myData->bData[bd].ch_relay_do[0].io.i_relay2 = P0;
				}
			}
		}
	}
	addr = myPs->addr.interface[IO_EXPEND][6];

	if(myData->AppControl.signal[APP_SIG_QUIT] != P0){
		outb(0x00, addr);
	}else{
		outb(myData->bData[bd].ch_relay_do[0].ch_io, addr);
	}
#endif
}

void OutputSwitch_5_Ch(int bd, int ch)
{
	unsigned char flag;
	int addr, base_addr, addr_step, run_cs, addr_div, index;

	flag = 0x01;
	flag = flag << (ch % 8);
	if(myCh->signal[C_SIG_OUT_SWITCH] == P1) {
		myData->bData[bd].outputSwitch[ch / 8] |= flag;
	} else {
		myData->bData[bd].outputSwitch[ch / 8] &= ~flag;
	}

	if(myPs->config.hwSpec == L_5V_500A_R3_1) {
		if(myCh->signal[C_SIG_I_RANGE] == RANGE3) {
			myData->bData[bd].outputSwitch[ch / 8] &= ~flag;
		}
	}
	if(myCh->ChAttribute.chNo_master == P0) {
	    myData->bData[bd].outputSwitch[ch / 8] &= ~flag;
	}

	base_addr = myPs->addr.main[BASE_ADDR];
	addr_step = myPs->addr.main[ADDR_STEP];
	addr_div = myPs->addr.main[ADDR_DIV];
	run_cs = myPs->addr.main[RUN_CS];

	addr = base_addr + addr_step * bd + addr_div;
	switch(myPs->config.hwSpec) {
		case L_5V_30A_R1:
		case L_5V_2A_R1:
			outb(0x10, addr);
			break;
		default:
			outb(0x01, addr);
			break;
	}

	addr = base_addr + addr_step * bd + run_cs;
	for(index=0; index <= (myPs->config.chPerBd - 1) / 8; index++) {
		outb(myData->bData[bd].outputSwitch[index], addr + index);
	}

	addr = base_addr + addr_step * bd + addr_div;
	outb(0x00, addr);

#if MACHINE_TYPE == 1
// 140407 oys add -I Relay On, Off
	for(ch=0; ch < 2; ch ++) {
		if(myData->bData[bd].cData[ch].signal[C_SIG_OUT_SWITCH] == P1) {
			if(myData->bData[bd].cData[ch].op.type != STEP_SHORT) {
				if(ch == 0) {
					myData->bData[bd].ch_relay_do[0].io.v_relay1 = P1;
					myData->bData[bd].ch_relay_do[0].io.i_relay1 = P1;
				} else {
					myData->bData[bd].ch_relay_do[0].io.v_relay2 = P1;
					myData->bData[bd].ch_relay_do[0].io.i_relay2 = P1;
				}
			} else {
				if(ch == 0) {
					myData->bData[bd].ch_relay_do[0].io.v_relay1 = P0;
					myData->bData[bd].ch_relay_do[0].io.i_relay1 = P0;
				} else {
					myData->bData[bd].ch_relay_do[0].io.v_relay2 = P0;
					myData->bData[bd].ch_relay_do[0].io.i_relay2 = P0;
				}
			}
		} else {
			if(myData->bData[bd].cData[ch].op.type != STEP_SHORT) {
				if(ch == 0) {
					myData->bData[bd].ch_relay_do[0].io.v_relay1 = P1;
					myData->bData[bd].ch_relay_do[0].io.i_relay1 = P0;
				} else {
					myData->bData[bd].ch_relay_do[0].io.v_relay2 = P1;
					myData->bData[bd].ch_relay_do[0].io.i_relay2 = P0;
				}
			} else {
				if(ch == 0) {
					myData->bData[bd].ch_relay_do[0].io.v_relay1 = P0;
					myData->bData[bd].ch_relay_do[0].io.i_relay1 = P0;
				} else {
					myData->bData[bd].ch_relay_do[0].io.v_relay2 = P0;
					myData->bData[bd].ch_relay_do[0].io.i_relay2 = P0;
				}
			}
		}
	}

	addr = myPs->addr.interface[IO_EXPEND][6];
	if(myData->AppControl.signal[APP_SIG_QUIT] != P0) {
		outb(0x00, addr);
	} else {
		outb(myData->bData[bd].ch_relay_do[0].ch_io, addr);
	}
#endif
}

//pms add for Multi
void OutputSwitch_9_Ch(int bd, int ch)
{
	int addr, base_addr, run_cs;
	int flag;

	base_addr = myPs->addr.main[BASE_ADDR];		//0x620
	run_cs = myPs->addr.main[RUN_CS];			//0xC
	addr = base_addr + run_cs;					//0x62C
	
	flag = 0x01;
	flag = flag << (ch % 8);					//out switch 0x62A 1 bit~ 4bit

	//1.switch on
	if(myCh->signal[C_SIG_OUT_SWITCH] == P1){
		myPs->misc.outFlag  |= flag;
	//2.switch off
	}else{
		myPs->misc.outFlag &= ~flag;
	}	

	outb(myPs->misc.outFlag, addr);

}//end of add

void OutputSwitch_6_Ch(int bd, int ch) //Pack Hardware
{
	int addr, base_addr, addr_step, run_cs, addr_div, range;
// o1:r2, o2:r1, o3:para, o4:charge_lamp
// o5:discharge_lamp, o6:run_lamp, o7:NC, o8:NC

	base_addr = myPs->addr.main[BASE_ADDR];
	addr_step = myPs->addr.main[ADDR_STEP];
	run_cs = myPs->addr.main[RUN_CS];
	addr_div = myPs->addr.main[ADDR_DIV];
	
	if(myCh->op.state == C_RUN) {
		myData->bData[bd].ch_do[ch].io.o6 = ON;
	} else {
		myData->bData[bd].ch_do[ch].io.o6 = OFF;
	}

   if(myCh->ChAttribute.opType == P1) {
        if(myCh->signal[C_SIG_PARALLEL_SWITCH] == P1) {
			myData->bData[bd].ch_do[ch].io.o3 = ON;
            myData->bData[bd].cData[ch+1].signal[C_SIG_OUT_SWITCH] = P0;
        } else {
			myData->bData[bd].ch_do[ch].io.o3 = OFF;
        }
    } else {
		myData->bData[bd].ch_do[ch].io.o3 = OFF;
	}
   switch(myCh->op.type) {
		case STEP_ADV_CYCLE:
		case STEP_LOOP:
		case STEP_OCV:
			break;
		case STEP_CHARGE:
			myData->bData[bd].ch_do[ch].io.o4 = ON;
			myData->bData[bd].ch_do[ch].io.o5 = OFF;
			break;
		case STEP_DISCHARGE:
		case STEP_Z:
			myData->bData[bd].ch_do[ch].io.o4 = OFF;
			myData->bData[bd].ch_do[ch].io.o5 = ON;
			break;
		case STEP_USER_PATTERN:
		case STEP_BALANCE:
			myData->bData[bd].ch_do[ch].io.o4 = ON;
			myData->bData[bd].ch_do[ch].io.o5 = ON;
			break;
		default:
			myData->bData[bd].ch_do[ch].io.o4 = OFF;
			myData->bData[bd].ch_do[ch].io.o5 = OFF;
			break;
   }

	range = (int)myCh->signal[C_SIG_I_RANGE];
	switch(range) {
		case RANGE0:
			myData->bData[bd].ch_do[ch].io.o1 = OFF;
			myData->bData[bd].ch_do[ch].io.o2 = OFF;
			myData->bData[bd].ch_do[ch].io.o7 = OFF;
			myData->bData[bd].ch_do[ch].io.o8 = OFF;
			break;
		case RANGE1:
			myData->bData[bd].ch_do[ch].io.o1 = OFF;
			myData->bData[bd].ch_do[ch].io.o2 = ON;
			myData->bData[bd].ch_do[ch].io.o7 = OFF;
			myData->bData[bd].ch_do[ch].io.o8 = OFF;
			break;
		case RANGE2:
			myData->bData[bd].ch_do[ch].io.o1 = ON;
			myData->bData[bd].ch_do[ch].io.o2 = OFF;
			myData->bData[bd].ch_do[ch].io.o7 = OFF;
			myData->bData[bd].ch_do[ch].io.o8 = OFF;
			break;
		case RANGE3:
			myData->bData[bd].ch_do[ch].io.o1 = OFF;
			myData->bData[bd].ch_do[ch].io.o2 = OFF;
			myData->bData[bd].ch_do[ch].io.o7 = OFF;
			myData->bData[bd].ch_do[ch].io.o8 = OFF;
			break;
		case RANGE4:
			myData->bData[bd].ch_do[ch].io.o1 = OFF;
			myData->bData[bd].ch_do[ch].io.o2 = OFF;
			myData->bData[bd].ch_do[ch].io.o7 = OFF;
			myData->bData[bd].ch_do[ch].io.o8 = OFF;
			break;
	}

	addr = base_addr + addr_step * bd + run_cs;
	outb(myData->bData[bd].ch_do[ch].ch_io, addr + ch);
}

/*Date				:2010	11	24
 *Editor			:pjy
 *Name				:OutputSwitch_7_Ch
 *parameter			:bd - 보드넘버 ch-채널번호
 *returnValue		:none
 *function description
 *address	80	40	20	10	8	4			2			1
 *620 							Low	Range	High Range	Run
 *62f													Run_CS
 *
 *high range
 *wr 62f 1 -> wr 620 3
 *low range
 *wr 62f 1 -> wr 620  5
 */
void OutputSwitch_7_Ch(int bd, int ch)
{
	int addr, base_addr, addr_step, run_cs, addr_div;
	//unsigned char flag;
	int range;

	base_addr = myPs->addr.main[BASE_ADDR];
	addr_step = myPs->addr.main[ADDR_STEP];
	run_cs = myPs->addr.main[RUN_CS];
	addr_div = myPs->addr.main[ADDR_DIV];


	//1.on output
	if(myCh->signal[C_SIG_OUT_SWITCH] == P1) {
		myData->bData[bd].ch_do[ch].io.o1 = ON;
	}else{
		myData->bData[bd].ch_do[ch].io.o1 = OFF;
	}
	switch(myCh->op.state){
		case C_STANDBY:
		case C_PAUSE:
			 myData->bData[bd].ch_do[ch].io.o4 = OFF;
			 break;
		default:
			 myData->bData[bd].ch_do[ch].io.o4 = ON;
			 break;
	}

	//1.3 get the range value
	range = (int)myCh->signal[C_SIG_I_RANGE];
	switch(range) {
		case RANGE0:
			 myData->bData[bd].ch_do[ch].io.o2 = OFF;
			 myData->bData[bd].ch_do[ch].io.o3 = OFF;
			break;
		case RANGE1:
			 myData->bData[bd].ch_do[ch].io.o2 = ON;
			 myData->bData[bd].ch_do[ch].io.o3 = OFF;
				//select high range
			break;
		case RANGE2:
			 myData->bData[bd].ch_do[ch].io.o2 = OFF;
			 myData->bData[bd].ch_do[ch].io.o3 = ON;
				//select low rangea
			break;
		default:
			 myData->bData[bd].ch_do[ch].io.o2 = OFF;
			 myData->bData[bd].ch_do[ch].io.o3 = OFF;
			break;
	}
	addr = base_addr + addr_step * bd + addr_div;
	outb(0x01, addr);
	addr = base_addr + addr_step * bd + run_cs;
	outb(myData->bData[bd].ch_do[ch].ch_io, addr + ch);
	
	addr = base_addr + addr_step * bd + addr_div;
	outb(0x00, addr);
}

void OutputSwitch_8_Ch(int bd, int ch)
{
	int addr, base_addr, addr_step, run_cs, index;
	unsigned char flag;

	base_addr = myPs->addr.main[BASE_ADDR];
	addr_step = myPs->addr.main[ADDR_STEP];
	run_cs = myPs->addr.main[RUN_CS];
	
	flag = 0x01;
	flag = flag << (ch % 8);
	if(myCh->signal[C_SIG_OUT_SWITCH] == P1) {
		myData->bData[bd].outputSwitch[ch/8] |= flag;
	} else {
		myData->bData[bd].outputSwitch[ch/8] &= ~flag;
	}
	
	if(myCh->ChAttribute.chNo_master == P0) {
	    myData->bData[bd].outputSwitch[ch/8] &= ~flag;
	}


	addr = base_addr + (addr_step * (bd+1)) + run_cs;

	for(index=0; index <= (myPs->config.chPerBd-1)/8; index++) {
		outb(myData->bData[bd].outputSwitch[index], addr + (index * addr_step));
	}
}

void OutputSwitch_10_Ch(int bd, int ch)
{
	int addr, base_addr, addr_step, run_cs, addr_div, index;
	unsigned char flag;

	base_addr = myPs->addr.main[BASE_ADDR];
	addr_step = myPs->addr.main[ADDR_STEP];
	run_cs = myPs->addr.main[RUN_CS];
	addr_div = myPs->addr.main[ADDR_DIV];
	flag = 0x01;
	flag = flag << (ch % 8);
	if(myCh->signal[C_SIG_OUT_SWITCH] == P1) {
		myData->bData[bd].outputSwitch[ch/8] |= flag;
	} else {
		myData->bData[bd].outputSwitch[ch/8] &= ~flag;
	}
//	if(myCh->ChAttribute.chNo_master == P0) {
//	    myData->bData[bd].outputSwitch[ch/8] &= ~flag;
//	}

	addr = base_addr + addr_step * bd + addr_div;
	outb(0x01, addr);

	addr = base_addr + addr_step * bd + run_cs;

	for(index=0; index <= (myPs->config.chPerBd-1)/8; index++) {
		outb(myData->bData[bd].outputSwitch[index], addr + (index*2));
	}

	addr = base_addr + addr_step * bd + addr_div;
	outb(0x00, addr);
}

/* write : lyh ..    Date : 2021.05.12
 * add for 500mA 2uA Type Cycler
 * 210512
*/
void OutputSwitch_11_Ch(int bd, int ch)
{
	unsigned char flag, switchNum, index;
	int addr, base_addr, addr_step, run_cs, addr_div, range;

	myCh = &(myData->bData[bd].cData[ch]);
	range = (int)myCh->signal[C_SIG_I_RANGE];

	flag = 0x01;
	flag = flag << (ch % 8);

	//210523 add for 2uA outb Value
	if(ch >= 16){	
		switchNum = (ch / 8) + 2;
	}else{ 
		switchNum = (ch / 8);
	}

	if(myCh->signal[C_SIG_OUT_SWITCH] == P1) {
		if(range == RANGE4){
			myData->bData[bd].outputSwitch[switchNum] &= ~flag;
			myData->bData[bd].outputSwitch[switchNum + 2] |= flag;
		}else{
			myData->bData[bd].outputSwitch[switchNum] |= flag;
			myData->bData[bd].outputSwitch[switchNum + 2] &= ~flag;
		}
	}else{
		myData->bData[bd].outputSwitch[switchNum] &= ~flag;
		myData->bData[bd].outputSwitch[switchNum + 2] &= ~flag;
	}

	base_addr = myPs->addr.main[BASE_ADDR];
	addr_step = myPs->addr.main[ADDR_STEP];
	addr_div = myPs->addr.main[ADDR_DIV];
	run_cs = myPs->addr.main[RUN_CS];

	//addr = 0x63f
	addr = base_addr + addr_step * bd + addr_div;
	outb(0x01, addr);

	//addr = 0x620
	addr = base_addr + addr_step * bd + run_cs;
	for(index=0; index <= (myPs->config.chPerBd - 1) / 4; index++) {
		outb(myData->bData[bd].outputSwitch[index], addr + index);
	}

	addr = base_addr + addr_step * bd + addr_div;
	outb(0x00, addr);
}

void ParallelSwitch_OnOff_Ch(int bd, int ch)
{
#if CYCLER_TYPE == DIGITAL_CYC
	return;	//180611 add
#endif
	
	switch(myPs->config.hwSpec) {
//		case L_5V_300A_R3:
		case L_6V_60A_R2_P:
			ParallelSwitch_1_Ch(bd, ch);
			break;
		case L_5V_200A_R3_P_AD2:
		case L_5V_50A_R2_P:
		case L_30V_40A_R2_P_AD2:
			ParallelSwitch_2_Ch(bd, ch);
			break;
		case L_5V_200A_R3_P:
		case L_5V_250A_R2:
			ParallelSwitch_3_Ch(bd, ch);
			break;
		case L_5V_150A_R2_P:
			ParallelSwitch_4_Ch(bd, ch);
			break;
		case L_MAIN_REV11:
			if(myPs->config.parallelMode == P2) { //kjg_180521
				ParallelSwitch_5p_Ch(bd, ch);
			} else {
				ParallelSwitch_5_Ch(bd, ch);
			}
			break;
		case L_8CH_MAIN_AD2_P:
			ParallelSwitch_6_Ch(bd, ch);
			break;
		case L_5V_1A_R3:
		case L_5V_10A_R3_NEW:
		case L_5V_500mA_2uA_R4:		//210512 lyhw
			ParallelSwitch_7_Ch(bd, ch);
			break;
		default:
			break;
	}
}

void ParallelSwitch_1_Ch(int bd, int ch)
{
	int addr, base_addr, addr_step, run_cs, addr_div, index;
	unsigned char flag;

	myCh = &(myData->bData[bd].cData[ch]);
	base_addr = myPs->addr.main[BASE_ADDR];
	addr_step = myPs->addr.main[ADDR_STEP];
	run_cs = myPs->addr.main[RUN_CS];
	addr_div = myPs->addr.main[ADDR_DIV];
	flag = 0x01;
	flag = flag << (ch % 8);

	if(myCh->signal[C_SIG_PARALLEL_SWITCH] == P1) {
		myData->bData[bd].parallelSwitch[ch/8] |= flag;
	} else {
		myData->bData[bd].parallelSwitch[ch/8] &= ~flag;
	}

	addr = base_addr + addr_step * bd + addr_div;
	outb(0x01, addr);

	addr = base_addr + addr_step * bd + run_cs;

	for(index=0; index <= (myPs->config.chPerBd-1)/8; index++) {
		outb(myData->bData[bd].parallelSwitch[index], addr + index);
	}

	addr = base_addr + addr_step * bd + addr_div;
	outb(0x00, addr);
}

void ParallelSwitch_2_Ch(int bd, int ch)
{
	int addr, base_addr, addr_step, parallel_cs, addr_div, index;
	unsigned char flag;

	if(myCh->ChAttribute.opType == P0) return;

	myCh = &(myData->bData[bd].cData[ch]);
	base_addr = myPs->addr.main[BASE_ADDR];
	addr_step = myPs->addr.main[ADDR_STEP];
	parallel_cs = myPs->addr.main[PARALLEL_CS];
	addr_div = myPs->addr.main[ADDR_DIV];
	flag = 0x01;
	flag = flag << (ch % 8);

	if(myCh->signal[C_SIG_PARALLEL_SWITCH] == P1) {
		myData->bData[bd].parallelSwitch[ch/8] |= flag;
		myData->bData[bd].cData[ch+1].signal[C_SIG_OUT_SWITCH] = P0;
	} else {
		myData->bData[bd].parallelSwitch[ch/8] &= ~flag;
	}

	addr = base_addr + addr_step * bd + addr_div;
	outb(0x01, addr);

	addr = base_addr + addr_step * bd + parallel_cs;

	for(index=0; index <= (myPs->config.chPerBd-1)/8; index++) {
		outb(myData->bData[bd].parallelSwitch[index], addr + index);
	}

	addr = base_addr + addr_step * bd + addr_div;
	outb(0x00, addr);
}

void ParallelSwitch_3_Ch(int bd, int ch)
{
	int addr, base_addr, addr_step, parallel_cs, addr_div, index;
	unsigned char flag;

	if(myCh->ChAttribute.opType == P0) return;

	base_addr = myPs->addr.main[BASE_ADDR];
	addr_step = myPs->addr.main[ADDR_STEP];
	parallel_cs = myPs->addr.main[PARALLEL_CS];
	addr_div = myPs->addr.main[ADDR_DIV];
	flag = 0x01;
	flag = flag << ((ch % 8)/2);

	if(myCh->signal[C_SIG_PARALLEL_SWITCH] == P1) {
		myData->bData[bd].parallelSwitch[ch/8] |= flag;
		myData->bData[bd].cData[ch+1].signal[C_SIG_OUT_SWITCH] = P0;
	} else {
		myData->bData[bd].parallelSwitch[ch/8] &= ~flag;
	}

	addr = base_addr + addr_step * bd + addr_div;
	outb(0x01, addr);

	addr = base_addr + addr_step * bd + parallel_cs;

	for(index=0; index <= (myPs->config.chPerBd-1)/8; index++) {
		outb(myData->bData[bd].parallelSwitch[index], addr + index);
	}

	addr = base_addr + addr_step * bd + addr_div;
	outb(0x00, addr);
}

void ParallelSwitch_4_Ch(int bd, int ch)
{
	int addr, base_addr, addr_step, parallel_cs, index;
	unsigned char flag,flag1;
	
	base_addr = myPs->addr.main[BASE_ADDR];
	addr_step = myPs->addr.main[ADDR_STEP];
	parallel_cs = myPs->addr.main[PARALLEL_CS];
	flag = 0x10; //power relay
	flag1 = 0x01; //sensing relay
	flag = flag << ((ch % 8)/2);
	flag1 = flag1 << ((ch % 8)/2);

    if(myCh->ChAttribute.opType == P1) { //kjiw
        myData->bData[bd].parallelSwitch[ch/8] |= flag1;
        if(myCh->signal[C_SIG_OUT_SWITCH] == P1) {
            myData->bData[bd].parallelSwitch[ch/8] |= flag;
            myData->bData[bd].cData[ch+1].signal[C_SIG_OUT_SWITCH] = P0;
        } else {
            myData->bData[bd].parallelSwitch[ch/8] &= ~flag;
        }
    } else {
		myData->bData[bd].parallelSwitch[ch/8] &= ~flag;
		myData->bData[bd].parallelSwitch[ch/8] &= ~flag1;
	}

	addr = base_addr + (addr_step * (bd+1)) + parallel_cs;

	for(index=0; index <= (myPs->config.chPerBd-1)/8; index++) {
		outb(myData->bData[bd].parallelSwitch[index], addr + (index * addr_step));
	}
}

void ParallelSwitch_5_Ch(int bd, int ch)
{
	unsigned char flag;
	int addr, base_addr, addr_step, parallel_cs, addr_div, index;

	if(myCh->ChAttribute.opType == P0) return;

	base_addr = myPs->addr.main[BASE_ADDR];
	addr_step = myPs->addr.main[ADDR_STEP];
	addr_div = myPs->addr.main[ADDR_DIV];
	parallel_cs = myPs->addr.main[PARALLEL_CS];

	flag = 0x01;
	flag = flag << ((ch % 8) / 2);
	if(myCh->signal[C_SIG_PARALLEL_SWITCH] == P1) {
		myData->bData[bd].parallelSwitch[ch / 8] |= flag;
		myData->bData[bd].cData[ch + 1].signal[C_SIG_OUT_SWITCH] = P0;
	} else {
		myData->bData[bd].parallelSwitch[ch / 8] &= ~flag;
	}

	addr = base_addr + addr_step * bd + addr_div;
	outb(0x08, addr);

	addr = base_addr + addr_step * bd;
	for(index=0; index <= (myPs->config.chPerBd - 1) / 8; index++) {
		outb(myData->bData[bd].parallelSwitch[index], addr + index);
	}

	addr = base_addr + addr_step * bd + addr_div;
	outb(0x00, addr);
}

void ParallelSwitch_5p_Ch(int bd, int ch)
{ //kjg_180521
	unsigned char flag;
	int addr, base_addr, addr_step, addr_div, index;

	flag = 0x01;
	flag = flag << (ch % 8);
	if(myCh->signal[C_SIG_PARALLEL_SWITCH] == P1) {
		myData->bData[bd].parallelSwitch[ch / 8] |= flag;
	} else {
		myData->bData[bd].parallelSwitch[ch / 8] &= ~flag;
	}

	base_addr = myPs->addr.main[BASE_ADDR];
	addr_step = myPs->addr.main[ADDR_STEP];
	addr_div = myPs->addr.main[ADDR_DIV];

	addr = base_addr + addr_step * bd + addr_div;
	outb(0x08, addr);

	addr = base_addr + addr_step * bd;
	for(index=0; index <= (myPs->config.chPerBd - 1) / 8; index++) {
		outb(myData->bData[bd].parallelSwitch[index], addr + index);
	}

	addr = base_addr + addr_step * bd + addr_div;
	outb(0x00, addr);
}

void ParallelSwitch_6_Ch(int bd, int ch)
{
	unsigned char flag;
	int addr, base_addr, addr_step, parallel_cs, addr_div, index;

	if(myCh->ChAttribute.opType == P0) return;

	base_addr = myPs->addr.main[BASE_ADDR];
	addr_step = myPs->addr.main[ADDR_STEP];
	parallel_cs = myPs->addr.main[PARALLEL_CS];
	addr_div = myPs->addr.main[ADDR_DIV];
	flag = 0x01;
	flag = flag << ((ch % 8)/2);

	if(myCh->signal[C_SIG_PARALLEL_SWITCH] == P1) {
		myData->bData[bd].parallelSwitch[ch/8] |= flag;
		myData->bData[bd].cData[ch+1].signal[C_SIG_OUT_SWITCH] = P0;
	} else {
		myData->bData[bd].parallelSwitch[ch/8] &= ~flag;
	}

	addr = base_addr + addr_step * bd + addr_div;
	outb(0x20, addr);

	addr = base_addr + addr_step * bd + parallel_cs;

	for(index=0; index <= (myPs->config.chPerBd-1)/8; index++) {
		outb(myData->bData[bd].parallelSwitch[index], addr + index);
	}

	addr = base_addr + addr_step * bd + addr_div;
	outb(0x00, addr);
}

void ParallelSwitch_7_Ch(int bd, int ch)
{
	unsigned char flag;
	int addr, base_addr, addr_step, parallel_cs, addr_div, index;
    
	if(myCh->ChAttribute.opType == P0) return;

	base_addr = myPs->addr.main[BASE_ADDR];
	addr_step = myPs->addr.main[ADDR_STEP];
	parallel_cs = myPs->addr.main[PARALLEL_CS];
	addr_div = myPs->addr.main[ADDR_DIV];
	flag = 0x01;
	flag = flag << ((ch % 8)/2);

    if(myCh->ChAttribute.opType == P1) { //kjiw
		if(myCh->signal[C_SIG_PARALLEL_SWITCH] == P1) {
            myData->bData[bd].parallelSwitch[ch/8] |= flag;
//			imyData->bData[bd].cData[ch+1].signal[C_SIG_OUT_SWITCH] = P0;
        } else {
            myData->bData[bd].parallelSwitch[ch/8] &= ~flag;
        }
    } else {
		myData->bData[bd].parallelSwitch[ch/8] &= ~flag;
	}
	
	//start RUN_CS
	addr = base_addr + addr_step * bd + addr_div;
	outb(0x01, addr);				

	addr = base_addr + addr_step * bd + parallel_cs; 
	for(index=0; index <= (myPs->config.chPerBd-1)/8; index++) {
		outb(myData->bData[bd].parallelSwitch[index], addr + (index*2));
	}

	addr = base_addr + addr_step * bd + addr_div;
	outb(0x00, addr);
}

void Status_LED_OnOff(int bd)
{
#if CYCLER_TYPE == DIGITAL_CYC
	return;	//180611 add
#endif
	
	switch(myPs->config.hwSpec) {
		case L_50V_50A:
			Status_LED_OnOff_1(bd);
			break;
		case L_5V_100A:
			Status_LED_OnOff_2(bd);
			break;
		default: break;
	}
}

void Status_LED_OnOff_1(int bd)
{
	int ch;
	int addr, base_addr, status_led;

	base_addr = myPs->addr.main[BASE_ADDR];
	status_led = myPs->addr.main[STATUS_LED];
	addr = base_addr + status_led;

	for(ch=0; ch < myPs->config.chPerBd; ch++) {
		myCh = &(myData->bData[bd].cData[ch]);
		switch(myCh->op.state) {
			case C_PAUSE:
				myCh->misc.statusLed = LED_FAULT;
				break;
			case C_RUN:
				switch(myCh->op.type) {
					case STEP_CHARGE:
						myCh->misc.statusLed = LED_CHARGE;
						break;
					case STEP_DISCHARGE:
						myCh->misc.statusLed = LED_DISCHARGE;
						break;
					case STEP_REST:
						myCh->misc.statusLed = LED_REST;
						break;
				}
				break;
	    	default: 
				myCh->misc.statusLed = LED_REST;
				break;
		}
		outb(myCh->misc.statusLed, addr + ch);
	}
}

void Status_LED_OnOff_2(int bd)
{
	unsigned char bit;
	int addr, ch;

	for(ch=0; ch < myPs->config.chPerBd; ch++) {
		myCh = &(myData->bData[bd].cData[ch]);
		switch(myCh->op.state) {
			case C_RUN:
				switch(myCh->op.type) {
					case STEP_CHARGE:
						bit = 0x01 << (ch * 1 + ch);
						myData->bData[bd].statusLed[ch/4] |= bit;
						bit = 0x02 << (ch * 1 + ch);
						myData->bData[bd].statusLed[ch/4] &= ~bit;
						break;
					case STEP_DISCHARGE:
						bit = 0x01 << (ch * 1 + ch);
						myData->bData[bd].statusLed[ch/4] &= ~bit;
						bit = 0x02 << (ch * 1 + ch);
						myData->bData[bd].statusLed[ch/4] |= bit;
						break;
				}
				break;
	    	default: 
				bit = 0x01 << (ch * 1 + ch);
				myData->bData[bd].statusLed[ch/4] &= ~bit;
				bit = 0x02 << (ch * 1 + ch);
				myCh->misc.statusLed &= ~bit;
				myData->bData[bd].statusLed[ch/4] &= ~bit;
				break;
		}
		addr = myPs->addr.interface[IO_EXPEND][0];
		outb(myData->bData[bd].statusLed[ch/4], addr);
	}
}
/*
void ReadOtFault(int bd)
{
	int rtn, ch, index;
	int addr, base_addr, bd_ot;
	unsigned char flag;

	switch(myPs->config.hwSpec) {
		case L_6V_6A:
		case L_5V_10mA:
		case L_5V_5A:
		case L_5V_30A:
		case L_2V_60A:
		case L_2V_100A:
		case L_5V_5A_2:
		case L_5V_20A:
		case L_50V_50A:
		case L_20V_25A:
		case L_5V_100A:
		case L_5V_30A_R1:
		case L_5V_100A_R1:
		case L_5V_100A_R1_EG:
		case L_5V_2A_R1:
		case L_5V_500A_R1:
		case L_5V_200A_R4:
		case L_5V_150A_R1:
		case L_5V_250A_R1:
		case L_5V_50A_R1:
		case L_5V_1000A_R1:
		case L_5V_300A_R1:
		case L_20V_10A_R1:
		case L_20V_50A_R2:
			rtn = 1;
			break;
		default:
			rtn = 0;
			break;
	}
	if(rtn == 1) return;

	base_addr = myPs->addr.main[BASE_ADDR];
	bd_ot = myPs->addr.main[BD_OT];
	if(myPs->config.ADC_type == COMM_TYPE) {
		 addr = base_addr + bd_ot + bd;
	} else {
		 addr = base_addr + bd_ot + bd;
	}
	for(index=0; index < myPs->config.chPerBd/8; index++) {
		myData->bData[bd].readOtFault[index] = ~(inb(addr + index));
	}

	for(ch=0; ch < myPs->config.chPerBd; ch++) {
		flag = 0x01;
		flag = flag << (ch % 8);
		if((myData->bData[bd].readOtFault[ch/8] & flag) == 0) {
			myCh->signal[C_SIG_OT_FAULT] = P0;
		} else {
			myCh->signal[C_SIG_OT_FAULT] = P1;
		}
	}
}

void ReadHwFault(int bd)
{
	int rtn, ch, index;
	int	addr, base_addr, hw_rd;
	unsigned char flag;

	switch(myPs->config.hwSpec) {
		case L_6V_6A:
		case L_5V_10mA:
		case L_5V_5A:
		case L_5V_30A:
		case L_2V_60A:
		case L_5V_20A:
		case L_2V_100A:
		case L_50V_50A:
		case L_20V_25A:
		case L_5V_100A:
		case L_5V_100A_R1:
		case L_5V_100A_R1_EG:
		case L_5V_30A_R1:
		case L_5V_2A_R1:
		case L_5V_500A_R1:
		case L_5V_200A_R4:
		case L_5V_150A_R1:
		case L_5V_250A_R1:
		case L_5V_50A_R1:
		case L_5V_1000A_R1:
		case L_5V_300A_R1:
		case L_20V_10A_R1:
		case L_20V_50A_R2:
			rtn = 1;
			break;
		default:	
			rtn = 0;
			break;
	}
	if(rtn == 1) return;

	base_addr = myPs->addr.main[BASE_ADDR];
	hw_rd = myPs->addr.main[HW_RD];
	if(myPs->config.ADC_type == COMM_TYPE) {
		addr = base_addr + hw_rd + bd;
	} else {
		addr = base_addr + hw_rd + bd;
	}
	for(index=0; index < myPs->config.chPerBd/8; index++) {
		myData->bData[bd].readHwFault[index] = ~(inb(addr + index));
	}

	for(ch=0; ch < myPs->config.chPerBd; ch++) {
		flag = 0x01;
		flag = flag << (ch % 8);
		if((myData->bData[bd].readHwFault[ch/8] & flag) == 0) {
			myCh->signal[C_SIG_HW_FAULT] = P0;
		} else {
			myCh->signal[C_SIG_HW_FAULT] = P1;
		}
	}
}
*/

void ReadHwFault_Ch(int bd, int ch) //Pack Hardware
{
	int rtn, bit;
	int	addr, base_addr, hw_rd, addr_step;
	unsigned char flag;

	switch(myPs->config.hwSpec) {
		case L_5V_600A_10A:
			rtn = 1;
			break;
		default:	
			rtn = 0;
			break;
	}
	if(rtn == 0) return;

	base_addr = myPs->addr.main[BASE_ADDR];
	addr_step = myPs->addr.main[ADDR_STEP];
	hw_rd = myPs->addr.main[HW_RD];
	if(myPs->config.ADC_type == COMM_TYPE) {
		addr = base_addr;
	} else {
		addr = base_addr + bd * addr_step + hw_rd;
	}

	myData->bData[bd].ch_di[ch].ch_io = inb(addr+ch);
	for(bit=0; bit < 8; bit++) {
		flag = 0x01;
		flag = flag << bit;
		switch(myData->bData[bd].ch_di[ch].ch_io & flag){
			case 0x01://OT
				myCh->signal[C_SIG_OT_FAULT] = P1;
				break;
			case 0x02://PS FAIL +7V
				myCh->signal[C_SIG_SMPS_FAULT] = P1;
				break;
			case 0x04://PS FAIL -3.3V
				myCh->signal[C_SIG_SMPS_FAULT] = P1;
				break;
			case 0x08://NC
				break;
			case 0x10://NC
				break;
			case 0x20://NC
				break;
			case 0x40://NC
				break;
			case 0x80://MODE CV N
				break;
		}
	}
}

void cC_D_Select(int bd, int ch, int type)
{
	int index, base_addr;
	unsigned char flag;

	switch(myPs->config.hwSpec) {
		case S_5V_200A:
			flag = 0x01;
			flag = flag << (ch % 8);
			index = ch / 8;
			if(type == P0) { //charge
				myData->bData[bd].C_D_Select[index] &= ~flag;
			} else { //discharge
				myData->bData[bd].C_D_Select[index] |= flag;
			}

			base_addr = myPs->addr.main[BASE_ADDR];
//			baseAddr = BD_ADDR + COM_BD_C_D_ADDR_1 + bd;
//			outb(myData->bData[bd].C_D_Select[index], baseAddr + index);
			break;
		case S_5V_200A_75A_15A_AD2:
			flag = 0x01;
			flag = flag << (ch % 8);
			index = ch / 8;
			if(type == P0) { //charge
				myData->bData[bd].C_D_Select[index] |= flag;
			} else { //discharge
				myData->bData[bd].C_D_Select[index] &= ~flag;
			}

			base_addr = myPs->addr.main[BASE_ADDR] + myPs->addr.main[CD_CS1];
			outb(myData->bData[bd].C_D_Select[index], base_addr + index);
			break;
		default:
			break;
	}
}

void cV_Range_Select(int bd, int ch, int range)
{
	int tmp, addr, base_addr, range_v;
	unsigned char flag = 0x01;

	if(myPs->config.rangeV <= RANGE1) {
		return;
	}

	flag = 0x01;
	flag = flag << (ch % 8);
	tmp = ch / 8;
	switch(range) {
		case RANGE0:
			myData->bData[bd].rangeSelectV[0][tmp] &= ~flag;
			myData->bData[bd].rangeSelectV[1][tmp] &= ~flag;
			myData->bData[bd].rangeSelectV[2][tmp] &= ~flag;
			myData->bData[bd].rangeSelectV[3][tmp] &= ~flag;
			break;
		case RANGE1:
			myData->bData[bd].rangeSelectV[0][tmp] |= flag;
			myData->bData[bd].rangeSelectV[1][tmp] &= ~flag;
			myData->bData[bd].rangeSelectV[2][tmp] &= ~flag;
			myData->bData[bd].rangeSelectV[3][tmp] &= ~flag;
			break;
		case RANGE2:
			myData->bData[bd].rangeSelectV[0][tmp] &= ~flag;
			myData->bData[bd].rangeSelectV[1][tmp] |= flag;
			myData->bData[bd].rangeSelectV[2][tmp] &= ~flag;
			myData->bData[bd].rangeSelectV[3][tmp] &= ~flag;
			break;
		case RANGE3:
			myData->bData[bd].rangeSelectV[0][tmp] &= ~flag;
			myData->bData[bd].rangeSelectV[1][tmp] &= ~flag;
			myData->bData[bd].rangeSelectV[2][tmp] |= flag;
			myData->bData[bd].rangeSelectV[3][tmp] &= ~flag;
			break;
		case RANGE4:
			myData->bData[bd].rangeSelectV[0][tmp] &= ~flag;
			myData->bData[bd].rangeSelectV[1][tmp] &= ~flag;
			myData->bData[bd].rangeSelectV[2][tmp] &= ~flag;
			myData->bData[bd].rangeSelectV[3][tmp] |= flag;
			break;
	}

	if(myPs->config.hwSpec != S_5V_200A_75A_15A_AD2) return;

	base_addr = myPs->addr.main[BASE_ADDR];
	range_v = myPs->addr.main[RANGE_V_CS];
	addr = base_addr + range_v + bd;

	tmp = range * 2;
	outb(myData->bData[bd].rangeSelectV[range-1][0], addr + tmp);
	outb(myData->bData[bd].rangeSelectV[range-1][1], addr + tmp + 1);
}

void cI_Range_Select(int bd, int ch, int range)
{
	switch(myPs->config.hwSpec) {
		case S_5V_200A:
			cI_Range_Select_1(bd, ch, range);
			break;
		case S_5V_200A_75A_15A_AD2:
			cI_Range_Select_2(bd, ch, range);
			break;
		default:
			break;
	}
}

void cI_Range_Select_1(int bd, int ch, int range)
{
	int tmp, addr, base_addr, range_i;
	unsigned char flag = 0x01;
	
	flag = 0x01;
	flag = flag << (ch % 8);
	tmp = ch / 8;
	switch(range) {
		case RANGE0:
			myData->bData[bd].rangeSelectI[0][tmp] &= ~flag;
			myData->bData[bd].rangeSelectI[1][tmp] &= ~flag;
			myData->bData[bd].rangeSelectI[2][tmp] &= ~flag;
			myData->bData[bd].rangeSelectI[3][tmp] &= ~flag;
			break;
		case RANGE1:
			myData->bData[bd].rangeSelectI[0][tmp] |= flag;
			myData->bData[bd].rangeSelectI[1][tmp] &= ~flag;
			myData->bData[bd].rangeSelectI[2][tmp] &= ~flag;
			myData->bData[bd].rangeSelectI[3][tmp] &= ~flag;
			break;
		case RANGE2:
			myData->bData[bd].rangeSelectI[0][tmp] &= ~flag;
			myData->bData[bd].rangeSelectI[1][tmp] |= flag;
			myData->bData[bd].rangeSelectI[2][tmp] &= ~flag;
			myData->bData[bd].rangeSelectI[3][tmp] &= ~flag;
			break;
		case RANGE3:
			myData->bData[bd].rangeSelectI[0][tmp] &= ~flag;
			myData->bData[bd].rangeSelectI[1][tmp] &= ~flag;
			myData->bData[bd].rangeSelectI[2][tmp] |= flag;
			myData->bData[bd].rangeSelectI[3][tmp] &= ~flag;
			break;
		case RANGE4:
			myData->bData[bd].rangeSelectI[0][tmp] &= ~flag;
			myData->bData[bd].rangeSelectI[1][tmp] &= ~flag;
			myData->bData[bd].rangeSelectI[2][tmp] &= ~flag;
			myData->bData[bd].rangeSelectI[3][tmp] |= flag;
			break;
	}

	base_addr = myPs->addr.main[BASE_ADDR];
	range_i = myPs->addr.main[RANGE_I_CS];
	addr = base_addr + range_i + bd * 2;
	outb(myData->bData[bd].rangeSelectI[0][0], addr);
	outb(myData->bData[bd].rangeSelectI[1][0], addr + 2);
}

void cI_Range_Select_2(int bd, int ch, int range)
{
	int tmp = 0, i;
	int	addr, base_addr, addr_step, range_i, addr_div, index;
	unsigned char flag = 0x01, div;

	myCh = &(myData->bData[bd].cData[ch]);
	flag = 0x01;
	flag = flag << (ch % 8);
	tmp = ch / 8;
	//range = (int)myCh->signal[C_SIG_I_RANGE];
	switch(range) {
		case RANGE0:
			myData->bData[bd].rangeSelectI[0][tmp] &= ~flag;
			myData->bData[bd].rangeSelectI[1][tmp] &= ~flag;
			myData->bData[bd].rangeSelectI[2][tmp] &= ~flag;
			myData->bData[bd].rangeSelectI[3][tmp] &= ~flag;
			break;
		case RANGE1:
			myData->bData[bd].rangeSelectI[0][tmp] |= flag;
			myData->bData[bd].rangeSelectI[1][tmp] &= ~flag;
			myData->bData[bd].rangeSelectI[2][tmp] &= ~flag;
			myData->bData[bd].rangeSelectI[3][tmp] &= ~flag;
			break;
		case RANGE2:
			myData->bData[bd].rangeSelectI[0][tmp] |= flag;
			myData->bData[bd].rangeSelectI[1][tmp] &= ~flag;
			myData->bData[bd].rangeSelectI[2][tmp] |= flag;
			myData->bData[bd].rangeSelectI[3][tmp] &= ~flag;
			break;
		case RANGE3:
			myData->bData[bd].rangeSelectI[0][tmp] &= ~flag;
			myData->bData[bd].rangeSelectI[1][tmp] |= flag;
			myData->bData[bd].rangeSelectI[2][tmp] &= ~flag;
			myData->bData[bd].rangeSelectI[3][tmp] &= ~flag;
			break;
		case RANGE4:
			myData->bData[bd].rangeSelectI[0][tmp] &= ~flag;
			myData->bData[bd].rangeSelectI[1][tmp] &= ~flag;
			myData->bData[bd].rangeSelectI[2][tmp] &= ~flag;
			myData->bData[bd].rangeSelectI[3][tmp] |= flag;
			break;
	}

	base_addr = myPs->addr.main[BASE_ADDR];
	addr_step = myPs->addr.main[ADDR_STEP];
	range_i = myPs->addr.main[RANGE_I_CS];
	addr_div = myPs->addr.main[ADDR_DIV];

	if(myPs->config.ADC_type == COMM_TYPE) {
		addr = base_addr + range_i + tmp;
	} else {
		for(i=0; i < myPs->config.rangeI; i++){
			div = 0x10 << i;
			addr = base_addr + addr_step * bd + addr_div;
			outb(div, addr);
		
			addr = base_addr + addr_step * bd + range_i;
			for(index=0; index <= (myPs->config.chPerBd-1) / 8; index++) {
				outb(myData->bData[bd].rangeSelectI[i][index], addr + index);
			}
		}
		addr = base_addr + addr_step * bd + addr_div;
		outb(0x00, addr);
	}
}

void V_Cmd_Output(int bd)
{
	switch(myPs->config.hwSpec) {
		case S_5V_200A:
			V_Cmd_Output_1(bd);
			break;
		case S_5V_200A_75A_15A_AD2:
			V_Cmd_Output_2(bd);
			break;
		default:
			break;
	}
}

void V_Cmd_Output_Ch(int bd, int ch)
{
#if CYCLER_TYPE == DIGITAL_CYC
	return;	//180611
#endif
	switch(myPs->config.hwSpec) {
		case S_5V_200A:
			V_Cmd_Output_1(bd);
			break;
		case S_5V_200A_75A_15A_AD2:
			V_Cmd_Output_2_Ch(bd, ch);
			break;
		default:
			break;
	}
}



void V_Cmd_Output_1(int bd)
{
	unsigned char flag, index;
	unsigned char bd_enable;
	int ch, value, div, range;
    int type, point=0;
	int addr, base_addr, da_bd_en, da_h_byte, dav_l;
    double tmp=0;
	U_ADDA ref;

	type = 0;

	for(ch=0; ch < myPs->config.chPerBd; ch++) {
		myCh = &(myData->bData[bd].cData[ch]);
		if(myCh->signal[C_SIG_V_CMD_OUTPUT] == P0) {
			continue;
		}
		myCh->signal[C_SIG_V_CMD_OUTPUT] = P0;

		value = myCh->misc.cmd_v;
		div = myCh->misc.cmd_v_div;
		range = myCh->misc.cmd_v_range;

		flag = 0x01;
		flag = flag << (ch % 8);
		index = ch / 8;
	
		if(div > 0 && div < 10) {
			point = cFindDACaliPoint(bd, ch, value, type, range);
			if((range+1) == RANGE1) {
				if(myCh->op.state == C_CALI) {
					tmp = ((double)value
						* myData->cali.tmpData[bd][ch].DA_A[type][range][point]
						+ myData->cali.tmpData[bd][ch].DA_B[type][range][point])
						* 1.01 + 2490000.0;
				} else {
					tmp = ((double)value
						* myData->cali.data[bd][ch].DA_A[type][range][point]
						+ myData->cali.data[bd][ch].DA_B[type][range][point])
						* 1.01 + 2490000.0;
				}
			} else if((range+1) == RANGE2) {
			} else if((range+1) == RANGE3) {
			} else { //range4
			}
		} else if(div > 10){
			div -= 10;
			if((range+1) == RANGE1) {
				tmp = (double)value * 1.01 + 2490000.0;
			} else if((range+1) == RANGE2) {
			} else if((range+1) == RANGE3) {
			} else { //range4
			}
		}else tmp = 0;
		if(myPs->config.ratioVoltage == MICRO) { //uV
			tmp *= 0.0032767;
		} else { //nV
			tmp *= 0.0000032767;
		}
		if(div != 5 && div > 0) tmp = tmp / 5.0 * div;
		ref.val = (short int)tmp;

		base_addr = myPs->addr.main[BASE_ADDR];
		da_bd_en = myPs->addr.main[DA_BD_ENABLE];
		da_h_byte = myPs->addr.main[DA_H_BYTE];
		dav_l = myPs->addr.main[DAV_L];

		bd_enable = 0x01;
		bd_enable = bd_enable << bd;
		addr = base_addr + da_bd_en;
		outb(bd_enable, addr);
		addr = base_addr + da_h_byte;
	   	outb(ref.byte[1], addr);
		addr = base_addr + dav_l + ch;
		outb(ref.byte[0], addr);
		addr = base_addr + da_bd_en;
		bd_enable = 0x00;
		outb(bd_enable, addr);
	}
}

void V_Cmd_Output_2(int bd)
{
	unsigned char bd_enable;
	unsigned char flag, index;
	int ch, value, div, range;
    int type, point=0, bit=0;
	int addr, base_addr, addr_step, da_bd_en, da_h_byte, dav_l, addr_div;
    double tmp=0;
	U_ADDA ref;

	type = 0;

	for(ch=0; ch < myPs->config.chPerBd; ch++) {
		myCh = &(myData->bData[bd].cData[ch]);
		if(myCh->signal[C_SIG_V_CMD_OUTPUT] == P0) {
			continue;
		}
		myCh->signal[C_SIG_V_CMD_OUTPUT] = P0;

		value = myCh->misc.cmd_v;
		div = myCh->misc.cmd_v_div;
		range = myCh->misc.cmd_v_range;

		flag = 0x01;
		flag = flag << (ch % 8);
		index = ch / 8;
	
		if(div > 0 && div < 10) {
			point = cFindDACaliPoint(bd, ch, value, type, range);
			if((range+1) == RANGE1) {
				if(myCh->op.state == C_CALI) {
					tmp = ((double)value
						* myData->cali.tmpData[bd][ch].DA_A[type][range][point]
						+ myData->cali.tmpData[bd][ch].DA_B[type][range][point]);
				} else {
					tmp = ((double)value
						* myData->cali.data[bd][ch].DA_A[type][range][point]
						+ myData->cali.data[bd][ch].DA_B[type][range][point]);
				}
			} else if((range+1) == RANGE2) {
				if(myCh->op.state == C_CALI) {
					tmp = ((double)value
						* myData->cali.tmpData[bd][ch].DA_A[type][range][point]
						+ myData->cali.tmpData[bd][ch].DA_B[type][range][point]);
				} else {
					tmp = ((double)value
						* myData->cali.data[bd][ch].DA_A[type][range][point]
						+ myData->cali.data[bd][ch].DA_B[type][range][point]);
				}
			} else if((range+1) == RANGE3) {
				if(myCh->op.state == C_CALI) {
					tmp = ((double)value
						* myData->cali.tmpData[bd][ch].DA_A[type][range][point]
						+ myData->cali.tmpData[bd][ch].DA_B[type][range][point]);
				} else {
					tmp = ((double)value
						* myData->cali.data[bd][ch].DA_A[type][range][point]
						+ myData->cali.data[bd][ch].DA_B[type][range][point]);
				}
			} else { //range4
				if(myCh->op.state == C_CALI) {
					tmp = ((double)value
						* myData->cali.tmpData[bd][ch].DA_A[type][range][point]
						+ myData->cali.tmpData[bd][ch].DA_B[type][range][point]);
				} else {
					tmp = ((double)value
						* myData->cali.data[bd][ch].DA_A[type][range][point]
						+ myData->cali.data[bd][ch].DA_B[type][range][point]);
				}
			}
		} else if(div > 10){
			div -= 10;
			if((range+1) == RANGE1) {
				tmp = (double)value;
			} else if((range+1) == RANGE2) {
				tmp = (double)value;
			} else if((range+1) == RANGE3) {
				tmp = (double)value;
			} else { //range4
				tmp = (double)value;
			}
		}else tmp = 0;
		if(myPs->config.ratioVoltage == MICRO) { //uV
			tmp *= 0.0032767;
		} else { //nV
			tmp *= 0.0000032767;
		}
		if(div != 5 && div > 0) tmp = tmp / 5.0 * div;

		if(myPs->config.DAC_type == DAC_7741)
			ref.val = (short int)tmp ^ 0x8000;
		else 
			ref.val = (short int)tmp;
		base_addr = myPs->addr.main[BASE_ADDR];
		addr_step = myPs->addr.main[ADDR_STEP];
		da_bd_en = myPs->addr.main[DA_BD_ENABLE];
		addr_div = myPs->addr.main[ADDR_DIV];
		da_h_byte = myPs->addr.main[DA_H_BYTE];
		dav_l = myPs->addr.main[DAV_L];

		bit = ch / 8;
		bd_enable = 0x01;
		bd_enable = bd_enable << bit;
		addr = base_addr + addr_step * bd + da_bd_en;
		outb(bd_enable, addr);

		addr = base_addr + addr_step * bd + da_h_byte;
   		outb(ref.byte[1], addr);
		addr = base_addr + addr_step * bd + addr_div;
		outb(0x02, addr);
		addr = base_addr + addr_step * bd + dav_l + (ch%8);
		outb(ref.byte[0], addr);
		addr = base_addr + addr_step * bd + addr_div;
		outb(0x00, addr);
	}
}

void V_Cmd_Output_2_Ch(int bd, int ch)
{
	unsigned char bd_enable;
	int value, div, range;
    int type, point=0, bit=0;
	int addr, base_addr, addr_step, da_bd_en, da_h_byte, dav_l, addr_div;
    double tmp=0;
	U_ADDA ref;

	type = 0;

	myCh = &(myData->bData[bd].cData[ch]);
	if(myCh->signal[C_SIG_V_CMD_OUTPUT] == P0) return;
	myCh->signal[C_SIG_V_CMD_OUTPUT] = P0;

	value = myCh->misc.cmd_v;
	div = myCh->misc.cmd_v_div;
	range = myCh->misc.cmd_v_range;

	
	if(div > 0 && div < 10) {
		point = cFindDACaliPoint(bd, ch, value, type, range);
		if((range+1) == RANGE1) {
			if(myCh->op.state == C_CALI) {
				tmp = ((double)value
					* myData->cali.tmpData[bd][ch].DA_A[type][range][point]
					+ myData->cali.tmpData[bd][ch].DA_B[type][range][point]);
			} else {
				tmp = ((double)value
					* myData->cali.data[bd][ch].DA_A[type][range][point]
					+ myData->cali.data[bd][ch].DA_B[type][range][point]);
			}
		} else if((range+1) == RANGE2) {
			if(myCh->op.state == C_CALI) {
				tmp = ((double)value
					* myData->cali.tmpData[bd][ch].DA_A[type][range][point]
					+ myData->cali.tmpData[bd][ch].DA_B[type][range][point]);
			} else {
				tmp = ((double)value
					* myData->cali.data[bd][ch].DA_A[type][range][point]
					+ myData->cali.data[bd][ch].DA_B[type][range][point]);
			}
		} else if((range+1) == RANGE3) {
			if(myCh->op.state == C_CALI) {
				tmp = ((double)value
					* myData->cali.tmpData[bd][ch].DA_A[type][range][point]
					+ myData->cali.tmpData[bd][ch].DA_B[type][range][point]);
			} else {
				tmp = ((double)value
					* myData->cali.data[bd][ch].DA_A[type][range][point]
					+ myData->cali.data[bd][ch].DA_B[type][range][point]);
			}
		} else { //range4
			if(myCh->op.state == C_CALI) {
				tmp = ((double)value
					* myData->cali.tmpData[bd][ch].DA_A[type][range][point]
					+ myData->cali.tmpData[bd][ch].DA_B[type][range][point]);
			} else {
				tmp = ((double)value
					* myData->cali.data[bd][ch].DA_A[type][range][point]
					+ myData->cali.data[bd][ch].DA_B[type][range][point]);
			}
		}
	} else if(div > 10){
		div -= 10;
		if((range+1) == RANGE1) {
			tmp = (double)value;
		} else if((range+1) == RANGE2) {
			tmp = (double)value;
		} else if((range+1) == RANGE3) {
			tmp = (double)value;
		} else { //range4
			tmp = (double)value;
		}
	}else tmp = 0;
	if(myPs->config.ratioVoltage == MICRO) { //uV
		tmp *= 0.0032767;
	} else { //nV
		tmp *= 0.0000032767;
	}
	if(div != 5 && div > 0) tmp = tmp / 5.0 * div;
	if(myPs->config.DAC_type == DAC_7741)
		ref.val = (short int)tmp ^ 0x8000;
	else
		ref.val = (short int)tmp;
	base_addr = myPs->addr.main[BASE_ADDR];
	addr_step = myPs->addr.main[ADDR_STEP];
	da_bd_en = myPs->addr.main[DA_BD_ENABLE];
	addr_div = myPs->addr.main[ADDR_DIV];
	da_h_byte = myPs->addr.main[DA_H_BYTE];
	dav_l = myPs->addr.main[DAV_L];

	bit = ch / 8;
	bd_enable = 0x01;
	bd_enable = bd_enable << bit;
	addr = base_addr + addr_step * bd + da_bd_en;
	outb(bd_enable, addr);

	addr = base_addr + addr_step * bd + da_h_byte;
   	outb(ref.byte[1], addr);
	addr = base_addr + addr_step * bd + addr_div;
	outb(0x02, addr);
	addr = base_addr + addr_step * bd + dav_l + (ch%8);
	outb(ref.byte[0], addr);
	addr = base_addr + addr_step * bd + addr_div;
	outb(0x00, addr);
	addr = base_addr + addr_step * bd + da_bd_en;
	outb(0x00, addr);
}


void I_Cmd_Output(int bd)
{
	switch(myPs->config.hwSpec) {
		case S_5V_200A:
			I_Cmd_Output_1(bd);
			break;
		case S_5V_200A_75A_15A_AD2:
			I_Cmd_Output_2(bd);
			break;
		default:
			break;
	}
}

void I_Cmd_Output_Ch(int bd, int ch)
{
#if CYCLER_TYPE == DIGITAL_CYC
	return;	//180611 add
#endif
	
	switch(myPs->config.hwSpec) {
		case S_5V_200A:
			I_Cmd_Output_1(bd);
			break;
		case S_5V_200A_75A_15A_AD2:
			I_Cmd_Output_2_Ch(bd, ch);
			break;
		default:
			break;
	}
}


void I_Cmd_Output_1(int bd)
{
	unsigned char flag, index;
	unsigned char bd_enable;
	int ch, value, div, range;
    int type, point;
	int addr, base_addr, da_bd_en, da_h_byte, dai_l;
	double tmp=0;
	U_ADDA ref;

	type = 1;

	for(ch=0; ch < myPs->config.chPerBd; ch++) {
		myCh = &(myData->bData[bd].cData[ch]);
		if(myCh->signal[C_SIG_I_CMD_OUTPUT] == P0) {
			continue;
		}
		myCh->signal[C_SIG_I_CMD_OUTPUT] = P0;

		value = myCh->misc.cmd_i;
		div = myCh->misc.cmd_i_div;
		range = myCh->misc.cmd_i_range;

		flag = 0x01;
		flag = flag << (ch % 8);
		index = ch / 8;

		if(div > 0 && div < 10) {
			point = cFindDACaliPoint(bd, ch, value, type, range);
			if(myCh->op.state == C_CALI) {
		 		tmp = (double)value
					* myData->cali.tmpData[bd][ch].DA_A[type][range][point]
					+ myData->cali.tmpData[bd][ch].DA_B[type][range][point];
			} else {
			 	tmp = (double)value
					* myData->cali.data[bd][ch].DA_A[type][range][point]
					+ myData->cali.data[bd][ch].DA_B[type][range][point];
			}

			if((range+1) == RANGE1) {
				if(value >= 0) {
					tmp = (tmp * 0.03901950975 + 936098.049);
				} else {
					tmp = (tmp * -0.03216608304 + 1666783.392);
				}
				if(myPs->config.ratioCurrent == MICRO) { //uA
					tmp *= 0.0032767;
				} else { //nA
					tmp *= 0.0000032767;
				}
			} else if((range+1) == RANGE2) {
				if(value >= 0) {
					tmp = (tmp * 0.39019509755 + 936098.049);
				} else {
					tmp = (tmp * -0.32166083042 + 1666783.392);
				}
				if(myPs->config.ratioCurrent == MICRO) { //uA
					tmp *= 0.0032767;
				} else { //nA
					tmp *= 0.0000032767;
				}
			} else if((range+1) == RANGE3) {
			} else { //range4
			}
		} else if(div > 10){
			div -= 10;
			tmp = (double)value;

			if((range+1) == RANGE1) {
				if(value >= 0) {
					tmp = (tmp * 0.03901950975 + 936098.049);
				} else {
					tmp = (tmp * -0.03216608304 + 1666783.392);
				}
				if(myPs->config.ratioCurrent == MICRO) { //uA
					tmp *= 0.0032767;
				} else { //nA
					tmp *= 0.0000032767;
				}
			} else if((range+1) == RANGE2) {
				if(value >= 0) {
					tmp = (tmp * 0.39019509755 + 936098.049);
				} else {
					tmp = (tmp * -0.32166083042 + 1666783.392);
				}
				if(myPs->config.ratioCurrent == MICRO) { //uA
					tmp *= 0.0032767;
				} else { //nA
					tmp *= 0.0000032767;
				}
			} else if((range+1) == RANGE3) {
			} else { //range4
			}
		}else tmp = 0;

		if(div != 5 && div > 0) tmp = tmp / 5.0 * div;
		ref.val = (short int)tmp;
		
		base_addr = myPs->addr.main[BASE_ADDR];
		da_bd_en = myPs->addr.main[DA_BD_ENABLE];
		da_h_byte = myPs->addr.main[DA_H_BYTE];
		dai_l = myPs->addr.main[DAI_L];
		
		bd_enable = 0x01;
		bd_enable = bd_enable << bd;
		addr = base_addr + da_bd_en;
		outb(bd_enable, addr);
		addr = base_addr + da_h_byte;
   	 	outb(ref.byte[1], addr);
		addr = base_addr + dai_l + ch;
   		outb(ref.byte[0], addr);
		addr = base_addr + da_bd_en;
		outb(0x00, addr);
	}
}

void I_Cmd_Output_2(int bd)
{
	unsigned char flag, index;
	unsigned char bd_enable;
	int ch, value, div, range;
    int type, point, bit=0;
	int addr, base_addr, addr_step, da_bd_en, da_h_byte, dai_l, addr_div;
	double tmp=0, shunt=0, digit;
	U_ADDA ref;

	type = 1;

	for(ch=0; ch < myPs->config.chPerBd; ch++) {
		myCh = &(myData->bData[bd].cData[ch]);
		if(myCh->signal[C_SIG_I_CMD_OUTPUT] == P0) {
			continue;
		}
		myCh->signal[C_SIG_I_CMD_OUTPUT] = P0;

		value = myCh->misc.cmd_i;
		div = myCh->misc.cmd_i_div;
		range = myCh->misc.cmd_i_range;

		flag = 0x01;
		flag = flag << (ch % 8);
		index = ch / 8;

		myCh->misc.preIref = value;
		if(div > 0 && div <= 10) {
			point = cFindDACaliPoint(bd, ch, value, type, range);
			if(myCh->op.state == C_CALI) {
			 	tmp = (double)value
					* myData->cali.tmpData[bd][ch].DA_A[type][range][point]
					+ myData->cali.tmpData[bd][ch].DA_B[type][range][point];
			} else {
			 	tmp = (double)value
					* myData->cali.data[bd][ch].DA_A[type][range][point]
					+ myData->cali.data[bd][ch].DA_B[type][range][point];
			}
		}else if(div > 10){
			div -=10;
			tmp = (double)value;
		}else tmp = 0;
		shunt = SelectShunt(range, value, tmp);
		digit = ConvertAmpRate(range, shunt, tmp,0);

		if(div != 5 && div > 0) digit = digit / 5.0 * div;
		if(myPs->config.DAC_type == DAC_7741)
			ref.val = (short int)digit ^ 0x8000;
		else
			ref.val = (short int)digit;
		
		base_addr = myPs->addr.main[BASE_ADDR];
		addr_step = myPs->addr.main[ADDR_STEP];
		da_bd_en = myPs->addr.main[DA_BD_ENABLE];
		addr_div = myPs->addr.main[ADDR_DIV];
		da_h_byte = myPs->addr.main[DA_H_BYTE];
		dai_l = myPs->addr.main[DAI_L];

		bit = ch / 8;
		bd_enable = 0x01;
		bd_enable = bd_enable << bit;
		addr = base_addr + addr_step * bd + da_bd_en;
		outb(bd_enable, addr);

		addr = base_addr + addr_step * bd + da_h_byte;
   		outb(ref.byte[1], addr);
		addr = base_addr + addr_step * bd + addr_div;
		outb(0x04, addr);
		addr = base_addr + addr_step * bd + dai_l + (ch%8);
   		outb(ref.byte[0], addr);
		addr = base_addr + addr_step * bd + addr_div;
		outb(0x00, addr);
	}
}

void I_Cmd_Output_2_Ch(int bd, int ch)
{
	unsigned char bd_enable;
	int value, div, range,dir;
    int type, point, bit=0;
	int addr, base_addr, addr_step, da_bd_en, da_h_byte, dai_l, addr_div;
	double tmp=0, shunt=0, digit;
	U_ADDA ref;

	type = 1;

	myCh = &(myData->bData[bd].cData[ch]);
	if(myCh->signal[C_SIG_I_CMD_OUTPUT] == P0) return;
	myCh->signal[C_SIG_I_CMD_OUTPUT] = P0;

	value = myCh->misc.cmd_i;
	div = myCh->misc.cmd_i_div;
	range = myCh->misc.cmd_i_range;
	
	myCh->misc.preIref = value;
			//120126 kji switching cali offset 
	dir = value;
	if(div > 0 && div <= 10) {
		point = cFindDACaliPoint(bd, ch, value, type, range);
		if(myCh->op.state == C_CALI) {
		 	tmp = (double)value
				* myData->cali.tmpData[bd][ch].DA_A[type][range][point]
				+ myData->cali.tmpData[bd][ch].DA_B[type][range][point];
		} else {
		 	tmp = (double)value
				* myData->cali.data[bd][ch].DA_A[type][range][point]
				+ myData->cali.data[bd][ch].DA_B[type][range][point];
		}
	}else if(div > 10){
		div -=10;
		tmp = (double)value;
	}else tmp = 0;
	shunt = SelectShunt(range, value, tmp);
	digit = ConvertAmpRate(range, shunt, tmp,dir);

	if(div != 5 && div > 0) digit = digit / 5.0 * div;
	if(myPs->config.DAC_type == DAC_7741)
		ref.val = (short int)digit ^ 0x8000;
	else
		ref.val = (short int)digit;
	
	base_addr = myPs->addr.main[BASE_ADDR];
	addr_step = myPs->addr.main[ADDR_STEP];
	da_bd_en = myPs->addr.main[DA_BD_ENABLE];
	addr_div = myPs->addr.main[ADDR_DIV];
	da_h_byte = myPs->addr.main[DA_H_BYTE];
	dai_l = myPs->addr.main[DAI_L];

	bit = ch / 8;
	bd_enable = 0x01;
	bd_enable = bd_enable << bit;
	addr = base_addr + addr_step * bd + da_bd_en;
	outb(bd_enable, addr);

	addr = base_addr + addr_step * bd + da_h_byte;
   	outb(ref.byte[1], addr);
	addr = base_addr + addr_step * bd + addr_div;
	outb(0x04, addr);
	addr = base_addr + addr_step * bd + dai_l + (ch%8);
   	outb(ref.byte[0], addr);
	addr = base_addr + addr_step * bd + addr_div;
	outb(0x00, addr);
	addr = base_addr + addr_step * bd + da_bd_en;
	outb(0x00, addr);
}

unsigned char cGrading(int bd, int ch, int No, unsigned char code)
{
	int stepNo, index;
	unsigned char item, gradeProc, check_index, check_No;
	unsigned char item_check = 0;
	long val=0, lower, upper;

	myCh = &(myData->bData[bd].cData[ch]);
//	stepNo = myCh->op.stepNo-1;
	stepNo = myCh->misc.advStepNo;

	//20190513 total item number check
	if(No == 0){
		for(check_index=0; check_index < MAX_GRADE_STEP; check_index++){
			for(check_No=0; check_No<2; check_No++){
				if(myPs->testCond[bd][ch].step[stepNo]
							.grade[check_No].gradeStep[check_index].item !=0)
					item_check++;
			}
		}
	}

	for(index = 0; index < MAX_GRADE_STEP; index++){
		if(myPs->testCond[bd][ch].step[stepNo]
					.grade[No].gradeStep[index].gradeCode == 0) return code;

		item = myPs->testCond[bd][ch].step[stepNo]
				.grade[No].gradeStep[index].item;
		gradeProc = myPs->testCond[bd][ch].step[stepNo]
				.grade[No].gradeStep[index].gradeProc;
		//20190513 total item number check
		if(item_check !=0){
			if((item_check%2) == 0)
					item_check = item_check - 2;
			else
					item_check = item_check - 1;
		}
		switch(item){
			case GRADE_V:
				val = myCh->op.Vsens;
				if(myCh->ChAttribute.chNo_master == P0) {
					val = myData->bData[bd].cData[ch-1].op.Vsens;
				}
				break;
			case GRADE_CAPACITY:
				val = myCh->op.ampareHour;
				if(myCh->ChAttribute.chNo_master == P0) {
					val += myData->bData[bd].cData[ch-1].op.ampareHour;
				}
				break;
			case GRADE_Z:
				val = myCh->op.z;
				if(myPs->config.hwSpec == L_5V_200A_1CH_JIG) 
					val = myCh->misc.saveZ;
				break;
			case GRADE_CURRENT:
				val = myCh->op.Isens;
				if(myCh->ChAttribute.chNo_master == P0) {
					val += myData->bData[bd].cData[ch-1].op.Isens;
				}
				break;
			case GRADE_TIME:
				val = myCh->op.runTime;
				break;
			case GRADE_FARAD:
				val = myCh->op.capacitance;
				if(myCh->ChAttribute.chNo_master == P0) {
					val += myData->bData[bd].cData[ch-1].op.capacitance;
				}
				break;
			case GRADE_TEMP:
				val = myCh->op.temp;
				if(myData->AnalogMeter.config.multiNum > 1){
					if(myCh->op.temp < myCh->op.temp1){
						val = myCh->op.temp1;
					}
				}
				if(myCh->ChAttribute.chNo_master == P0) {
					val = myData->bData[bd].cData[ch-1].op.temp;
					if(myData->AnalogMeter.config.multiNum > 1){
						if(myData->bData[bd].cData[ch-1].op.temp
							< myData->bData[bd].cData[ch-1].op.temp1){
							val = myData->bData[bd].cData[ch-1].op.temp1;
						}
					}
				}
				break;
			case GRADE_POWER:
				val = myCh->op.watt;
				if(myCh->ChAttribute.chNo_master == P0) {
					val += myData->bData[bd].cData[ch-1].op.watt;
				}
				break;
			case GRADE_WATTHOUR:
				val = myCh->op.wattHour;
				if(myCh->ChAttribute.chNo_master == P0) {
					val += myData->bData[bd].cData[ch-1].op.wattHour;
				}
				break;
		}

		lower = myPs->testCond[bd][ch].step[stepNo]
			.grade[No].gradeStep[index].lowerValue;
		upper = myPs->testCond[bd][ch].step[stepNo]
			.grade[No].gradeStep[index].upperValue;
		
		if(lower <= val && val < upper) {
			code = (int)myPs->testCond[bd][ch].step[stepNo]
					.grade[0].gradeStep[index].gradeCode;
			code = cGrading_Check(bd, ch, No+1, index, code);
			if(code > 0){  
				break; //20190513 add 
			} else if(item_check == 0 && 
						myCh->misc.grade_flag%2 != 0 && code == GRADE_NONE){
						myCh->misc.grade_flag = 0;
					if(gradeProc != 0){
						if(myCh->misc.gradeProcFlag == P0
							&& myCh->op.code != C_FAULT_NEXTSTEP_CMD) {
							switch(gradeProc){
								case GRADE_STOP:
									myCh->misc.gradeProcFlag = P1;
									myCh->op.code = C_STOP_GRADE;
									myCh->op.phase = P100;
									if(myCh->ChAttribute.chNo_master == P0)
									{
										myData->bData[bd].cData[ch-1].misc
										.gradeProcFlag = P1;
										myData->bData[bd].cData[ch-1].op.code
											= myCh->op.code;
										myData->bData[bd].cData[ch-1].op.phase
											= myCh->op.phase;
									}
									return code;
								case GRADE_PAUSE:
									myCh->misc.gradeProcFlag = P1;
									myCh->misc.tmpState = myCh->op.state;
									myCh->misc.tmpCode = myCh->op.code;
									myCh->op.code = C_FAULT_GRADE;
									myCh->op.phase = P100;
									if(myCh->ChAttribute.chNo_master == P0)
									{
										myData->bData[bd].cData[ch-1]
													.misc.gradeProcFlag = P1;
										myData->bData[bd].cData[ch-1]
													.misc.tmpState
											= myCh->op.state;
										myData->bData[bd].cData[ch-1]
													.misc.tmpCode
											= myCh->op.code;
										myData->bData[bd].cData[ch-1].op.code
											= myCh->op.code;
										myData->bData[bd].cData[ch-1].op.phase
											= myCh->op.phase;
									}
									return code;
								default: break;
							}
						}
					}
					//end add
				}
		}else{
			code = cGrading_Check(bd, ch, No+1, index, GRADE_NONE);
			if(code > 0){
				break;
			}else{
				//170728 oys add : Grade condition process
				if(item_check == 0 && gradeProc != 0){
					if(myCh->misc.gradeProcFlag == P0
						&& myCh->op.code != C_FAULT_NEXTSTEP_CMD) {
						switch(gradeProc){
							case GRADE_STOP:
								myCh->misc.gradeProcFlag = P1;
								myCh->op.code = C_STOP_GRADE;
								myCh->op.phase = P100;
								if(myCh->ChAttribute.chNo_master == P0)
								{
									myData->bData[bd].cData[ch-1].misc
									.gradeProcFlag = P1;
									myData->bData[bd].cData[ch-1].op.code
										= myCh->op.code;
									myData->bData[bd].cData[ch-1].op.phase
										= myCh->op.phase;
								}
								return code;
							case GRADE_PAUSE:
								myCh->misc.gradeProcFlag = P1;
								myCh->misc.tmpState = myCh->op.state;
								myCh->misc.tmpCode = myCh->op.code;
								myCh->op.code = C_FAULT_GRADE;
								myCh->op.phase = P100;
								if(myCh->ChAttribute.chNo_master == P0)
								{
									myData->bData[bd].cData[ch-1].misc
									.gradeProcFlag = P1;
									myData->bData[bd].cData[ch-1].misc.tmpState
										= myCh->op.state;
									myData->bData[bd].cData[ch-1].misc.tmpCode
										= myCh->op.code;
									myData->bData[bd].cData[ch-1].op.code
										= myCh->op.code;
									myData->bData[bd].cData[ch-1].op.phase
										= myCh->op.phase;
								}
								return code;
							default: break;
						}
					}
				}
				//end add
			}
		}
	}
	return code;
}

unsigned char cGrading_Check(int bd, int ch, int No, int index, unsigned char code)
{
	int stepNo;
	unsigned char item;
	long val=0, lower, upper;

	myCh = &(myData->bData[bd].cData[ch]);
	stepNo = myCh->op.stepNo-1;

	if(No >= MAX_GRADE_ITEM) return code;
	if(myPs->testCond[bd][ch].step[stepNo]
			.grade[No].gradeStep[index].gradeCode == 0) return code;

	item = myPs->testCond[bd][ch].step[stepNo]
			.grade[No].gradeStep[index].item;

	switch(item){
		case GRADE_V:
			val = myCh->op.Vsens;
			break;
		case GRADE_CAPACITY:
			val = myCh->op.ampareHour;
			if(myCh->ChAttribute.chNo_master == P0) {
				val += myData->bData[bd].cData[ch-1].op.ampareHour;
			}
			break;
		case GRADE_Z:
			val = myCh->op.z;
			if(myPs->config.hwSpec == L_5V_200A_1CH_JIG) 
				val = myCh->misc.saveZ;
			break;
		case GRADE_CURRENT:
			val = myCh->op.Isens;
			if(myCh->ChAttribute.chNo_master == P0) {
				val += myData->bData[bd].cData[ch-1].op.Isens;
			}
			break;
		case GRADE_TIME:
			val = myCh->op.runTime;
			break;
		case GRADE_FARAD:
			val = myCh->op.capacitance;
			if(myCh->ChAttribute.chNo_master == P0) {
				val += myData->bData[bd].cData[ch-1].op.capacitance;
			}
			break;
		case GRADE_TEMP:
			val = myCh->op.temp;
			if(myData->AnalogMeter.config.multiNum > 1){
				if(myCh->op.temp < myCh->op.temp1){
					val = myCh->op.temp1;
				}
			}
			if(myCh->ChAttribute.chNo_master == P0) {
				val = myData->bData[bd].cData[ch-1].op.temp;
				if(myData->AnalogMeter.config.multiNum > 1){
					if(myData->bData[bd].cData[ch-1].op.temp
						< myData->bData[bd].cData[ch-1].op.temp1){
						val = myData->bData[bd].cData[ch-1].op.temp1;
					}
				}
			}
			break;
		case GRADE_POWER:
			val = myCh->op.watt;
			if(myCh->ChAttribute.chNo_master == P0) {
				val += myData->bData[bd].cData[ch-1].op.watt;
			}
			break;
		case GRADE_WATTHOUR:
			val = myCh->op.wattHour;
			if(myCh->ChAttribute.chNo_master == P0) {
				val += myData->bData[bd].cData[ch-1].op.wattHour;
			}
			break;
	}

	lower = myPs->testCond[bd][ch].step[stepNo]
		.grade[No].gradeStep[index].lowerValue;
	upper = myPs->testCond[bd][ch].step[stepNo]
		.grade[No].gradeStep[index].upperValue;
	if(myPs->testCond[bd][ch].step[stepNo]
				.grade[No].gradeStep[index].gradeCode == GRADE_AND){
		if(code != GRADE_NONE){
			if(lower <= val && val < upper) {
				code = (int)myPs->testCond[bd][ch].step[stepNo]
						.grade[0].gradeStep[index].gradeCode;
				code = cGrading_Check(bd, ch, No+1, index, code);
			}else{
				myCh->misc.grade_flag = No; //20190513 add
				code = GRADE_NONE;
			}
		}
	}else if(myPs->testCond[bd][ch].step[stepNo]
				.grade[No].gradeStep[index].gradeCode == GRADE_OR){
		if(code == GRADE_NONE){
			if(lower <= val && val < upper) {
				code = (int)myPs->testCond[bd][ch].step[stepNo]
						.grade[0].gradeStep[index].gradeCode;
				code = cGrading_Check(bd, ch, No+1, index, code);
			}
		}
	}else{
//		code = GRADE_NONE;
	}
	return code;
}

/*
int GradeCodeCheck(int bd, int ch, unsigned long stepNo, long val)
{
	unsigned char gradeStepCount;
	int i, code;
	long lower, upper;

	gradeStepCount = myPs->testCond[bd][ch].step[stepNo]
		.grade[0].gradeStepCount;

	code = 0;
	for(i=0; i < gradeStepCount; i++) {
		lower = myPs->testCond[bd][ch].step[stepNo]
			.grade[0].gradeStep[i].lowerValue;
		upper = myPs->testCond[bd][ch].step[stepNo]
			.grade[0].gradeStep[i].upperValue;
		if(lower <= val && upper > val) {
			code = (int)myPs->testCond[bd][ch].step[stepNo]
				.grade[0].gradeStep[i].gradeCode;
			return code;
		}
	}

	return code;
}
*/

int SelectHwSpec(int bd, int ch)
{
	int rtn = 5;

	myCh = &(myData->bData[bd].cData[ch]);
#if CYCLER_TYPE == DIGITAL_CYC
	if(myCh->op.semiPreType == STEP_USER_PATTERN){ //210621
		if(myCh->op.type == STEP_CHARGE 
			|| myCh->op.type == STEP_DISCHARGE){ 
			return 4;
		}
	}
			
	if(myCh->op.semiPreType == myCh->op.type){
		if(myCh->op.type == STEP_CHARGE 
			|| myCh->op.type == STEP_DISCHARGE){ 
			return 2;
		}else{
			return 1; //180611 add
		}
	}else{	
		return 1; //180611 add
	}
#endif
	if(myPs->config.hwSpec == L_5V_6A_R3) return 6;

	switch(myPs->config.rangeI) {
		case 1:
			rtn = 1;
			break;
		case 2:
		case 3:
		case 4:
			if(myPs->config.maxCurrent[0] >= L_500A) {
				rtn = 5;
			} else if(myPs->config.maxCurrent[0] <= L_50A) {
				rtn = 6;
			} else {
				if(myCh->misc.start == 1) {
					rtn = 1;
				} else {
					rtn = 3;
				}
			}
			break;
		default:
			break;
	}

	if(myPs->config.hwSpec >= S_5V_200A){
		if(myCh->op.preType == STEP_REST) {
			myCh->misc.preRangeI = myCh->op.rangeI;
			return 2;
		}
		if(myCh->op.rangeI == myCh->misc.preRangeI) {
			return 7;
		} else {
			myCh->misc.preRangeI = myCh->op.rangeI;
		  	return 2;
		}
	}

	if(myCh->op.preType == STEP_REST) {
		myCh->misc.preRangeI = myCh->op.rangeI;
		return 1;
	} else if(myCh->op.preType == STEP_OCV) {
		myCh->misc.preRangeI = myCh->op.rangeI;
		return 3;
	} else {
		if(myCh->op.rangeI == myCh->misc.preRangeI) return 1;
	}

	myCh->misc.preRangeI = myCh->op.rangeI; //kjgw_180521

	return rtn;
}

void initCh(int bd, int ch)
{
	int i, parallel_ch;
   	unsigned long advStepNo, capStep, powerStep;
	unsigned short SocSoeFlag;

	myCh = &(myData->bData[bd].cData[ch]);
	advStepNo = myCh->misc.advStepNo;
	SocSoeFlag = myData->mData.testCond[bd][ch].step[advStepNo].SocSoeFlag;

	if((ch % 2) == 0) parallel_ch = ch + 1;
	else parallel_ch = ch - 1;

	if(myData->AppControl.config.systemType == CYCLER_CAN){
	}else{
		if(myCh->op.type == STEP_REST) {
			if(myPs->testCond[bd][ch].step[advStepNo].endT != 0) {
				if(myPs->testCond[bd][ch].step[advStepNo].endT >= 6000){
					myCh->signal[C_SIG_RANGE_SWITCH] = P0;
				}else{
					myCh->signal[C_SIG_RANGE_SWITCH] = P1;
				}
			}else{
				myCh->signal[C_SIG_RANGE_SWITCH] = P0;
			}
		}else{
			if(myCh->op.code == C_END_CYCLE_TIME){
				if(myCh->ChAttribute.chNo_master == P0) {
					myCh->signal[C_SIG_OUT_SWITCH] = P0;
					myCh->signal[C_SIG_RANGE_SWITCH] = P1;
					myData->bData[bd].cData[ch-1].signal[C_SIG_OUT_SWITCH] = P1;
					myData->bData[bd].cData[ch-1].signal[C_SIG_RANGE_SWITCH] = P1;
				}else{
					myCh->signal[C_SIG_OUT_SWITCH] = P1;
					myCh->signal[C_SIG_RANGE_SWITCH] = P1;
				}
			}else{
				myCh->signal[C_SIG_RANGE_SWITCH] = P1;
			}
		}
	}
	
	myCh->signal[C_SIG_V_RANGE] = myCh->op.rangeV+1;
	myCh->signal[C_SIG_I_RANGE] = myCh->op.rangeI+1;

	if(myPs->testCond[bd][ch].step[advStepNo].socCapStepNo != 0) {
		//20190214 SocSoeFlag -> 0:SOC / 1:DOD / 2: SOE / 3: DOE
		if(SocSoeFlag < 2) {
			capStep = myPs->testCond[bd][ch].step[advStepNo].socCapStepNo-1;
			//pjy add for toshiba
			if(capStep < 1000){
				if(myPs->config.capacityType == CAPACITY_AMPARE_HOURS) {
					myCh->misc.actualCapacity
					= myPs->testCond[bd][ch].step[capStep].socStepCap;
				} else if(myPs->config.capacityType == CAPACITY_CAPACITANCE) {
					myCh->misc.actualCapacity
					= myPs->testCond[bd][ch].step[capStep].socStepCap;
				}
			}else{
				capStep = capStep - 1000;
				if(myCh->op.type == STEP_CHARGE) {
					myCh->misc.actualCapacity = myCh->misc.charge_integralCap[capStep];
				}
				if(myCh->op.type == STEP_DISCHARGE || myCh->op.type == STEP_Z) {
					myCh->misc.actualCapacity = myCh->misc.discharge_integralCap[capStep];
				}
				if(myCh->op.type == STEP_USER_MAP 
								|| myCh->op.type == STEP_USER_PATTERN) {
					if(myPs->testCond[bd][ch].step[advStepNo].endSoc > 0) {
						myCh->misc.actualCapacity = 
								myCh->misc.charge_integralCap[capStep];
					} else if(myPs->testCond[bd][ch].step[advStepNo].endSoc <0){
						myCh->misc.actualCapacity = 
								myCh->misc.discharge_integralCap[capStep];
					}
				}
			}//end of add
		} else { 
			powerStep = myPs->testCond[bd][ch].step[advStepNo].socCapStepNo-1;
			myCh->misc.actualWattHour
				= myPs->testCond[bd][ch].step[powerStep].socStepPower;
		}
	}
	
	/*
	if(myPs->testCond[bd][ch].step[advStepNo].socCapStepNo != 0) {
		capStep = myPs->testCond[bd][ch].step[advStepNo].socCapStepNo-1;
		if(myPs->config.capacityType == CAPACITY_AMPARE_HOURS) {
			myCh->misc.actualCapacity
				= myPs->testCond[bd][ch].step[capStep].socStepCap;
		} else if(myPs->config.capacityType == CAPACITY_CAPACITANCE) {
			myCh->misc.actualCapacity
				= myPs->testCond[bd][ch].step[capStep].socStepCap;
		}
	*/

	myCh->misc.ocv = myCh->op.Vsens;
	//myCh->signal[C_SIG_CP_DCR_FLAG] = P0;
	myCh->op.grade = 0;
   	myCh->op.runTime = 0;
   	myCh->misc.cvFlag = P0;
	//210204
   	myCh->misc.cvFaultCheckFlag = 0;
   	myCh->misc.saveDt = 0;
//   	myCh->op.checkDelayTime = 0;
	myCh->op.meanVolt = 0;
	myCh->op.meanCurr = 0;
    myCh->op.watt = 0;
    myCh->op.wattHour = 0;
	myCh->op.ampareHour = 0;
  	myCh->op.charge_ampareHour = 0;
  	myCh->op.discharge_ampareHour = 0;
	myCh->op.charge_wattHour = 0;
	myCh->op.discharge_wattHour = 0;
	myCh->op.capacitance = 0;
	//20180206
	myCh->op.capacitance_iec = 0;	
	myCh->op.capacitance_maxwell = 0;	
	myCh->op.z = 0;
	myCh->misc.saveZ = 0;
	myCh->op.Isens = 0;
	myCh->misc.pulseDataCount = 0;
	myCh->misc.delta_flag = P0;
	myCh->misc.d_count = 0;
	myCh->misc.d_count_iec = 0;
	myCh->misc.d_flag = 0;
	myCh->misc.d_flag2 = 0;
	myCh->misc.d_count2 = 0;
   	myCh->misc.saveDt = 0;
	myCh->misc.saveDv = myCh->op.Vsens;
	myCh->misc.saveDi = myCh->op.Isens;
   	myCh->misc.saveDtemp = myCh->op.temp;
	if(myCh->ChAttribute.chNo_master == 0) {
		myCh->misc.saveDi
			= myCh->op.Isens + myData->bData[bd].cData[ch-1].op.Isens;
   		myCh->misc.saveDtemp
			= myData->bData[bd].cData[ch-1].op.temp;
	}
	myCh->misc.meanCount = 0;
	myCh->misc.meanSumVolt = 0;
	myCh->misc.meanSumCurr = 0;
	myCh->misc.sumCapacity = 0;
	myCh->misc.seedCapacity = 0;
	myCh->misc.sumChargeAmpareHour = 0;
	myCh->misc.sumDischargeAmpareHour = 0;
	myCh->misc.seedChargeAmpareHour = 0;
	myCh->misc.seedDischargeAmpareHour = 0;
	myCh->misc.sumChargeWattHour = 0;
	myCh->misc.sumDischargeWattHour = 0;
	myCh->misc.seedChargeWattHour = 0;
	myCh->misc.seedDischargeWattHour = 0;
   	myCh->misc.tmpWatt = 0;
	myCh->misc.sumWattHour = 0;
	myCh->misc.seedWattHour = 0;
	myCh->misc.nextDelay = P0;
	myCh->misc.maxV = 0;
	myCh->misc.minV = 0;
	myCh->misc.Drop_maxV = 0;			//211104 hun
	myCh->misc.Drop_minV = 0;			//211104 hun
	myCh->misc.startV = 0;
	myCh->misc.startT = 0;
	myCh->misc.maxT = 0;
	myCh->misc.minT = 0;
	myCh->misc.maxI = 0;
	myCh->misc.minI = 0;
	myCh->misc.fbCountV_H = 0;
	myCh->misc.fbCountI_H = 0;
	myCh->misc.fbSumI_H = 0;
	myCh->misc.fbSumV_H = 0;
	myCh->misc.fbCountV_L = 0;
	myCh->misc.fbCountI_L = 0;
	myCh->misc.fbSumI_L = 0;
	myCh->misc.fbSumV_L = 0;
	myCh->misc.fbCountV_M = 0;
	myCh->misc.fbCountI_M = 0;
	myCh->misc.fbSumI_M = 0;
	myCh->misc.fbSumV_M = 0;
	myCh->misc.sensCount = 0;
	myCh->misc.sensCountFlag = P0;
	myCh->misc.sensBufCount = 0;
	myCh->misc.sensBufCountFlag = P0;
//#if CYCLER_TYPE == DIGITAL_CYC		//hun_210907
	memset((long *)&myCh->misc.sensSumV[0], 0x00, sizeof(long)*MAX_FILTER_AD_COUNT);
	memset((long *)&myCh->misc.sensSumI[0], 0x00, sizeof(long)*MAX_FILTER_AD_COUNT);
	memset((long *)&myCh->misc.tmpBufIsens[0], 0x00, sizeof(long)*MAX_FILTER_AD_COUNT);
	myCh->misc.cvFlag = P0;
	#ifdef _EXTERNAL_CONTROL
	myCh->misc.chCV = P0;
	#endif						
	//210204
   	myCh->misc.cvFaultCheckFlag = 0;
	myCh->misc.endFlag = 0;	//180903 add
//#endif
	myCh->misc.fbV = 0;
	myCh->misc.fbI = 0;
	myCh->misc.cvTime = 0;
	myCh->misc.c_v1 = 0;
	myCh->misc.c_v2 = 0;
	myCh->misc.c_t1 = 0;
	myCh->misc.c_t2 = 0;
	myCh->misc.userPatternCnt = 0;
	myCh->misc.userPatternRunTime = 0;
	myCh->misc.pid_ui1[0] = 0.0;
	myCh->misc.pid_ui1[1] = 0.0;
	myCh->misc.pid_error1[0] = 0.0;
	myCh->misc.pid_error1[1] = 0.0;
	myCh->misc.patternPhase = P0; 
	myCh->ccv[1] = myCh->ccv[0];
	myCh->ccv[0].index = 0;
	myCh->ccv[0].count = 0;
	myCh->ccv[0].avg_v = 0;
	myCh->ccv[0].avg_i = 0;
	for(i=0; i < 10; i++) {
		myCh->ccv[0].ad_ccv[i] = 0;
		myCh->ccv[0].ad_cci[i] = 0;
	}
	myCh->misc.startSoc = 0;
	myCh->misc.soc = 0;
//141208 oys SDI MES VER4 data
	myCh->op.meanTemp = 0;
	myCh->misc.meanSumTemp = 0;
	myCh->misc.mes_data_flag = 0;
	myCh->misc.ccTime = 0;

	myCh->misc.sumChargeCCCVAh = 0;
	myCh->misc.seedChargeCCCVAh = 0;
	myCh->misc.chargeCCCVAh = 0;
	myCh->misc.sumChargeCCAh = 0;
	myCh->misc.seedChargeCCAh = 0;
	myCh->misc.chargeCCAh = 0;
	myCh->misc.sumChargeCVAh = 0;
	myCh->misc.seedChargeCVAh = 0;
	myCh->misc.chargeCVAh = 0;

	myCh->misc.sumDischargeCCCVAh = 0;
	myCh->misc.seedDischargeCCCVAh = 0;
	myCh->misc.dischargeCCCVAh = 0;
	myCh->misc.sumDischargeCCAh = 0;
	myCh->misc.seedDischargeCCAh = 0;
	myCh->misc.dischargeCCAh = 0;
	myCh->misc.sumDischargeCVAh = 0;
	myCh->misc.seedDischargeCVAh = 0;
	myCh->misc.dischargeCVAh = 0;
	myCh->misc.feedback_start = P0;
	//171227 add
	myCh->misc.nAfterIncludeCnt_iec = 0;

	myCh->misc.efficiency_pause_flag = P0;
	//170728 oys
	myCh->misc.gradeProcFlag = P0;
	//171123 oys
	myCh->misc.chGroupCheckFlag = P0;
	//110402 integral sum init
	myData->bData[bd].cData[ch].misc.seedintegralCapacity
		= myData->bData[bd].cData[ch].op.integral_ampareHour;
	myData->bData[bd].cData[ch].misc.sumintegralCapacity = 0L;
	
	myData->bData[bd].cData[ch].misc.seedintegralWattHour
   		= myData->bData[bd].cData[ch].op.integral_WattHour;
	myData->bData[bd].cData[ch].misc.sumintegralWattHour = 0L;
	//20180206 sch add for capacitance iec & maxwell
	myCh->misc.delta_t_iec[0] = 0;
	myCh->misc.delta_t_iec[1] = 0;
	myCh->misc.delta_v_iec[0] = 0;
	myCh->misc.delta_v_iec[1] = 0;
	myCh->misc.delta_w_iec[0] = 0;
	myCh->misc.delta_w_iec[1] = 0;
	myCh->misc.delta_flag_iec = P0;
	myCh->misc.delta_sumI_iec = 0;
	myCh->misc.delta_cnt_iec = 0;

	myCh->misc.delta_t_maxwell[0] = 0;
	myCh->misc.delta_t_maxwell[1] = 0;
	myCh->misc.delta_v_maxwell[0] = 0;
	myCh->misc.delta_v_maxwell[1] = 0;
	myCh->misc.delta_flag_maxwell = P0;
	myCh->misc.delta_sumI_maxwell = 0;
	myCh->misc.delta_cnt_maxwell = 0;
	
	//20190607 add
	myCh->misc.Pre_change_V = 0; 
	myCh->misc.change_V = 0; 
	myCh->misc.change_V_timer = 0; 
	for(i=0 ; i<MAX_COMP_POINT ; i++){
		myCh->misc.chk_V_time[i] = 0;
		myCh->misc.chk_V_upper[i] = 0;
		myCh->misc.chk_V_lower[i] = 0;
		
		myCh->misc.chk_I_time[i] = 0;
		myCh->misc.chk_I_upper[i] = 0;
		myCh->misc.chk_I_lower[i] = 0;
	}

	//190319 add lyhw
	if(myData->mData.config.parallelMode == P2){
		if(myCh->misc.parallel_cycle_phase == P50){
			myData->bData[bd].cData[parallel_ch].misc.sensCount = 0;
			myData->bData[bd].cData[parallel_ch].misc.sensCountFlag = 0;
			myData->bData[bd].cData[parallel_ch].misc.sensBufCount = 0;
			myData->bData[bd].cData[parallel_ch].misc.sensBufCountFlag = 0;
		}
	}
	//20190513 add
	myCh->misc.grade_flag = 0;
	//20190719 oys add
	myCh->misc.save10msDt = 0;
	//190829 oys
	myCh->misc.pre_v_chk_time = 0;
	myCh->misc.pre_chk_v = 0;
	myCh->misc.pattern_point_runTime = 0;
	//191119 lyhw
	myCh->misc.userPattern_ReadFlag = 0;
	myCh->misc.pattern_change_flag = 0;
	myCh->misc.StepPattern_TotalNum = 0;
	myCh->misc.StepPattern_ReadNum = 0;
	//200317 lyhw
	myCh->misc.reserved_cmd_flag = 0;
	
	//210428 hun
	myCh->misc.restCheckFlag = 0;
	myCh->misc.restFaultCount = 0;
	myCh->misc.restCheckStartFlag = 0;
	myCh->misc.restCheckNum = 0;
//	myCh->misc.restCheck_preTime = 0;
//	myCh->misc.restCheck_startV = myCh->op.Vsens;
	
	//kjc_211028
	#ifdef _ULSAN_SDI_SAFETY
	myCh->misc.humpCheck_T = 0;
	myCh->misc.humpCheck_I = 0;
	myCh->misc.humpComp_T = 0;
	myCh->misc.humpComp_I = 0;
	myCh->misc.humpComp_I = 0;
	#endif
	
	for(i=0; i<20; i++){
		myCh->misc.restCheck_preV[i] = 0;
	}
	
	myCh->misc.CAN_PreCmd = CAN_START;
	if(myData->AppControl.config.systemType == CYCLER_CAN){
		if(myCh->signal[C_SIG_OUT_SWITCH_ON] != P2){
			myCh->signal[C_SIG_OUT_SWITCH_ON] = P0;
		}
		if(myCh->signal[C_SIG_OUT_SWITCH_OFF] != P2){
			myCh->signal[C_SIG_OUT_SWITCH_OFF] = P0;
		}
	}
	//200430 hun w
	#ifdef _SDI_SAFETY_V1	
	myCh->misc.fault_deltaV = 0;	//hun_200430
	#endif
	#ifdef _SDI_SAFETY_V2	
	myCh->misc.Master_recipe_deltaV = 0;	//ljs 210412
	myCh->misc.deltaV_cnt = 0;
	#endif
	#if CAPACITY_CONTROL == 1
	for(i=0; i < MAX_STEP; i++){
		myCh->misc.C_Rate_stepCapacity[i] = 0;
		myCh->misc.c_rate_fault_flag[i] = 0;
	}
	#endif
	#ifdef _TRACKING_MODE
	myCh->op.SOC = 0;
	myCh->op.SOH = 0;
	#endif
	#ifdef _EQUATION_CURRENT
	myCh->misc.equation_calc_err_flag = 0; //211111
	#endif
	myCh->misc.inv_auto_continue_count = 0;
	//hun_211125
	myCh->misc.charge_cc_hump_flag = P0;
	myCh->misc.charge_cv_hump_flag = P0;
	myCh->misc.charge_cc_hump_start_time = 0;
	myCh->misc.charge_cv_hump_start_time = 0;
	myCh->misc.charge_cc_hump_start_voltage = 0;
	myCh->misc.charge_cv_hump_start_current = 0;
			
	myCh->misc.discharge_cc_hump_flag = P0;
	myCh->misc.discharge_cv_hump_flag = P0;
	myCh->misc.discharge_cc_hump_start_time = 0;
	myCh->misc.discharge_cv_hump_start_time = 0;
	myCh->misc.discharge_cc_hump_start_voltage = 0;
	myCh->misc.discharge_cv_hump_start_current = 0;
	//220124 hun
	myCh->misc.acir_voltage = 0;
	myCh->misc.acir = 0;
	//220203_hun
	myCh->misc.groupAvgVsens = 0;
	myCh->misc.group_StartVoltage_flag = 0;
	myCh->misc.DCR_PreV = 0;	//220221 LJS
	myCh->misc.Fault_Check_flag = 0;
	myCh->misc.Std_Time = 0;
	myCh->misc.std_gasVoltage = myCh->misc.gasVoltage;	//220322_hun
}


void cCalculate_Capacitance(int bd, int ch, unsigned long advStepNo)
{
	long val1, val2, Vsens, Isens, time, tmpIsens;
	double tmp, deltaT, deltaV;

	myCh = &(myData->bData[bd].cData[ch]);
	if(myPs->config.capacityType != CAPACITY_CAPACITANCE) {
		return;

	}
	val1 = myPs->testCond[bd][ch].step[advStepNo].capacitance_v1;
	val2 = myPs->testCond[bd][ch].step[advStepNo].capacitance_v2;
	if(val1 <= 0 && val2 <= 0) return;

	Vsens = myCh->misc.tmpVsens;
	Isens = myCh->op.Isens;
	tmpIsens = myCh->misc.tmpIsens;
	if(myCh->ChAttribute.chNo_master == P0)
	{
		Isens += myData->bData[bd].cData[ch-1].op.Isens;
		tmpIsens += myData->bData[bd].cData[ch-1].misc.tmpIsens;
	}
	time = myCh->op.runTime;
	
	if(myCh->op.type == STEP_CHARGE) {
		if(myCh->misc.delta_flag == P0){
			if(Vsens >= val1) {
				//hun_160317
				myCh->misc.c_v1 = Vsens;
				myCh->misc.c_t1 = time;
				myCh->misc.delta_flag = P1;
			}
		}else if(myCh->misc.delta_flag == P1){
			deltaT = (time - myCh->misc.c_t1) * 10;
			deltaV = (double)labs(Vsens - myCh->misc.c_v1);
			if(deltaV <= 0){
				myCh->op.capacitance = 0;
			}else{
				tmp = deltaT * (double)labs(Isens);
				myCh->op.capacitance = (long)(tmp / deltaV);
			}
			if(Vsens >= val2) {
				myCh->misc.c_v2 = Vsens;
				myCh->misc.c_t2 = time;
				deltaT = (myCh->misc.c_t2 - myCh->misc.c_t1) * 10;
				deltaV = (double)labs(myCh->misc.c_v2 - myCh->misc.c_v1);
				if(deltaV <= 0){
					myCh->op.capacitance = 0;
				}else{
					tmp = deltaT * (double)labs(Isens);
					myCh->op.capacitance = (long)(tmp / deltaV);
				}
				myCh->misc.delta_flag = P2;
			}
		}
	} else if(myCh->op.type == STEP_DISCHARGE) {
		if(myCh->misc.delta_flag == P0){
			if(Vsens <= val2) {
				myCh->misc.c_v1 = Vsens;
				myCh->misc.c_t1 = time;
				myCh->misc.delta_flag = P1;
			}
		}else if(myCh->misc.delta_flag == P1) {
			deltaT = (time - myCh->misc.c_t1) * 10;
			deltaV = (double)labs(Vsens - myCh->misc.c_v1);
			if(deltaV <= 0){
				myCh->op.capacitance = 0;
			}else{
				tmp = deltaT * (double)labs(Isens);
				myCh->op.capacitance = (long)(tmp / deltaV);
			}
			if(Vsens <= val1) {
				myCh->misc.c_v2 = Vsens;
				myCh->misc.c_t2 = time;
				deltaT = (myCh->misc.c_t2 - myCh->misc.c_t1) * 10;
				deltaV = (double)labs(myCh->misc.c_v2 - myCh->misc.c_v1);
				if(deltaV <= 0){
					myCh->op.capacitance = 0;
				}else{
					tmp = deltaT * (double)labs(Isens);
					myCh->op.capacitance = (long)(tmp / deltaV);
				}
				myCh->misc.delta_flag = P2;
			}
		}
	}
	//160317 oys add
	if(myCh->ChAttribute.chNo_master == P0)
	{
		myData->bData[bd].cData[ch-1].misc.c_v1
			= myCh->misc.c_v1;
		myData->bData[bd].cData[ch-1].misc.c_v2
			= myCh->misc.c_v2;
		myData->bData[bd].cData[ch-1].misc.c_t1
			= myCh->misc.c_t1;
		myData->bData[bd].cData[ch-1].misc.c_t2
			= myCh->misc.c_t2;
	}
}

//20180206 sch add for capacitance iec & maxwell----------------------------
void cCalculate_Capacitance_IEC(int bd, int ch, unsigned long advStepNo)
{
	int rtn, cnt;
	long val1, val2, Vsens, Isens, time, tmpIsens;
	double avgI, deltaW, deltaV;

	myCh = &(myData->bData[bd].cData[ch]);
	if(myPs->config.capacityType != CAPACITY_CAPACITANCE) {
		return;
	}

	val1 = myCh->misc.ocv * 0.7;
	val2 = myCh->misc.ocv * 0.9;
	
	if(val1 <= 0 && val2 <= 0) return;

	Vsens = myCh->misc.tmpVsens;
	Isens = fabs(myCh->op.Isens);
	tmpIsens = myCh->misc.tmpIsens;
	time = myCh->op.runTime;
	rtn = 0;
	
	if(myCh->ChAttribute.chNo_master == P0)
	{
		Isens += myData->bData[bd].cData[ch-1].op.Isens;
		tmpIsens += myData->bData[bd].cData[ch-1].misc.tmpIsens;
	}
	
	if(myCh->op.type == STEP_CHARGE) {
		return;
	} else if(myCh->op.type == STEP_DISCHARGE) {
		if(myCh->misc.delta_flag_iec == P0){
			if(Vsens <= val2) {
				myCh->misc.delta_t_iec[0] = time;
				myCh->misc.delta_v_iec[0] = Vsens;
				myCh->misc.delta_w_iec[0] = myCh->op.discharge_wattHour;
				myCh->misc.delta_flag_iec = P1;
			}
		}else if(myCh->misc.delta_flag_iec == P1) {
			deltaW = (myCh->op.discharge_wattHour - myCh->misc.delta_w_iec[0]) * 3600;//mW
			deltaW = (double)fabs(deltaW);//mW

			deltaV = (double)((myCh->misc.delta_v_iec[0]/1000.0) 
					* (myCh->misc.delta_v_iec[0]/1000.0) 
					 - (Vsens/1000.0) * (Vsens/1000.0));
			deltaV = (double)fabs(deltaV/1000.0); //mV
			
			if(deltaV <= 0){
				myCh->op.capacitance_iec = 0;
			}else{
				myCh->op.capacitance_iec = (long)labs(2 * deltaW / deltaV);
			}

			if(Vsens <= val1) {
				myCh->misc.delta_t_iec[1] = time;
				myCh->misc.delta_v_iec[1] = Vsens;
				myCh->misc.delta_w_iec[1] = myCh->op.discharge_wattHour;
				myCh->misc.delta_flag_iec = P2;
				rtn = 1;
			}
		}
	}
	//160317 oys add
	if(myCh->ChAttribute.chNo_master == P0)
	{
		myData->bData[bd].cData[ch-1].misc.delta_v_iec[0]
			= myCh->misc.delta_v_iec[0];
		myData->bData[bd].cData[ch-1].misc.delta_v_iec[1]
			= myCh->misc.delta_v_iec[1];
		myData->bData[bd].cData[ch-1].misc.delta_t_iec[0]
			= myCh->misc.delta_t_iec[0];
		myData->bData[bd].cData[ch-1].misc.delta_t_iec[1]
			= myCh->misc.delta_t_iec[1];
	}
	if(myCh->misc.delta_flag_iec == P1
			|| myCh->misc.delta_flag_iec == P2){
		++myCh->misc.delta_cnt_iec;
		myCh->misc.delta_sumI_iec += Isens;
		if(myCh->misc.delta_flag_iec == P2){
			myCh->misc.delta_flag_iec = P3;
		}
	}
	if(rtn == 1){
		cnt = myCh->misc.delta_cnt_iec;
		avgI = (double)fabs(myCh->misc.delta_sumI_iec/cnt);

		deltaW = (myCh->misc.delta_w_iec[1]-myCh->misc.delta_w_iec[0])*3600;//mW
		deltaW = (double)fabs(deltaW * 1000); //W

		deltaV = (double)((myCh->misc.delta_v_iec[0]/1000.0) * (myCh->misc.delta_v_iec[0]/1000.0) 
				- (myCh->misc.delta_v_iec[1]/1000.0) * (myCh->misc.delta_v_iec[1]/1000.0));
		deltaV = (double)fabs(deltaV/1000.0);//mV
		myCh->op.capacitance_iec = (long)labs((2 * deltaW / deltaV));	
	}
}

void cCalculate_Capacitance_Maxwell(int bd, int ch, unsigned long advStepNo)
{
	int rtn, cnt;
	long val1, val2, Vsens, Isens, time, tmpIsens;
	double avgI, deltaT, deltaV;

	myCh = &(myData->bData[bd].cData[ch]);
	
	if(myPs->config.capacityType != CAPACITY_CAPACITANCE) {
		return;
	}

	val1 = myCh->misc.ocv * 0.5;
	val2 = myCh->misc.ocv;
	
	if(val1 <= 0 && val2 <= 0) return;

	Vsens = myCh->misc.tmpVsens;
	Isens = fabs(myCh->op.Isens);
	tmpIsens = myCh->misc.tmpIsens;
	time = myCh->op.runTime;

	rtn = 0;
	
	if(myCh->ChAttribute.chNo_master == P0)
	{
		Isens += myData->bData[bd].cData[ch-1].op.Isens;
		tmpIsens += myData->bData[bd].cData[ch-1].misc.tmpIsens;
	}
	
	if(myCh->op.type == STEP_CHARGE) {
		return;
	} else if(myCh->op.type == STEP_DISCHARGE) {
		if(myCh->misc.delta_flag_maxwell == P0){
			if(Vsens <= val2) {
				myCh->misc.delta_t_maxwell[0] = time;
				myCh->misc.delta_v_maxwell[0] = Vsens;
				myCh->misc.delta_flag_maxwell = P1;
			}
		}else if(myCh->misc.delta_flag_maxwell == P1) {
			deltaT = (double)(time - myCh->misc.delta_t_maxwell[0]);
			deltaT = deltaT * 10;	//mS

			deltaV = (double)fabs(myCh->misc.delta_v_maxwell[0] - Vsens);
			
			if(deltaV <= 0){
				myCh->op.capacitance_maxwell = 0;
			}else{
				myCh->op.capacitance_maxwell 
						= (long)labs(deltaT * (double)Isens/deltaV);
			}

			if(Vsens <= val1) {
				myCh->misc.delta_t_maxwell[1] = time;
				myCh->misc.delta_v_maxwell[1] = Vsens;
				myCh->misc.delta_flag_maxwell = P2;
				rtn = 1;
			}
		}
	}
	//160317 oys add
	if(myCh->ChAttribute.chNo_master == P0)
	{
		myData->bData[bd].cData[ch-1].misc.delta_v_maxwell[0]
			= myCh->misc.delta_v_maxwell[0];
		myData->bData[bd].cData[ch-1].misc.delta_v_maxwell[1]
			= myCh->misc.delta_v_maxwell[1];
		myData->bData[bd].cData[ch-1].misc.delta_t_maxwell[0]
			= myCh->misc.delta_t_maxwell[0];
		myData->bData[bd].cData[ch-1].misc.delta_t_maxwell[1]
			= myCh->misc.delta_t_maxwell[1];
	}
	if(myCh->misc.delta_flag_maxwell == P1
			|| myCh->misc.delta_flag_maxwell == P2){
		++myCh->misc.delta_cnt_maxwell;
		myCh->misc.delta_sumI_maxwell += Isens;
		if(myCh->misc.delta_flag_maxwell == P2){
			myCh->misc.delta_flag_maxwell = P3;
		}
	}
	if(rtn == 1){
		cnt = myCh->misc.delta_cnt_maxwell;
		avgI = (double)fabs(myCh->misc.delta_sumI_maxwell/cnt);

		deltaT = myCh->misc.delta_t_maxwell[1] - myCh->misc.delta_t_maxwell[0];
		deltaT = deltaT * 10;	//mS
		deltaV = (double)fabs(myCh->misc.delta_v_maxwell[1] 
						- myCh->misc.delta_v_maxwell[0]);
		myCh->op.capacitance_maxwell = (long)(deltaT * avgI/deltaV);	
	}
}

//20180206 sch add for capacitance iec & maxwell End-------------------------
void cCalculate_DCR(int bd, int ch, unsigned long advStepNo)
{
	if(myPs->config.capacityType == CAPACITY_AMPARE_HOURS){
		if(myPs->config.hwSpec == L_5V_200A_1CH_JIG){
			cCalculate_DCR_3(bd, ch, advStepNo);
		} else {
			if(VENDER == 3) {
				cCalculate_DCR_2_SK(bd, ch, advStepNo);
			} else {
				if(myData->mData.config.function[F_DCR_TYPE] == 1){
					cCalculate_DCR_4(bd, ch, advStepNo);
				}else{
					if(myData->mData.config.Semi_Autojig_DCR_Calculate == 1){
						cCalculate_DCR_2_Semi_Autojig(bd, ch, advStepNo);	
					}else{
						#ifdef _IMPEDANCE_FUNCTION
						cCalculate_DCR_5(bd, ch, advStepNo);
						#endif
						cCalculate_DCR_2(bd, ch, advStepNo);
					}
				}
			}
		}
	} else {
		if(myPs->config.hwSpec == L_5V_150A_R3_AD2
			|| myPs->config.hwSpec == L_8CH_MAIN_AD2_P){
			if(myCh->op.type == STEP_REST){
				cCalculate_DCR_3_1(bd, ch, advStepNo);
			}else if(myCh->op.type == STEP_CHARGE){
//				cCalculate_DCR_3_1(bd, ch, advStepNo);
			}else if(myCh->op.type == STEP_DISCHARGE){
				cCalculate_DCR_IEC(bd, ch, advStepNo);
			}else{
				cCalculate_DCR_1(bd, ch, advStepNo);
			}
		}else{
			cCalculate_DCR_1(bd, ch, advStepNo);
		}
	}
}

void cCalculate_DCR_1(int bd, int ch, unsigned long advStepNo)
{
	int i, val1, val2;
	double tmp, dTn, dTnN, sumV, avgV, sumT2;
	double tmp2, mul_sumT2N, sumTV, mul_sumTVN;

	myCh = &(myData->bData[bd].cData[ch]);
//	val1 = myPs->testCond[bd][ch].step[advStepNo].z_t2;
//	if(val1 <= 0) return;
	
	if(myCh->misc.d_count == 0) {
		memset((long *)&myCh->misc.d_t, 0x00, sizeof(long)*100);
		memset((long *)&myCh->misc.d_v, 0x00, sizeof(long)*100);
		val1 = myPs->testCond[bd][ch].step[advStepNo].z_t1;
		if(myCh->op.runTime >= val1) {
			i = myCh->misc.d_count++;
			myCh->misc.d_t[i] 
					= myCh->op.runTime;
//					= myCh->op.runTime
//						- (10 - ((bd%4) + 14 + (ch * 2))/10.0);
			myCh->misc.d_v[i] = myCh->misc.tmpVsens;
		}
	} else {
		if(myCh->misc.d_flag == 0) {
			if(myCh->misc.d_count < 100) {
				i = myCh->misc.d_count++;
				myCh->misc.d_t[i] 
					= myCh->op.runTime;
//					= myCh->op.runTime
//						- (10 - ((bd%4) + 14 + (ch * 2))/10.0);
				myCh->misc.d_v[i] = myCh->misc.tmpVsens;
				val2 = myPs->testCond[bd][ch].step[advStepNo].z_t2;
				if(myCh->op.runTime >= val2) {
					myCh->misc.d_flag = 1;
				}
				if(myCh->misc.d_count == 100) {
					myCh->misc.d_flag = 1;
				}
				if(myCh->misc.d_flag == 1) {
					dTn = 0.0; sumV = 0.0; sumT2 = 0.0; sumTV = 0.0;
					for(i=0; i < myCh->misc.d_count; i++) {
						dTn += (double)myCh->misc.d_t[i] / 100.0;
						sumV += (double)myCh->misc.d_v[i] / 1000.0;
						sumT2 += ((double)myCh->misc.d_t[i] / 100.0)
						* ((double)myCh->misc.d_t[i] / 100.0);
						sumTV += ((double)myCh->misc.d_t[i] / 100.0)
						* ((double)myCh->misc.d_v[i] / 1000.0);
					}
					i = myCh->misc.d_count;
					dTnN = dTn / (double)i;
					avgV = sumV / (double)i;
					mul_sumT2N = sumT2 * (double)i;
					mul_sumTVN = sumTV * (double)i;
					tmp = mul_sumT2N - dTn * dTn;
					if(tmp != 0.0) {
						tmp = (mul_sumTVN - dTn * sumV) / tmp;
						tmp = (avgV - tmp * dTnN) * 1000.0;
						myCh->misc.d_voltage = (long)tmp;
					} else {
						myCh->misc.d_voltage = 0;
					}
					val1 = myCh->ccv[1].avg_v;
					val2 = myCh->misc.d_voltage;
					
					tmp = (double)fabsl(val1-val2);

					val1 = myCh->misc.tmpIsens;
					val2 = myCh->ccv[1].avg_i;
					if(myCh->ChAttribute.chNo_master == P0)
					{
						val1 += myData->bData[bd].cData[ch-1].misc.tmpIsens;
						val2 += myData->bData[bd].cData[ch-1].ccv[1].avg_i;
					}

					tmp2 = (double)fabsl(val1-val2);
					if(tmp2 != 0) {
						tmp /= tmp2;
						myCh->op.z = (long)(tmp * 1000000.0);
					} else {
						myCh->op.z = 0;
					}
				}
			}
		}
	}
}

void cCalculate_DCR_IEC(int bd, int ch, unsigned long advStepNo)
{
	int stepNo, i;
	int diff;

	myCh = &(myData->bData[bd].cData[ch]);
	stepNo = myCh->op.stepNo;	
	if(myCh->misc.d_count_iec == 0) {
		i = myCh->misc.d_count_iec++;
		myCh->misc.nAfterIncludeCnt_iec++;
		memset((long *)&myCh->misc.d_t_iec, 0x00, sizeof(long)*MAX_PULSE_DATA_IEC);
		memset((long *)&myCh->misc.d_v_iec, 0x00, sizeof(long)*MAX_PULSE_DATA_IEC);
		memset((long *)&myCh->misc.d_i_iec, 0x00, sizeof(long)*MAX_PULSE_DATA_IEC);
		myCh->misc.d_v_iec[i] = myCh->misc.ocv;
		myCh->misc.nDCRTime1_iec = 0;
		myCh->misc.nDCRTime2_iec = 0;
		myCh->misc.d_flag2 = 0;
	}else{
		if(myCh->misc.d_flag2 == 0) {
			if(myCh->signal[C_SIG_IEC_START] == P1){
				myCh->signal[C_SIG_IEC_START] = P0;
			}
			if(myCh->op.Vsens <= myCh->misc.ocv * 0.9){
				if(myCh->misc.nDCRTime2_iec == 0){
					myCh->misc.nDCRTime2_iec = myCh->op.runTime;
					i = myCh->misc.d_count_iec++;
					myCh->misc.nAfterIncludeCnt_iec++;
					myCh->misc.d_t_iec[i] = myCh->op.runTime;
					myCh->misc.d_v_iec[i] = myCh->misc.tmpVsens;
					myCh->misc.d_i_iec[i] = myCh->misc.tmpIsens;
				}else{
					if(myCh->op.Vsens <= myCh->misc.ocv * 0.7){
						myCh->misc.d_flag2 = 1;
						if(myCh->misc.d_count_iec == MAX_PULSE_DATA_IEC){
							i = 150;
						}else{
							i = myCh->misc.d_count_iec++;
							myCh->misc.nAfterIncludeCnt_iec++;
						}
						myCh->misc.d_t_iec[i] = myCh->op.runTime;
						myCh->misc.d_v_iec[i] = myCh->misc.tmpVsens;
						myCh->misc.d_i_iec[i] = myCh->misc.tmpIsens;
					}else{
						diff = myCh->op.runTime 
							- myData->bData[bd].cData[ch].misc.nDCRTime2_iec;
						// 3S Data recive
						if(diff % 300 == 0){
		//				if(diff % 20 == 0){
							if(myCh->misc.d_count_iec < MAX_PULSE_DATA_IEC){
								i = myCh->misc.d_count_iec++;
								myCh->misc.nAfterIncludeCnt_iec++;
								myCh->misc.d_t_iec[i] = myCh->op.runTime;
								myCh->misc.d_v_iec[i] = myCh->misc.tmpVsens;
								myCh->misc.d_i_iec[i] = myCh->misc.tmpIsens;
							}else if(myCh->misc.d_count_iec 
											== MAX_PULSE_DATA_IEC){
								myCh->misc.d_count_iec = MAX_PULSE_DATA_IEC;
							}
						}
					}
				}

				//20180514 modify for IEC
				if(myCh->misc.d_count_iec == MAX_PULSE_DATA_IEC) {
					myCh->misc.d_flag2 = 1;
				}
			}
		}
	}
}

void cCalculate_DCR_2_SK(int bd, int ch, unsigned long advStepNo)
{
	int i, val1, val2=0;
	double tmp, tmp2;
//	double tmp, dTn, dTnN, sumV, avgV, sumT2;
//	double tmp2, mul_sumT2N, sumTV, mul_sumTVN;

	myCh = &(myData->bData[bd].cData[ch]);
	val1 = myPs->testCond[bd][ch].step[advStepNo].z_t2;
//	if(val1 <= 0) return;
	
	if(myCh->misc.d_count == 0) {
		memset((long *)&myCh->misc.d_t, 0x00, sizeof(long)*100);
		memset((long *)&myCh->misc.d_v, 0x00, sizeof(long)*100);
//		val1 = myPs->testCond[bd][ch].step[advStepNo].z_t1;
//		if(myCh->op.runTime >= val1) {
			i = myCh->misc.d_count++;
			myCh->misc.d_t[0] 
					= myCh->op.runTime;
//					= myCh->op.runTime
//						- (10 - ((bd%4) + 14 + (ch * 2))/10.0);
			myCh->misc.d_v[0] = myCh->misc.tmpVsens;
			myCh->misc.d_flag = 0;
//		}
	} else {
		if(myCh->misc.d_flag == 0) {
/*			if(myCh->misc.d_count < 100) {
				i = myCh->misc.d_count++;
				myCh->misc.d_t[i] 
					= myCh->op.runTime;
					= myCh->op.runTime
						- (10 - ((bd%4) + 14 + (ch * 2))/10.0);
				myCh->misc.d_v[i] = myCh->misc.tmpVsens;
				val2 = myPs->testCond[bd][ch].step[advStepNo].z_t2;
				if(val2 != 0 && myCh->op.runTime >= val2) {
					myCh->misc.d_flag = 1;
				}
			} else {
				val2 = myPs->testCond[bd][ch].step[advStepNo].z_t2;
				if(val2 != 0 && myCh->op.runTime >= val2) {
					myCh->misc.d_flag = 1;
				}
				if(myCh->op.runTime == 1000) {
					myCh->misc.d_flag = 1;
				}
				if(myCh->misc.d_count == 100) {
					myCh->misc.d_flag = 1;
			}
*/
			if(myCh->op.type == STEP_CHARGE || myCh->op.type == STEP_DISCHARGE){
				if(myCh->op.runTime == 1000) {
					myCh->misc.d_flag = 1;
				}
			} else {
				val2 = myPs->testCond[bd][ch].step[advStepNo].z_t2;
				if(val2 != 0 && myCh->op.runTime >= val2) {
					myCh->misc.d_flag = 1;
				}
			}
			if(myCh->misc.d_flag == 1) {
/*				dTn = 0.0; sumV = 0.0; sumT2 = 0.0; sumTV = 0.0;
				for(i=0; i < myCh->misc.d_count; i++) {
					dTn += (double)myCh->misc.d_t[i] / 100.0;
					sumV += (double)myCh->misc.d_v[i] / 1000.0;
					sumT2 += ((double)myCh->misc.d_t[i] / 100.0)
					* ((double)myCh->misc.d_t[i] / 100.0);
					sumTV += ((double)myCh->misc.d_t[i] / 100.0)
					* ((double)myCh->misc.d_v[i] / 1000.0);
				}
				i = myCh->misc.d_count;
				dTnN = dTn / (double)i;
				avgV = sumV / (double)i;
				mul_sumT2N = sumT2 * (double)i;
				mul_sumTVN = sumTV * (double)i;
				tmp = mul_sumT2N - dTn * dTn;
				if(tmp != 0.0) {
					tmp = (mul_sumTVN - dTn * sumV) / tmp;
					tmp = (avgV - tmp * dTnN) * 1000.0;
					myCh->misc.d_voltage = (long)tmp;
				} else {
					myCh->misc.d_voltage = 0;
				}
*/
				val1 = myCh->misc.d_v[0];
				val2 = myCh->op.Vsens;
//				val2 = myCh->misc.tmpVsens;
				
				tmp = (double)fabsl(val1-val2);

				val1 = myCh->op.Isens;
				val2 = 0;				
//				val1 = myCh->misc.tmpIsens;
//				val2 = myCh->ccv[1].avg_i;
				if(myCh->ChAttribute.chNo_master == P0)
				{

					val1 += myData->bData[bd].cData[ch-1].op.Isens;
//					val1 += myData->bData[bd].cData[ch-1].misc.tmpIsens;
//					val2 += myData->bData[bd].cData[ch-1].ccv[1].avg_i;
				}

				tmp2 = (double)fabsl(val1);
				if(tmp2 != 0) {
					tmp /= tmp2;
					myCh->op.z = (long)fabs(tmp * 1000000.0);
				} else {
					myCh->op.z = 0;
				}
			}
		}
	}
}

void cCalculate_DCR_2(int bd, int ch, unsigned long advStepNo)
{
	int i, val1, val2=0;
	double tmp, dTn, dTnN, sumV, avgV, sumT2;
	double tmp2, mul_sumT2N, sumTV, mul_sumTVN;

	myCh = &(myData->bData[bd].cData[ch]);
	val1 = myPs->testCond[bd][ch].step[advStepNo].z_t2;
//	if(val1 <= 0) return;
	
	if(myCh->misc.d_count == 0) {
		memset((long *)&myCh->misc.d_t, 0x00, sizeof(long)*100);
		memset((long *)&myCh->misc.d_v, 0x00, sizeof(long)*100);
//		val1 = myPs->testCond[bd][ch].step[advStepNo].z_t1;
//		if(myCh->op.runTime >= val1) {
			i = myCh->misc.d_count++;
			myCh->misc.d_t[0] 
					= myCh->op.runTime;
//					= myCh->op.runTime
//						- (10 - ((bd%4) + 14 + (ch * 2))/10.0);
			myCh->misc.d_v[0] = myCh->misc.tmpVsens;
			myCh->misc.d_flag = 0;
//		}
	} else {
		if(myCh->misc.d_flag == 0) {
			if(myCh->misc.d_count < 100) {
				i = myCh->misc.d_count++;
				myCh->misc.d_t[i] 
					= myCh->op.runTime;
//					= myCh->op.runTime
//						- (10 - ((bd%4) + 14 + (ch * 2))/10.0);
				myCh->misc.d_v[i] = myCh->misc.tmpVsens;
				val2 = myPs->testCond[bd][ch].step[advStepNo].z_t2;
				if(val2 != 0 && myCh->op.runTime >= val2) {
					myCh->misc.d_flag = 1;
				}
			} else {
				val2 = myPs->testCond[bd][ch].step[advStepNo].z_t2;
				if(val2 != 0 && myCh->op.runTime >= val2) {
					myCh->misc.d_flag = 1;
				}
				if(myCh->op.runTime == 1000) {
					myCh->misc.d_flag = 1;
				}
		//		if(myCh->misc.d_count == 100) {
		//			myCh->misc.d_flag = 1;
			}
			if(myCh->misc.d_flag == 1) {
				dTn = 0.0; sumV = 0.0; sumT2 = 0.0; sumTV = 0.0;
				for(i=0; i < myCh->misc.d_count; i++) {
					dTn += (double)myCh->misc.d_t[i] / 100.0;
					sumV += (double)myCh->misc.d_v[i] / 1000.0;
					sumT2 += ((double)myCh->misc.d_t[i] / 100.0)
					* ((double)myCh->misc.d_t[i] / 100.0);
					sumTV += ((double)myCh->misc.d_t[i] / 100.0)
					* ((double)myCh->misc.d_v[i] / 1000.0);
				}
				i = myCh->misc.d_count;
				dTnN = dTn / (double)i;
				avgV = sumV / (double)i;
				mul_sumT2N = sumT2 * (double)i;
				mul_sumTVN = sumTV * (double)i;
				tmp = mul_sumT2N - dTn * dTn;
				if(tmp != 0.0) {
					tmp = (mul_sumTVN - dTn * sumV) / tmp;
					tmp = (avgV - tmp * dTnN) * 1000.0;
					myCh->misc.d_voltage = (long)tmp;
				} else {
					myCh->misc.d_voltage = 0;
				}
				val1 = myCh->misc.d_v[0];
				val2 = myCh->misc.tmpVsens;
				
				tmp = (double)fabsl(val1-val2);

				val1 = myCh->misc.tmpIsens;
				val2 = 0;
//				val2 = myCh->ccv[1].avg_i;
				if(myCh->ChAttribute.chNo_master == P0)
				{
					val1 += myData->bData[bd].cData[ch-1].misc.tmpIsens;
//					val2 += myData->bData[bd].cData[ch-1].ccv[1].avg_i;
				}

				tmp2 = (double)fabsl(val1);
				if(tmp2 != 0) {
					tmp /= tmp2;
					myCh->op.z = (long)(tmp * 1000000.0);
				} else {
					myCh->op.z = 0;
				}
			}
		}
	}
}

void cCalculate_DCR_2_Semi_Autojig(int bd, int ch, unsigned long advStepNo)	
{
	int val1, val2=0;
	double tmp, tmp2;
	
	myCh = &(myData->bData[bd].cData[ch]);
		
	if(myCh->misc.d_flag == 0) {
		if(myCh->op.runTime >= 0) {
			myCh->misc.d_flag = 1;
		}
	}
		
	if(myCh->misc.d_flag == 1) {
		val1 = myCh->misc.DCR_PreV;
		val2 = myCh->misc.tmpVsens;

		tmp = (double)fabsl(val1-val2);

		val1 = myCh->misc.tmpIsens;
		val2 = 0;
		if(myCh->ChAttribute.chNo_master == P0)
		{
			val1 += myData->bData[bd].cData[ch-1].misc.tmpIsens;
		}
		tmp2 = (double)fabsl(val1);
		if(tmp2 != 0) {
			tmp /= tmp2;
			myCh->op.z = (long)(tmp * 1000000.0);
		} else {
			myCh->op.z = 0;
		}
	}
}


void cCalculate_DCR_3(int bd, int ch, unsigned long advStepNo)
{
	int i, val1, val2=0;
	double tmp,tmp2 ;

	myCh = &(myData->bData[bd].cData[ch]);
	val1 = myPs->testCond[bd][ch].step[advStepNo].z_t2;
//	if(val1 <= 0) return;
	
	if(myCh->misc.d_count == 0) {
		memset((long *)&myCh->misc.d_t, 0x00, sizeof(long)*100);
		memset((long *)&myCh->misc.d_v, 0x00, sizeof(long)*100);
//		val1 = myPs->testCond[bd][ch].step[advStepNo].z_t1;
//		if(myCh->op.runTime >= val1) {
			i = myCh->misc.d_count++;
			myCh->misc.d_t[0] 
					= myCh->op.runTime;
//					= myCh->op.runTime
//						- (10 - ((bd%4) + 14 + (ch * 2))/10.0);
			myCh->misc.d_v[0] = myCh->misc.tmpVsens;
			myCh->misc.d_flag = 0;
//		}
	} else {
		val1 = myCh->misc.d_v[0];
		val2 = myCh->misc.tmpVsens;
			
		tmp = (double)fabsl(val1-val2);

		val1 = myCh->misc.tmpIsens;
		val2 = 0;

		tmp2 = (double)fabsl(val1);
		if(tmp2 != 0) {
			tmp /= tmp2;
			myCh->op.z = (long)(tmp * 1000000.0);
		} else {
			myCh->op.z = 0;
		}
	}
	if(myPs->testCond[bd][ch].step[advStepNo].endT_CV != 0) {
		if(myCh->op.runTime == myPs->testCond[bd][ch].step[advStepNo].endT_CV) {
			myCh->misc.saveZ = myCh->op.z;
		}
	} else {
		myCh->misc.saveZ = myCh->op.z;
	}
}

void cCalculate_DCR_3_1(int bd, int ch, unsigned long advStepNo)
{
	int val1, val2=0;
	double tmp,tmp2 ;

	myCh = &(myData->bData[bd].cData[ch]);
	val1 = myPs->testCond[bd][ch].step[advStepNo].z_t2;
//	if(val1 <= 0) return;
	
	if(myCh->misc.d_count == 0) {
		memset((long *)&myCh->misc.d_t, 0x00, sizeof(long)*100);
		memset((long *)&myCh->misc.d_v, 0x00, sizeof(long)*100);
		myCh->misc.d_count++;
		myCh->misc.d_flag = 0;
	} else {
//		if(myCh->misc.d_flag == 0){
			if(myCh->op.runTime >= 500) { // 5sec
				if(myCh->misc.d_flag == 0){
					myCh->misc.d_flag = 1;
				}
			}
			if(myCh->misc.d_flag == 0){
				val1 = myCh->ccv[1].avg_v;
				val2 = myCh->misc.tmpVsens;
			
				tmp = (double)fabsl(val1-val2);
	
				val1 = myCh->ccv[1].avg_i;
				val2 = myCh->misc.tmpIsens;

				tmp2 = (double)fabsl(val1-val2);
				if(tmp2 != 0) {
					tmp /= tmp2;
					myCh->op.z = (long)(tmp * 1000000.0);
				} else {
					myCh->op.z = 0;
				}
				myCh->misc.saveZ = myCh->op.z;
			}else if(myCh->misc.d_flag == 1){
				myCh->misc.d_flag = 2;
				val1 = myCh->ccv[1].avg_v;
				val2 = myCh->misc.tmpVsens;
			
				tmp = (double)fabsl(val1-val2);
	
				val1 = myCh->ccv[1].avg_i;
				val2 = myCh->misc.tmpIsens;
//				val2 = 0;

				tmp2 = (double)fabsl(val1-val2);
				if(tmp2 != 0) {
					tmp /= tmp2;
					myCh->op.z = (long)(tmp * 1000000.0);
				} else {
					myCh->op.z = 0;
				}
				myCh->misc.saveZ = myCh->op.z;
			}
//		}
	}
}

void cCalculate_DCR_4(int bd, int ch, unsigned long advStepNo)
{	//20200106 add for NV Impedance data
	int i, val1, val2=0;
	double tmp, dTn, dTnN, sumV, avgV, sumT2;
	double tmp2, mul_sumT2N, sumTV, mul_sumTVN;

	myCh = &(myData->bData[bd].cData[ch]);
	if(myCh->misc.cvFlag == 1) return;
	
	val1 = myPs->testCond[bd][ch].step[advStepNo].z_t2;
	
	if(myCh->misc.d_count == 0) {
		memset((long *)&myCh->misc.d_t, 0x00, sizeof(long)*100);
		memset((long *)&myCh->misc.d_v, 0x00, sizeof(long)*100);
		// val1 = myPs->testCond[bd][ch].step[advStepNo].z_t1;
		i = myCh->misc.d_count++;
		myCh->misc.d_t[0] = myCh->op.runTime;
		// = myCh->op.runTime - (10 - ((bd%4) + 14 + (ch * 2))/10.0);
		myCh->misc.d_v[0] = myCh->misc.tmpVsens;
		myCh->misc.d_flag = 0;
	} else {
		if(myCh->op.type == STEP_CHARGE 
			|| myCh->op.type == STEP_DISCHARGE){
			val1 = myCh->misc.d_v[0];
			val2 = myCh->misc.tmpVsens;
			tmp = (double)fabsl(val1-val2);

			if(myCh->misc.meanCount == 0){
				val1 = myCh->misc.tmpIsens;
				if(myCh->ChAttribute.chNo_master == P0){
					val1 += myData->bData[bd].cData[ch-1].misc.tmpIsens;
					//val2 += myData->bData[bd].cData[ch-1].ccv[1].avg_i;
				}
			}else{
				val1 = myCh->op.meanCurr;
				if(myCh->ChAttribute.chNo_master == P0){
					val1 += myData->bData[bd].cData[ch-1].op.meanCurr;
				}
			}
			val2 = 0;

			tmp2 = (double)fabsl(val1);
			if(tmp2 != 0) {
				tmp /= tmp2;
				myCh->op.z = (long)(tmp * 1000000.0);
			} else {
				myCh->op.z = 0;
			}
		}else{
			if(myCh->misc.d_flag == 0) {
				if(myCh->misc.d_count < 100) {
					i = myCh->misc.d_count++;
					myCh->misc.d_t[i] = myCh->op.runTime;
				//	= myCh->op.runTime	- (10 - ((bd%4) + 14 + (ch * 2))/10.0);
					myCh->misc.d_v[i] = myCh->misc.tmpVsens;
					val2 = myPs->testCond[bd][ch].step[advStepNo].z_t2;
					if(val2 != 0 && myCh->op.runTime >= val2) {
						myCh->misc.d_flag = 1;
					}
				} else {
					val2 = myPs->testCond[bd][ch].step[advStepNo].z_t2;
					if(val2 != 0 && myCh->op.runTime >= val2) {
						myCh->misc.d_flag = 1;
					}
					if(myCh->op.runTime == 1000) {
						myCh->misc.d_flag = 1;
					}
			//		if(myCh->misc.d_count == 100) {
			//			myCh->misc.d_flag = 1;
			//		}
				}
				
				if(myCh->misc.d_flag == 1) {
					dTn = 0.0; sumV = 0.0; sumT2 = 0.0; sumTV = 0.0;
					for(i=0; i < myCh->misc.d_count; i++) {
						dTn += (double)myCh->misc.d_t[i] / 100.0;
						sumV += (double)myCh->misc.d_v[i] / 1000.0;
						sumT2 += ((double)myCh->misc.d_t[i] / 100.0)
						* ((double)myCh->misc.d_t[i] / 100.0);
						sumTV += ((double)myCh->misc.d_t[i] / 100.0)
						* ((double)myCh->misc.d_v[i] / 1000.0);
					}
					i = myCh->misc.d_count;
					dTnN = dTn / (double)i;
					avgV = sumV / (double)i;
					mul_sumT2N = sumT2 * (double)i;
					mul_sumTVN = sumTV * (double)i;
					tmp = mul_sumT2N - dTn * dTn;
					if(tmp != 0.0) {
						tmp = (mul_sumTVN - dTn * sumV) / tmp;
						tmp = (avgV - tmp * dTnN) * 1000.0;
						myCh->misc.d_voltage = (long)tmp;
					} else {
						myCh->misc.d_voltage = 0;
					}
					val1 = myCh->misc.d_v[0];
					val2 = myCh->misc.tmpVsens;
					
					tmp = (double)fabsl(val1-val2);
	
					val1 = myCh->misc.tmpIsens;
					val2 = 0;
//					val2 = myCh->ccv[1].avg_i;
					if(myCh->ChAttribute.chNo_master == P0)
					{
						val1 += myData->bData[bd].cData[ch-1].misc.tmpIsens;
//						val2 += myData->bData[bd].cData[ch-1].ccv[1].avg_i;
					}
	
					tmp2 = (double)fabsl(val1);
					if(tmp2 != 0) {
						tmp /= tmp2;
						myCh->op.z = (long)(tmp * 1000000.0);
					} else {
						myCh->op.z = 0;
					}
				}
			}
		}
	}
}

void cCalculate_DCR_5(int bd, int ch, unsigned long advStepNo)
{

	myCh = &(myData->bData[bd].cData[ch]);
	
	if(myCh->misc.d_count2 == 0) {
		myCh->misc.d_v2 = myCh->misc.tmpVsens;
		myCh->op.z_100mS = 0;
		myCh->op.z_1S = 0;
		myCh->op.z_5S = 0;
		myCh->op.z_30S = 0;
		myCh->op.z_60S = 0;
		myCh->misc.d_count2++;
	} else {
		if(myCh->op.runTime == 10) {	//100mS
			Calculate_Impedance(bd, ch, 1);
		}else if(myCh->op.runTime == 100) {	//1S
			Calculate_Impedance(bd, ch, 2);
		}else if(myCh->op.runTime == 500) {	//5S
			Calculate_Impedance(bd, ch, 3);
		}else if(myCh->op.runTime == 1000) {	//10S
		//	Calculate_Impedance(bd, ch, 4);
		}else if(myCh->op.runTime == 3000) {	//30S
			Calculate_Impedance(bd, ch, 5);
		}else if(myCh->op.runTime == 6000) {	//60S
			Calculate_Impedance(bd, ch, 6);
		}
	}
}
void Calculate_Impedance(int bd, int ch, int d_flag)
{
	int val1 = 0, val2=0;
	double tmp = 0, tmp2 = 0;

	val1 = myCh->misc.d_v2;
	val2 = myCh->misc.tmpVsens;
			
	tmp = (double)fabsl(val1-val2);
	val1 = myCh->misc.tmpIsens;
	val2 = 0;
	if(myCh->ChAttribute.chNo_master == P0)
	{
		val1 += myData->bData[bd].cData[ch-1].misc.tmpIsens;
	}
	tmp2 = (double)fabsl(val1);
	if(tmp2 != 0) {
		tmp /= tmp2;
		if(d_flag == 1){
			myCh->op.z_100mS = (long)(tmp * 1000000.0);
		}else if(d_flag == 2){
			myCh->op.z_1S = (long)(tmp * 1000000.0);
		}else if(d_flag == 3){
			myCh->op.z_5S = (long)(tmp * 1000000.0);
		}else if(d_flag == 4){
			myCh->op.z = (long)(tmp * 1000000.0);
		}else if(d_flag == 5){
			myCh->op.z_30S = (long)(tmp * 1000000.0);
		}else if(d_flag == 6){
			myCh->op.z_60S = (long)(tmp * 1000000.0);
		}
	} else {
		if(d_flag == 1){
			myCh->op.z_100mS = 0;
		}else if(d_flag == 2){
			myCh->op.z_1S = 0;
		}else if(d_flag == 3){
			myCh->op.z_5S = 0;
		}else if(d_flag == 4){
			myCh->op.z = 0;
		}else if(d_flag == 5){
			myCh->op.z_30S = 0;
		}else if(d_flag == 6){
			myCh->op.z_60S = 0;
		}
	}
}

void cCali_Ch_Select(int bd, int ch, int val2)
{
	int addr, realCh, shunt_range, range, sel_range, type;
	unsigned char caliVal=0,tmpVal=0;

	range = myData->cali.tmpCond[bd][ch].range;
	type = myData->cali.tmpCond[bd][ch].type;

	if(myData->CaliMeter.config.Shunt_Sel_Calibrator == 0){
		addr = 0x607;
		realCh = (bd * myPs->config.chPerBd) + ch;
		tmpVal = realCh / 8;
		caliVal = tmpVal << 4;
		caliVal |= realCh % 8;
	}else {
		addr = 0x607;
		realCh = (bd * myPs->config.chPerBd) + ch;
		tmpVal = realCh / 8;
		caliVal = tmpVal << 4;
		caliVal |= realCh % 8;
		shunt_range = (int)myData->CaliMeter.caliConfig.Shunt_Range_Select[range];
		if(shunt_range < 0) shunt_range = 0;
		
		sel_range = shunt_range;

		if(shunt_range > 0) shunt_range--;

// 140623 oys w : Shunt Calibration
#if SHUNT_R_RCV >= 1
		if(myData->mData.cali_hallCT == P1) { //180525 add for hallct cali
			myData->CaliMeter.hallCT_ratio
				= myData->cali.tmpCond[bd][ch].point[type][range].shuntValue;
		} else {
			myData->CaliMeter.shunt_mOhm
				= myData->cali.tmpCond[bd][ch].point[type][range].shuntValue;
		}
#else
		myData->CaliMeter.shunt_mOhm 
			= myData->CaliMeter.caliConfig.Shunt[shunt_range];
#endif
		switch(sel_range){
			case 2:
			//	caliVal |= (unsigned)(0x01 << 3);
				caliVal |= 0x08;
				break;
			case 3:
			//	caliVal |= (unsigned)(0x01 << 7);
				caliVal |= 0x80;
				break;
//160808 oys add : calibration box range4 add.
			case 4:
				caliVal |= 0x88;
				break;
			default:
				break;
		}
#if SHUNT_R_RCV == 2
		if(myData->mData.cali_hallCT == P1){
			if(val2 >= 0) { //180525 add for hallct cali
				myData->CaliMeter.hallCT_ratio
				= myData->cali.tmpCond[bd][ch].point[type][range].shuntValue;
			}else if(val2 < 0) {
				myData->CaliMeter.hallCT_ratio
				= myData->cali.tmpCond[bd][ch].point[type][range].shuntValue2;
			}
		}else{
			myData->CaliMeter.shunt_mOhm
				= myData->cali.tmpCond[bd][ch].point[type][range].shuntValue;
		}
		if(myPs->config.hwSpec == L_5V_1A_R3 
			|| myPs->config.hwSpec == L_5V_10A_R3_NEW
			|| myPs->config.hwSpec ==  L_5V_500mA_2uA_R4){
			switch(sel_range){
				case 2:
				//	caliVal |= (unsigned)(0x01 << 3);
					caliVal |= 0x08;
					break;
				case 3:
				//	caliVal |= (unsigned)(0x01 << 7);
					caliVal |= 0x80;
					break;
				//160808 oys add : calibration box range4 add.
				case 4:
					caliVal |= 0x88;
					break;
				default:
					break;
			}
		}else{
			// Select Cali Box - Infomation / O(on), X(off)
			// bits-          7 | 6 | 5 | 4 | 3 | 2 | 1 | 0 |
			// Voltage x610-  X | X | X | X | O | O | O | X |
			// Current x610-  X | X | X | X | X | X | X | O |
			
			addr = 0x610;
			switch(type){
				case 0:   //voltage
					caliVal = 0x0E;
					break;
				case 1:   //curretn
					caliVal = 0x01;
					break;
				default:
					break;
			}
		}
		
#endif
	}
	outb(caliVal, addr);
}		

void cCali_Ch_Select_CAN(int bd, int ch, int val2)
{	//210308 lyhw for CAN JIG IO Cali
#if CYCLER_TYPE == CAN_CYC
	int index;
	int addr, realCh, shunt_range, range, sel_range, type;
	unsigned char caliVal, tmpVal, b_num;
	
	caliVal = tmpVal = 0;

	range = myData->cali.tmpCond[bd][ch].range;
	type = myData->cali.tmpCond[bd][ch].type;

	if(myData->CaliMeter.config.Shunt_Sel_Calibrator == 0){
		addr = 0x607;
		realCh = (bd * myPs->config.chPerBd) + ch;
		tmpVal = realCh / 8;
		caliVal = tmpVal << 4;
		caliVal |= realCh % 8;
	} else {
		realCh = (bd * myPs->config.chPerBd) + ch;
		tmpVal = realCh / 8;
		for(index = 0; index < 3; index++){
			//binary output
			b_num = tmpVal % 2;
			if(b_num == 1){
				myPs->signal[M_SIG_CAN1_4 + index] = P1;
			}else{
				myPs->signal[M_SIG_CAN1_4 + index] = P0;
			}
			tmpVal = tmpVal / 2;
		}
		
		caliVal = (unsigned char)realCh % 8;
		for(index = 0; index < 3; index++){
			//binary output
			b_num = caliVal % 2;
			if(b_num == 1){
				myPs->signal[M_SIG_CAN1_0 + index] = P1;
			}else{
				myPs->signal[M_SIG_CAN1_0 + index] = P0;
			}
			caliVal = caliVal / 2;
		}

		shunt_range 
			= (int)myData->CaliMeter.caliConfig.Shunt_Range_Select[range];

		if(shunt_range < 0) shunt_range = 0;
		
		sel_range = shunt_range;

		if(shunt_range > 0) shunt_range--;

// 140623 oys w : Shunt Calibration
#if SHUNT_R_RCV >= 1
		if(myData->mData.cali_hallCT == P1) { //180525 add for hallct cali
			myData->CaliMeter.hallCT_ratio
				= myData->cali.tmpCond[bd][ch].point[type][range].shuntValue;
		} else {
			myData->CaliMeter.shunt_mOhm
				= myData->cali.tmpCond[bd][ch].point[type][range].shuntValue;
		}
#else
		myData->CaliMeter.shunt_mOhm 
			= myData->CaliMeter.caliConfig.Shunt[shunt_range];
#endif
		switch(sel_range){
			case 2:		//SEL4
				myPs->signal[M_SIG_CAN1_3] = P1;
				break;
			case 3:		//GRP4
				myPs->signal[M_SIG_CAN1_7] = P1;
				break;
			case 4:		//GRP4, SEL4
				myPs->signal[M_SIG_CAN1_3] = P1;
				myPs->signal[M_SIG_CAN1_7] = P1;
				break;
			default:
				break;
		}
#if SHUNT_R_RCV == 2
		if(myData->mData.cali_hallCT == P1){
			if(val2 >= 0) { //180525 add for hallct cali
				myData->CaliMeter.hallCT_ratio
				= myData->cali.tmpCond[bd][ch].point[type][range].shuntValue;
			}else if(val2 < 0) {
				myData->CaliMeter.hallCT_ratio
				= myData->cali.tmpCond[bd][ch].point[type][range].shuntValue2;
			}
		}else{
			myData->CaliMeter.shunt_mOhm
				= myData->cali.tmpCond[bd][ch].point[type][range].shuntValue;
		}

		switch(sel_range){
			case 2:		//SEL4
				myPs->signal[M_SIG_CAN1_3] = P1;
				break;
			case 3:		//GRP4
				myPs->signal[M_SIG_CAN1_7] = P1;
				break;
			case 4:		//GRP4, SEL4
				myPs->signal[M_SIG_CAN1_3] = P1;
				myPs->signal[M_SIG_CAN1_7] = P1;
				break;
			default:
				break;
		}
		
#endif
	}
#endif
}

//180118 add for auto cali Main_rev11
void cCali_Ch_Select_auto_2(int bd, int ch)
{
	int addr, realCh, shunt_range, range, sel_range, type;
	unsigned char caliVal=0,tmpVal=0;
	unsigned char typeVal=0;
	
	range = myData->cali.tmpCond[bd][ch].range;
	type = myData->cali.tmpCond[bd][ch].type;
		
	// type : 0 (voltage), type : 1 (current)
	// range : 0(HIGH), 1(MIDDLE), 2(LOW), 3(LOWLOW)
	// bits-   7   |   6   |   5   |   4   |   3   |   2   |   1   |   0   |
	// x601- D0_B8 | D0_B7 | D0_B6 | D0_B5 | D0_B3 | D0_B3 | D0_B2 | D0_B1 |
	// x602- D0_B16| D0_B15| D0_B14| D0_B13| D0_B12| D0_B11| D0_B10| D0_B9 |
	// 74HCT138 <---- active low
	
	if(myPs->config.hwSpec == L_MAIN_REV11 && ch < 16){
		//1. select voltage or current
		switch(type){
			case 0:					//2. voltage
				addr = 0x601;
				typeVal = 0x01;
				outb(typeVal, addr);
				break;
			case 1:					//3. current
				addr = 0x601;
				shunt_range 
				= (int)myData->CaliMeter.caliConfig.Shunt_Range_Select[range];
				
				if(shunt_range < 0) shunt_range = 0;
				sel_range = shunt_range;

				if(shunt_range > 0) shunt_range--;
	
				#if SHUNT_R_RCV == 1
				myData->CaliMeter.shunt_mOhm
				= myData->cali.tmpCond[bd][ch].point[type][range].shuntValue;
				#else
				myData->CaliMeter.shunt_mOhm 
				= myData->CaliMeter.caliConfig.Shunt[shunt_range];
				#endif
				//3.1 select current Range
				switch(sel_range){
					case 2:			//LOW
						typeVal = 0x02;
						typeVal |= 0x20;
						break;
					default:		//HIGH
						typeVal = 0x10;
						typeVal |= 0x20;		
						break;
				}	
				//3.2 H/W Switch Select out
				outb(typeVal, addr);
				break;
			default:
				break;
		}
		//4. select cali for Ch
		if(ch < 8){ 
			addr = 0x602;
			caliVal = ch ^ 0x3f;
			caliVal |= 0x40;		//IC Enable
		}else{
			addr = 0x602;
			realCh = ch % 8;
			caliVal = (realCh << 3) ^ 0x3f;
			caliVal |= 0x80;		//IC Enable
		}
	}else{
		addr = 0x607;
		realCh = (bd * myPs->config.chPerBd) + ch;
		tmpVal = realCh / 8;
		caliVal = tmpVal << 4;
		caliVal |= realCh % 8;
	}
	//3. output Value
	outb(caliVal, addr);
}

void cCali(int bd, int ch)
{
	int rtn, type, range, point, runTime;
#if CYCLER_TYPE == CAN_CYC
	int i = 0;
#endif

	sens_ch_ad_count_increment(bd,ch);
	
	type = myData->cali.tmpCond[bd][ch].type;
	range = myData->cali.tmpCond[bd][ch].range;
	point = (int)myCh->signal[C_SIG_CALI_POINT];

    switch(myCh->signal[C_SIG_CALI_PHASE]) {
		case P0: //voltage cali
			myPs->signal[M_SIG_CALI_RELAY] = P0;
			myData->CaliMeter.caliType = CALI_V;
			rtn = cCalibrationV(bd, ch, point); //da_v, ad_v;
			if(rtn > 0) {
				myCh->op.phase = P0;
				if(point != (int)myData->cali.tmpCond[bd][ch]
					.point[type][range].setPointNum-1) {
   	 				myCh->signal[C_SIG_CALI_POINT]++;
				} else {
					myCh->signal[C_SIG_CALI_POINT] = P0;
   	 				myCh->signal[C_SIG_CALI_PHASE] = P9;
//					myCh->signal[C_SIG_I_RANGE] = RANGE1;
					//hun_160303_d
					if(myData->mData.cali_meas_type == MEAS)
					{
						myCh->signal[C_SIG_CALI_PHASE] = P31;
						myCh->misc.semiSwitchState = SEMI_PRE;
						cSemiSwitch_Cali(bd, ch, STEP_IDLE);
					}
				}
			}
			break;
		case P9:
			cCalculate_CaliData(bd, ch);
			myCh->signal[C_SIG_CALI_PHASE] = P10;
			myCh->signal[C_SIG_I_RANGE] = RANGE1;
			break;
		case P10: //voltage cali check
			myPs->signal[M_SIG_CALI_RELAY] = P0;
			myData->CaliMeter.caliType = CALI_V;
			rtn = cCalibrationCheckV(bd, ch, point);
			if(rtn > 0) {
				myCh->op.phase = P0;
				if(point != (int)myData->cali.tmpCond[bd][ch]
					.point[type][range].checkPointNum-1) {
					myCh->signal[C_SIG_CALI_POINT]++;
				} else {
					if(myData->cali.tmpCond[bd][ch].mode == CALI_MODE_NORMAL) {
						send_msg(MODULE_TO_DATASAVE,
							MSG_MODULE_DATASAVE_CALI_NORMAL_RESULT_SAVE,
							bd, ch);
					} else if(myData->cali.tmpCond[bd][ch].mode
						== CALI_MODE_CHECK) {
						send_msg(MODULE_TO_DATASAVE,
							MSG_MODULE_DATASAVE_CALI_CHECK_RESULT_SAVE, bd, ch);
					}
					myCh->signal[C_SIG_CALI_PHASE] = P11;
					myCh->signal[C_SIG_I_RANGE] = RANGE1;
				}
			}
			break;
		case P11: //wait check data save to file
			if(myCh->signal[C_SIG_CALI_NORMAL_RESULT_SAVED] == P1) {
				myCh->signal[C_SIG_CALI_NORMAL_RESULT_SAVED] = P0;
				myCh->signal[C_SIG_CALI_PHASE] = P12;
			}
			if(myCh->signal[C_SIG_CALI_CHECK_RESULT_SAVED] == P1) {
				myCh->signal[C_SIG_CALI_CHECK_RESULT_SAVED] = P0;
				myCh->signal[C_SIG_CALI_PHASE] = P12;
			}
			break;
		case P12:
			myCh->op.phase = P0;
			myCh->op.state = C_STANDBY;
			myCh->signal[C_SIG_OUT_SWITCH] = P0;
			if(myPs->config.hwSpec > DC_DIGITAL_SPEC){	//180611 add for digital
				myCh->signal[C_SIG_OUT_SWITCH_OFF] = P1;
			}	
		
			#if CYCLER_TYPE == CAN_CYC
			if(myData->AppControl.config.systemType == CYCLER_CAN){
				for(i = 0; i < 8; i++){
					myPs->signal[M_SIG_CAN1_0 + i] = P0;
				}	
			}else{
				myCh->signal[C_SIG_RANGE_SWITCH] = P0;
			}
			#endif
			if(myPs->config.hwSpec >= S_5V_200A) { //switching
				cV_Range_Select(bd, ch, 0);
				cI_Range_Select(bd, ch, 0);
			}
			break;
		case P20: //current cali
			myPs->signal[M_SIG_CALI_RELAY] = P1;
			myData->CaliMeter.caliType = CALI_I;
			rtn = cCalibrationI(bd, ch, point); //da_i, ad_i;
			if(rtn > 0) {
				myCh->op.phase = P0;
				if(point != (int)myData->cali.tmpCond[bd][ch]
					.point[type][range].setPointNum-1) {
					myCh->signal[C_SIG_CALI_POINT]++;
				} else {
					myCh->signal[C_SIG_CALI_POINT] = P0;
					myCh->op.runTime = 0;
    				myCh->signal[C_SIG_CALI_PHASE] = P21;
					myCh->misc.semiSwitchState = SEMI_PRE;
					cSemiSwitch_Cali(bd, ch, STEP_IDLE);
					if(myData->mData.cali_meas_type == MEAS)
					{
						myCh->signal[C_SIG_CALI_PHASE] = P31;
					}
				}
			}
			break;
		case P21:
	    	myCh->op.runTime += myPs->misc.rt_scan_time;
			runTime = 100;
			if(myCh->op.runTime >= runTime){
				myCh->op.runTime =0;
				myPs->signal[M_SIG_CALI_DISCHARGE_RELAY] = P0;
				myPs->signal[M_SIG_CALI_CHARGE_RELAY] = P0;
				myCh->signal[C_SIG_CALI_PHASE] = P29;
			}
			break;
		case P29:
			cCalculate_CaliData(bd, ch);
			myCh->signal[C_SIG_CALI_PHASE] = P30;
			break;
		case P30: //current cali check
			myPs->signal[M_SIG_CALI_RELAY] = P1;
			myData->CaliMeter.caliType = CALI_I;
			rtn = cCalibrationCheckI(bd, ch, point);
			if(rtn > 0) {
				myCh->op.phase = P0;
				if(point != (int)myData->cali.tmpCond[bd][ch]
					.point[type][range].checkPointNum-1) {
					myCh->signal[C_SIG_CALI_POINT]++;
				} else {
					if(myData->cali.tmpCond[bd][ch].mode == CALI_MODE_NORMAL) {
						send_msg(MODULE_TO_DATASAVE,
							MSG_MODULE_DATASAVE_CALI_NORMAL_RESULT_SAVE,
							bd, ch);
					} else if(myData->cali.tmpCond[bd][ch].mode
						== CALI_MODE_CHECK) {
						send_msg(MODULE_TO_DATASAVE,
							MSG_MODULE_DATASAVE_CALI_CHECK_RESULT_SAVE, bd, ch);
					}
					myCh->signal[C_SIG_CALI_PHASE] = P31;
					myCh->misc.semiSwitchState = SEMI_PRE;
					cSemiSwitch_Cali(bd, ch, STEP_IDLE);
				}
			}
			break;
		case P31: //wait check data save to file
			//210323 lyhw
			if(myData->AppControl.config.systemType == CYCLER_CAN){
				myCh->signal[C_SIG_OUT_SWITCH] = P0;
			}

			if(myData->mData.cali_meas_type == MEAS){
				myCh->op.runTime = 0;
				myCh->signal[C_SIG_CALI_PHASE] = P32;
			}
			if(myCh->signal[C_SIG_CALI_NORMAL_RESULT_SAVED] == P1) {
				myCh->signal[C_SIG_CALI_NORMAL_RESULT_SAVED] = P0;
				myCh->signal[C_SIG_CALI_PHASE] = P32;
			}
			if(myCh->signal[C_SIG_CALI_CHECK_RESULT_SAVED] == P1) {
				myCh->signal[C_SIG_CALI_CHECK_RESULT_SAVED] = P0;
				myCh->op.runTime = 0;
				myCh->signal[C_SIG_CALI_PHASE] = P32;
			}
			break;
		case P32:
	    	myCh->op.runTime += myPs->misc.rt_scan_time;
			runTime = 100;
			if(myCh->op.runTime >= runTime){
				myCh->op.runTime =0;
				myPs->signal[M_SIG_CALI_RELAY] = P0;
				myPs->signal[M_SIG_CALI_DISCHARGE_RELAY] = P0;
				myPs->signal[M_SIG_CALI_CHARGE_RELAY] = P0;
				myCh->signal[C_SIG_CALI_PHASE] = P33;
			}
			break;
		case P33:
			myPs->signal[M_SIG_CALI_RELAY] = P0;
			myCh->op.phase = P0;
			myCh->op.state = C_STANDBY;
			myCh->signal[C_SIG_OUT_SWITCH] = P0;
			if(myPs->config.hwSpec > DC_DIGITAL_SPEC){	//180611 add for digital
				myCh->signal[C_SIG_OUT_SWITCH_OFF] = P1;
			}
			#if CYCLER_TYPE == CAN_CYC	
			if(myData->AppControl.config.systemType == CYCLER_CAN){
				for(i = 0; i < 8; i++){
					myPs->signal[M_SIG_CAN1_0 + i] = P0;
				}
			}else{
				myCh->signal[C_SIG_RANGE_SWITCH] = P0;
			}
			#endif
			if(myPs->config.hwSpec >= S_5V_200A) { //switching
				cV_Range_Select(bd, ch, 0);
				cI_Range_Select(bd, ch, 0);
			}
			break;
		default: break;
	}
}

int cCalibrationV(int bd, int ch, int point)
{
	int rtn, type, rangeV, rangeI, div, val2_rangeI;
	long val1, val2;
	
	rtn = type = val2_rangeI = 0;
	rangeV = myData->cali.tmpCond[bd][ch].range;
	if(myData->mData.config.function[F_I_OFFSET_CALI] == P1){
		rangeI = myCh->signal[C_SIG_I_RANGE]-1;
	}else{
		rangeI = 0;
	}
	div = 15;

	val1 = myData->cali.tmpCond[bd][ch].point[type][rangeV].setPoint[point];
	if(val1 > myPs->config.maxVoltage[rangeV]) {
		val1 = myPs->config.maxVoltage[rangeV];
	} else if(val1 < myPs->config.minVoltage[rangeV]) {
		val1 = myPs->config.minVoltage[rangeV];
	}

	//5V/10mA (Load : 1Kohm 1/4W) 5mA
	//6V/6A (Load : 10ohm 10W) 600mA
	//Linear 5V/200A (Load : 10ohm 10W) 500mA
	//Switching 5V/200A (Load : 4.7ohm/4EA=1.175ohm 40W) 4255mA
	//2V/100A (Load : 4.7ohm/4EA=1.175ohm 40W) 1702mA
	//5V/50A (Load : 4.7ohm/2EA=2.35ohm 20W) 2128mA
	//50V/50A (Load : 200ohm 1EA)
	if(rangeV == 0) {
		if(myData->AppControl.config.systemType == CYCLER_CAN){
			//210312 lyhw from lee change ho
			val2_rangeI = myPs->config.rangeI-1;
			if(val1 > 0){		
				val2 = myPs->config.maxCurrent[val2_rangeI];
			}else{
				val2 = myPs->config.minCurrent[val2_rangeI];
			}
		}else{
			if(val1 > 0){
				val2 = myPs->config.maxCurrent[rangeI];
				//val2 = myPs->config.maxCurrent[val2_rangeI];
			}else{
				val2 = myPs->config.minCurrent[rangeI];
				//val2 = myPs->config.minCurrent[val2_rangeI];
			}
		}
	}else{
		val2 = myPs->config.minCurrent[rangeI];
		if(myPs->config.hwSpec == L_5V_500mA_2uA_R4){	//210611 lyhw
			rangeI = (RANGE4 - 1);
			if(val1 > 0){
				val2 = myPs->config.maxCurrent[rangeI];
			}else{
				val2 = myPs->config.minCurrent[rangeI];
			}
		}
	}
	
    switch(myCh->op.phase) {
		case P0:
			if(myData->AppControl.config.systemType == CYCLER_CAN){
				//210323 lyhw for CAN JIG IO Control
				cCali_Ch_Select_CAN(bd, ch, val2);
				cSemiSwitch_CAN(bd, ch);
				myPs->signal[M_SIG_CALI_RELAY] = P0;
			}else{
				if(myData->CaliMeter.config.Shunt_Sel_Calibrator == 2){
					cCali_Ch_Select_auto_2(bd, ch);
				}else{
					cCali_Ch_Select(bd, ch, val2);
				}
				
				myPs->signal[M_SIG_CALI_RELAY] = P0;
				if(myPs->config.hwSpec < S_5V_200A) { //linear
					myCh->signal[C_SIG_OUT_SWITCH] = P1;
					myCh->misc.cmd_v = val1;
				} else { //switching
					cCalCmdI(bd, ch, 0, 0, rangeI);
					cCalCmdV(bd, ch, 0, 0, rangeV);
					cCalCmdLimitV(bd, ch, val1, P0);
					if(val2 >= 0){
						cC_D_Select(bd, ch, P0);
					}else{
						cC_D_Select(bd, ch, P1);
					}
					cV_Range_Select(bd, ch, rangeV+1);
					cI_Range_Select(bd, ch, rangeI+1);
	
					myCh->signal[C_SIG_V_RANGE] = (unsigned char)(rangeV+1);
					myCh->signal[C_SIG_I_RANGE] = (unsigned char)(rangeI+1);
					
					myCh->misc.cmd_v = val1;
					myCh->misc.cmd_v_div = (short int)div;
					myCh->misc.cmd_v_range = (short int)(rangeV);
					myCh->misc.cmd_i = val2;
					myCh->misc.cmd_i_div = (short int)div;
					myCh->misc.cmd_i_range = (short int)(rangeI);
					myCh->signal[C_SIG_V_CMD_OUTPUT] = P1;
					myCh->signal[C_SIG_I_CMD_OUTPUT] = P1;
					myPs->signal[M_SIG_CALI_DISCHARGE_RELAY] = P0;
					myPs->signal[M_SIG_CALI_CHARGE_RELAY] = P0;
				}
			}
			myCh->op.phase = P1;
			myCh->op.runTime = 0;
			break;
		case P1:
			//210323 lyhw add for CAN
			if(myData->AppControl.config.systemType == CYCLER_CAN){
				myCh->signal[C_SIG_V_RANGE] = (unsigned char)(rangeV+1);
				myCh->signal[C_SIG_I_RANGE] = (unsigned char)(rangeI+1);
				myCh->signal[C_SIG_RANGE_SWITCH] = P1;

				if(myCh->op.runTime == 20){
					myCh->signal[C_SIG_OUT_SWITCH] = P1;
					myCh->misc.cmd_v = val1;
				}

				myCh->op.runTime += myPs->misc.rt_scan_time;
				if(myCh->op.runTime >= 50) {
					myCh->op.runTime = 0;
					myCh->op.phase = P2;
				}
			}else{
				if(myPs->config.hwSpec < S_5V_200A) { //linear
					myCh->signal[C_SIG_V_RANGE] = (unsigned char)(rangeV+1);
					myCh->signal[C_SIG_I_RANGE] = (unsigned char)(rangeI+1);
					myCh->signal[C_SIG_RANGE_SWITCH] = P1;
				} else { //switching
					if(val2 >= 0){
						cCalCmdLimitV(bd, ch, val1, P0);
					}else{
						cCalCmdLimitV(bd, ch, 0, P1);
					}
					cCalCmdI(bd, ch, val2, 0, rangeI);
				}
				myCh->op.runTime += myPs->misc.rt_scan_time;
				if(myCh->op.runTime >= RTTASK_1500MS) {
					myCh->op.runTime = 0;
					myCh->op.phase = P2;
				}
			}
			break;
		case P2:
			if(myPs->config.hwSpec < S_5V_200A) { //linear
			} else { //switching
				cCalCmdV(bd, ch, val1, div, rangeV);
			}
			myCh->op.phase = P3;
			break;
		case P3:
			//210323 lyhw
			if(myData->AppControl.config.systemType == CYCLER_CAN){
				ref_output_CAN(bd, ch, val1, val2, div, rangeV, rangeI, 1);
			}else{
				if(myPs->config.hwSpec < S_5V_200A) { //linear
					if(myData->mData.cali_meas_type == MEAS){
						cCalCmdV(bd, ch, val1, 5, rangeV);
						cCalCmdI(bd, ch, val2, div, rangeI);
					}else{
						cCalCmdV(bd, ch, val1, div, rangeV);
						if(myData->mData.config.function[F_I_OFFSET_CALI] == P1){
							cCalCmdI(bd, ch, val2, 5, rangeI);
						}else{
							cCalCmdI(bd, ch, val2, div, rangeI);
						}
					}
				} else { //switching
					cCalCmdI(bd, ch, val2, div, rangeI);
					myCh->signal[C_SIG_OUT_SWITCH] = P1;
					if(myPs->config.hwSpec > DC_DIGITAL_SPEC){	//180611 add 
						myCh->signal[C_SIG_OUT_SWITCH_ON] = P1;
					}	
				}
			}
			myCh->op.runTime = 0;
			myCh->op.phase = P4;
			break;
		case P4:
			if(myPs->config.FadBdUse == P1){
	    		myCh->op.runTime += myPs->misc.rt_scan_time;
				if(myCh->op.runTime >= RTTASK_1500MS) {
					myCh->op.runTime = 0;
					myCh->op.phase = P5;
					myCh->signal[C_SIG_TRIGGER] = P1;
				}
			}else{
				myCh->op.phase = P5;
			}
			break;
		case P5:
	    	myCh->op.runTime += myPs->misc.rt_scan_time;
			if(myCh->op.runTime >= RTTASK_1500MS * 2) {
				if(myData->AppControl.config.debugType != P0) {
				} else {
					send_msg(MODULE_TO_METER, MSG_MODULE_METER_REQUEST, bd, ch);
					if(myData->AppControl.loadProcess[LOAD_CALIMETER2] == P1){
						send_msg(MODULE_TO_CALIMETER2, MSG_MODULE_METER_REQUEST, bd, ch);
					}
				}
				//140701 nam w : actual measure
				if(myData->mData.cali_meas_type == MEAS){
					myCh->op.runTime = 0;
					myCh->op.phase = P6;
				}else{
					myCh->op.runTime = 0;
					myCh->op.phase = P10;
				}
			}
			break;
//140701 nam w : actual measure
		case P6:
			myCh->op.runTime += myPs->misc.rt_scan_time;
			if(myCh->op.runTime % 100 == 0){
				send_msg(MODULE_TO_METER, MSG_MODULE_METER_REQUEST, bd, ch);
				if(myCh->signal[C_SIG_METER_REPLY] == P1) {
					myCh->signal[C_SIG_METER_REPLY] = P0;

					myData->cali.tmpData[bd][ch]
						.set_ad[type][rangeV][0]
						= (double)myCh->op.Vsens;
					myData->cali.tmpData[bd][ch]
						.set_meter[type][rangeV][0]
						= return_meter_value(bd, ch, type);

					send_msg(MODULE_TO_DATASAVE,
						MSG_MODULE_DATASAVE_CALI_NORMAL_RESULT_SAVE,
						bd, ch);
					myCh->op.phase = P6;
					rtn = 0;
					if(myCh->op.runTime >= myData->mData.cali_meas_time){
					//	myCh->op.state = C_CALI;
					//	myCh->signal[C_SIG_CALI_PHASE] = P31;
					//	myCh->misc.semiSwitchState = SEMI_PRE;
					//	cSemiSwitch_Cali(bd, ch, STEP_IDLE);
						rtn = 1;
						break;
					}
				} else if(myCh->signal[C_SIG_METER_ERROR] == P1) {
					myCh->signal[C_SIG_METER_ERROR] = P0;
					myCh->signal[C_SIG_OUT_SWITCH] = P0;
					if(myPs->config.hwSpec > DC_DIGITAL_SPEC){	//180611 add
						myCh->signal[C_SIG_OUT_SWITCH_OFF] = P1;
					}	
					myCh->signal[C_SIG_V_RANGE] = RANGE0;
					myCh->signal[C_SIG_I_RANGE] = RANGE0;
					myCh->op.state = C_STANDBY;
					myCh->op.phase = P0;
				}
			}
			break;
		case P10: // meter, ad value read
			if(myData->AppControl.config.debugType != P0) {
				myCh->signal[C_SIG_METER_REPLY] = P0;
				myCh->signal[C_SIG_CALIMETER2_REPLY] = P0;
				myData->cali.tmpData[bd][ch].set_ad[type][rangeV][point]
					= myData->cali.orgAD[type];
				myData->cali.tmpData[bd][ch].set_meter[type][rangeV][point]
					= return_meter_value(bd, ch, type);
				myCh->op.phase = P20;
			} else {
				data_gathering_cali(bd, ch, type, rangeV, point);
			}
			break;
		case P11:
			data_gathering_cali_meter2(bd, ch, 1, rangeI, point);
			break;
		case P15:
			data_gathering_cali_meter2(bd, ch, 1, rangeI, point);
			break;
		case P20:
			//210323 lyhw for can
			if(myData->AppControl.config.systemType == CYCLER_CAN){
				myCh->signal[C_SIG_OUT_SWITCH] = P0;
				myCh->op.phase = P21;
			}else{
				if(myPs->config.hwSpec < S_5V_200A) { //linear
					myCh->signal[C_SIG_V_RANGE] = RANGE1;
				} else { 	//switching
					//myCh->signal[C_SIG_OUT_SWITCH] = P0;
					cCalCmdI(bd, ch, 0, 0, rangeI);
					cCalCmdV(bd, ch, 0, 0, rangeV);
					cCalCmdLimitV(bd, ch, val1, P0);
					cC_D_Select(bd, ch, P0);
					cV_Range_Select(bd, ch, rangeV+1);
					cI_Range_Select(bd, ch, rangeI+1);
				}
				myCh->op.phase = P30;
			}
			break;
		case P21:
			//210323 lyhw for can
			myCh->op.phase = P30;
			break;
		case P30:
			rtn = 1;
			break;
		default: break;
	}
	return rtn;
}

int cCalibrationCheckV(int bd, int ch, int point)
{
	int rtn, type, rangeV, rangeI, div, val2_rangeI;
	long val1, val2;

	rtn = 0;
	type = val2_rangeI = 0;
	rangeV = myData->cali.tmpCond[bd][ch].range;

	if(myData->mData.config.function[F_I_OFFSET_CALI] == P1){
		rangeI = myCh->signal[C_SIG_I_RANGE]-1;
	}else{
		rangeI = 0;
	}

	div = 15;

	val1 = myData->cali.tmpCond[bd][ch].point[type][rangeV].checkPoint[point];
	if(val1 > myPs->config.maxVoltage[rangeV]) {
		val1 = myPs->config.maxVoltage[rangeV];
	} else if(val1 < myPs->config.minVoltage[rangeV]) {
		val1 = myPs->config.minVoltage[rangeV];
	}

	//5V/10mA (Load : 1Kohm 1/4W) 5mA
	//6V/6A (Load : 10ohm 10W) 600mA
	//Linear 5V/200A (Load : 10ohm 10W) 500mA
	//Switching 5V/200A (Load : 4.7ohm/4EA=1.175ohm 40W) 4255mA
	//2V/100A (Load : 4.7ohm/4EA=1.175ohm 40W) 1702mA
	//5V/50A (Load : 4.7ohm/2EA=2.35ohm 20W) 2128mA
	//50V/50A (Load : 200ohm 1EA)
	if(rangeV == 0){
		if(myData->AppControl.config.systemType == CYCLER_CAN){ //210321 lyhw
			val2_rangeI = myPs->config.rangeI - 1;
			if(val1 > 0){		
				val2 = myPs->config.maxCurrent[val2_rangeI];
			}else{
				val2 = myPs->config.minCurrent[val2_rangeI];
			}
		}else{
			if(val1 > 0){
				val2 = myPs->config.maxCurrent[rangeI];
			//	val2 = myPs->config.maxCurrent[val2_rangeI];
			}else{
				val2 = myPs->config.minCurrent[rangeI];
			//	val2 = myPs->config.minCurrent[val2_rangeI];
			}
		}
	}else{
		val2 = myPs->config.minCurrent[rangeI];
		if(myPs->config.hwSpec == L_5V_500mA_2uA_R4){	//210611 lyhw
			rangeI = (RANGE4 - 1);
			if(val1 > 0){
				val2 = myPs->config.maxCurrent[rangeI];
			}else{
				val2 = myPs->config.minCurrent[rangeI];
			}
		}
	}

	switch(myCh->op.phase) {
		case P0:
			//210323 lyhw
			if(myData->AppControl.config.systemType == CYCLER_CAN){
				//210308 lyhw for CAN JIG IO Control
				cCali_Ch_Select_CAN(bd, ch, val2);
				cSemiSwitch_CAN(bd, ch);
				myPs->signal[M_SIG_CALI_RELAY] = P0;
			}else{
				if(myData->CaliMeter.config.Shunt_Sel_Calibrator == 2){
					cCali_Ch_Select_auto_2(bd, ch);
				}else{
					cCali_Ch_Select(bd, ch, val2);
				}

				myPs->signal[M_SIG_CALI_RELAY] = P0;
				if(myPs->config.hwSpec < S_5V_200A) { //linear
					myCh->signal[C_SIG_OUT_SWITCH] = P1;
					myCh->misc.cmd_v = val1;
				} else { //switching
					cCalCmdI(bd, ch, 0, 0, rangeI);
					cCalCmdV(bd, ch, 0, 0, rangeV);
					cCalCmdLimitV(bd, ch, val1, P0);
					cV_Range_Select(bd, ch, rangeV+1);
					cI_Range_Select(bd, ch, rangeI+1);
					if(val2 >= 0){
						cC_D_Select(bd, ch, P0);
					}else{
						cC_D_Select(bd, ch, P1);
					}
					myCh->signal[C_SIG_V_RANGE] = (unsigned char)(rangeV+1);
					myCh->signal[C_SIG_I_RANGE] = (unsigned char)(rangeI+1);
					
					myCh->misc.cmd_v = val1;
					myCh->misc.cmd_v_div = (short int)5;
					myCh->misc.cmd_v_range = (short int)(rangeV);
					myCh->misc.cmd_i = val2;
					myCh->misc.cmd_i_div = (short int)15;
					myCh->misc.cmd_i_range = (short int)(rangeI);
					myCh->signal[C_SIG_V_CMD_OUTPUT] = P1;
					myCh->signal[C_SIG_I_CMD_OUTPUT] = P1;
					myPs->signal[M_SIG_CALI_DISCHARGE_RELAY] = P0;
					myPs->signal[M_SIG_CALI_CHARGE_RELAY] = P0;
					//myCh->op.phase = P4;
				}
			}
			myCh->op.phase = P1;
			myCh->op.runTime = 0;
			break;
		case P1:
			//210323 lyhw for can
			if(myData->AppControl.config.systemType == CYCLER_CAN){
				if(myCh->op.runTime == 10){
					myCh->signal[C_SIG_V_RANGE] = (unsigned char)(rangeV+1);
					myCh->signal[C_SIG_I_RANGE] = (unsigned char)(rangeI+1);
					myCh->signal[C_SIG_RANGE_SWITCH] = P1;
				}
				if(myCh->op.runTime == 20){
					myCh->signal[C_SIG_OUT_SWITCH] = P1;
					myCh->misc.cmd_v = val1;
				}

				myCh->op.runTime += myPs->misc.rt_scan_time;
				if(myCh->op.runTime >= 50) {
					myCh->op.runTime = 0;
					myCh->op.phase = P2;
				}
			}else{
				if(myPs->config.hwSpec < S_5V_200A) { //linear
					myCh->signal[C_SIG_V_RANGE] = (unsigned char)(rangeV+1);
					myCh->signal[C_SIG_I_RANGE] = (unsigned char)(rangeI+1);
					myCh->signal[C_SIG_RANGE_SWITCH] = P1;
				} else { //switching
					if(val1 >= 0){
						cCalCmdLimitV(bd, ch, val1, P0);
					}else{
						cCalCmdLimitV(bd, ch, 0, P1);
					}
					cCalCmdI(bd, ch, val2, 0, rangeI);
				}
	    		myCh->op.runTime += myPs->misc.rt_scan_time;
				if(myCh->op.runTime >= RTTASK_1500MS) {
					myCh->op.runTime = 0;
					myCh->op.phase = P2;
				}
			}
			break;
		case P2:
			if(myPs->config.hwSpec < S_5V_200A) { //linear
			} else { //switching
				cCalCmdV(bd, ch, val1, 5, rangeV);
				//myCh->signal[C_SIG_OUT_SWITCH] = P1;
			}
			myCh->op.phase = P3;
			break;
		case P3:
			//210323 lyhw
			if(myData->AppControl.config.systemType == CYCLER_CAN){
				ref_output_CAN(bd, ch, val1, val2, 5, rangeV, rangeI, 1);
			}else{
				if(myPs->config.hwSpec < S_5V_200A) { //linear
					cCalCmdV(bd, ch, val1, 5, rangeV);
					if(myData->mData.config.function[F_I_OFFSET_CALI] == P1){
						cCalCmdI(bd, ch, val2, 5, rangeI);
					}else{
						cCalCmdI(bd, ch, val2, div, rangeI);
					}
				} else { //switching
					cCalCmdI(bd, ch, val2, div, rangeI);
					myCh->signal[C_SIG_OUT_SWITCH] = P1;
					if(myPs->config.hwSpec > DC_DIGITAL_SPEC){	//180611 add
						myCh->signal[C_SIG_OUT_SWITCH_ON] = P1;
					}	
				}
			}
			myCh->op.runTime = 0;
			myCh->op.phase = P4;
			break;
		case P4:
			if(myPs->config.FadBdUse == P1){
	    		myCh->op.runTime += myPs->misc.rt_scan_time;
				if(myCh->op.runTime >= RTTASK_1500MS) {
					myCh->op.runTime = 0;
					myCh->op.phase = P5;
					myCh->signal[C_SIG_TRIGGER] = P1;
				}
			}else{
				myCh->op.phase = P5;
			}
			break;
		case P5:
	    	myCh->op.runTime += myPs->misc.rt_scan_time;
			if(myCh->op.runTime >= RTTASK_1500MS) {
				if(myData->AppControl.config.debugType != P0) {
				} else {
					send_msg(MODULE_TO_METER, MSG_MODULE_METER_REQUEST, bd, ch);
					if(myData->AppControl.loadProcess[LOAD_CALIMETER2] == P1){
						send_msg(MODULE_TO_CALIMETER2, MSG_MODULE_METER_REQUEST, bd, ch);
					}
				}
				myCh->op.phase = P10;
				myCh->op.runTime = 0;
			}
			break;
		case P10: // meter, ad value read
			if(myData->AppControl.config.debugType != P0) {
				myCh->signal[C_SIG_METER_REPLY] = P0;
				myData->cali.tmpData[bd][ch].check_ad[type][rangeV][point]
					= (double)myCh->op.Vsens;
				myData->cali.tmpData[bd][ch].check_meter[type][rangeV][point]
					= return_meter_value(bd, ch, type);
				myCh->op.phase = P20;
			} else {
				data_gathering_check(bd, ch, type, rangeV, point);
			}
			break;
		case P11:
			data_gathering_check_meter2(bd, ch, 1, rangeI, point);
			break;
		case P15:
			data_gathering_check_meter2(bd, ch, 1, rangeI, point);
			break;
		case P20:
			//210323 lyhw for can
			if(myData->AppControl.config.systemType == CYCLER_CAN){
				myCh->signal[C_SIG_OUT_SWITCH] = P0;
				myCh->op.phase = P21;
			}else{
				if(myPs->config.hwSpec < S_5V_200A) { //linear
				} else { //switching
					cCalCmdI(bd, ch, 0, 0, rangeI);
					cCalCmdV(bd, ch, 0, 0, rangeV);
					cCalCmdLimitV(bd, ch, val1, P0);
					cC_D_Select(bd, ch, P0);
					cV_Range_Select(bd, ch, rangeV+1);
					cI_Range_Select(bd, ch, rangeI+1);
				}
				myCh->op.phase = P30;
			}
			break;
		case P21:
			myCh->op.phase = P30;
			break;
		case P30:
			rtn = 1;
			break;
		default: break;
	}
	return rtn;
}

int cCalibrationI(int bd, int ch, int point)
{
	int rtn, type, rangeV, rangeI, div, calRelay;
	long val1, val2;
	rtn = 0;
	type = 1;
	rangeV = 0;
	rangeI = myData->cali.tmpCond[bd][ch].range;
	div = 15;

	val1 = myPs->config.maxVoltage[rangeV];

	val2 = myData->cali.tmpCond[bd][ch].point[type][rangeI].setPoint[point];
	if(val2 > myPs->config.maxCurrent[rangeI]) {
		val2 = myPs->config.maxCurrent[rangeI];
	} else if(val2 < myPs->config.minCurrent[rangeI]) {
		val2 = myPs->config.minCurrent[rangeI];
	}

	if(val2 < 0) val1 *=(-1);
	if(val1 > 0 && val2 > 0){
		calRelay = 1; //charge
	}else if(val1 <= 0 && val2 < 0){
		calRelay = 2; //discharge
	}else{
		calRelay = 0; //open
	}
    switch(myCh->op.phase) {
		case P0:
			//210323 lyhw
			if(myData->AppControl.config.systemType == CYCLER_CAN){
				//210308 lyhw for CAN JIG IO Control
				cCali_Ch_Select_CAN(bd, ch, val2);
				cSemiSwitch_CAN(bd, ch);
				myPs->signal[M_SIG_CALI_RELAY] = P1;
				myCh->misc.cmd_i = val2;
			}else{
				if(myData->CaliMeter.config.Shunt_Sel_Calibrator == 2){
					cCali_Ch_Select_auto_2(bd, ch);
				}else{
					cCali_Ch_Select(bd, ch, val2);
				}

				myPs->signal[M_SIG_CALI_RELAY] = P1;
				if(myPs->config.hwSpec < S_5V_200A) { //linear
					if(val2 >= 0){
						cSemiSwitch_Cali(bd, ch, STEP_CHARGE);
					}else{
						cSemiSwitch_Cali(bd, ch, STEP_DISCHARGE);
					}
					if(calRelay == 1){
						myPs->signal[M_SIG_CALI_DISCHARGE_RELAY] = P0;
					}else if(calRelay == 2){
						myPs->signal[M_SIG_CALI_CHARGE_RELAY] = P0;
					}else{
						myPs->signal[M_SIG_CALI_CHARGE_RELAY] = P0;
						myPs->signal[M_SIG_CALI_DISCHARGE_RELAY] = P0;
					}
					myCh->misc.cmd_i = val2;
				} else { //switching
					if(val2 >= 0) {
						cCalCmdI(bd, ch, 0, div, rangeI);
						cCalCmdV(bd, ch, 0, div, rangeV);
						cCalCmdLimitV(bd, ch, val1, P0);
						cC_D_Select(bd, ch, P0);
						cV_Range_Select(bd, ch, rangeV+1);
						cI_Range_Select(bd, ch, rangeI+1);
					} else {
						cCalCmdI(bd, ch, 0, div, rangeI);
						cCalCmdV(bd, ch, 0, div, rangeV);
						cCalCmdLimitV(bd, ch, val1, P1);
						cC_D_Select(bd, ch, P1);
						cV_Range_Select(bd, ch, rangeV+1);
						cI_Range_Select(bd, ch, rangeI+1);
					}
					myCh->signal[C_SIG_V_RANGE] = (unsigned char)(rangeV+1);
					myCh->signal[C_SIG_I_RANGE] = (unsigned char)(rangeI+1);
					
					myCh->misc.cmd_v = val1;
					myCh->misc.cmd_v_div = (short int)div;
					myCh->misc.cmd_v_range = (short int)(rangeV);
					myCh->misc.cmd_i = val2;
					myCh->misc.cmd_i_div = (short int)div;
					myCh->misc.cmd_i_range = (short int)(rangeI);
					myCh->signal[C_SIG_V_CMD_OUTPUT] = P1;
					myCh->signal[C_SIG_I_CMD_OUTPUT] = P1;
					myPs->signal[M_SIG_CALI_DISCHARGE_RELAY] = P0;
					myPs->signal[M_SIG_CALI_CHARGE_RELAY] = P0;
					//myCh->op.phase = P4;
				}
			}
			myCh->op.runTime = 0;
			myCh->op.phase = P1;
			break;
		case P1:
			//210323 lyhw
			if(myData->AppControl.config.systemType == CYCLER_CAN){
				myCh->signal[C_SIG_V_RANGE] = (unsigned char)(rangeV+1);
				myCh->signal[C_SIG_I_RANGE] = (unsigned char)(rangeI+1);
				myCh->signal[C_SIG_RANGE_SWITCH] = P1;
				myCh->op.preType = STEP_IDLE;
				
				if(myCh->op.runTime == 20){
					myCh->signal[C_SIG_OUT_SWITCH] = P1;
				}
				
				myCh->op.runTime += myPs->misc.rt_scan_time;
				if(myCh->op.runTime >= 50) {
					myCh->op.runTime = 0;
					myCh->op.phase = P2;
				}else{
					if(calRelay == 1){
						myPs->signal[M_SIG_CALI_CHARGE_RELAY] = P1;
					}else if(calRelay == 2){
						myPs->signal[M_SIG_CALI_DISCHARGE_RELAY] = P1;
					}else{
						myPs->signal[M_SIG_CALI_CHARGE_RELAY] = P0;
						myPs->signal[M_SIG_CALI_DISCHARGE_RELAY] = P0;
					}
				}
			}else{
				if(myPs->config.hwSpec < S_5V_200A) { //linear
					myCh->signal[C_SIG_V_RANGE] = (unsigned char)(rangeV+1);
					myCh->signal[C_SIG_I_RANGE] = (unsigned char)(rangeI+1);
					myCh->signal[C_SIG_RANGE_SWITCH] = P1;
					myCh->op.preType = STEP_IDLE;
				} else { //switching
					if(val2 >= 0) {
						cCalCmdLimitV(bd, ch, val1, P0);
					} else {
						cCalCmdLimitV(bd, ch, 0, P1);
					}
					cCalCmdI(bd, ch, val2, 0, rangeI);
				}
				
				if(myCh->op.runTime == 0) { // Once
					myCh->signal[C_SIG_OUT_SWITCH] = P1;
				}
				
				myCh->op.runTime += myPs->misc.rt_scan_time;
				if(myCh->op.runTime >= RTTASK_1500MS) {
					myCh->op.runTime = 0;
					myCh->op.phase = P2;
				}else{
					if(calRelay == 1){
						myPs->signal[M_SIG_CALI_CHARGE_RELAY] = P1;
					}else if(calRelay == 2){
						myPs->signal[M_SIG_CALI_DISCHARGE_RELAY] = P1;
					}else{
						myPs->signal[M_SIG_CALI_CHARGE_RELAY] = P0;
						myPs->signal[M_SIG_CALI_DISCHARGE_RELAY] = P0;
					}
				}
			}
			break;
		case P2:
			if(myPs->config.hwSpec < S_5V_200A) { //linear
			} else { //switching
				if(val2 >= 0) {
					cCalCmdV(bd, ch, val1, div, rangeV);
				} else {
					cCalCmdV(bd, ch, 0, div, rangeV);
				}
				if(myPs->config.hwSpec > DC_DIGITAL_SPEC){	//180611 add
					myCh->signal[C_SIG_OUT_SWITCH] = P1;
					myCh->signal[C_SIG_OUT_SWITCH_ON] = P1;
				}	
			}
			myCh->op.phase = P3;
			break;
		case P3:
			//210323 lyhw
			if(myData->AppControl.config.systemType == CYCLER_CAN){
				//1019 - chang mode 1->2
				ref_output_CAN(bd, ch, val1, val2, div, rangeV, rangeI, 2);
			}else{
				if(myPs->config.hwSpec < S_5V_200A) { //linear
					//140701 nam w : actual measure
					if(myData->mData.cali_meas_type == MEAS){
						if(val2 < 0) {
							cCalCmdV(bd, ch, val1, div, rangeV);
							cCalCmdI(bd, ch, val2, 5, rangeI);
						}else{
							cCalCmdI(bd, ch, val2, 5, rangeI);
							cCalCmdV(bd, ch, val1, div, rangeV);
						}
					} else {
						ref_output(bd, ch, val1, val2, div, rangeV, rangeI, 1);
					}
				} else { //switching
					cCalCmdI(bd, ch, val2, div, rangeI);
				}
			}
			myCh->op.runTime = 0;
			myCh->op.phase = P4;
			break;
		case P4:
			if(myPs->config.FadBdUse == P1){
	    		myCh->op.runTime += myPs->misc.rt_scan_time;
				if(myCh->op.runTime >= RTTASK_1500MS) {
					myCh->op.runTime = 0;
					myCh->op.phase = P5;
					myCh->signal[C_SIG_TRIGGER] = P1;
				}
			}else{
				myCh->op.phase = P5;
			}
			break;
		case P5:
	    	myCh->op.runTime += myPs->misc.rt_scan_time;
			if(myCh->op.runTime >= RTTASK_1500MS) {
				if(myData->AppControl.config.debugType != P0) {
				} else {
					send_msg(MODULE_TO_METER, MSG_MODULE_METER_REQUEST, bd, ch);
				}
				//140701 nam w : actual measure
				if(myData->mData.cali_meas_type == MEAS){
					myCh->op.runTime = 0;
					myCh->op.phase = P6;
				}else{
					myCh->op.runTime = 0;
					myCh->op.phase = P10;
				}
			}
			break;
//140701 nam w : actual measure
		case P6:
			myCh->op.runTime += myPs->misc.rt_scan_time;
			if(myCh->op.runTime % 100 == 0){
				send_msg(MODULE_TO_METER, MSG_MODULE_METER_REQUEST, bd, ch);

				if(myCh->signal[C_SIG_METER_REPLY] == P1) {
					myCh->signal[C_SIG_METER_REPLY] = P0;

					myData->cali.tmpData[bd][ch]
						.set_ad[type][rangeI][0]
						= (double)myCh->op.Isens;
					myData->cali.tmpData[bd][ch]
						.set_meter[type][rangeI][0] 
						=  return_meter_value(bd, ch, type);

					send_msg(MODULE_TO_DATASAVE,
					MSG_MODULE_DATASAVE_CALI_NORMAL_RESULT_SAVE,
					bd, ch);
					myCh->op.phase = P6;
					rtn = 0;
					if(	myCh->op.runTime >= myData->mData.cali_meas_time){
					//	myCh->op.state = C_CALI;
					//	myCh->signal[C_SIG_CALI_PHASE] = P31;
					//	myCh->misc.semiSwitchState = SEMI_PRE;
					//	cSemiSwitch_Cali(bd, ch, STEP_IDLE);
						rtn = 1;
						break;
					}
				} else if(myCh->signal[C_SIG_METER_ERROR] == P1) {
					myCh->signal[C_SIG_METER_ERROR] = P0;
					myCh->signal[C_SIG_OUT_SWITCH] = P0;
					myCh->signal[C_SIG_V_RANGE] = RANGE0;
					myCh->signal[C_SIG_I_RANGE] = RANGE0;
					myCh->op.state = C_STANDBY;
					myCh->op.phase = P0;
				}
			}
			break;
		case P10: // meter, ad value read
			if(myData->AppControl.config.debugType != P0) { //for cali debug
				myCh->signal[C_SIG_METER_REPLY] = P0;
				myCh->signal[C_SIG_CALIMETER2_REPLY] = P0;
				myData->cali.tmpData[bd][ch].set_ad[type][rangeI][point]
					= myData->cali.orgAD[type];
				myData->cali.tmpData[bd][ch].set_meter[type][rangeI][point]
					= return_meter_value(bd, ch, type);
				myCh->op.phase = P20;
			} else {
				data_gathering_cali(bd, ch, type, rangeI, point);
			}
			break;
		case P20:
			//210323 lyhw
			if(myData->AppControl.config.systemType == CYCLER_CAN){
				myCh->signal[C_SIG_OUT_SWITCH] = P0;
				myCh->op.phase = P21;
			}else{
				if(myPs->config.hwSpec < S_5V_200A) { //linear
					if(val2 >= 0){
						cSemiSwitch_Cali(bd, ch, STEP_CHARGE);
					}else{
						cSemiSwitch_Cali(bd, ch, STEP_DISCHARGE);
					}
				} else { //switching
					cCalCmdI(bd, ch, 0, 15, rangeI);
					cCalCmdV(bd, ch, 0, 15, rangeV);
					cCalCmdLimitV(bd, ch, val1, P0);
					cC_D_Select(bd, ch, P0);
					cV_Range_Select(bd, ch, rangeV+1);
					cI_Range_Select(bd, ch, rangeI+1);
				}
				myCh->op.phase = P30;
			}
			break;
		case P21:
			myCh->op.phase = P30;
			break;
		case P30:
			rtn = 1;
			break;
		default: break;
	}
	return rtn;
}

int cCalibrationCheckI(int bd, int ch, int point)
{
	int rtn, type, rangeV, rangeI, div, calRelay;
	long val1, val2;

	rtn = 0;
	type = 1;
	rangeV = 0;
	rangeI = myData->cali.tmpCond[bd][ch].range;
	div = 5;

	val1 = myPs->config.maxVoltage[rangeV];

	val2 = myData->cali.tmpCond[bd][ch].point[type][rangeI].checkPoint[point];
	if(val2 > myPs->config.maxCurrent[rangeI]) {
		val2 = myPs->config.maxCurrent[rangeI];
	} else if(val2 < myPs->config.minCurrent[rangeI]) {
		val2 = myPs->config.minCurrent[rangeI];
	}

	if(val2 < 0) val1 *=(-1);
	if(val1 > 0 && val2 > 0){
		calRelay = 1; //charge
	}else if(val1 < 0 && val2 < 0){
		calRelay = 2; //discharge
	}else{
		calRelay = 0; //open
	}
    switch(myCh->op.phase) {
		case P0:
			//210323 lyhw for CAN JIG IO Control
			if(myData->AppControl.config.systemType == CYCLER_CAN){
				cCali_Ch_Select_CAN(bd, ch, val2);
				cSemiSwitch_CAN(bd, ch);
				myPs->signal[M_SIG_CALI_RELAY] = P1;
				myCh->misc.cmd_i = val2;
			}else{
				if(myData->CaliMeter.config.Shunt_Sel_Calibrator == 2){
					cCali_Ch_Select_auto_2(bd, ch);
				}else{
					cCali_Ch_Select(bd, ch, val2);
				}
			
				myPs->signal[M_SIG_CALI_RELAY] = P1;
				if(myPs->config.hwSpec < S_5V_200A) { //linear
					if(val2 >= 0){
						cSemiSwitch_Cali(bd, ch, STEP_CHARGE);
					}else{
						cSemiSwitch_Cali(bd, ch, STEP_DISCHARGE);
					}
					if(calRelay == 1){
						myPs->signal[M_SIG_CALI_DISCHARGE_RELAY] = P0;
					}else if(calRelay == 2){
						myPs->signal[M_SIG_CALI_CHARGE_RELAY] = P0;
					}else{
						myPs->signal[M_SIG_CALI_DISCHARGE_RELAY] = P0;
						myPs->signal[M_SIG_CALI_CHARGE_RELAY] = P0;
					}
					myCh->misc.cmd_i = val2;
				} else { //switching
					if(val2 >= 0) {
						cCalCmdI(bd, ch, 0, 15, rangeI);
						cCalCmdV(bd, ch, 0, 15, rangeV);
						cCalCmdLimitV(bd, ch, val1, P0);
						cC_D_Select(bd, ch, P0);
						cV_Range_Select(bd, ch, rangeV+1);
						cI_Range_Select(bd, ch, rangeI+1);
					} else {
						cCalCmdI(bd, ch, 0, 15, rangeI);
						cCalCmdV(bd, ch, 0, 15, rangeV);
						cCalCmdLimitV(bd, ch, val1, P1);
						cC_D_Select(bd, ch, P1);
						cV_Range_Select(bd, ch, rangeV+1);
						cI_Range_Select(bd, ch, rangeI+1);
					}
					myCh->signal[C_SIG_V_RANGE] = (unsigned char)(rangeV+1);
					myCh->signal[C_SIG_I_RANGE] = (unsigned char)(rangeI+1);
					
					myCh->misc.cmd_v = val1;
					myCh->misc.cmd_v_div = 15;
					myCh->misc.cmd_v_range = (short int)(rangeV);
					myCh->misc.cmd_i = val2;
					myCh->misc.cmd_i_div = 5;
					myCh->misc.cmd_i_range = (short int)(rangeI);
					myCh->signal[C_SIG_V_CMD_OUTPUT] = P1;
					myCh->signal[C_SIG_I_CMD_OUTPUT] = P1;
					myPs->signal[M_SIG_CALI_DISCHARGE_RELAY] = P0;
					myPs->signal[M_SIG_CALI_CHARGE_RELAY] = P0;
				}
			}
			myCh->op.runTime = 0;
			myCh->op.phase = P1;
			break;
		case P1:
			if(myData->AppControl.config.systemType == CYCLER_CAN){
				myCh->signal[C_SIG_V_RANGE] = (unsigned char)(rangeV+1);
				myCh->signal[C_SIG_I_RANGE] = (unsigned char)(rangeI+1);
				myCh->signal[C_SIG_RANGE_SWITCH] = P1;
				myCh->op.preType = STEP_IDLE;
				
				if(myCh->op.runTime == 20){
					myCh->signal[C_SIG_OUT_SWITCH] = P1;
				}
				
				myCh->op.runTime += myPs->misc.rt_scan_time;
				if(myCh->op.runTime >= 50) {
					myCh->op.runTime = 0;
					myCh->op.phase = P2;
				}
			}else{
				if(myPs->config.hwSpec < S_5V_200A) { //linear
					myCh->signal[C_SIG_V_RANGE] = (unsigned char)(rangeV+1);
					myCh->signal[C_SIG_I_RANGE] = (unsigned char)(rangeI+1);
					myCh->signal[C_SIG_RANGE_SWITCH] = P1;
					myCh->op.preType = STEP_IDLE;
				} else { //switching
					if(val2 >= 0) {
						cCalCmdLimitV(bd, ch, val1, P0);
					} else {
						cCalCmdLimitV(bd, ch, 0, P1);
					}
					cCalCmdI(bd, ch, val2, 0, rangeI);
				}			
				if(myCh->op.runTime == 0) { // Once
					myCh->signal[C_SIG_OUT_SWITCH] = P1;
				}
				myCh->op.runTime += myPs->misc.rt_scan_time;
				if(myCh->op.runTime >= RTTASK_1500MS) {
					myCh->op.runTime = 0;
					myCh->op.phase = P2;
				}else{
					if(calRelay == 1){
						myPs->signal[M_SIG_CALI_CHARGE_RELAY] = P1;
					}else if(calRelay == 2){
						myPs->signal[M_SIG_CALI_DISCHARGE_RELAY] = P1;
					}else{
						myPs->signal[M_SIG_CALI_CHARGE_RELAY] = P0;
						myPs->signal[M_SIG_CALI_DISCHARGE_RELAY] = P0;
					}
				}
			}
			/*
			if(myCh->op.runTime == 0) { // Once
				myCh->signal[C_SIG_OUT_SWITCH] = P1;
			}
	    	myCh->op.runTime += myPs->misc.rt_scan_time;
			*/
			break;
		case P2:
			if(myPs->config.hwSpec < S_5V_200A) { //linear
			} else { //switching
				if(val2 >= 0) {
					cCalCmdV(bd, ch, val1, 15, rangeV);
				} else {
					cCalCmdV(bd, ch, 0, 15, rangeV);
				}
				myCh->signal[C_SIG_OUT_SWITCH] = P1;
				if(myPs->config.hwSpec > DC_DIGITAL_SPEC){	//180611 add
					myCh->signal[C_SIG_OUT_SWITCH_ON] = P1;
				}
			}
			myCh->op.phase = P3;
			break;
		case P3:
			//210323 lyhw
			if(myData->AppControl.config.systemType == CYCLER_CAN){
				//201019 chaner mode 1->2
				ref_output_CAN(bd, ch, val1, val2, div, rangeV, rangeI, 2);
			}else{
				if(myPs->config.hwSpec < S_5V_200A) { //linear
					if(val2 < 0) {
						cCalCmdV(bd, ch, val1, 15, rangeV);
						cCalCmdI(bd, ch, val2, div, rangeI);
					}else{
						cCalCmdI(bd, ch, val2, div, rangeI);
						cCalCmdV(bd, ch, val1, 15, rangeV);
					}
				} else { //switching
					cCalCmdI(bd, ch, val2, div, rangeI);
				}
			}
			myCh->op.runTime = 0;
			myCh->op.phase = P4;
	    	break;
		case P4:
			if(myPs->config.FadBdUse == P1){
	    		myCh->op.runTime += myPs->misc.rt_scan_time;
				if(myCh->op.runTime >= RTTASK_1500MS) {
					myCh->op.runTime = 0;
					myCh->op.phase = P5;
					myCh->signal[C_SIG_TRIGGER] = P1;
				}
			}else{
				myCh->op.phase = P5;
			}
			break;
		case P5:
	    	myCh->op.runTime += myPs->misc.rt_scan_time;
			if(myCh->op.runTime >= RTTASK_1500MS) {
				if(myData->AppControl.config.debugType != P0) {
				} else {
					send_msg(MODULE_TO_METER, MSG_MODULE_METER_REQUEST, bd, ch);
				}
				myCh->op.phase = P10;
				myCh->op.runTime = 0;
			}
			break;
		case P10:
			if(myData->AppControl.config.debugType != P0) {
				myCh->signal[C_SIG_METER_REPLY] = P0;
				myData->cali.tmpData[bd][ch].check_ad[type][rangeI][point]
					= (double)myCh->op.Isens;
				myData->cali.tmpData[bd][ch].check_meter[type][rangeI][point]
					= return_meter_value(bd, ch, type);
				myCh->op.phase = P20;
			} else {
				data_gathering_check(bd, ch, type, rangeI, point);
			}
			break;
		case P20:
			//210323 lyhw
			if(myData->AppControl.config.systemType == CYCLER_CAN){
				myCh->signal[C_SIG_OUT_SWITCH] = P0;
				myCh->op.phase = P21;
			}else{
				if(myPs->config.hwSpec < S_5V_200A) { //linear
					if(val2 >= 0){
						cSemiSwitch_Cali(bd, ch, STEP_CHARGE);
					}else{
						cSemiSwitch_Cali(bd, ch, STEP_DISCHARGE);
					}
				} else { //switching
					cCalCmdI(bd, ch, 0, 15, rangeI);
					cCalCmdV(bd, ch, 0, 15, rangeV);
					cCalCmdLimitV(bd, ch, val1, P0);
					cC_D_Select(bd, ch, P0);
					cV_Range_Select(bd, ch, rangeV+1);
					cI_Range_Select(bd, ch, rangeI+1);
				}
			}
			myCh->op.phase = P30;
			break;
		case P21:
			myCh->op.phase = P30;
			break;
		case P30:
			rtn = 1;
			break;
		default: break;
    }
	return rtn;
}

void cCalculate_CaliData(int bd, int ch)
{
	int type;
	type = myData->cali.tmpCond[bd][ch].type;
	if(myData->AppControl.config.systemType == CYCLER_CAN){
		if(type ==0){
			cCalculate_CaliData_1(bd, ch);
		}else{
		//	cCalculate_CaliData_CAN(bd, ch);
			//0724
			cCalculate_CaliData_1(bd, ch);
		}
		return;
	}
	switch(myPs->config.hwSpec) {
		case S_5V_200A_75A_15A_AD2:
			if(type ==0){
				cCalculate_CaliData_1(bd, ch);
			}else{
				cCalculate_CaliData_2(bd, ch);
			}
			break;
		case DC_5V_150A_PARA:			//180611 add for digital
		case DC_5V_CYCLER_NEW:
			cCalculate_CaliData_3(bd, ch);
			break;
		default:
			cCalculate_CaliData_1(bd, ch);
			break;
	}
}

void cCalculate_CaliData_1(int bd, int ch)
{
	int type, range, point, rangeI;
	long temp;
	double cali_a, cali_b, tmp1, tmp2, tmp3;

	type = myData->cali.tmpCond[bd][ch].type;
	range = myData->cali.tmpCond[bd][ch].range;

	myData->cali.tmpData[bd][ch].caliFlag[type][range] = 1;

	for(point=0; point
		< (myData->cali.tmpCond[bd][ch].point[type][range].setPointNum-1);
		point++) {
		//da
		tmp1 = (double)myData->cali.tmpCond[bd][ch]
			.point[type][range].setPoint[point+1]
			- (double)myData->cali.tmpCond[bd][ch]
			.point[type][range].setPoint[point];
		tmp2 = myData->cali.tmpData[bd][ch].set_meter[type][range][point+1]
			- myData->cali.tmpData[bd][ch].set_meter[type][range][point];

		cali_a = tmp1/tmp2;
		cali_b = (double)myData->cali.tmpCond[bd][ch]
			.point[type][range].setPoint[point]
			- (myData->cali.tmpData[bd][ch].set_meter[type][range][point]
			* cali_a);
		 
		myData->cali.tmpData[bd][ch].DA_A[type][range][point] = cali_a;
		myData->cali.tmpData[bd][ch].DA_B[type][range][point] = cali_b;

		//ad
		tmp1 = myData->cali.tmpData[bd][ch].set_meter[type][range][point+1]
			- myData->cali.tmpData[bd][ch].set_meter[type][range][point];
		tmp2 = myData->cali.tmpData[bd][ch].set_ad[type][range][point+1]
			- myData->cali.tmpData[bd][ch].set_ad[type][range][point];

		cali_a = tmp1/tmp2;
		cali_b = myData->cali.tmpData[bd][ch].set_meter[type][range][point]
			- myData->cali.tmpData[bd][ch].set_ad[type][range][point]
			* cali_a;

		myData->cali.tmpData[bd][ch].AD_A[type][range][point] = cali_a;
		myData->cali.tmpData[bd][ch].AD_B[type][range][point] = cali_b;
	//make fad cali AD Data	
		if(myPs->config.FadBdUse == P1){
			//ad
			tmp1 = myData->cali.tmpData[bd][ch].set_meter[type][range][point+1]
				- myData->cali.tmpData[bd][ch].set_meter[type][range][point];
			tmp2 = myData->cali.tmpData_fad[bd][ch].set_ad[type][range][point+1]
				- myData->cali.tmpData_fad[bd][ch].set_ad[type][range][point];

			cali_a = tmp1/tmp2;
			cali_b = myData->cali.tmpData[bd][ch].set_meter[type][range][point]
				- myData->cali.tmpData_fad[bd][ch].set_ad[type][range][point]
				* cali_a;

			myData->cali.tmpData_fad[bd][ch].AD_A[type][range][point] = cali_a;
			myData->cali.tmpData_fad[bd][ch].AD_B[type][range][point] = cali_b;
		}
		if(myData->mData.config.function[F_I_OFFSET_CALI] == P1){
			if(myData->CaliMeter.caliType == CALI_V){
				for(rangeI = 0; rangeI < myPs->config.rangeI; rangeI++){
			//ad
					tmp1 = myData->cali.tmpData_caliMeter2[bd][ch].set_meter[1][rangeI][point+1]
						- myData->cali.tmpData_caliMeter2[bd][ch].set_ad[1][rangeI][point+1];
					tmp2 = myData->cali.tmpData_caliMeter2[bd][ch].set_meter[1][rangeI][point]
						- myData->cali.tmpData_caliMeter2[bd][ch].set_ad[1][rangeI][point];
					tmp3 = myData->cali.tmpData[bd][ch].set_meter[0][0][point+1]
						   - myData->cali.tmpData[bd][ch].set_meter[0][0][point];
						cali_a = (tmp1-tmp2)/tmp3;
						cali_b = (double)tmp1
								- myData->cali.tmpData[bd][ch].set_meter[0][0][point+1]
								* cali_a;
						myData->cali.tmpData_caliMeter2[bd][ch].AD_A[1][rangeI][point] = cali_a;
						myData->cali.tmpData_caliMeter2[bd][ch].AD_B[1][rangeI][point] = cali_b;
				}
			}

		}
	}

	if(type == 0) {
		point = myData->cali.tmpCond[bd][ch].point[type][range].setPointNum-1;
		temp = myData->cali.tmpData[bd][ch].set_meter[type][range][point];
		if(temp == 0) {
			temp = 1;
		}
		if(myData->cali.tmpCond[bd][ch].point[type][range].setPoint[point]
			>= 0) {
			tmp1 = (myData->cali.tmpData[bd][ch].set_ad[type][range][point]
				- myData->cali.tmpData[bd][ch].set_meter[type][range][point])
				/ temp;
			myData->cali.tmpData[bd][ch].AD_Ratio[type][range][0] = 1.0 - tmp1;
		} else {
			tmp1 = (myData->cali.tmpData[bd][ch].set_ad[type][range][point]
				* (-1)
				- myData->cali.tmpData[bd][ch].set_meter[type][range][point]
				* (-1))
				/ (temp * (-1));
			myData->cali.tmpData[bd][ch].AD_Ratio[type][range][0] = 1.0 - tmp1;
		}

		point = 0;
		temp = myData->cali.tmpData[bd][ch].set_meter[type][range][point];
		if(temp == 0) {
			temp = 1;
		}
		if(myData->cali.tmpCond[bd][ch].point[type][range].setPoint[point]
			>= 0) {
			tmp2 = (myData->cali.tmpData[bd][ch].set_ad[type][range][point]
				- myData->cali.tmpData[bd][ch].set_meter[type][range][point])
				/ temp;
			myData->cali.tmpData[bd][ch].AD_Ratio[type][range][1] = 1.0 - tmp2;
		} else {
			tmp2 = (myData->cali.tmpData[bd][ch].set_ad[type][range][point]
				* (-1)
				- myData->cali.tmpData[bd][ch].set_meter[type][range][point]
				* (-1))
				/ (temp * (-1));
			myData->cali.tmpData[bd][ch].AD_Ratio[type][range][1] = 1.0 - tmp2;
		}
	} else {
		point = myData->cali.tmpCond[bd][ch].point[type][range].setPointNum-1;
		temp = myData->cali.tmpData[bd][ch].set_meter[type][range][point];
		if(temp == 0) {
			temp = 1;
		}
		if(myData->cali.tmpCond[bd][ch].point[type][range].setPoint[point]
			>= 0) {
			tmp1 = (myData->cali.tmpData[bd][ch].set_ad[type][range][point]
				- myData->cali.tmpData[bd][ch].set_meter[type][range][point])
				/ temp;
			myData->cali.tmpData[bd][ch].AD_Ratio[type][range][0] = 1.0 - tmp1;
		} else {
			tmp1 = (myData->cali.tmpData[bd][ch].set_ad[type][range][point]
				* (-1)
				- myData->cali.tmpData[bd][ch].set_meter[type][range][point]
				* (-1))
				/ (temp * (-1));
			myData->cali.tmpData[bd][ch].AD_Ratio[type][range][0] = 1.0 - tmp1;
		}

		point = 0;
		temp = myData->cali.tmpData[bd][ch].set_meter[type][range][point];
		if(temp == 0) {
			temp = 1;
		}
		if(myData->cali.tmpCond[bd][ch].point[type][range].setPoint[point]
			>= 0) {
			tmp2 = (myData->cali.tmpData[bd][ch].set_ad[type][range][point]
				- myData->cali.tmpData[bd][ch].set_meter[type][range][point])
				/ temp;
			myData->cali.tmpData[bd][ch].AD_Ratio[type][range][1] = 1.0 - tmp2;
		} else {
			tmp2 = (myData->cali.tmpData[bd][ch].set_ad[type][range][point]
				* (-1)
				- myData->cali.tmpData[bd][ch].set_meter[type][range][point]
				* (-1))
				/ (temp * (-1));
			myData->cali.tmpData[bd][ch].AD_Ratio[type][range][1] = 1.0 - tmp2;
		}
	}
}

void cCalculate_CaliData_2(int bd, int ch)
{
	int type, range, point, discharge_pointNum, charge_pointNum;
	long temp;
	double cali_a, cali_b, tmp1, tmp2;

	type = myData->cali.tmpCond[bd][ch].type;
	range = myData->cali.tmpCond[bd][ch].range;

	myData->cali.tmpData[bd][ch].caliFlag[type][range] = 1;

	discharge_pointNum = charge_pointNum = 0;
	for(point=0; point
		< myData->cali.tmpCond[bd][ch].point[type][range].setPointNum;
		point++) {
		if(myData->cali.tmpCond[bd][ch].point[type][range].setPoint[point]
			< 0) {
			discharge_pointNum++;
		} else {
			charge_pointNum++;
		}
	}
	myData->cali.tmpCond[bd][ch].point[type][range].discharge_pointNum = discharge_pointNum;
	myData->cali.tmpCond[bd][ch].point[type][range].charge_pointNum = charge_pointNum;

	for(point=0; point < (discharge_pointNum - 1); point++) {
		//da(discharge)
		tmp1 = (double)myData->cali.tmpCond[bd][ch]
			.point[type][range].setPoint[point+1]
			- (double)myData->cali.tmpCond[bd][ch]
			.point[type][range].setPoint[point];
		tmp2 = myData->cali.tmpData[bd][ch].set_meter[type][range][point+1]
			- myData->cali.tmpData[bd][ch].set_meter[type][range][point];

		cali_a = tmp1/tmp2;
		cali_b = (double)myData->cali.tmpCond[bd][ch]
			.point[type][range].setPoint[point]
			- (myData->cali.tmpData[bd][ch].set_meter[type][range][point]
			* cali_a);
		 
		myData->cali.tmpData[bd][ch].DA_A[type][range][point] = cali_a;
		myData->cali.tmpData[bd][ch].DA_B[type][range][point] = cali_b;
	}

	for(point = discharge_pointNum; point
		< (myData->cali.tmpCond[bd][ch].point[type][range].setPointNum-1);
		point++) {
		//da(charge)
		tmp1 = (double)myData->cali.tmpCond[bd][ch]
			.point[type][range].setPoint[point+1]
			- (double)myData->cali.tmpCond[bd][ch]
			.point[type][range].setPoint[point];
		tmp2 = myData->cali.tmpData[bd][ch].set_meter[type][range][point+1]
			- myData->cali.tmpData[bd][ch].set_meter[type][range][point];

		cali_a = tmp1/tmp2;
		cali_b = (double)myData->cali.tmpCond[bd][ch]
			.point[type][range].setPoint[point]
			- (myData->cali.tmpData[bd][ch].set_meter[type][range][point]
			* cali_a);
		 
		myData->cali.tmpData[bd][ch].DA_A[type][range][point-1] = cali_a;
		myData->cali.tmpData[bd][ch].DA_B[type][range][point-1] = cali_b;
	}

	for(point=0; point < (discharge_pointNum - 1); point++) {
		//ad
		tmp1 = myData->cali.tmpData[bd][ch].set_meter[type][range][point+1]
			- myData->cali.tmpData[bd][ch].set_meter[type][range][point];
		tmp2 = myData->cali.tmpData[bd][ch].set_ad[type][range][point+1]
			- myData->cali.tmpData[bd][ch].set_ad[type][range][point];

		cali_a = tmp1/tmp2;
		cali_b = myData->cali.tmpData[bd][ch].set_meter[type][range][point]
			- myData->cali.tmpData[bd][ch].set_ad[type][range][point]
			* cali_a;

		myData->cali.tmpData[bd][ch].AD_A[type][range][point] = cali_a;
		myData->cali.tmpData[bd][ch].AD_B[type][range][point] = cali_b;
	}
	for(point = discharge_pointNum; 
		point < (myData->cali.tmpCond[bd][ch].point[type][range].setPointNum-1);
		point++) {
		//ad
		tmp1 = myData->cali.tmpData[bd][ch].set_meter[type][range][point+1]
			- myData->cali.tmpData[bd][ch].set_meter[type][range][point];
		tmp2 = myData->cali.tmpData[bd][ch].set_ad[type][range][point+1]
			- myData->cali.tmpData[bd][ch].set_ad[type][range][point];

		cali_a = tmp1/tmp2;
		cali_b = myData->cali.tmpData[bd][ch].set_meter[type][range][point]
			- myData->cali.tmpData[bd][ch].set_ad[type][range][point]
			* cali_a;

		myData->cali.tmpData[bd][ch].AD_A[type][range][point-1] = cali_a;
		myData->cali.tmpData[bd][ch].AD_B[type][range][point-1] = cali_b;
	}

	if(type == 0) {
		point = myData->cali.tmpCond[bd][ch].point[type][range].setPointNum-1;
		temp = myData->cali.tmpData[bd][ch].set_meter[type][range][point];
		if(temp == 0) {
			temp = 1;
		}
		if(myData->cali.tmpCond[bd][ch].point[type][range].setPoint[point]
			>= 0) {
			tmp1 = (myData->cali.tmpData[bd][ch].set_ad[type][range][point]
				- myData->cali.tmpData[bd][ch].set_meter[type][range][point])
				/ temp;
			myData->cali.tmpData[bd][ch].AD_Ratio[type][range][0] = 1.0 - tmp1;
		} else {
			tmp1 = (myData->cali.tmpData[bd][ch].set_ad[type][range][point]
				* (-1)
				- myData->cali.tmpData[bd][ch].set_meter[type][range][point]
				* (-1))
				/ (temp * (-1));
			myData->cali.tmpData[bd][ch].AD_Ratio[type][range][0] = 1.0 - tmp1;
		}

		point = 0;
		temp = myData->cali.tmpData[bd][ch].set_meter[type][range][point];
		if(temp == 0) {
			temp = 1;
		}
		if(myData->cali.tmpCond[bd][ch].point[type][range].setPoint[point]
			>= 0) {
			tmp2 = (myData->cali.tmpData[bd][ch].set_ad[type][range][point]
				- myData->cali.tmpData[bd][ch].set_meter[type][range][point])
				/ temp;
			myData->cali.tmpData[bd][ch].AD_Ratio[type][range][1] = 1.0 - tmp2;
		} else {
			tmp2 = (myData->cali.tmpData[bd][ch].set_ad[type][range][point]
				* (-1)
				- myData->cali.tmpData[bd][ch].set_meter[type][range][point]
				* (-1))
				/ (temp * (-1));
			myData->cali.tmpData[bd][ch].AD_Ratio[type][range][1] = 1.0 - tmp2;
		}
	} else {
		point = myData->cali.tmpCond[bd][ch].point[type][range].setPointNum-1;
		temp = myData->cali.tmpData[bd][ch].set_meter[type][range][point];
		if(temp == 0) {
			temp = 1;
		}
		if(myData->cali.tmpCond[bd][ch].point[type][range].setPoint[point]
			>= 0) {
			tmp1 = (myData->cali.tmpData[bd][ch].set_ad[type][range][point]
				- myData->cali.tmpData[bd][ch].set_meter[type][range][point])
				/ temp;
			myData->cali.tmpData[bd][ch].AD_Ratio[type][range][0] = 1.0 - tmp1;
		} else {
			tmp1 = (myData->cali.tmpData[bd][ch].set_ad[type][range][point]
				* (-1)
				- myData->cali.tmpData[bd][ch].set_meter[type][range][point]
				* (-1))
				/ (temp * (-1));
			myData->cali.tmpData[bd][ch].AD_Ratio[type][range][0] = 1.0 - tmp1;
		}

		point = 0;
		temp = myData->cali.tmpData[bd][ch].set_meter[type][range][point];
		if(temp == 0) {
			temp = 1;
		}
		if(myData->cali.tmpCond[bd][ch].point[type][range].setPoint[point]
			>= 0) {
			tmp2 = (myData->cali.tmpData[bd][ch].set_ad[type][range][point]
				- myData->cali.tmpData[bd][ch].set_meter[type][range][point])
				/ temp;
			myData->cali.tmpData[bd][ch].AD_Ratio[type][range][1] = 1.0 - tmp2;
		} else {
			tmp2 = (myData->cali.tmpData[bd][ch].set_ad[type][range][point]
				* (-1)
				- myData->cali.tmpData[bd][ch].set_meter[type][range][point]
				* (-1))
				/ (temp * (-1));
			myData->cali.tmpData[bd][ch].AD_Ratio[type][range][1] = 1.0 - tmp2;
		}
	}
}

void cCalculate_CaliData_3(int bd, int ch)
{	//180611 add for digital
	int type, range, point;
	long temp;
	double cali_a, cali_b, tmp1, tmp2;

	type = myData->cali.tmpCond[bd][ch].type;
	range = myData->cali.tmpCond[bd][ch].range;

	myData->cali.tmpData[bd][ch].caliFlag[type][range] = 1;

	for(point=0; point
		< (myData->cali.tmpCond[bd][ch].point[type][range].setPointNum-1);
		point++) {
		//da
		tmp1 = (double)myData->cali.tmpCond[bd][ch]
			.point[type][range].setPoint[point+1]
			- (double)myData->cali.tmpCond[bd][ch]
			.point[type][range].setPoint[point];
		tmp2 = myData->cali.tmpData[bd][ch].set_meter[type][range][point+1]
			- myData->cali.tmpData[bd][ch].set_meter[type][range][point];

		cali_a = tmp1/tmp2;
		cali_b = (double)myData->cali.tmpCond[bd][ch]
			.point[type][range].setPoint[point]
			- (myData->cali.tmpData[bd][ch].set_meter[type][range][point]
			* cali_a);
		 
		myData->cali.tmpData[bd][ch].DA_A[type][range][point] = cali_a;
		myData->cali.tmpData[bd][ch].DA_B[type][range][point] = cali_b;

		//ad
		cali_a = (1.0 / cali_a);

		cali_b = cali_b * (-1.0); 

		myData->cali.tmpData[bd][ch].AD_A[type][range][point] = cali_a;
		myData->cali.tmpData[bd][ch].AD_B[type][range][point] = cali_b;
	}

	if(type == 0) {
		point = myData->cali.tmpCond[bd][ch].point[type][range].setPointNum-1;
		temp = myData->cali.tmpData[bd][ch].set_meter[type][range][point];
		if(temp == 0) {
			temp = 1;
		}
		if(myData->cali.tmpCond[bd][ch].point[type][range].setPoint[point]
			>= 0) {
			tmp1 = (myData->cali.tmpData[bd][ch].set_ad[type][range][point]
				- myData->cali.tmpData[bd][ch].set_meter[type][range][point])
				/ temp;
			myData->cali.tmpData[bd][ch].AD_Ratio[type][range][0] = 1.0 - tmp1;
		} else {
			tmp1 = (myData->cali.tmpData[bd][ch].set_ad[type][range][point]
				* (-1)
				- myData->cali.tmpData[bd][ch].set_meter[type][range][point]
				* (-1))
				/ (temp * (-1));
			myData->cali.tmpData[bd][ch].AD_Ratio[type][range][0] = 1.0 - tmp1;
		}

		point = 0;
		temp = myData->cali.tmpData[bd][ch].set_meter[type][range][point];
		if(temp == 0) {
			temp = 1;
		}
		if(myData->cali.tmpCond[bd][ch].point[type][range].setPoint[point]
			>= 0) {
			tmp2 = (myData->cali.tmpData[bd][ch].set_ad[type][range][point]
				- myData->cali.tmpData[bd][ch].set_meter[type][range][point])
				/ temp;
			myData->cali.tmpData[bd][ch].AD_Ratio[type][range][1] = 1.0 - tmp2;
		} else {
			tmp2 = (myData->cali.tmpData[bd][ch].set_ad[type][range][point]
				* (-1)
				- myData->cali.tmpData[bd][ch].set_meter[type][range][point]
				* (-1))
				/ (temp * (-1));
			myData->cali.tmpData[bd][ch].AD_Ratio[type][range][1] = 1.0 - tmp2;
		}
	} else {
		point = myData->cali.tmpCond[bd][ch].point[type][range].setPointNum-1;
		temp = myData->cali.tmpData[bd][ch].set_meter[type][range][point];
		if(temp == 0) {
			temp = 1;
		}
		if(myData->cali.tmpCond[bd][ch].point[type][range].setPoint[point]
			>= 0) {
			tmp1 = (myData->cali.tmpData[bd][ch].set_ad[type][range][point]
				- myData->cali.tmpData[bd][ch].set_meter[type][range][point])
				/ temp;
			myData->cali.tmpData[bd][ch].AD_Ratio[type][range][0] = 1.0 - tmp1;
		} else {
			tmp1 = (myData->cali.tmpData[bd][ch].set_ad[type][range][point]
				* (-1)
				- myData->cali.tmpData[bd][ch].set_meter[type][range][point]
				* (-1))
				/ (temp * (-1));
			myData->cali.tmpData[bd][ch].AD_Ratio[type][range][0] = 1.0 - tmp1;
		}

		point = 0;
		temp = myData->cali.tmpData[bd][ch].set_meter[type][range][point];
		if(temp == 0) {
			temp = 1;
		}
		if(myData->cali.tmpCond[bd][ch].point[type][range].setPoint[point]
			>= 0) {
			tmp2 = (myData->cali.tmpData[bd][ch].set_ad[type][range][point]
				- myData->cali.tmpData[bd][ch].set_meter[type][range][point])
				/ temp;
			myData->cali.tmpData[bd][ch].AD_Ratio[type][range][1] = 1.0 - tmp2;
		} else {
			tmp2 = (myData->cali.tmpData[bd][ch].set_ad[type][range][point]
				* (-1)
				- myData->cali.tmpData[bd][ch].set_meter[type][range][point]
				* (-1))
				/ (temp * (-1));
			myData->cali.tmpData[bd][ch].AD_Ratio[type][range][1] = 1.0 - tmp2;
		}
	}
}

void cCalculate_CaliData_CAN(int bd, int ch)
{
	int type, range, point, discharge_pointNum = 0, charge_pointNum = 0;
	long temp;
	double cali_a, cali_b, tmp1, tmp2;

	type = myData->cali.tmpCond[bd][ch].type;
	range = myData->cali.tmpCond[bd][ch].range;

	myData->cali.tmpData[bd][ch].caliFlag[type][range] = 1;

	discharge_pointNum = charge_pointNum = 0;
	for(point=0; point
		< myData->cali.tmpCond[bd][ch].point[type][range].setPointNum;
		point++) {
		if(myData->cali.tmpCond[bd][ch].point[type][range].setPoint[point]
			< 0) {
			discharge_pointNum++;
		} else {
			charge_pointNum++;
		}
	}
	myData->cali.tmpCond[bd][ch].point[type][range].discharge_pointNum
		= discharge_pointNum;
	myData->cali.tmpCond[bd][ch].point[type][range].charge_pointNum
		= charge_pointNum;

	for(point=0; point < discharge_pointNum; point++) {
		//da(discharge)
		tmp1 = (double)myData->cali.tmpCond[bd][ch]
			.point[type][range].setPoint[point+1]
			- (double)myData->cali.tmpCond[bd][ch]
			.point[type][range].setPoint[point];
		tmp2 = myData->cali.tmpData[bd][ch].set_meter[type][range][point+1]
			- myData->cali.tmpData[bd][ch].set_meter[type][range][point];

		cali_a = tmp1/tmp2;
		cali_b = (double)myData->cali.tmpCond[bd][ch]
			.point[type][range].setPoint[point]
			- (myData->cali.tmpData[bd][ch].set_meter[type][range][point]
			* cali_a);
		 
		myData->cali.tmpData[bd][ch].DA_A[type][range][point] = cali_a;
		myData->cali.tmpData[bd][ch].DA_B[type][range][point] = cali_b;
	}

	for(point = discharge_pointNum; point
		< (myData->cali.tmpCond[bd][ch].point[type][range].setPointNum-1);
		point++) {
		//da(charge)
		tmp1 = (double)myData->cali.tmpCond[bd][ch]
			.point[type][range].setPoint[point+1]
			- (double)myData->cali.tmpCond[bd][ch]
			.point[type][range].setPoint[point];
		tmp2 = myData->cali.tmpData[bd][ch].set_meter[type][range][point+1]
			- myData->cali.tmpData[bd][ch].set_meter[type][range][point];

		cali_a = tmp1/tmp2;
		cali_b = (double)myData->cali.tmpCond[bd][ch]
			.point[type][range].setPoint[point]
			- (myData->cali.tmpData[bd][ch].set_meter[type][range][point]
			* cali_a);
		 
		myData->cali.tmpData[bd][ch].DA_A[type][range][point-1] = cali_a;
		myData->cali.tmpData[bd][ch].DA_B[type][range][point-1] = cali_b;
	}

	for(point=0; point < (discharge_pointNum); point++) {
		//ad
		tmp1 = myData->cali.tmpData[bd][ch].set_meter[type][range][point+1]
			- myData->cali.tmpData[bd][ch].set_meter[type][range][point];
		tmp2 = myData->cali.tmpData[bd][ch].set_ad[type][range][point+1]
			- myData->cali.tmpData[bd][ch].set_ad[type][range][point];

		cali_a = tmp1/tmp2;
		cali_b = myData->cali.tmpData[bd][ch].set_meter[type][range][point]
			- myData->cali.tmpData[bd][ch].set_ad[type][range][point]
			* cali_a;

		myData->cali.tmpData[bd][ch].AD_A[type][range][point] = cali_a;
		myData->cali.tmpData[bd][ch].AD_B[type][range][point] = cali_b;
	}
	for(point = discharge_pointNum; 
		point < (myData->cali.tmpCond[bd][ch].point[type][range].setPointNum-1);
		point++) {
		//ad
		tmp1 = myData->cali.tmpData[bd][ch].set_meter[type][range][point+1]
			- myData->cali.tmpData[bd][ch].set_meter[type][range][point];
		tmp2 = myData->cali.tmpData[bd][ch].set_ad[type][range][point+1]
			- myData->cali.tmpData[bd][ch].set_ad[type][range][point];

		cali_a = tmp1/tmp2;
		cali_b = myData->cali.tmpData[bd][ch].set_meter[type][range][point]
			- myData->cali.tmpData[bd][ch].set_ad[type][range][point]
			* cali_a;

		myData->cali.tmpData[bd][ch].AD_A[type][range][point-1] = cali_a;
		myData->cali.tmpData[bd][ch].AD_B[type][range][point-1] = cali_b;
	}

	if(type == 0) {
		point = myData->cali.tmpCond[bd][ch].point[type][range].setPointNum-1;
		temp = myData->cali.tmpData[bd][ch].set_meter[type][range][point];
		if(temp == 0) {
			temp = 1;
		}
		if(myData->cali.tmpCond[bd][ch].point[type][range].setPoint[point]
			>= 0) {
			tmp1 = (myData->cali.tmpData[bd][ch].set_ad[type][range][point]
				- myData->cali.tmpData[bd][ch].set_meter[type][range][point])
				/ temp;
			myData->cali.tmpData[bd][ch].AD_Ratio[type][range][0] = 1.0 - tmp1;
		} else {
			tmp1 = (myData->cali.tmpData[bd][ch].set_ad[type][range][point]
				* (-1)
				- myData->cali.tmpData[bd][ch].set_meter[type][range][point]
				* (-1))
				/ (temp * (-1));
			myData->cali.tmpData[bd][ch].AD_Ratio[type][range][0] = 1.0 - tmp1;
		}

		point = 0;
		temp = myData->cali.tmpData[bd][ch].set_meter[type][range][point];
		if(temp == 0) {
			temp = 1;
		}
		if(myData->cali.tmpCond[bd][ch].point[type][range].setPoint[point]
			>= 0) {
			tmp2 = (myData->cali.tmpData[bd][ch].set_ad[type][range][point]
				- myData->cali.tmpData[bd][ch].set_meter[type][range][point])
				/ temp;
			myData->cali.tmpData[bd][ch].AD_Ratio[type][range][1] = 1.0 - tmp2;
		} else {
			tmp2 = (myData->cali.tmpData[bd][ch].set_ad[type][range][point]
				* (-1)
				- myData->cali.tmpData[bd][ch].set_meter[type][range][point]
				* (-1))
				/ (temp * (-1));
			myData->cali.tmpData[bd][ch].AD_Ratio[type][range][1] = 1.0 - tmp2;
		}
	} else {
		point = myData->cali.tmpCond[bd][ch].point[type][range].setPointNum-1;
		temp = myData->cali.tmpData[bd][ch].set_meter[type][range][point];
		if(temp == 0) {
			temp = 1;
		}
		if(myData->cali.tmpCond[bd][ch].point[type][range].setPoint[point]
			>= 0) {
			tmp1 = (myData->cali.tmpData[bd][ch].set_ad[type][range][point]
				- myData->cali.tmpData[bd][ch].set_meter[type][range][point])
				/ temp;
			myData->cali.tmpData[bd][ch].AD_Ratio[type][range][0] = 1.0 - tmp1;
		} else {
			tmp1 = (myData->cali.tmpData[bd][ch].set_ad[type][range][point]
				* (-1)
				- myData->cali.tmpData[bd][ch].set_meter[type][range][point]
				* (-1))
				/ (temp * (-1));
			myData->cali.tmpData[bd][ch].AD_Ratio[type][range][0] = 1.0 - tmp1;
		}

		point = 0;
		temp = myData->cali.tmpData[bd][ch].set_meter[type][range][point];
		if(temp == 0) {
			temp = 1;
		}
		if(myData->cali.tmpCond[bd][ch].point[type][range].setPoint[point]
			>= 0) {
			tmp2 = (myData->cali.tmpData[bd][ch].set_ad[type][range][point]
				- myData->cali.tmpData[bd][ch].set_meter[type][range][point])
				/ temp;
			myData->cali.tmpData[bd][ch].AD_Ratio[type][range][1] = 1.0 - tmp2;
		} else {
			tmp2 = (myData->cali.tmpData[bd][ch].set_ad[type][range][point]
				* (-1)
				- myData->cali.tmpData[bd][ch].set_meter[type][range][point]
				* (-1))
				/ (temp * (-1));
			myData->cali.tmpData[bd][ch].AD_Ratio[type][range][1] = 1.0 - tmp2;
		}
	}
}

double return_meter_value(int bd, int ch, int type) //20160229
{
	unsigned char offset_val=0;
	int i, range;
	double tmp=0.0, ratio=0.0, realValue=0.0;
	double shunt = 0.0;	//hun_200217
	double realValue2 = 0.0; //hun_200217
	i = 0;
	offset_val = 0;
	//realValue = labs(myData->CaliMeter.value) / 100;
	realValue = myData->CaliMeter.value / 100;
	range = myData->cali.tmpCond[bd][ch].range;
	shunt = myData->CaliMeter.shunt_mOhm;	//hun_200217
	realValue2 = myData->CaliMeter.orgValue; //hun_200217	
	if(type == 0){
#if SHUNT_R_RCV == 2
		if(myData->mData.cali_hallCT == P1 ||
			myData->mData.cali_hallCT == P3) {	//hun_210830
			if(labs(realValue2) <= 1200){	//1.2V
				if(realValue2 >= 0) offset_val = 8;
			}else if(labs(realValue2) <= 12000){ //12V
				if(realValue2 >= 0) offset_val = 9;
			}
			myData->CaliMeter.offset_val = offset_val;	//kjc_200309

			myData->CaliMeter.orgValue += myData->cali.tmpCond[bd][ch]
					.point[type][range].meter_offset[offset_val];
				
			tmp = (myData->CaliMeter.orgValue * 100000) / 100.0;
		} else {
			if(labs(realValue2) <= 1.2){	// 1.2mV
				if(realValue2 >= 0) offset_val = 4;
				else offset_val = 9;
			}else if(labs(realValue2) <= 12){ //120mV
				if(realValue2 >= 0) offset_val = 3;
				else offset_val = 8;
			}else if(labs(realValue2) <= 120){	//120mV
				if(realValue2 >= 0) offset_val = 2;
				else offset_val = 7;
			}else if(labs(realValue2) <= 1200){	//1.2V
				if(realValue2 >= 0) offset_val = 1;
				else offset_val = 6;
			}else if(labs(realValue2) <= 12000){ //12V
				if(realValue2 >= 0) offset_val = 0;
				else offset_val = 5;
			}
			myData->CaliMeter.offset_val = offset_val;	//kjc_200309
			myData->CaliMeter.orgValue += myData->cali.tmpCond[bd][ch]
					.point[type][range].meter_offset[offset_val];
				
			tmp = (myData->CaliMeter.orgValue * 100000) / 100.0;
		}
#else
		tmp = myData->CaliMeter.value / 100.0;
#endif
	}else{
#if SHUNT_R_RCV == 2
		//180602 lyhw add for caliMeter offset value
		// C_1MA = 1mA , C_10MA = 10mA, C_100MA = 100mA 
		if(myData->mData.cali_hallCT == P1 ||
			myData->mData.cali_hallCT == P3) {	//hun_210830
			if(labs(realValue2) <= 1.2){	//1.2mA
				if(realValue2 >= 0)	offset_val = 3;
				else	offset_val = 7;
			}else if(labs(realValue2) <= 12){ //12mA
				if(realValue2 >= 0)	offset_val = 2;
				else	offset_val = 6;
			}else if(labs(realValue2) <= 120){ //120mA
				if(realValue2 >= 0)	offset_val = 1;
				else	offset_val = 5;
			}else if(labs(realValue2) <= 1200){ //1200mA
				if(realValue2 >= 0)	offset_val = 0;
				else	offset_val = 4;
			}
		} else {
			if(labs(realValue2) <= 1.2){	// 1.2mV
				if(realValue2 >= 0) offset_val = 4;
				else offset_val = 9;
			}else if(labs(realValue2) <= 12){ //120mV
				if(realValue2 >= 0) offset_val = 3;
				else offset_val = 8;
			}else if(labs(realValue2) <= 120){	//120mV
				if(realValue2 >= 0) offset_val = 2;
				else offset_val = 7;
			}else if(labs(realValue2) <= 1200){	//1.2V
				if(realValue2 >= 0) offset_val = 1;
				else offset_val = 6;
			}else if(labs(realValue2) <= 12000){ //12V
				if(realValue2 >= 0) offset_val = 0;
				else offset_val = 5;
			}
		}
		myData->CaliMeter.offset_val = offset_val;	//kjc_200309
		myData->CaliMeter.orgValue += myData->cali.tmpCond[bd][ch]
			.point[type][range].meter_offset[offset_val];
#endif
		switch(myData->CaliMeter.config.measureI) {
			case MEASURE_I_3: //DCCT 600A/400mA
				tmp = myData->CaliMeter.value / 40.0 * 600.0;
				break;
			case MEASURE_I_4: //DCCT 150A/200mA
				tmp = myData->CaliMeter.value / 20.0 * 150.0;
				break;
			case MEASURE_I_9: //DCCT 300A/300mA
				tmp = myData->CaliMeter.value / 30.0 * 300.0;
				break;
			default: //meter DCI
				if(myData->mData.cali_hallCT == P1 ||
					myData->mData.cali_hallCT == P3) {	//hun_210830
					ratio = myData->CaliMeter.hallCT_ratio;	//180525 lyh
					if(myData->CaliMeter.config.readType == READ_V_I) {
						if(myPs->config.maxCurrent[0] == 600000000) {
							tmp = myData->CaliMeter.value / 40.0 * 600.0;
						} else if(myPs->config.maxCurrent[0] == 1000000000) {
							tmp = myData->CaliMeter.value / 66.6667 * 1000.0;
						}else{	// raio = inputvalue : 1
							#if SHUNT_R_RCV == 2
							tmp = myData->CaliMeter.orgValue * ratio * 1000;
							#else
							tmp = myData->CaliMeter.value / 100.0 * ratio;
							#endif
						}
					}
				} else {
					if(myPs->config.ratioCurrent == MICRO) { //uA
						#if SHUNT_R_RCV == 2
						tmp = (((myData->CaliMeter.orgValue * 100000) 
							/ shunt) * 1000) / 100.0;
						#else
							tmp = myData->CaliMeter.value / 100.0;
						#endif
					
					} else { //nA
						#if SHUNT_R_RCV == 2
						tmp = (((myData->CaliMeter.orgValue * 100000) 
							/ shunt) * 1000) * 10.0;
						#else //200428 rewrite
							tmp = myData->CaliMeter.value * 10.0; 
						#endif
					}
				}
				break;
		}
	}
	return tmp;
}

double return_calimeter2_value(int bd, int ch, int type) //20160229
{
	double tmp=0.0, ratio = 0.0;

	if(type  == 0){
		tmp = myData->CaliMeter2.value / 100.0;
	}else{
		switch(myData->CaliMeter2.config.measureI) {
			case MEASURE_I_3: //DCCT 600A/400mA
				tmp = myData->CaliMeter2.value / 40.0 * 600.0;
				break;
			case MEASURE_I_4: //DCCT 150A/200mA
				tmp = myData->CaliMeter2.value / 20.0 * 150.0;
				break;
			default: //meter DCI
				if(myData->mData.cali_hallCT == 1){
					ratio = myData->CaliMeter.hallCT_ratio;	//180525 lyh
					if(myData->CaliMeter2.config.readType == READ_V_I){
						if(myPs->config.maxCurrent[0] == 600000000){
							tmp = myData->CaliMeter2.value / 40.0 * 600.0;
						}else if(myPs->config.maxCurrent[0] == 1000000000){
							tmp = myData->CaliMeter2.value / 66.6667 * 1000.0;
						}else{	// raio = inputvalue : 1
							tmp = myData->CaliMeter.value / 100.0 * ratio;
						}
					}
				}else{
					if(myPs->config.ratioCurrent == MICRO) { //uA
						tmp = myData->CaliMeter2.value / 100.0;
					}else{ //nA
						tmp = myData->CaliMeter2.value * 10.0;
					}
				}
				break;
		}
	}
	return tmp;
}

void data_gathering_cali(int bd, int ch, int type, int range, int point)
{
	double tmp = 0.0;

	if(myCh->signal[C_SIG_METER_REPLY] == P1) {
		myCh->signal[C_SIG_METER_REPLY] = P0;
					
//111215 detail calibration add
		myCh->misc.caliCheckPoint++;
		myCh->misc.caliCheckSum += myData->cali.orgAD[type];
		if(myCh->misc.caliCheckPoint >= myCh->misc.setCaliNum) {
			myData->cali.tmpData[bd][ch].set_ad[type][range][point]
				= (double)(myCh->misc.caliCheckSum / 
								myCh->misc.setCaliNum);
		}
#ifdef _SK_CALI_TYPE
		myData->cali.tmpData[bd][ch].set_meterValue[type][range][point]
			= (double)(myData->CaliMeter.orgValue * 1000);
#endif

		tmp = return_meter_value(bd, ch, type);

		if(type == 0){
			myCh->misc.caliCheckSum1 +=	tmp;
		}else{
			myCh->misc.caliCheckSum1 +=	 
				(tmp + (double)myData->CaliMeter.config.I_offset);
		}
		if(myData->AppControl.loadProcess[LOAD_CALIMETER2] == P1){
			if(myData->CaliMeter.caliType == CALI_V){
				myCh->op.phase = P11;
			}else{
				myCh->op.phase = P2;
			}
		}else{
			myCh->op.phase = P2;
		}
//111215 detail calibration add
		if(myCh->misc.caliCheckPoint >= myCh->misc.setCaliNum) {
			myData->cali.tmpData[bd][ch].set_meter[type][range][point] 
				= (double)(myCh->misc.caliCheckSum1 / myCh->misc.setCaliNum);
			myCh->misc.caliCheckPoint = 0;
			myCh->misc.caliCheckSum = 0;
			myCh->misc.caliCheckSum1 = 0;
			if(myData->AppControl.loadProcess[LOAD_CALIMETER2] == P1){
				if(myData->CaliMeter.caliType == CALI_V){
					myCh->op.phase = P15;
				}else{
					myCh->op.phase = P20;
				}
			}else{
				myCh->op.phase = P20;
			}
			if(myPs->config.FadBdUse == P1){
				myData->cali.tmpData_fad[bd][ch].set_ad[type][range][point]
				= myData->cali.orgAD_fad[type];
			}
		}
	} else if(myCh->signal[C_SIG_METER_ERROR] == P1) {
#if CYCLER_TYPE == DIGITAL_CYC
		myCh->signal[C_SIG_OUT_SWITCH_OFF] = P1;
#endif
		myCh->signal[C_SIG_METER_ERROR] = P0;
		myCh->signal[C_SIG_OUT_SWITCH] = P0;
		myCh->signal[C_SIG_V_RANGE] = RANGE0;
		myCh->signal[C_SIG_I_RANGE] = RANGE0;
		myCh->op.state = C_STANDBY;
		myCh->op.phase = P0;
	}
}

void data_gathering_check(int bd, int ch, int type, int range, int point)
{
	double tmp = 0.0;

	if(myCh->signal[C_SIG_METER_REPLY] == P1) {
		myCh->signal[C_SIG_METER_REPLY] = P0;
		
//111215 detail calibration add
		myCh->misc.caliCheckPoint++;
		if(type == 0){
			myCh->misc.caliCheckSum += (double)myCh->op.Vsens;
		}else{
			myCh->misc.caliCheckSum += (double)myCh->op.Isens;
		}
		if(myCh->misc.caliCheckPoint >= myCh->misc.checkCaliNum) {
			myData->cali.tmpData[bd][ch].check_ad[type][range][point]
				= (double)(myCh->misc.caliCheckSum / 
								myCh->misc.checkCaliNum);
		}
#ifdef _SK_CALI_TYPE
		myData->cali.tmpData[bd][ch].check_meterValue[type][range][point]
			= (double)(myData->CaliMeter.orgValue * 1000);
#endif
					
		tmp = return_meter_value(bd, ch, type);

		if(type == 0){
			myCh->misc.caliCheckSum1 +=	tmp; 
		}else{
			myCh->misc.caliCheckSum1 +=	 
				(tmp + (double)myData->CaliMeter.config.I_offset);
		}

		if(myData->AppControl.loadProcess[LOAD_CALIMETER2] == P1){
			if(myData->CaliMeter.caliType == CALI_V){
				myCh->op.phase = P11;
			}else{
				myCh->op.phase = P2;
			}
		}else{
			myCh->op.phase = P2;
		}

		if(myCh->misc.caliCheckPoint >= myCh->misc.checkCaliNum) {
			myData->cali.tmpData[bd][ch].check_meter
				[type][range][point] = (double)
				(myCh->misc.caliCheckSum1 / myCh->misc.checkCaliNum);
			myCh->misc.caliCheckPoint = 0;
			myCh->misc.caliCheckSum = 0;
			myCh->misc.caliCheckSum1 = 0;
			if(myData->AppControl.loadProcess[LOAD_CALIMETER2] == P1){
				if(myData->CaliMeter.caliType == CALI_V){
					myCh->op.phase = P15;
				}else{
					myCh->op.phase = P20;
				}
			}else{
				myCh->op.phase = P20;
			}

			if(myPs->config.FadBdUse == P1){
				myData->cali.tmpData_fad[bd][ch].check_ad[type][range][point]
				= myData->cali.orgAD_fad[type];
			}
		}
	} else if(myCh->signal[C_SIG_METER_ERROR] == P1) {
#if CYCLER_TYPE == DIGITAL_CYC
		myCh->signal[C_SIG_OUT_SWITCH_OFF] = P1;
#endif
		myCh->signal[C_SIG_METER_ERROR] = P0;
		myCh->signal[C_SIG_OUT_SWITCH] = P0;
		myCh->signal[C_SIG_V_RANGE] = RANGE0;
		myCh->signal[C_SIG_I_RANGE] = RANGE0;
		myCh->op.state = C_STANDBY;
		myCh->op.phase = P0;
	}
}

void data_gathering_cali_meter2(int bd, int ch, int type, int range, int point)
{
	if(myCh->signal[C_SIG_CALIMETER2_REPLY] == P1) {
		myCh->signal[C_SIG_CALIMETER2_REPLY] = P0;
					
		myData->cali.tmpData_caliMeter2[bd][ch].set_ad[type][range][point]
			= (double)myData->cali.orgAD_caliMeter2[type];


		myData->cali.tmpData_caliMeter2[bd][ch].set_meter[type][range][point] 
			= (double) return_calimeter2_value(bd, ch, type);
		
		if(myCh->op.phase == P11){
			myCh->op.phase = P2;
		}else if(myCh->op.phase == P15){
			if(myCh->signal[C_SIG_I_RANGE] < myPs->config.rangeI){
				myCh->op.phase = P2;
				myCh->signal[C_SIG_I_RANGE]++;
			}else{
				myCh->signal[C_SIG_I_RANGE] = RANGE1;
				myCh->op.phase = P20;
			}
		}
	} else if(myCh->signal[C_SIG_CALIMETER2_ERROR] == P1) {
		myCh->signal[C_SIG_CALIMETER2_ERROR] = P0;
		myCh->signal[C_SIG_OUT_SWITCH] = P0;
		myCh->signal[C_SIG_V_RANGE] = RANGE0;
		myCh->signal[C_SIG_I_RANGE] = RANGE0;
		myCh->op.state = C_STANDBY;
		myCh->op.phase = P0;
	}
}

void data_gathering_check_meter2(int bd, int ch, int type, int range, int point)
{
	double tmp = 0.0;

	if(myCh->signal[C_SIG_CALIMETER2_REPLY] == P1) {
		myCh->signal[C_SIG_CALIMETER2_REPLY] = P0;
		
		myData->cali.tmpData_caliMeter2[bd][ch].check_ad[type][range][point]
			= (double)myData->cali.orgAD_caliMeter2[type];
					
		tmp = return_calimeter2_value(bd, ch, type);

		myData->cali.tmpData_caliMeter2[bd][ch].check_meter
			[type][range][point] = 
				(tmp + (double)myData->CaliMeter.config.I_offset);

		if(myCh->op.phase == P11){
			myCh->op.phase = P2;
		}else if(myCh->op.phase == P15){
			if(myCh->signal[C_SIG_I_RANGE] < myPs->config.rangeI){
				myCh->op.phase = P2;
				myCh->signal[C_SIG_I_RANGE]++;
			}else{
				myCh->signal[C_SIG_I_RANGE] = RANGE1;
				myCh->op.phase = P20;
			}
		}
	} else if(myCh->signal[C_SIG_CALIMETER2_ERROR] == P1) {
		myCh->signal[C_SIG_CALIMETER2_ERROR] = P0;
		myCh->signal[C_SIG_OUT_SWITCH] = P0;
		myCh->signal[C_SIG_V_RANGE] = RANGE0;
		myCh->signal[C_SIG_I_RANGE] = RANGE0;
		myCh->op.state = C_STANDBY;
		myCh->op.phase = P0;
	}
}

void cSemiSwitch(int bd, int ch)
{
#if CYCLER_TYPE == DIGITAL_CYC
	return;	//180611 add
#endif
	if(myData->AppControl.config.systemType == CYCLER_CAN){
		cSemiSwitch_CAN(bd, ch);
		return;
	}

	switch(myPs->config.hwSpec) {
		case L_5V_3A:
		case L_6V_6A:
		case L_5V_2A:
		case L_5V_200A:
		case L_5V_10mA:
		case L_5V_5A:
		case L_5V_5A_2:
		case L_5V_30A:
		case L_2V_60A:
			cSemiSwitch_L1(bd, ch);
			break;
/*		case L_2V_100A:
		case L_5V_50A:
		case L_5V_50A_R2:
		case L_5V_50A_R2_1:
		case L_5V_300A_R3:
		case L_5V_200A_R3:
		case L_5V_100A_R2_1:
		case L_5V_150A_R3:
		case L_5V_1000A_R3:
		case L_10V_5A_R2:
			cSemiSwitch_L2(bd, ch);
			break;
*/		case L_50V_50A:
			cSemiSwitch_L3(bd, ch);
			break;
		case L_20V_25A:
		case L_5V_100A:
			cSemiSwitch_L4(bd, ch);
			break;
		case L_5V_250A_R1:
			cSemiSwitch_L6(bd, ch);
		case S_5V_200A:
			cSemiSwitch_S1(bd, ch);
			break;
		case S_5V_200A_75A_15A_AD2:
			cSemiSwitch_S2(bd, ch);
			break;
		case L_5V_500mA_2uA_R4:		//210601 lyhw
			cSemiSwitch_L7(bd, ch);
			break;
		default:
			cSemiSwitch_L5(bd, ch);
			break;
	}
}

void cSemiSwitch_L1(int bd, int ch)
{
	int stepType, div, rangeV, rangeI;
	long val1, max_val2, min_val2;
	unsigned long advStepNo;

	myCh = &(myData->bData[bd].cData[ch]);

    advStepNo = myCh->misc.advStepNo;
	rangeV = 0;
	rangeI = myPs->config.rangeI-1;

	stepType = myPs->testCond[bd][ch].step[advStepNo].type;

	val1 = myPs->config.maxVoltage[rangeV];
	max_val2 = myPs->config.maxCurrent[rangeI];
	min_val2 = myPs->config.minCurrent[rangeI];
	div = 5;

	if(myCh->misc.semiSwitchState == SEMI_IDLE) {
		cCalCmdV(bd, ch, val1*(-1), div, rangeV);
		cCalCmdI(bd, ch, max_val2, div, rangeI);
		myCh->misc.semiSwitchState = SEMI_PRE;
	} else if(myCh->misc.semiSwitchState == SEMI_PRE) {
		if(stepType == STEP_CHARGE) {
			cCalCmdV(bd, ch, val1, div, rangeV);
			cCalCmdI(bd, ch, min_val2, div, rangeI);
			myCh->misc.semiSwitchState = SEMI_V_P;
		} else if(stepType == STEP_DISCHARGE || stepType == STEP_Z) {
			cCalCmdV(bd, ch, val1*(-1), div, rangeV);
			cCalCmdI(bd, ch, max_val2, div, rangeI);
			myCh->misc.semiSwitchState = SEMI_V_N;
		}
	} else if(myCh->misc.semiSwitchState == SEMI_V_P) {
		if(stepType == STEP_CHARGE) {
			cCalCmdI(bd, ch, min_val2, div, rangeI);
			cCalCmdV(bd, ch, val1, div, rangeV);
		} else if(stepType == STEP_DISCHARGE || stepType == STEP_Z) {
			cCalCmdV(bd, ch, val1*(-1), div, rangeV);
			cCalCmdI(bd, ch, max_val2, div, rangeI);
			myCh->misc.semiSwitchState = SEMI_V_N;
		} else {
			cCalCmdI(bd, ch, min_val2, div, rangeI);
			cCalCmdV(bd, ch, val1, div, rangeV);
			myCh->misc.semiSwitchState = SEMI_PRE;
		}
	} else if(myCh->misc.semiSwitchState == SEMI_V_N) {
		if(stepType == STEP_CHARGE) {
			cCalCmdV(bd, ch, val1, div, rangeV);
			cCalCmdI(bd, ch, min_val2, div, rangeI);
			myCh->misc.semiSwitchState = SEMI_V_P;
		} else if(stepType == STEP_DISCHARGE || stepType == STEP_Z) {
			cCalCmdI(bd, ch, max_val2, div, rangeI);
			cCalCmdV(bd, ch, val1*(-1), div, rangeV);
		} else {
			cCalCmdI(bd, ch, max_val2, div, rangeI);
			cCalCmdV(bd, ch, val1*(-1), div, rangeV);
			myCh->misc.semiSwitchState = SEMI_PRE;
		}
	}
}

void cSemiSwitch_L2(int bd, int ch)
{
	int stepType, div, rangeV, rangeI, mode;
	long val1, max_val2, min_val2;
	unsigned long advStepNo;

	myCh = &(myData->bData[bd].cData[ch]);
	
    advStepNo = myCh->misc.advStepNo;
	rangeV = 0;
	rangeI = myPs->config.rangeI-1;
	mode = CCCV;

	stepType = myPs->testCond[bd][ch].step[advStepNo].type;

	val1 = myPs->config.maxVoltage[rangeV];
	max_val2 = myPs->config.maxCurrent[rangeI];
	min_val2 = myPs->config.minCurrent[rangeI];
	div = 15;

	if(myCh->misc.semiSwitchState == SEMI_IDLE) {
		cCalCmdV(bd, ch, val1*(-1), div, rangeV);
		cCalCmdI(bd, ch, max_val2, div, rangeI);
		myCh->misc.semiSwitchState = SEMI_PRE;
	} else if(myCh->misc.semiSwitchState == SEMI_PRE) {
		if(stepType == STEP_CHARGE) {
			cCalCmdV(bd, ch, val1, div, rangeV);
			cCalCmdI(bd, ch, min_val2, div, rangeI);
			myCh->misc.semiSwitchState = SEMI_V_P;
		} else if(stepType == STEP_DISCHARGE 
			|| stepType == STEP_Z) {
			cCalCmdV(bd, ch, val1*(-1), div, rangeV);
			cCalCmdI(bd, ch, max_val2, div, rangeI);
			myCh->misc.semiSwitchState = SEMI_V_N;
		}
	} else if(myCh->misc.semiSwitchState == SEMI_V_P) {
		if(stepType == STEP_CHARGE) {
			cCalCmdI(bd, ch, min_val2, div, rangeI);
		} else if(stepType == STEP_DISCHARGE 
			|| stepType == STEP_Z) {
			cCalCmdV(bd, ch, val1*(-1), div, rangeV);
			cCalCmdI(bd, ch, max_val2/(80), div, rangeI);
			myCh->misc.semiSwitchState = SEMI_V_N;
		} else {
			cCalCmdV(bd, ch, val1, div, rangeV);
			cCalCmdI(bd, ch, 0, div, rangeI);
			myCh->misc.semiSwitchState = SEMI_REST;
		}
	} else if(myCh->misc.semiSwitchState == SEMI_V_N) {
		if(stepType == STEP_CHARGE) {
			cCalCmdV(bd, ch, val1, div, rangeV);
			cCalCmdI(bd, ch, min_val2/(80), div, rangeI);
			myCh->misc.semiSwitchState = SEMI_V_P;
		} else if(stepType == STEP_DISCHARGE 
				|| stepType == STEP_Z) {
			cCalCmdI(bd, ch, 0, div, rangeI);
		} else {
			cCalCmdV(bd, ch, val1*(-1), div, rangeV);
			cCalCmdI(bd, ch, max_val2, div, rangeI);
			myCh->misc.semiSwitchState = SEMI_REST;
		}
	} else if(myCh->misc.semiSwitchState == SEMI_REST) {
		if(stepType == STEP_CHARGE) {
			cCalCmdV(bd, ch, val1, div, rangeV);
			cCalCmdI(bd, ch, min_val2, div, rangeI);
			myCh->misc.semiSwitchState = SEMI_V_P;
		} else if(stepType == STEP_DISCHARGE || stepType == STEP_Z) {
			cCalCmdV(bd, ch, 0, div, rangeV);
			cCalCmdI(bd, ch, max_val2, div, rangeI);
			myCh->misc.semiSwitchState = SEMI_V_N;
		} else {
			myCh->misc.semiSwitchState = SEMI_REST;
		}
	} else {
		myCh->misc.semiSwitchState = SEMI_REST;
		ref_output(bd, ch, -val1 , max_val2, div, rangeV, rangeI, mode);
	}
}

void cSemiSwitch_L3(int bd, int ch)
{
	int stepType, div, rangeV, rangeI;
	long val1, max_val2, min_val2;
	unsigned long advStepNo;

	myCh = &(myData->bData[bd].cData[ch]);

    advStepNo = myCh->misc.advStepNo;
	rangeV = 0;
	rangeI = myPs->config.rangeI-1;

	stepType = myPs->testCond[bd][ch].step[advStepNo].type;

	val1 = myPs->config.maxVoltage[rangeV];
	max_val2 = myPs->config.maxCurrent[rangeI];
	min_val2 = myPs->config.minCurrent[rangeI];
	div = 15;

	cCalCmdV(bd, ch, val1*(-1), div, rangeV);
	cCalCmdI(bd, ch, max_val2, div, rangeI);
}

void cSemiSwitch_L4(int bd, int ch)
{
	int stepType, div, rangeV, rangeI;
	long val1, val2, max_val2, min_val2;
	unsigned long advStepNo;

	myCh = &(myData->bData[bd].cData[ch]);

    advStepNo = myCh->misc.advStepNo;
	rangeV = 0;
	rangeI = myPs->config.rangeI-1;

	stepType = myPs->testCond[bd][ch].step[advStepNo].type;

	val1 = myPs->config.maxVoltage[rangeV];
	max_val2 = myPs->config.maxCurrent[rangeI];
	min_val2 = myPs->config.minCurrent[rangeI];
	div = 15;

	if(myCh->op.preType == STEP_CHARGE) {
		cCalCmdI(bd, ch, min_val2, div, rangeI);
		cCalCmdV(bd, ch, val1, div, rangeV);
	} else if(myCh->op.preType == STEP_DISCHARGE) {
		cCalCmdV(bd, ch, val1, div, rangeV);
		cCalCmdI(bd, ch, min_val2, div, rangeI);
	} else {
		val1 = 0;
		cCalCmdV(bd, ch, val1, div, rangeV);
		val2 = 0;
		cCalCmdI(bd, ch, val2, div, rangeI);
	}
}

void cSemiSwitch_L5(int bd, int ch)
{
	int rangeV, rangeI, div, mode;
	long max_val1, min_val1, max_val2, min_val2;

	myCh = &(myData->bData[bd].cData[ch]);

	rangeV = 0;
	rangeI = myPs->config.rangeI - 1;
	mode = CCCV;

	max_val1 = myPs->config.maxVoltage[rangeV];
	min_val1 = myPs->config.minVoltage[rangeV];
	max_val2 = myPs->config.maxCurrent[rangeI];
	min_val2 = myPs->config.minCurrent[rangeI];
	div = 15;

	if(myCh->misc.semiSwitchState == SEMI_REST) {
		myCh->misc.semiSwitchState = SEMI_IDLE;
		return;
	}

	myCh->misc.semiSwitchState = SEMI_IDLE;
	ref_output(bd, ch, -max_val1, max_val2, div, rangeV, rangeI, mode);
}

void cSemiSwitch_L6(int bd, int ch)
{
	S_CH_STEP_INFO step;

	myCh = &(myData->bData[bd].cData[ch]);

	if(myCh->misc.semiSwitchState == SEMI_IDLE) {
		myCh->signal[C_SIG_ACTIVE_SWITCH] = P1;
		return;
	}

	if(myCh->op.state == C_PAUSE) {
		myCh->signal[C_SIG_ACTIVE_SWITCH] = P1;
		return;
	}

	step = step_info(bd, ch);

	if(step.refI == 0) {
		myCh->signal[C_SIG_ACTIVE_SWITCH] = P1;
	} else if(step.refI > 0) {
		myCh->signal[C_SIG_ACTIVE_SWITCH] = P11;
	} else {
		myCh->signal[C_SIG_ACTIVE_SWITCH] = P21;
	}
}

void cSemiSwitch_L7(int bd, int ch)
{
	int rangeV, rangeI, div, mode;
	long max_val1, min_val1, max_val2, min_val2;

	myCh = &(myData->bData[bd].cData[ch]);

	rangeV = 0;
	//modify for 500mA Range 3
	rangeI = myPs->config.rangeI - 2;
	mode = CCCV;

	max_val1 = myPs->config.maxVoltage[rangeV];
	min_val1 = myPs->config.minVoltage[rangeV];
	max_val2 = myPs->config.maxCurrent[rangeI];
	min_val2 = myPs->config.minCurrent[rangeI];
	div = 15;

	if(myCh->misc.semiSwitchState == SEMI_REST) {
		myCh->misc.semiSwitchState = SEMI_IDLE;
		return;
	}

	myCh->misc.semiSwitchState = SEMI_IDLE;
	ref_output(bd, ch, -max_val1, max_val2, div, rangeV, rangeI, mode);
}



void cSemiSwitch_S1(int bd, int ch)
{
	int stepType, rangeV, rangeI, mode;
	long val1;
	unsigned long advStepNo;
	S_CH_STEP_INFO step;

	myCh = &(myData->bData[bd].cData[ch]);
	
	step = step_info(bd, ch);

	advStepNo = step.advStepNo;
	rangeV = step.rangeV;
	rangeI = step.rangeI;
	val1 = step.refV;
	mode = step.mode;

	stepType = myPs->testCond[bd][ch].step[advStepNo].type;

	if(val1 > myPs->config.maxVoltage[rangeV]) {
		val1 = myPs->config.maxVoltage[rangeV];
	} else if(val1 < 0) {
		val1 = 0;
	}

	if(myCh->misc.semiSwitchState == SEMI_IDLE) {
		cCalCmdI(bd, ch, 0, 0, rangeI);
		cCalCmdV(bd, ch, 0, 0, rangeV);
		cCalCmdLimitV(bd, ch, val1, P0);
		cC_D_Select(bd, ch, P0);
		cV_Range_Select(bd, ch, 1);
		//cI_Range_Select(bd, ch, 2);
		cI_Range_Select(bd, ch, 0);
		myCh->misc.semiSwitchState = SEMI_PRE;
	} else if(myCh->misc.semiSwitchState == SEMI_PRE) {
		if(stepType == STEP_CHARGE) {
			cCalCmdI(bd, ch, 0, 0, rangeI);
			cCalCmdV(bd, ch, 0, 0, rangeV);
			cCalCmdLimitV(bd, ch, val1, P0);
			cC_D_Select(bd, ch, P0);
			cV_Range_Select(bd, ch, rangeV+1);
			cI_Range_Select(bd, ch, rangeI+1);
			myCh->misc.semiSwitchState = SEMI_V_P;
		} else if(stepType == STEP_DISCHARGE || stepType == STEP_Z) {
			cCalCmdI(bd, ch, 0, 0, rangeI);
			cCalCmdV(bd, ch, 0, 0, rangeV);
			cCalCmdLimitV(bd, ch, val1, P1);
			cC_D_Select(bd, ch, P1);
			cV_Range_Select(bd, ch, rangeV+1);
			cI_Range_Select(bd, ch, rangeI+1);
			myCh->misc.semiSwitchState = SEMI_V_N;
		}
	} else if(myCh->misc.semiSwitchState == SEMI_V_P) {
		if(stepType == STEP_CHARGE) {
			cV_Range_Select(bd, ch, rangeV+1);
			cI_Range_Select(bd, ch, rangeI+1);
		} else if(stepType == STEP_DISCHARGE || stepType == STEP_Z) {
			cCalCmdI(bd, ch, 0, 0, rangeI);
			cCalCmdV(bd, ch, 0, 0, rangeV);
			cCalCmdLimitV(bd, ch, val1, P1);
			cC_D_Select(bd, ch, P1);
			cV_Range_Select(bd, ch, rangeV+1);
			cI_Range_Select(bd, ch, rangeI+1);
			myCh->misc.semiSwitchState = SEMI_V_N;
		} else {
			cCalCmdI(bd, ch, 0, 0, rangeI);
			cCalCmdV(bd, ch, 0, 0, rangeV);
			cCalCmdLimitV(bd, ch, val1, P0);
			cC_D_Select(bd, ch, P0);
			cV_Range_Select(bd, ch, rangeV+1);
			cI_Range_Select(bd, ch, rangeI+1);
			myCh->misc.semiSwitchState = SEMI_PRE;
		}
	} else if(myCh->misc.semiSwitchState == SEMI_V_N) {
		if(stepType == STEP_CHARGE) {
			cCalCmdI(bd, ch, 0, 0, rangeI);
			cCalCmdV(bd, ch, 0, 0, rangeV);
			cCalCmdLimitV(bd, ch, val1, P0);
			cC_D_Select(bd, ch, P0);
			cV_Range_Select(bd, ch, rangeV+1);
			cI_Range_Select(bd, ch, rangeI+1);
			myCh->misc.semiSwitchState = SEMI_V_P;
		} else if(stepType == STEP_DISCHARGE || stepType == STEP_Z) {
			cV_Range_Select(bd, ch, rangeV+1);
			cI_Range_Select(bd, ch, rangeI+1);
		} else {
			cCalCmdI(bd, ch, 0, 0, rangeI);
			cCalCmdV(bd, ch, 0, 0, rangeV);
			cCalCmdLimitV(bd, ch, val1, P0);
			cC_D_Select(bd, ch, P0);
			cV_Range_Select(bd, ch, rangeV+1);
			cI_Range_Select(bd, ch, rangeI+1);
			myCh->misc.semiSwitchState = SEMI_PRE;
		}
	}
}

void cSemiSwitch_S2(int bd, int ch)
{
	int stepType, rangeV, rangeI, mode;
	long val1;
	unsigned long advStepNo;
	S_CH_STEP_INFO step;

	myCh = &(myData->bData[bd].cData[ch]);
	
	step = step_info(bd, ch);

	advStepNo = step.advStepNo;
	rangeV = step.rangeV;
	rangeI = step.rangeI;
	val1 = step.refV;
	mode = step.mode;

	stepType = myPs->testCond[bd][ch].step[advStepNo].type;

	if(val1 > myPs->config.maxVoltage[rangeV]) {
		val1 = myPs->config.maxVoltage[rangeV];
	} else if(val1 < 0) {
		val1 = 0;
	}

	if(myCh->misc.semiSwitchState == SEMI_IDLE) {
		cCalCmdI(bd, ch, 0, 0, rangeI);
		cCalCmdV(bd, ch, 0, 0, rangeV);
		cCalCmdLimitV(bd, ch, val1, P0);
		cC_D_Select(bd, ch, P0);
//		cV_Range_Select(bd, ch, 1);
//		cI_Range_Select(bd, ch, 0);
		myCh->misc.semiSwitchState = SEMI_PRE;
	} else if(myCh->misc.semiSwitchState == SEMI_PRE) {
		if(stepType == STEP_CHARGE) {
			cCalCmdI(bd, ch, 0, 0, rangeI);
			cCalCmdV(bd, ch, 0, 0, rangeV);
			cCalCmdLimitV(bd, ch, val1, P0);
			cC_D_Select(bd, ch, P0);
			cV_Range_Select(bd, ch, rangeV+1);
			cI_Range_Select(bd, ch, rangeI+1);
			myCh->misc.semiSwitchState = SEMI_V_P;
		} else if(stepType == STEP_DISCHARGE || stepType == STEP_Z) {
			cCalCmdI(bd, ch, 0, 0, rangeI);
			cCalCmdV(bd, ch, 0, 0, rangeV);
			cCalCmdLimitV(bd, ch, val1, P1);
			cC_D_Select(bd, ch, P1);
			cV_Range_Select(bd, ch, rangeV+1);
			cI_Range_Select(bd, ch, rangeI+1);
			myCh->misc.semiSwitchState = SEMI_V_N;
		}
	} else if(myCh->misc.semiSwitchState == SEMI_V_P) {
		if(stepType == STEP_CHARGE) {
			cV_Range_Select(bd, ch, rangeV+1);
			cI_Range_Select(bd, ch, rangeI+1);
		} else if(stepType == STEP_DISCHARGE || stepType == STEP_Z) {
			cCalCmdI(bd, ch, 0, 0, rangeI);
			cCalCmdV(bd, ch, 0, 0, rangeV);
			cCalCmdLimitV(bd, ch, val1, P1);
			cC_D_Select(bd, ch, P1);
			cV_Range_Select(bd, ch, rangeV+1);
			cI_Range_Select(bd, ch, rangeI+1);
			myCh->misc.semiSwitchState = SEMI_V_N;
		} else {
			cCalCmdI(bd, ch, 0, 0, rangeI);
			cCalCmdV(bd, ch, 0, 0, rangeV);
			cCalCmdLimitV(bd, ch, val1, P0);
			cC_D_Select(bd, ch, P0);
			cV_Range_Select(bd, ch, rangeV+1);
			//cI_Range_Select(bd, ch, rangeI+1);
			cI_Range_Select(bd, ch, 0);
			myCh->misc.semiSwitchState = SEMI_PRE;
		}
	} else if(myCh->misc.semiSwitchState == SEMI_V_N) {
		if(stepType == STEP_CHARGE) {
			cCalCmdI(bd, ch, 0, 0, rangeI);
			cCalCmdV(bd, ch, 0, 0, rangeV);
			cCalCmdLimitV(bd, ch, val1, P0);
			cC_D_Select(bd, ch, P0);
			cV_Range_Select(bd, ch, rangeV+1);
			cI_Range_Select(bd, ch, rangeI+1);
			myCh->misc.semiSwitchState = SEMI_V_P;
		} else if(stepType == STEP_DISCHARGE || stepType == STEP_Z) {
			cV_Range_Select(bd, ch, rangeV+1);
			cI_Range_Select(bd, ch, rangeI+1);
		} else {
			cCalCmdI(bd, ch, 0, 0, rangeI);
			cCalCmdV(bd, ch, 0, 0, rangeV);
			cCalCmdLimitV(bd, ch, val1, P0);
			cC_D_Select(bd, ch, P0);
			cV_Range_Select(bd, ch, rangeV+1);
			//cI_Range_Select(bd, ch, rangeI+1);
			cI_Range_Select(bd, ch, 0);
			myCh->misc.semiSwitchState = SEMI_PRE;
		}
	}
}

void cSemiSwitch_p(int bd, int ch, int parallel_ch)
{ //kjg_180521
	int rangeV, rangeI, div, mode;
	long max_val1, min_val1, max_val2, min_val2;

	rangeV = 0;
	rangeI = myPs->config.rangeI - 1;
	mode = CCCV;

	max_val1 = myPs->config.maxVoltage[rangeV];
	min_val1 = myPs->config.minVoltage[rangeV];
	max_val2 = myPs->config.maxCurrent[rangeI];
	min_val2 = myPs->config.minCurrent[rangeI];
	div = 15;

	ref_output_p(bd, ch, parallel_ch, -max_val1, max_val2, div, rangeV, rangeI, mode);
}

void cSemiSwitch_Start(int bd, int ch, int type)
{
	int div, rangeV, rangeI, parallel_ch;
	long max_val1, min_val1, max_val2, min_val2;

	if(myData->AppControl.config.systemType == CYCLER_CAN){
		cSemiSwitch_CAN(bd, ch);
		return;
	}
	
	myCh = &(myData->bData[bd].cData[ch]);

	rangeV = 0;
	rangeI = myPs->config.rangeI - 1;
	if(myPs->config.hwSpec == L_5V_500mA_2uA_R4){
		//add for 2uA Type - 500mA low Range Select
		if(myPs->config.rangeI == 4)	rangeI = rangeI - 1;
	}

	max_val1 = myPs->config.maxVoltage[rangeV];
	min_val1 = -myPs->config.maxVoltage[rangeV];
	max_val2 = myPs->config.maxCurrent[rangeI];
	min_val2 = myPs->config.minCurrent[rangeI];
	div = 15;

	if(type == STEP_CHARGE) {
		cCalCmdI(bd, ch, min_val2, div, rangeI);
		cCalCmdV(bd, ch, max_val1, div, rangeV);
	} else if(type == STEP_DISCHARGE || type == STEP_Z) {
		cCalCmdV(bd, ch, min_val1, div, rangeV);
		cCalCmdI(bd, ch, max_val2, div, rangeI);
	}

	if(myCh->misc.parallel_cycle_phase == P50) { //kjg_180521
		if((ch % 2) == 0) parallel_ch = ch + 1;
		else parallel_ch = ch - 1;

		if(type == STEP_CHARGE) {
			cCalCmdI_p(bd, parallel_ch, min_val2, div, rangeI);
			cCalCmdV_p(bd, parallel_ch, max_val1, div, rangeV);
		} else if(type == STEP_DISCHARGE || type == STEP_Z) {
			cCalCmdV_p(bd, parallel_ch, min_val1, div, rangeV);
			cCalCmdI_p(bd, parallel_ch, max_val2, div, rangeI);
		}
	}
}

void cSemiSwitch_Charge(int bd, int ch, int step)
{
	int div, rangeV, rangeI, parallel_ch;
	long max_val1, min_val1, max_val2, min_val2, val1, val2;

	if(myData->AppControl.config.systemType == CYCLER_CAN){
		cSemiSwitch_CAN(bd, ch);
		return;
	}

	myCh = &(myData->bData[bd].cData[ch]);

	rangeV = myCh->op.rangeV;
	rangeI = myCh->op.rangeI;

	max_val1 = myPs->config.maxVoltage[rangeV];
	min_val1 = -myPs->config.maxVoltage[rangeV];
	max_val2 = myPs->config.maxCurrent[rangeI];
	min_val2 = myPs->config.minCurrent[rangeI];
	div = 5;

	if(myCh->misc.semiSwitchState == SEMI_REST) {
		myCh->misc.semiSwitchState = SEMI_IDLE;
		return;
	}

	if(step == 0) {
		cCalCmdI(bd, ch, 0, div, rangeI);
		cCalCmdV(bd, ch, 0, div, rangeV);
	} else if(step == 1) {
		val1 = max_val1 * 1.8;
		val2 = min_val2 * 1.8;
		cCalCmdV(bd, ch, val1, div, rangeV);
		cCalCmdI(bd, ch, val2, div, rangeI);
	} else if(step == 2) {
		if(myData->mData.config.function[F_SEMI_SWITCH_TYPE] == P1) {
			val1 = max_val1 * 1.8;
			val2 = min_val2 * 1.0;
			//cCalCmdV(bd, ch, val1, div, rangeV);
			cCalCmdI(bd, ch, val2, div, rangeI);
			myCh->misc.semiSwitchState = SEMI_V_P;
		} else {
			myCh->misc.semiSwitchState = SEMI_V_P;
		}
	} else if(step == 3) {
		val1 = max_val1 * 1.8;
		val2 = min_val2 * 1.8;
		cCalCmdI(bd, ch, val2, div, rangeI);
		cCalCmdV(bd, ch, val1, div, rangeV);
	} else if(step == 4) {}

	if(myCh->misc.parallel_cycle_phase == P50) { //kjg_180521
		if((ch % 2) == 0) parallel_ch = ch + 1;
		else parallel_ch = ch - 1;

		if(step == 0) {
			cCalCmdI_p(bd, parallel_ch, 0, div, rangeI);
			cCalCmdV_p(bd, parallel_ch, 0, div, rangeV);
		} else if(step == 1) {
			val1 = max_val1 * 1.8;
			val2 = min_val2 * 1.8;
			cCalCmdV_p(bd, parallel_ch, val1, div, rangeV);
			cCalCmdI_p(bd, parallel_ch, val2, div, rangeI);
		} else if(step == 2) {
			if(myData->mData.config.function[F_SEMI_SWITCH_TYPE] == P1) {
				val1 = max_val1 * 1.8;
				val2 = min_val2 * 1.0;
				//cCalCmdV_p(bd, parallel_ch, val1, div, rangeV);
				cCalCmdI_p(bd, parallel_ch, val2, div, rangeI);
			} else {}
		} else if(step == 3) {
			val1 = max_val1 * 1.8;
			val2 = min_val2 * 1.8;
			cCalCmdI_p(bd, parallel_ch, val2, div, rangeI);
			cCalCmdV_p(bd, parallel_ch, val1, div, rangeV);
		} else if(step == 4) {}
	}
}

void cSemiSwitch_Discharge(int bd, int ch, int step)
{
	int div, rangeV, rangeI, parallel_ch;
	long max_val1, min_val1, max_val2, min_val2;
	float para =0.0;

	if(myPs->config.hwSpec >= S_5V_200A) return;
	if(myData->AppControl.config.systemType == CYCLER_CAN){
		cSemiSwitch_CAN(bd, ch);
		return;
	}

	myCh = &(myData->bData[bd].cData[ch]);

	rangeV = myCh->op.rangeV;
	rangeI = myCh->op.rangeI;

	max_val1 = myPs->config.maxVoltage[rangeV];
	min_val1 = -myPs->config.maxVoltage[rangeV];
#if CYCLER_TYPE == LINEAR_CYC || CYCLER_TYPE == CAN_CYC
	para = 1.0;
#else
	if(myCh->ChAttribute.opType == P1){	//180611 add 
		para = 2.0;
	}else{
		para = 1.0;
	}
#endif
	max_val2 = myPs->config.maxCurrent[rangeI]*para;
	min_val2 = myPs->config.minCurrent[rangeI]*para;
	div = 5;
	
	if(myCh->misc.semiSwitchState == SEMI_REST) {
		myCh->misc.semiSwitchState = SEMI_IDLE;
		return;
	}

	if(step == 0) {
		cCalCmdI(bd, ch, 0, div, rangeI);
		cCalCmdV(bd, ch, 0, div, rangeV);
	} else if(step == 1) {
		cCalCmdI(bd, ch, max_val2, div, rangeI);
		cCalCmdV(bd, ch, -max_val1, div, rangeV);
	} else if(step == 2) {
		myCh->misc.semiSwitchState = SEMI_V_N;
	}

	if(myCh->misc.parallel_cycle_phase == P50) { //kjg_180521
		if((ch % 2) == 0) parallel_ch = ch + 1;
		else parallel_ch = ch - 1;

		if(step == 0) {
			cCalCmdI_p(bd, parallel_ch, 0, div, rangeI);
			cCalCmdV_p(bd, parallel_ch, 0, div, rangeV);
		} else if(step == 1) {
			cCalCmdI_p(bd, parallel_ch, max_val2, div, rangeI);
			cCalCmdV_p(bd, parallel_ch, -max_val1, div, rangeV);
		} else if(step == 2) {
		}
	}
}

void cSemiSwitch_Rest(int bd, int ch, unsigned long	advStepNo, int step)
{
	int div, rangeV, rangeI, parallel_ch;
	unsigned char type;
	long max_val1, min_val1, max_val2, min_val2, val1, val2;
	float para=0.0;

	if(myData->AppControl.config.systemType == CYCLER_CAN){
		cSemiSwitch_CAN(bd, ch);
		return;
	}

	myCh = &(myData->bData[bd].cData[ch]);
	
	rangeV = 0;
	rangeI = myPs->config.rangeI - 1;
	//need Check
	if(myPs->config.hwSpec == L_5V_500mA_2uA_R4){
		//add for 2uA Type - 500mA low Range Select
		if(myPs->config.rangeI == 4)	rangeI = rangeI - 1;
	}

	max_val1 = myPs->config.maxVoltage[rangeV] * (1.8);
	min_val1 = -myPs->config.maxVoltage[rangeV] * (1.8);
	
#if CYCLER_TYPE == LINEAR_CYC || CYCLER_TYPE == CAN_CYC
	para = 1.0;
#else
	if(myCh->ChAttribute.opType == P1){	//180611 add 
		para = 2.0;
	}else{
		para = 1.0;
	}
#endif
	
	max_val2 = myPs->config.maxCurrent[rangeI]*para;
	min_val2 = myPs->config.minCurrent[rangeI]*para;
	div = 5;

	type = cSemi_Rest_Check(bd, ch);

	if(step == 0) {
		if(type == STEP_CHARGE) {
			val1 = max_val1;
			val2 = min_val2;
			cCalCmdV(bd, ch, val1, div, rangeV);
			cCalCmdI(bd, ch, val2, div, rangeI);
		} else {
			val1 = -max_val1;
			val2 = max_val2;
			cCalCmdV(bd, ch, val1, div, rangeV);
			cCalCmdI(bd, ch, val2, div, rangeI);
		}
	} else {
		if(type == STEP_CHARGE) {
			val1 = max_val1;
			val2 = min_val2;
			cCalCmdI(bd, ch, val2, div, rangeI);
			cCalCmdV(bd, ch, val1, div, rangeV);
		} else {
			val1 = -max_val1;
			val2 = max_val2;
			cCalCmdI(bd, ch, val2, div, rangeI);
			cCalCmdV(bd, ch, val1, div, rangeV);
		}
	}

	if(myCh->misc.parallel_cycle_phase == P50) { //kjg_180521
		if((ch % 2) == 0) parallel_ch = ch + 1;
		else parallel_ch = ch - 1;

		if(step == 0) {
			if(type == STEP_CHARGE) {
				val1 = max_val1;
				val2 = min_val2;
				cCalCmdV_p(bd, parallel_ch, val1, div, rangeV);
				cCalCmdI_p(bd, parallel_ch, val2, div, rangeI);
			} else {
				val1 = -max_val1;
				val2 = max_val2;
				cCalCmdV_p(bd, parallel_ch, val1, div, rangeV);
				cCalCmdI_p(bd, parallel_ch, val2, div, rangeI);
			}
		} else {
			if(type == STEP_CHARGE) {
				val1 = max_val1;
				val2 = min_val2;
				cCalCmdI_p(bd, parallel_ch, val2, div, rangeI);
				cCalCmdV_p(bd, parallel_ch, val1, div, rangeV);
			} else {
				val1 = -max_val1;
				val2 = max_val2;
				cCalCmdI_p(bd, parallel_ch, val2, div, rangeI);
				cCalCmdV_p(bd, parallel_ch, val1, div, rangeV);
			}
		}
	}

	if(myPs->config.hwSpec < S_5V_200A) {
		myCh->misc.semiSwitchState = SEMI_REST;
	}
}

unsigned char cSemi_Rest_Check(int bd, int ch)
{
	unsigned char type;
    int rtn = 0;
	unsigned long advStepNo;

	myCh = &(myData->bData[bd].cData[ch]);

	//151111 oys add
	advStepNo = myCh->misc.advStepNo;
	type = myPs->testCond[bd][ch].step[advStepNo].type;
	if(type == STEP_REST) {
		if(myPs->testCond[bd][ch].step[advStepNo].endTGoto != 0) {
			advStepNo = myPs->testCond[bd][ch].step[advStepNo].endTGoto - 1;
		} else {
			advStepNo = myCh->misc.advStepNo + 1;
		}
	} else {
		advStepNo = myCh->misc.advStepNo + 1;
	}
	//add end

//	advStepNo = myCh->misc.advStepNo + 1;
	type = myPs->testCond[bd][ch].step[advStepNo].type;
	if(type == STEP_LOOP) {
		rtn = cGoto_Type_Check(bd, ch);	
		if(rtn == 1) {
			advStepNo = advStepNo + 1;
		} else if(rtn == 2) {
			advStepNo = myCh->misc.advCycleStep;
		} else if(rtn == 3) {
			advStepNo = (int)myPs->testCond[bd][ch].step[advStepNo]
				.advGotoStep - 1;
		}

		type = myPs->testCond[bd][ch].step[advStepNo].type;
		switch(type) {
			case STEP_ADV_CYCLE:
			case STEP_PARALLEL_CYCLE: //kjg_180521
				type = myPs->testCond[bd][ch].step[advStepNo + 1].type;
				break;
			default:
				break;
		}
	}

	return type;
}

unsigned long cSemi_Rest_StepNo_Check(int bd, int ch)
{
	unsigned char type;
    int rtn = 0;
	unsigned long advStepNo;

	myCh = &(myData->bData[bd].cData[ch]);

	advStepNo = myCh->misc.advStepNo + 1;
	type = myPs->testCond[bd][ch].step[advStepNo].type;

	if(type == STEP_LOOP) {
		rtn = cGoto_Type_Check(bd, ch);	
		if(rtn == 1) {
			advStepNo = advStepNo + 1;
		} else if(rtn == 2) {
			advStepNo = myCh->misc.advCycleStep;
		} else if(rtn == 3) {
			advStepNo = (int)myPs->testCond[bd][ch].step[advStepNo]
				.advGotoStep - 1;
		}

		type = myPs->testCond[bd][ch].step[advStepNo].type;
		switch(type) {
			case STEP_ADV_CYCLE:
			case STEP_PARALLEL_CYCLE: //kjg_180521
				advStepNo = advStepNo + 1;
				break;
			default:
				break;
		}
	}
	return advStepNo;
}

void cSemiSwitch_Pattern(int bd, int ch, int step)
{
	int div, rangeV, rangeI, cmd_dir, parallel_ch;
	long max_val1, min_val1, max_val2, min_val2;
	float para=0.0;

	if(myData->AppControl.config.systemType == CYCLER_CAN){
		cSemiSwitch_CAN(bd, ch);
		return;
	}

	myCh = &(myData->bData[bd].cData[ch]);

	rangeV = 0;
	rangeI = myPs->config.rangeI - 1;
	if(myPs->config.hwSpec == L_5V_500mA_2uA_R4){
		//add for 2uA Type - 500mA low Range Select
		if(myPs->config.rangeI == 4)	rangeI = rangeI - 1;
	}

	max_val1 = myPs->config.maxVoltage[rangeV] * (1.8);
	min_val1 = -myPs->config.maxVoltage[rangeV] * (1.8);

#if CYCLER_TYPE == LINEAR_CYC || CYCLER_TYPE == CAN_CYC
	para = 1.0;
#else
	if(myCh->ChAttribute.opType == P1){	//180611 add 
		para = 2.0;
	}else{
		para = 1.0;
	}
#endif
	
	max_val2 = myPs->config.maxCurrent[rangeI]*para;
	min_val2 = myPs->config.minCurrent[rangeI]*para;
	div = 15;

	cmd_dir = myCh->misc.cmdV_dir;

	if(step == 0) {
		cCalCmdI(bd, ch, 0, div, rangeI);
		cCalCmdV(bd, ch, 0, div, rangeV);
	} else {
		if(cmd_dir == CMD_V_PLUS) {
			cCalCmdV(bd, ch, max_val1, div, rangeV);
			cCalCmdI(bd, ch, min_val2, div, rangeI);
		} else {
			cCalCmdV(bd, ch, min_val1, div, rangeV);
			cCalCmdI(bd, ch, max_val2, div, rangeI);
		}
	}

	if(myCh->misc.parallel_cycle_phase == P50) { //kjg_180521
		if((ch % 2) == 0) parallel_ch = ch + 1;
		else parallel_ch = ch - 1;

		if(step == 0) {
			cCalCmdI_p(bd, parallel_ch, 0, div, rangeI);
			cCalCmdV_p(bd, parallel_ch, 0, div, rangeV);
		} else {
			if(cmd_dir == CMD_V_PLUS) {
				cCalCmdV_p(bd, parallel_ch, max_val1, div, rangeV);
				cCalCmdI_p(bd, parallel_ch, min_val2, div, rangeI);
			} else {
				cCalCmdV_p(bd, parallel_ch, min_val1, div, rangeV);
				cCalCmdI_p(bd, parallel_ch, max_val2, div, rangeI);
			}
		}
	}
}

void cSemiSwitch_End(int bd, int ch, int step)
{
	int div, rangeV, rangeI, parallel_ch;
	long max_val1, min_val1, max_val2, min_val2;
	float para=0.0;

	if(myData->AppControl.config.systemType == CYCLER_CAN){
		cSemiSwitch_CAN(bd, ch);
		return;
	}

	myCh = &(myData->bData[bd].cData[ch]);

	rangeV = myCh->op.rangeV;
	rangeI = myCh->op.rangeI;

	max_val1 = myPs->config.maxVoltage[rangeV];
	min_val1 = -myPs->config.maxVoltage[rangeV];
	
#if CYCLER_TYPE == LINEAR_CYC || CYCLER_TYPE == CAN_CYC
	para = 1.0;
#else
	if(myCh->ChAttribute.opType == P1){	//180611 add 
		para = 2.0;
	}else{
		para = 1.0;
	}
#endif
	
	max_val2 = myPs->config.maxCurrent[rangeI]*para;
	min_val2 = myPs->config.minCurrent[rangeI]*para;
	div = 5;

	if(step == 0) {
		cCalCmdI(bd, ch, 0, 0, rangeI);
		cCalCmdV(bd, ch, 0, 0, rangeV);
	} else if(step == 1) {
		cSemiSwitch(bd, ch);
	} else if(step == 2) {
		cCalCmdV(bd, ch, min_val1, div, rangeV);
		cCalCmdI(bd, ch, max_val2, div, rangeI);
	}

	if(myCh->misc.parallel_cycle_phase == P50) { //kjg_180521
		if((ch % 2) == 0) parallel_ch = ch + 1;
		else parallel_ch = ch - 1;

		if(step == 0) {
			cCalCmdI_p(bd, parallel_ch, 0, 0, rangeI);
			cCalCmdV_p(bd, parallel_ch, 0, 0, rangeV);
		} else if(step == 1) {
			cSemiSwitch_p(bd, ch, parallel_ch);
		} else if(step == 2) {
			cCalCmdV_p(bd, parallel_ch, min_val1, div, rangeV);
			cCalCmdI_p(bd, parallel_ch, max_val2, div, rangeI);
		}
	}
}
/*
void cSemiSwitch_Cali(int bd, int ch, unsigned char stepType)
{
	int div;
	long val1, max_val2, min_val2;
	int rangeV, rangeI;

//	if(myPs->config.hwSpec >= S_5V_200A) return;

	myCh = &(myData->bData[bd].cData[ch]);
	rangeV = 0;
	rangeI = myPs->config.rangeI-1;

	val1 = myPs->config.maxVoltage[rangeV];
	max_val2 = myPs->config.maxCurrent[rangeI];
	min_val2 = myPs->config.minCurrent[rangeI];
	div = 15;

	if(myCh->misc.semiSwitchState == SEMI_IDLE) {
		cCalCmdV(bd, ch, val1*(-1), div, rangeV);
		cCalCmdI(bd, ch, max_val2, div, rangeI);
		myCh->misc.semiSwitchState = SEMI_PRE;
	} else if(myCh->misc.semiSwitchState == SEMI_PRE) {
		if(stepType == STEP_CHARGE) {
			cCalCmdV(bd, ch, val1, div, rangeV);
			cCalCmdI(bd, ch, min_val2, div, rangeI);
			myCh->misc.semiSwitchState = SEMI_V_P;
		} else if(stepType == STEP_DISCHARGE 
			|| stepType == STEP_Z) {
			cCalCmdV(bd, ch, val1*(-1), div, rangeV);
			cCalCmdI(bd, ch, max_val2, div, rangeI);
			myCh->misc.semiSwitchState = SEMI_V_N;
		}else if(stepType == STEP_IDLE) {
			cCalCmdI(bd, ch, 0, div, rangeI);
			cCalCmdV(bd, ch, 0, div, rangeV);
		}
	} else if(myCh->misc.semiSwitchState == SEMI_V_P) {
		if(stepType == STEP_CHARGE) {
			rangeI = myCh->signal[C_SIG_I_RANGE] - 1;
			if(rangeI < 0) rangeI = 0;
			if(rangeI != rangeI) {
				cCalCmdV(bd, ch, 0, div, rangeV);
				cCalCmdI(bd, ch, 0, div, rangeI);
				myCh->misc.semiSwitchState = SEMI_V_P;
			}
		} else if(stepType == STEP_DISCHARGE 
			|| stepType == STEP_Z) {
			cCalCmdV(bd, ch, val1*(-1), div, rangeV);
			cCalCmdI(bd, ch, max_val2, div, rangeI);
			myCh->misc.semiSwitchState = SEMI_V_N;
		} else {
			cCalCmdV(bd, ch, val1, div, rangeV);
			cCalCmdI(bd, ch, min_val2, div, rangeI);
			myCh->misc.semiSwitchState = SEMI_PRE;
		}
	} else if(myCh->misc.semiSwitchState == SEMI_V_N) {
		if(stepType == STEP_CHARGE) {
			cCalCmdV(bd, ch, val1, div, rangeV);
			cCalCmdI(bd, ch, min_val2, div, rangeI);
			myCh->misc.semiSwitchState = SEMI_V_P;
		} else if(stepType == STEP_DISCHARGE 
				|| stepType == STEP_Z) {
			rangeI = myCh->signal[C_SIG_I_RANGE] - 1;
			if(rangeI < 0) rangeI = 0;
			if(rangeI != rangeI) {
				cCalCmdV(bd, ch, 0, div, rangeV);
				cCalCmdI(bd, ch, 0, div, rangeI);
				myCh->misc.semiSwitchState = SEMI_V_N;
			}
		} else {
			cCalCmdV(bd, ch, val1*(-1), div, rangeV);
			cCalCmdI(bd, ch, max_val2, div, rangeI);
			myCh->misc.semiSwitchState = SEMI_PRE;
		}
	}
}
*/

void cSemiSwitch_Cali(int bd, int ch, unsigned char stepType)
{
	int div;
	long val1, max_val2, min_val2;
	int rangeV, rangeI;
	float para=0.0;

//	if(myPs->config.hwSpec >= S_5V_200A) return;
	if(myData->AppControl.config.systemType == CYCLER_CAN){
		cSemiSwitch_CAN(bd, ch);
		return;
	}

	myCh = &(myData->bData[bd].cData[ch]);
	rangeV = 0;
	rangeI = myPs->config.rangeI-1;

	val1 = myPs->config.maxVoltage[rangeV];

#if CYCLER_TYPE == LINEAR_CYC || CYCLER_TYPE == CAN_CYC
	para = 1.0;
#else
	if(myCh->ChAttribute.opType == P1){	//180611 add 
		para = 2.0;
	}else{
		para = 1.0;
	}
#endif
	
	max_val2 = myPs->config.maxCurrent[rangeI]*para;
	min_val2 = myPs->config.minCurrent[rangeI]*para;
	div = 15;

	if(stepType == STEP_CHARGE) {
		cCalCmdV(bd, ch, val1, 15, rangeV);
		cCalCmdI(bd, ch, min_val2, 15, rangeI);
	} else if(stepType == STEP_DISCHARGE 
		|| stepType == STEP_Z) {
		cCalCmdV(bd, ch, val1*(-1), 15, rangeV);
		cCalCmdI(bd, ch, max_val2, 15, rangeI);
	}
}

//20190605 KHK----------------------------------------
void ref_output(int bd, int ch, long Vref, long Iref, int div, int rangeV, int rangeI, int mode)
{
	long preVref, preIref;

	myCh = &(myData->bData[bd].cData[ch]);

	preVref = myCh->misc.preVref;
	preIref = myCh->misc.preIref;

	if(Vref >= 0) {
		if(preVref >= 0) {
			if(Iref >= 0) { //charge
				if(preIref >= 0) { //charge -> charge
					cCalCmdV(bd, ch, Vref, div, rangeV);
					cCalCmdI(bd, ch, Iref, div, rangeI);
				} else {
					cCalCmdI(bd, ch, Iref, div, rangeI);
					cCalCmdV(bd, ch, Vref, div, rangeV);
				}
			} else {
				if(preIref >= 0) { //charge -> semi
					cCalCmdV(bd, ch, Vref, div, rangeV);
					cCalCmdI(bd, ch, Iref, div, rangeI);
				} else { //semi -> semi
					cCalCmdV(bd, ch, Vref, div, rangeV);
					cCalCmdI(bd, ch, Iref, div, rangeI);
				}
			}
		} else { //semi
			if(Iref >= 0) { //charge
				if(preIref >= 0) { //semi -> charge
					cCalCmdI(bd, ch, Iref, div, rangeI);
					cCalCmdV(bd, ch, Vref, div, rangeV);
				} else { //semi -> charge
					cCalCmdI(bd, ch, Iref, div, rangeI);
					cCalCmdV(bd, ch, Vref, div, rangeV);
				}
			} else { //semi, discharge
				if(preIref >= 0) { //semi -> discharge 
					cCalCmdI(bd, ch, Iref, div, rangeI);
					cCalCmdV(bd, ch, Vref, div, rangeV);
				} else { //discharge -> semi
					cCalCmdV(bd, ch, Vref, div, rangeV);
					cCalCmdI(bd, ch, Iref, div, rangeI);
				}
			}
		}
	} else { //semi
		if(preVref >= 0) { //charge, discharge
			if(Iref >= 0) { //semi
				if(preIref >= 0) { //charge -> semi
					cCalCmdV(bd, ch, Vref, div, rangeV);
					cCalCmdI(bd, ch, Iref, div, rangeI);
				} else { //discharge -> semi
					cCalCmdI(bd, ch, Iref, div, rangeI);
					cCalCmdV(bd, ch, Vref, div, rangeV);
				}
			} else { //discharge
				if(preIref >= 0) { //charge -> discharge
					cCalCmdV(bd, ch, Vref, div, rangeV);
					cCalCmdI(bd, ch, Iref, div, rangeI);
				} else { //semi -> discharge
					cCalCmdI(bd, ch, Iref, div, rangeI);
					cCalCmdV(bd, ch, Vref, div, rangeV);
				}
			}
		} else {
			if(Iref >= 0) { //semi
				if(preIref >= 0) { //semi -> semi
					cCalCmdI(bd, ch, Iref, div, rangeI);
					cCalCmdV(bd, ch, Vref, div, rangeV);
				} else { //discharge -> semi
					cCalCmdI(bd, ch, Iref, div, rangeI);
					cCalCmdV(bd, ch, Vref, div, rangeV);
				}
			} else { //discharge
				if(preIref >= 0) { //semi -> discharge
					cCalCmdI(bd, ch, Iref, div, rangeI);
					cCalCmdV(bd, ch, Vref, div, rangeV);
				} else { //discharge -> discharge
					cCalCmdV(bd, ch, Vref, div, rangeV);
					cCalCmdI(bd, ch, Iref, div, rangeI);
				}
			}
		}
	}
}

void ref_output_p(int bd, int ch, int parallel_ch, long Vref, long Iref, int div, int rangeV, int rangeI, int mode)
{ //kjg_180521
	long preVref, preIref;

	preVref = myData->bData[bd].cData[ch].misc.preVref;
	preIref = myData->bData[bd].cData[ch].misc.preIref;

	if(Vref >= 0) {
		if(preVref >= 0) {
			if(Iref >= 0) { //charge
				if(preIref >= 0) { //charge -> charge
					cCalCmdV_p(bd, parallel_ch, Vref, div, rangeV);
					cCalCmdI_p(bd, parallel_ch, Iref, div, rangeI);
				} else {
					cCalCmdI_p(bd, parallel_ch, Iref, div, rangeI);
					cCalCmdV_p(bd, parallel_ch, Vref, div, rangeV);
				}
			} else {
				if(preIref >= 0) { //charge -> semi
					cCalCmdV_p(bd, parallel_ch, Vref, div, rangeV);
					cCalCmdI_p(bd, parallel_ch, Iref, div, rangeI);
				} else { //semi -> semi
					cCalCmdV_p(bd, parallel_ch, Vref, div, rangeV);
					cCalCmdI_p(bd, parallel_ch, Iref, div, rangeI);
				}
			}
		} else { //semi
			if(Iref >= 0) { //charge
				if(preIref >= 0) { //semi -> charge
					cCalCmdI_p(bd, parallel_ch, Iref, div, rangeI);
					cCalCmdV_p(bd, parallel_ch, Vref, div, rangeV);
				} else { //semi -> charge
					cCalCmdI_p(bd, parallel_ch, Iref, div, rangeI);
					cCalCmdV_p(bd, parallel_ch, Vref, div, rangeV);
				}
			} else { //semi, discharge
				if(preIref >= 0) { //semi -> discharge 
					cCalCmdI_p(bd, parallel_ch, Iref, div, rangeI);
					cCalCmdV_p(bd, parallel_ch, Vref, div, rangeV);
				} else { //discharge -> semi
					cCalCmdV_p(bd, parallel_ch, Vref, div, rangeV);
					cCalCmdI_p(bd, parallel_ch, Iref, div, rangeI);
				}
			}
		}
	} else { //semi
		if(preVref >= 0) { //charge, discharge
			if(Iref >= 0) { //semi
				if(preIref >= 0) { //charge -> semi
					cCalCmdV_p(bd, parallel_ch, Vref, div, rangeV);
					cCalCmdI_p(bd, parallel_ch, Iref, div, rangeI);
				} else { //discharge -> semi
					cCalCmdI_p(bd, parallel_ch, Iref, div, rangeI);
					cCalCmdV_p(bd, parallel_ch, Vref, div, rangeV);
				}
			} else { //discharge
				if(preIref >= 0) { //charge -> discharge
					cCalCmdV_p(bd, parallel_ch, Vref, div, rangeV);
					cCalCmdI_p(bd, parallel_ch, Iref, div, rangeI);
				} else { //semi -> discharge
					cCalCmdI_p(bd, parallel_ch, Iref, div, rangeI);
					cCalCmdV_p(bd, parallel_ch, Vref, div, rangeV);
				}
			}
		} else {
			if(Iref >= 0) { //semi
				if(preIref >= 0) { //semi -> semi
					cCalCmdI_p(bd, parallel_ch, Iref, div, rangeI);
					cCalCmdV_p(bd, parallel_ch, Vref, div, rangeV);
				} else { //discharge -> semi
					cCalCmdI_p(bd, parallel_ch, Iref, div, rangeI);
					cCalCmdV_p(bd, parallel_ch, Vref, div, rangeV);
				}
			} else { //discharge
				if(preIref >= 0) { //semi -> discharge
					cCalCmdI_p(bd, parallel_ch, Iref, div, rangeI);
					cCalCmdV_p(bd, parallel_ch, Vref, div, rangeV);
				} else { //discharge -> discharge
					cCalCmdV_p(bd, parallel_ch, Vref, div, rangeV);
					cCalCmdI_p(bd, parallel_ch, Iref, div, rangeI);
				}
			}
		}
	}
}

void cActiveSwitch(void)
{
	switch(myPs->config.hwSpec) {
		case L_5V_250A_R1:
			cActiveSwitch_L1();
			break;
		default:
			break;
	}
}

void cActiveSwitch_L1(void)
{
	int i, bd, ch, mode;
	int rangeV, rangeI, div;
	long val1, val2, max_val1, min_val1, max_val2, min_val2;
	S_CH_STEP_INFO step;

	for(i=0; i < myPs->config.installedCh; i++) {
		bd = i / myPs->config.chPerBd;
		ch = i % myPs->config.chPerBd;

		myCh = &(myData->bData[bd].cData[ch]);

		step = step_info(bd, ch);

		val1 = step.refV;
		val2 = step.refI;

		rangeV = (int)step.rangeV;
		rangeI = (int)step.rangeI;
		mode = (int)step.mode;

		max_val1 = myPs->config.maxVoltage[rangeV];
		min_val1 = myPs->config.maxVoltage[rangeV] * (-1);
		max_val2 = (long)((float)myPs->config.maxCurrent[rangeI] * (0.1));
		min_val2 = (long)((float)myPs->config.minCurrent[rangeI] * (0.1));
		div = 15;

		switch(myCh->misc.semiSwitchState) {
			case SEMI_IDLE:
				switch(myCh->signal[C_SIG_ACTIVE_SWITCH]) {
					case P1: //SEMI_PRE
						cCalCmdI(bd, ch, 0, div, rangeI);
						myCh->signal[C_SIG_ACTIVE_SWITCH] = P2;
						break;
					case P2:
						myCh->signal[C_SIG_ACTIVE_SWITCH] = P3;
						break;
					case P3:
						//cCalCmdV(bd, ch, min_val1, div, rangeV);
						cCalCmdV(bd, ch, max_val1, div, rangeV);
						myCh->signal[C_SIG_ACTIVE_SWITCH] = P4;
						break;
					case P4:
						//cCalCmdI(bd, ch, max_val2, div, rangeI);
						cCalCmdI(bd, ch, min_val2, div, rangeI);
						myCh->misc.semiSwitchState = SEMI_PRE;
						myCh->signal[C_SIG_ACTIVE_SWITCH] = P0;
						break;
					default:
						break;
				}
				break;
			case SEMI_PRE:
				switch(myCh->signal[C_SIG_ACTIVE_SWITCH]) {
					case P0:
						break;
					case P1: //SEMI_PRE
						cCalCmdI(bd, ch, 0, div, rangeI);
						myCh->signal[C_SIG_ACTIVE_SWITCH] = P2;
						break;
					case P2:
						myCh->signal[C_SIG_ACTIVE_SWITCH] = P3;
						break;
					case P3:
						//cCalCmdV(bd, ch, min_val1, div, rangeV);
						cCalCmdV(bd, ch, max_val1, div, rangeV);
						myCh->signal[C_SIG_ACTIVE_SWITCH] = P4;
						break;
					case P4:
						//cCalCmdI(bd, ch, max_val2, div, rangeI);
						cCalCmdI(bd, ch, min_val2, div, rangeI);
						myCh->misc.semiSwitchState = SEMI_PRE;
						myCh->signal[C_SIG_ACTIVE_SWITCH] = P0;
						break;
					case P11: //SEMI_V_P
						cCalCmdI(bd, ch, 0, div, rangeI);
						myCh->signal[C_SIG_ACTIVE_SWITCH] = P12;
						break;
					case P12:
						myCh->signal[C_SIG_ACTIVE_SWITCH] = P13;
						break;
					case P13:
						cCalCmdV(bd, ch, val1, 5, rangeV);
						cCalCmdI(bd, ch, min_val2, div, rangeI);
						myCh->signal[C_SIG_ACTIVE_SWITCH] = P14;
						break;
					case P14:
						cCalCmdI(bd, ch, val2, 5, rangeI);
						myCh->misc.semiSwitchState = SEMI_V_P;
						myCh->signal[C_SIG_ACTIVE_SWITCH] = P0;
						break;
					case P21: //SEMI_V_N
						cCalCmdI(bd, ch, max_val2, div, rangeI);
						myCh->signal[C_SIG_ACTIVE_SWITCH] = P31;
						break;
					case P22:
						cCalCmdI(bd, ch, val2, 5, rangeI);
						myCh->misc.semiSwitchState = SEMI_V_N;
						myCh->signal[C_SIG_ACTIVE_SWITCH] = P0;
						break;
					default:
						if(myCh->signal[C_SIG_ACTIVE_SWITCH] >= P60) { //delay
							cCalCmdV(bd, ch, val1, 5, rangeV);
							myCh->signal[C_SIG_ACTIVE_SWITCH] = P22;
						} else {
							myCh->signal[C_SIG_ACTIVE_SWITCH]++;
						}
						break;
				}
				break;
			case SEMI_V_P:
				switch(myCh->signal[C_SIG_ACTIVE_SWITCH]) {
					case P1: //SEMI_PRE
						cCalCmdI(bd, ch, 0, div, rangeI);
						myCh->signal[C_SIG_ACTIVE_SWITCH] = P2;
						break;
					case P2:
						myCh->signal[C_SIG_ACTIVE_SWITCH] = P3;
						break;
					case P3:
						//cCalCmdV(bd, ch, min_val1, div, rangeV);
						cCalCmdV(bd, ch, max_val1, div, rangeV);
						myCh->signal[C_SIG_ACTIVE_SWITCH] = P4;
						break;
					case P4:
						//cCalCmdI(bd, ch, max_val2, div, rangeI);
						cCalCmdI(bd, ch, min_val2, div, rangeI);
						myCh->misc.semiSwitchState = SEMI_PRE;
						myCh->signal[C_SIG_ACTIVE_SWITCH] = P0;
						break;
					case P11: //SEMI_V_P
						//cCalCmdI(bd, ch, 0, div, rangeI);
						myCh->signal[C_SIG_ACTIVE_SWITCH] = P12;
						break;
					case P12:
						cCalCmdV(bd, ch, val1, 5, rangeV);
						myCh->signal[C_SIG_ACTIVE_SWITCH] = P13;
						break;
					case P13:
						cCalCmdI(bd, ch, val2, 5, rangeI);
						myCh->misc.semiSwitchState = SEMI_V_P;
						myCh->signal[C_SIG_ACTIVE_SWITCH] = P0;
						break;
					case P21: //SEMI_V_N
						cCalCmdI(bd, ch, 0, div, rangeI);
						myCh->signal[C_SIG_ACTIVE_SWITCH] = P22;
						break;
					case P22:
						cCalCmdV(bd, ch, min_val1, div, rangeV);
						myCh->signal[C_SIG_ACTIVE_SWITCH] = P23;
						break;
					case P23:
						cCalCmdV(bd, ch, val1, 5, rangeV);
						cCalCmdI(bd, ch, max_val2, div, rangeI);
						myCh->signal[C_SIG_ACTIVE_SWITCH] = P24;
						break;
					case P24:
						cCalCmdI(bd, ch, val2, 5, rangeI);
						myCh->misc.semiSwitchState = SEMI_V_N;
						myCh->signal[C_SIG_ACTIVE_SWITCH] = P0;
						break;
					default:
						break;
				}
				break;
			case SEMI_V_N:
				switch(myCh->signal[C_SIG_ACTIVE_SWITCH]) {
					case P1: //SEMI_PRE
						cCalCmdI(bd, ch, 0, div, rangeI);
						myCh->signal[C_SIG_ACTIVE_SWITCH] = P2;
						break;
					case P2:
						myCh->signal[C_SIG_ACTIVE_SWITCH] = P3;
						break;
					case P3:
						//cCalCmdV(bd, ch, min_val1, div, rangeV);
						cCalCmdV(bd, ch, max_val1, div, rangeV);
						myCh->signal[C_SIG_ACTIVE_SWITCH] = P4;
						break;
					case P4:
						//cCalCmdI(bd, ch, max_val2, div, rangeI);
						cCalCmdI(bd, ch, min_val2, div, rangeI);
						myCh->misc.semiSwitchState = SEMI_PRE;
						myCh->signal[C_SIG_ACTIVE_SWITCH] = P0;
						break;
					case P11: //SEMI_V_P
						cCalCmdI(bd, ch, 0, div, rangeI);
						myCh->signal[C_SIG_ACTIVE_SWITCH] = P12;
						break;
					case P12:
						cCalCmdV(bd, ch, max_val1, div, rangeV);
						myCh->signal[C_SIG_ACTIVE_SWITCH] = P13;
						break;
					case P13:
						cCalCmdV(bd, ch, val1, 5, rangeV);
						cCalCmdI(bd, ch, min_val2, div, rangeI);
						myCh->signal[C_SIG_ACTIVE_SWITCH] = P14;
						break;
					case P14:
						cCalCmdI(bd, ch, val2, 5, rangeI);
						myCh->misc.semiSwitchState = SEMI_V_P;
						myCh->signal[C_SIG_ACTIVE_SWITCH] = P0;
						break;
					case P21: //SEMI_V_N
						//cCalCmdI(bd, ch, 0, div, rangeI);
						myCh->signal[C_SIG_ACTIVE_SWITCH] = P22;
						break;
					case P22:
						cCalCmdV(bd, ch, val1, 5, rangeV);
						myCh->signal[C_SIG_ACTIVE_SWITCH] = P23;
						break;
					case P23:
						cCalCmdI(bd, ch, val2, 5, rangeI);
						myCh->misc.semiSwitchState = SEMI_V_N;
						myCh->signal[C_SIG_ACTIVE_SWITCH] = P0;
						break;
					default:
						break;
				}
				break;
			default:
				break;
		}
	}
}

void CompWriteCh(int bd, int ch)
{
	int addr, base_addr, addr_step, addr_div, da_h_byte, dav_l;
    double tmp=0;
	U_ADDA ref;

#if CYCLER_TYPE == DIGITAL_CYC
	return;	//180611 add
#endif
	if(myPs->config.hwSpec != L_5V_150A_R2_P) return;
	myCh = &(myData->bData[bd].cData[ch]);
	
	base_addr = myPs->addr.main[BASE_ADDR];
	addr_step = myPs->addr.main[ADDR_STEP];
	if(myPs->config.MainBdType == CPLD_TYPE) 
		addr_div = myPs->addr.main[ADDR_DIV] + 0x10;
	else
		addr_div = myPs->addr.main[ADDR_DIV];
	da_h_byte = myPs->addr.main[DA_H_BYTE];
	dav_l = myPs->addr.main[DAV_L];
	
	if(myCh->ChCompData.useFlag && myCh->ChAttribute.chNo_master != P0) {
		tmp = (double)(myCh->ChCompData.compPlus * 0.0032767);
		if(tmp == 0.0) tmp = 32767.0;
		if(tmp > 32767.0) tmp = 32767.0;
		if(tmp < -32767.0) tmp = -32767.0;
		ref.val = (short int)(tmp);
		addr = base_addr + (addr_step * (bd+1)) + da_h_byte;
		if(ch >= 8)
			addr = addr + addr_step;
   		outb(ref.byte[1], addr);
		addr = (base_addr + (addr_step * (bd+1)) + addr_div);
		if(ch >= 8)
			addr = addr + addr_step;
		outb(0x01, addr);
		addr = base_addr + (addr_step * (bd+1)) + dav_l + (ch%8);
		if(ch >= 8)
			addr = addr + addr_step;
   		outb(ref.byte[0], addr);
		addr = (base_addr + (addr_step * (bd+1)) + addr_div);
		if(ch >= 8)
			addr = addr + addr_step;
		outb(0x00, addr);
		
		tmp = (double)(myCh->ChCompData.compMinus * 0.0032767);
		if(tmp == 0.0) tmp = 32767.0;
		if(tmp > 32767.0) tmp = 32767.0;
		if(tmp < -32767.0) tmp = -32767.0;
		ref.val = (short int)(tmp);
		addr = base_addr + (addr_step * (bd+1)) + da_h_byte;
		if(ch >= 8)
			addr = addr + addr_step;
   		outb(ref.byte[1], addr);
		addr = (base_addr + (addr_step * (bd+1)) + addr_div);
		if(ch >= 8)
			addr = addr + addr_step;
		outb(0x02, addr);
		addr = base_addr + (addr_step * (bd+1)) + dav_l + (ch%8);
		if(ch >= 8)
			addr = addr + addr_step;
   		outb(ref.byte[0], addr);
		addr = (base_addr + (addr_step * (bd+1)) + addr_div);
		if(ch >= 8)
			addr = addr + addr_step;
		outb(0x00, addr);
	} else {
		tmp = 32767.0;
		ref.val = (short int)(tmp);
		addr = base_addr + (addr_step * (bd+1)) + da_h_byte;
		if(ch >= 8)
			addr = addr + addr_step;
   		outb(ref.byte[1], addr);
		addr = (base_addr + (addr_step * (bd+1)) + addr_div);
		if(ch >= 8)
			addr = addr + addr_step;
		outb(0x01, addr);
		addr = base_addr + (addr_step * (bd+1)) + dav_l + (ch%8);
		if(ch >= 8)
			addr = addr + addr_step;
   		outb(ref.byte[0], addr);
		addr = (base_addr + (addr_step * (bd+1)) + addr_div);
		if(ch >= 8)
			addr = addr + addr_step;
		outb(0x00, addr);
		
		tmp = 32767.0;
		ref.val = (short int)(tmp);
		addr = base_addr + (addr_step * (bd+1)) + da_h_byte;
		if(ch >= 8)
			addr = addr + addr_step;
   		outb(ref.byte[1], addr);
		addr = (base_addr + (addr_step * (bd+1)) + addr_div);
		if(ch >= 8)
			addr = addr + addr_step;
		outb(0x02, addr);
		addr = base_addr + (addr_step * (bd+1)) + dav_l + (ch%8);
		if(ch >= 8)
			addr = addr + addr_step;
   		outb(ref.byte[0], addr);
		addr = (base_addr + (addr_step * (bd+1)) + addr_div);
		if(ch >= 8)
			addr = addr + addr_step;
		outb(0x00, addr);

	}
}

#if AUX_CONTROL == 1
	#if NETWORK_VERSION >= 4103
int cEndCond_Aux(int bd, int ch)
{
	unsigned long advStepNo;
    int i, j, auxNo, map, rtn, stepType;
	long val2;

	rtn = NORMAL_COND;
	if(myPs->config.installedTemp == 0
		&& myPs->config.installedAuxV == 0) return 0;

	auxNo = myPs->config.installedTemp + myPs->config.installedAuxV;
	if(auxNo > MAX_AUX_DATA) auxNo = MAX_AUX_DATA;

	advStepNo = myCh->misc.advStepNo;
	stepType = myPs->testCond[bd][ch].step[advStepNo].type;

	for(i=0; i < auxNo; i++) {
		if((ch+1) != myData->auxSetData[i].chNo) continue;

		j = myData->auxSetData[i].auxChNo - 1;
		if(j < 0) continue;

		if(myData->auxSetData[i].auxType == 0) { //aux temperature
			val2 = myData->AnalogMeter.temp[j].temp;

			rtn = cEndCond_Aux_step(bd, ch, advStepNo, val2, i);
		} else if(myData->auxSetData[i].auxType == 1) { //aux voltage
			map = myData->daq.misc.map[j];
			if(map < 0) continue;

			val2 = myData->daq.op.ch_vsens[map];

			rtn = cEndCond_Aux_step(bd, ch, advStepNo, val2, i);
		}
		if(rtn > 0){
			if(stepType == STEP_REST){
				myCh->signal[C_SIG_OUT_SWITCH] = P1;
				myCh->signal[C_SIG_RANGE_SWITCH] = P1;
			}
			return rtn;
		}
	}
	return rtn;
}

int cEndCond_Aux_step(int bd, int ch, int advStepNo, long val2, int aux_idx)
{
	int rtnCode = 0, func, func_div;
	long factor;

	if(myData->auxSetData[aux_idx].auxType == 0) { //temperature
		factor = 1;
	} else { //voltage
		factor = 1000;
	}
	for(func = 0; func < MAX_AUX_FUNCTION; func++) {
		func_div = myPs->testCond[bd][ch].step[advStepNo].auxType[func];
		if(func_div != AUX_V_FUNC_DIV_NONE){
			if((int)myData->auxSetData[aux_idx].function_div1 == func_div
				|| (int)myData->auxSetData[aux_idx].function_div2 == func_div
				|| (int)myData->auxSetData[aux_idx].function_div3 == func_div) {
					
				rtnCode = aux_end_code_check(bd, ch, aux_idx, func, val2, factor);
			}
			if(rtnCode > 0){
			myCh->op.code = rtnCode;
			return END_COND;
			}
		}
		rtnCode = aux_end_code_check2(bd, ch, aux_idx, func, val2, factor);

		if(rtnCode > 0){
			myCh->op.code = rtnCode;
			return END_COND;
		}
	}
	return NORMAL_COND;
}

int	aux_end_code_check(int bd, int ch, int aux_idx, int func, long val1_a, long factor)
{
	unsigned long advStepNo;
	long val1_b, rtn;

	advStepNo = myData->bData[bd].cData[ch].misc.advStepNo;

	val1_b = myPs->testCond[bd][ch].step[advStepNo].endAuxValue[func] * factor;
	rtn = NORMAL_COND;
	switch(myPs->testCond[bd][ch].step[advStepNo].auxCompareType[func]){
		case COMP_NONE:
			rtn = 0;
			break;
		case COMP_LESS_THAN: //val1_a < val1_b
			if(val1_b == 0) {
				rtn = -1;
			} else {
				if(val1_a < val1_b) rtn = 1;
				else rtn = -1;
			}
			break;
		case COMP_LESS_THAN_OR_EQUAL_TO: //val1_a <= val1_b
			if(val1_b == 0) {
				rtn = -1;
			} else {
				if(val1_a <= val1_b) rtn = 2;
				else rtn = -1;
			}
			break;
		case COMP_GREATER_THAN: //val1_a > val1_b
			if(val1_b == 0) {
				rtn = -1;
			} else {
				if(val1_a > val1_b) rtn = 3;
				else rtn = -1;
			}
			break;
		case COMP_GREATER_THAN_OR_EQUAL_TO: //val1_a >= val1_b
			if(val1_b == 0) {
				rtn = -1;
			} else {
				if(val1_a >= val1_b) rtn = 4;
				else rtn = -1;
			}
			break;
		case COMP_EQUAL_TO: //val1_a = val1_b
			if(val1_b == 0) {
				rtn = -1;
			} else {
				if(val1_a == val1_b) rtn = 5;
				else rtn = -1;
			}
			break;
		case COMP_NOT_EQUAL_TO: //val1_a != val1_b
			rtn = 0;
			break;
		default:
			rtn = 0;
			break;
	}
	if(rtn <= 0){
		myData->auxMisc.endCnt[aux_idx][func] = 0;
		return 0;
	}

	rtn = NORMAL_COND;
	myData->auxMisc.endCnt[aux_idx][func]++;
	if(myData->auxMisc.endCnt[aux_idx][func] >= 3){
		myData->auxMisc.endCnt[aux_idx][func] = 0;
		if(myData->auxSetData[aux_idx].auxType == 0) { //temperature
			rtn = C_END_AUX_TEMP;
		}else{
			rtn = C_END_AUX_VOLTAGE;
		}
		if(myPs->testCond[bd][ch].step[advStepNo].auxGoto[func] > 0){
			myData->auxMisc.auxGoto[bd][ch] 
				= myPs->testCond[bd][ch].step[advStepNo].auxGoto[func];
		}else{
			myData->auxMisc.auxGoto[bd][ch] = 0;
		}
	}
	return rtn;
}

int	aux_end_code_check2(int bd, int ch, int aux_idx, int func, long val_1, long factor)
{
	long val_2, val_3, rtn;
	
	rtn = NORMAL_COND;

	val_2 = myData->auxSetData[aux_idx].end_upper;
	val_3 = myData->auxSetData[aux_idx].end_lower;

	if(val_2 != 0){
		if(val_1 >= val_2)
			myData->auxMisc.auxEndCnt[aux_idx]++;
		if(myData->auxMisc.auxEndCnt[aux_idx] >= MAX_ERROR_CNT) {
			myData->auxMisc.auxEndCnt[aux_idx] = 0;
			myCh->misc.tmpState = myCh->op.state;
			myCh->misc.tmpCode = myCh->op.code;
			rtn = 6;
		}
	}
	if(val_3 != 0){
		if(val_1 <= val_3)
			myData->auxMisc.auxEndCnt[aux_idx]++;
		if(myData->auxMisc.auxEndCnt[aux_idx] >= MAX_ERROR_CNT) {
			myData->auxMisc.auxEndCnt[aux_idx] = 0;
			myCh->misc.tmpState = myCh->op.state;
			myCh->misc.tmpCode = myCh->op.code;
			rtn = 7;
		}
	}
	if(rtn >= 6) {	
		if(myData->auxSetData[aux_idx].auxType == 0) { //temperature
			if(rtn == 6){
				rtn = C_END_AUX_TEMP_UPPER;
			}
			if(rtn == 7){
				rtn = C_END_AUX_TEMP_LOWER;
			}
		}else{
			if(rtn == 6){
				rtn = C_END_AUX_VOLTAGE_UPPER;
			}
			if(rtn == 7){
				rtn = C_END_AUX_VOLTAGE_LOWER;
			}
		}
		return rtn;
	}
	return rtn;
}
	#endif
#endif

#if MACHINE_TYPE == 2
void DIO_BD_Control(int bd, int ch)
{
	int base_addr, dio_addr, use_bd = 0, use_ch = 16;
	unsigned char flag1 = 0, flag2 = 0, output = 0;
	
	if(use_bd < bd || use_ch <= ch)
	{
		return;
	}
	if(((ch+1) % 2) != 0)
		return;
	
	base_addr = myPs->addr.main[BASE_ADDR];
	dio_addr = (base_addr + 0x60) + (ch / 2);

	switch(myData->bData[bd].cData[ch-1].op.state) {
   		case C_IDLE:
   		case C_STANDBY:
		case C_CALI:
				flag1 = 0x0;
				break;
		case C_RUN:
			switch(myData->bData[bd].cData[ch-1].op.type) {
				case STEP_CHARGE:
						flag1 = 0x1;
						break;
				case STEP_DISCHARGE:
						flag1 = 0x2;
						break;
				case STEP_REST:
						flag1 = 0x3;
						break;
				case STEP_OCV:
				case STEP_Z:
				case STEP_USER_PATTERN:
				case STEP_USER_MAP:
				case STEP_BALANCE:
						break;
				case STEP_END:
						flag1 = 0x0;
						break;
				default: //STEP_ADV_CYCLE, STEP_LOOP, STEP_END
					break;
			}
			break;
		case C_PAUSE:
				if(myData->bData[bd].cData[ch-1].op.code >= C_FAULT_OT
					&& myData->bData[bd].cData[ch-1].op.code <= C_FAULT_MAIN_EMG){
					flag1 = 0xf;
				}else{
					flag1 = 0xe;
				}
				break;
    	default: break;
	}
	switch(myData->bData[bd].cData[ch].op.state) {
   		case C_IDLE:
   		case C_STANDBY:
		case C_CALI:
				flag2 = 0x0;
				break;
		case C_RUN:
			switch(myData->bData[bd].cData[ch].op.type) {
				case STEP_CHARGE:
						flag2 = 0x1;
						break;
				case STEP_DISCHARGE:
						flag2 = 0x2;
						break;
				case STEP_REST:
						flag2 = 0x3;
						break;
				case STEP_OCV:
				case STEP_Z:
				case STEP_USER_PATTERN:
				case STEP_USER_MAP:
				case STEP_BALANCE:
						break;
				case STEP_END:
						flag2 = 0x0;
						break;
				default: //STEP_ADV_CYCLE, STEP_LOOP, STEP_END
					break;
			}
			break;
		case C_PAUSE:
				if(myData->bData[bd].cData[ch].op.code >= C_FAULT_OT
					&& myData->bData[bd].cData[ch].op.code <= C_FAULT_MAIN_EMG){
					flag2 = 0xf;
				}else{
					flag2 = 0xe;
				}
				break;
    	default: break;
	}
	output = flag1 + (flag2 << 4);
	
	outb(output, dio_addr);
}
#endif
//20190801 oys add : Convert C_rate to I value process
long Convert_C_rate_to_I_value(int bd, int ch, long c_rate) {
	long rtn = 0, cellCapacity;
	
	myCh = &(myData->bData[bd].cData[ch]);

	if(myCh->misc.cRateUseFlag == P0) return c_rate;

	cellCapacity = myPs->testCond[bd][ch].step[0].endP;
	if(cellCapacity == 0) return c_rate;

	if(myCh->misc.standardC_Flag == P1) {
		rtn	= myCh->misc.standardC * ((float)c_rate / 1000);
	} else {
		rtn	= cellCapacity * ((float)c_rate / 1000);
	}
	return rtn;
}

//20190826 oys add : SAMSUNG SDI Delta capacity check process
int deltaCapacityCheck(int bd, int ch, int rtn, unsigned long advStepNo) {
	int selectCycle = 0;
	unsigned short advCycleStep;
	long deltaChargeCap, deltaDischargeCap, c_cap_diff = 0, d_cap_diff = 0;
	int gotoStepCount = 0;	//kjc_200413
	#ifdef _SDI_SAFETY_V1	
	int loopStepNo = 0;
	int cycleStepNo = 0;	//kjc_200413
	int i, j, k;	//kjc_200413
		#if AUX_CONTROL == 1
		int l = 0;
		#endif
	#endif
	
	myCh = &(myData->bData[bd].cData[ch]);

	if(VENDER != 2) return rtn;
	if(rtn != END_COND) return rtn; 

	//SAMSUNG SDI -> 2nd Cycle Loop Capacity
	advCycleStep = myCh->misc.advCycleStep;
	deltaChargeCap = myData->mData.testCond[bd][ch]
						.step[advCycleStep].faultUpperC;
	deltaDischargeCap = myData->mData.testCond[bd][ch]
						.step[advCycleStep].faultLowerC;
	selectCycle = myData->mData.testCond[bd][ch]
						.step[advCycleStep].faultUpperZ;
	#ifdef _SDI_SAFETY_V1	
	//kjc_200413_s
	//Step movement count check when end condition it met
	for(i = advStepNo; i < myData->mData.testCond[bd][ch].header.totalStep; i++){
		if(myData->mData.testCond[bd][ch].step[i].type == STEP_LOOP){
			loopStepNo = i;
			break;
		}
	}

	for(j = loopStepNo; j > 0; j--){
		if(myData->mData.testCond[bd][ch].step[j].type == STEP_ADV_CYCLE){
			cycleStepNo = j;
			break;
		}
	}
	for(k = cycleStepNo; k < loopStepNo; k ++){
		#if AUX_CONTROL == 1
		for(l = 0 ; l < MAX_AUX_FUNCTION; l++){
			if(myPs->testCond[bd][ch].step[k].auxGoto[l] != 0){
			gotoStepCount ++ ;
			}
		}
		#endif
		if(myPs->testCond[bd][ch].step[k].endVGoto != 0
		|| myPs->testCond[bd][ch].step[k].endIGoto != 0
		|| myPs->testCond[bd][ch].step[k].endTCVGoto != 0
		|| myPs->testCond[bd][ch].step[k].endTempGoto != 0
		|| myPs->testCond[bd][ch].step[k].endSocGoto != 0
		|| myPs->testCond[bd][ch].step[k].endTGoto != 0
		|| myPs->testCond[bd][ch].step[k].endCGoto != 0
		|| myPs->testCond[bd][ch].step[k].gotoFlag != 0
		|| myPs->testCond[bd][ch].step[k].endIntegralCGoto != 0
		|| myPs->testCond[bd][ch].step[k].endIntegralWhGoto != 0
		|| myPs->testCond[bd][ch].step[k].advGotoStep != 0){
			gotoStepCount ++ ;
		}
	}
	#endif
	//kjc_200413_e
	//kjc_210825_re
	if(deltaChargeCap != 0 || deltaDischargeCap != 0) {
		if(myCh->misc.currentCycle == selectCycle) {
			if(myCh->ChAttribute.chNo_master == P0) {
				if(myCh->op.type == STEP_CHARGE){
					myData->bData[bd].cData[ch-1].misc.sel_Cyc_C_Cap[advStepNo]
						= myCh->op.charge_ampareHour
						+ myData->bData[bd].cData[ch-1].op.charge_ampareHour;
					myData->bData[bd].cData[ch-1].misc.sel_Cyc_D_Cap[advStepNo] = 0;
				}
				if(myCh->op.type == STEP_DISCHARGE){ 
					myData->bData[bd].cData[ch-1].misc.sel_Cyc_C_Cap[advStepNo] = 0;
					myData->bData[bd].cData[ch-1].misc.sel_Cyc_D_Cap[advStepNo]
						= myCh->op.discharge_ampareHour
						+ myData->bData[bd].cData[ch-1].op.discharge_ampareHour;
				}
				myCh->misc.Standard_Cycle = myCh->misc.currentCycle;
			} else if(myCh->ChAttribute.opType == P0) {
				if(myCh->op.type == STEP_CHARGE){
					myCh->misc.sel_Cyc_C_Cap[advStepNo]
						= myCh->op.charge_ampareHour;
					myCh->misc.sel_Cyc_D_Cap[advStepNo] = 0;
				}
				if(myCh->op.type == STEP_DISCHARGE){ 
					myCh->misc.sel_Cyc_C_Cap[advStepNo] = 0;
					myCh->misc.sel_Cyc_D_Cap[advStepNo]
						= myCh->op.discharge_ampareHour;
				}
				myCh->misc.Standard_Cycle = myCh->misc.currentCycle;
			}
		} else if(myCh->misc.currentCycle > selectCycle) {
			if(myCh->ChAttribute.chNo_master == P0 && gotoStepCount == 0) {	//kjc_200413
				c_cap_diff = myData->bData[bd].cData[ch-1]
								.misc.sel_Cyc_C_Cap[advStepNo]
								- (myCh->op.charge_ampareHour
								+ myData->bData[bd].cData[ch-1]
									.op.charge_ampareHour);
				d_cap_diff = myData->bData[bd].cData[ch-1]
								.misc.sel_Cyc_D_Cap[advStepNo]
								- (myCh->op.discharge_ampareHour
								+ myData->bData[bd].cData[ch-1]
									.op.discharge_ampareHour);
				if(myCh->misc.sel_Cyc_C_Cap[advStepNo] != 0){		//hun_201010
					if(c_cap_diff != 0 && deltaChargeCap != 0) {	//kjc_200427
						if(labs(c_cap_diff)
							> (myData->bData[bd].cData[ch-1]
								.misc.sel_Cyc_C_Cap[advStepNo]
								* (float)deltaChargeCap/10000)) {
							myCh->misc.tmpState = myCh->op.state;
							myCh->misc.tmpCode = myCh->op.code;
							myCh->op.code = C_FAULT_CHARGE_DELTA_CAPACITY;
							Fault_Value_Check(myCh->misc.advStepNo,
							myCh->op.charge_ampareHour + 
							myData->bData[bd].cData[ch-1].op.charge_ampareHour,
						   	myData->bData[bd].cData[ch-1].misc.
							sel_Cyc_C_Cap[advStepNo],c_cap_diff,deltaChargeCap,
						   	myData->bData[bd].cData[ch-1].misc.
							sel_Cyc_C_Cap[advStepNo]*(float)deltaChargeCap/10000
							, myCh->misc.currentCycle,myCh->misc.Standard_Cycle,
						   	0, 0);
							rtn = FAULT_COND;
							return rtn;
						}else{
							//kjc_200413
							myData->bData[bd].cData[ch-1].misc.sel_Cyc_C_Cap[advStepNo]
							= myCh->op.charge_ampareHour + 
								myData->bData[bd].cData[ch-1].misc.sel_Cyc_C_Cap[advStepNo];
							myCh->misc.Standard_Cycle = myCh->misc.currentCycle;
						}
					}
				}else if(myCh->misc.sel_Cyc_D_Cap[advStepNo] != 0){	//hun_201010
					if(d_cap_diff != 0 && deltaDischargeCap != 0) {	//kjc_200427
						if(labs(d_cap_diff)
								> (myData->bData[bd].cData[ch-1]
								.misc.sel_Cyc_D_Cap[advStepNo]
								* (float)deltaDischargeCap/10000)) {
							myCh->misc.tmpState = myCh->op.state;
							myCh->misc.tmpCode = myCh->op.code;
							myCh->op.code = C_FAULT_DISCHARGE_DELTA_CAPACITY;
							Fault_Value_Check(myCh->misc.advStepNo,
							myCh->op.discharge_ampareHour + 
							myData->bData[bd].cData[ch-1].op.
							discharge_ampareHour,
							myData->bData[bd].cData[ch-1].misc.
							sel_Cyc_D_Cap[advStepNo],d_cap_diff,
							deltaDischargeCap, myData->bData[bd].cData[ch-1].
							misc.sel_Cyc_D_Cap[advStepNo]
							*(float)deltaDischargeCap/10000,
						   	myCh->misc.currentCycle, myCh->misc.Standard_Cycle,
							0, 0);
							rtn = FAULT_COND;
							return rtn;
						}else{
							//kjc_200413
							myData->bData[bd].cData[ch-1].misc.sel_Cyc_D_Cap[advStepNo]
							= myCh->op.discharge_ampareHour
								+ myData->bData[bd].cData[ch-1].op.discharge_ampareHour;
							myCh->misc.Standard_Cycle = myCh->misc.currentCycle;
						}
					}
				}
			} else if(myCh->ChAttribute.opType == P0 && gotoStepCount == 0) {	//kjc_200413
				c_cap_diff = myCh->misc.sel_Cyc_C_Cap[advStepNo]
								- myCh->op.charge_ampareHour;
				d_cap_diff = myCh->misc.sel_Cyc_D_Cap[advStepNo]
								- myCh->op.discharge_ampareHour;

				if(myCh->misc.sel_Cyc_C_Cap[advStepNo] != 0){		//hun_201010
					if(c_cap_diff != 0 && deltaChargeCap != 0) {	//kjc_200427
						if(labs(c_cap_diff)
								> (myCh->misc.sel_Cyc_C_Cap[advStepNo]
								* (float)deltaChargeCap/10000)) {
							myCh->misc.tmpState = myCh->op.state;
							myCh->misc.tmpCode = myCh->op.code;
							myCh->op.code = C_FAULT_CHARGE_DELTA_CAPACITY;
							Fault_Value_Check(myCh->misc.advStepNo,
							myCh->op.charge_ampareHour,
						   	myCh->misc.sel_Cyc_C_Cap[advStepNo],c_cap_diff,
							deltaChargeCap, myCh->misc.sel_Cyc_C_Cap[advStepNo]
							* (float)deltaChargeCap/10000, 
							myCh->misc.currentCycle, myCh->misc.Standard_Cycle,
							0, 0);
							rtn = FAULT_COND;
							return rtn;
						}else{
							//kjc_200413
							myCh->misc.sel_Cyc_C_Cap[advStepNo]
								= myCh->op.charge_ampareHour;
							myCh->misc.Standard_Cycle = myCh->misc.currentCycle;
						}
					}
				}else if(myCh->misc.sel_Cyc_D_Cap[advStepNo] != 0){	//hun_201010
					if(d_cap_diff != 0 && deltaDischargeCap != 0) {	//kjc_200427
						if(labs(d_cap_diff)
								> (myCh->misc.sel_Cyc_D_Cap[advStepNo]
								* (float)deltaDischargeCap/10000)) {
							myCh->misc.tmpState = myCh->op.state;
							myCh->misc.tmpCode = myCh->op.code;
							myCh->op.code = C_FAULT_DISCHARGE_DELTA_CAPACITY;
							Fault_Value_Check(myCh->misc.advStepNo,
							myCh->op.discharge_ampareHour,
						   	myCh->misc.sel_Cyc_D_Cap[advStepNo],d_cap_diff,
							deltaDischargeCap, 
							myCh->misc.sel_Cyc_D_Cap[advStepNo]
							* (float)deltaDischargeCap/10000, 
							myCh->misc.currentCycle, myCh->misc.Standard_Cycle,
							0, 0);
							rtn = FAULT_COND;
							return rtn;
						}else{
							//kjc_200413
							myCh->misc.sel_Cyc_D_Cap[advStepNo]
								= myCh->op.discharge_ampareHour;
							myCh->misc.Standard_Cycle = myCh->misc.currentCycle;
						}
					}
				}
			}
		}
	}
	return rtn;
}




#ifdef _TRACKING_MODE
long cFind_SOC_Tracking_Current(int bd, int ch)
{
	unsigned char type, rpt_step, stepType;
	int i, j, tmp, tmp1, check_i;
	long temp=0, SOC=0, val=0, val1, val2, diff, diff_current, soc1, soc2;
	long set_Ah, set_soc, Current_Ah = 0;
	float rptSOC_1, rptSOC_2;
	float A, B;
	
	set_Ah = labs(myPs->testCond[bd][ch].safety.rptsoc);
	rpt_step = myData->bData[bd].cData[ch].misc.socTrackingStep;
	stepType = myCh->op.type;

	if(stepType == STEP_CHARGE){
		Current_Ah = myCh->op.charge_ampareHour;
	}else if(stepType == STEP_DISCHARGE){
		Current_Ah = myCh->op.discharge_ampareHour;
	}else if(stepType == STEP_USER_PATTERN){
		Current_Ah = myCh->op.charge_ampareHour - myCh->op.discharge_ampareHour;
		if(Current_Ah < 0) Current_Ah = 0;
	}

	if(set_Ah != 0){
		set_soc = labs(myPs->testCond[bd][ch].safety.soc);
		rptSOC_1 = (float)set_Ah;
		if(set_soc == 1000){
			rptSOC_2 = (float)rptSOC_1;
			myCh->op.rptSOC = rptSOC_2;
		}else{
			rptSOC_2 = (float)rptSOC_1 * (float)(1000.0 / (1000.0 - set_soc));
			myCh->op.rptSOC = rptSOC_2;
		}
		SOC = (double)(Current_Ah * 10000.0)
			 / (double)myCh->op.rptSOC;
		myCh->op.SOC = SOC;
	}else{
		set_soc = myPs->testCond[bd][ch].step[rpt_step].rptSOC;
		rptSOC_1 = (float)myCh->op.ampareHour_SOC;
		if(set_soc == 1000){
			rptSOC_2 = rptSOC_1;
			myCh->op.rptSOC = rptSOC_2;
		}else{
			rptSOC_2 = (float)rptSOC_1 * (float)(1000.0 / (1000.0 - set_soc));
			myCh->op.rptSOC = rptSOC_2;
		}
		SOC = (double)(Current_Ah * 10000.0)
			 / (double)(myCh->op.rptSOC);
		myCh->op.SOC = SOC;
	}
	
	temp = 0;
	if(myData->mData.config.installedTemp != 0){
		temp = myData->bData[bd].cData[ch].misc.AuxTemp_max / 10;
	}else{	
		temp = myData->bData[bd].cData[ch].op.temp / 10;
	}

	type = 1;
	tmp = myPs->testCond[bd][ch].SOC_tracking[type].soc_num;
	if(tmp > (MAX_SOC_TRACKING_DATA -5)) tmp = MAX_SOC_TRACKING_DATA - 5; //25 ->rewrite 210720
	if(tmp <= 0) tmp = 1;

	for(i=0; i < tmp; i++) { // SOC
		if(SOC < myPs->testCond[bd][ch].SOC_tracking[type].SOC[i]) break;
	}
	i = i -1;
	if(i < 0){
	   	i = 0;
	}
	check_i = i;
	if(check_i >= myPs->testCond[bd][ch].SOC_tracking[type].soc_num-1){
		check_i = myPs->testCond[bd][ch].SOC_tracking[type].soc_num-2;
		if(check_i < 0) 
			check_i = 0;
	}

	tmp = myPs->testCond[bd][ch].SOC_tracking[type].temp_num;
//	if(tmp > MAX_SOC_TRACKING_DATA tmp = MAX_SOC_TRACKING_DATA; //20
	if(tmp > (MAX_SOC_TRACKING_DATA-10)) tmp = MAX_SOC_TRACKING_DATA - 10; //20 ->rewrite 210720
	if(tmp <= 0) tmp = 1;

	for(j=0; j < tmp; j++) { // Temp
		if(temp < myPs->testCond[bd][ch].SOC_tracking[type].temp[j]) break;
	}
	j = j - 1;
	if(j < 0){
		j = 0;
	}
	tmp1 = myPs->testCond[bd][ch].SOC_tracking[type].soc_num;
	tmp = myPs->testCond[bd][ch].SOC_tracking[type].temp_num;
	if(temp > myPs->testCond[bd][ch].SOC_tracking[type].temp[tmp-1]){
		temp = myPs->testCond[bd][ch].SOC_tracking[type].temp[tmp-1];
		j = tmp-2;
		if(SOC <= myPs->testCond[bd][ch].SOC_tracking[type].SOC[0]){
			i = 0;
			val1 =  (long)(temp * myPs->testCond[bd][ch].SOC_tracking[type].tracking_data_A[i][j]
					+ myPs->testCond[bd][ch].SOC_tracking[type].tracking_data_B[i][j]);
			val2 = val1;
		}else if(SOC >= myPs->testCond[bd][ch].SOC_tracking[type].SOC[tmp1-1]){
			i = tmp1 -1;
			val1 =  (long)(temp * myPs->testCond[bd][ch].SOC_tracking[type].tracking_data_A[i][j]
					+ myPs->testCond[bd][ch].SOC_tracking[type].tracking_data_B[i][j]);
			val2 = val1;
		}else{
			val1 =  (long)(temp * myPs->testCond[bd][ch].SOC_tracking[type].tracking_data_A[i][j]
					+ myPs->testCond[bd][ch].SOC_tracking[type].tracking_data_B[i][j]);
			val2 =  (long)(temp * myPs->testCond[bd][ch].SOC_tracking[type].tracking_data_A[i+1][j]
					+ myPs->testCond[bd][ch].SOC_tracking[type].tracking_data_B[i+1][j]);
		}
	}else if(temp < myPs->testCond[bd][ch].SOC_tracking[type].temp[0]){
		temp = myPs->testCond[bd][ch].SOC_tracking[type].temp[0];
		j = 0;
		if(SOC <= myPs->testCond[bd][ch].SOC_tracking[type].SOC[0]){
			i = 0;
			val1 =  (long)(temp * myPs->testCond[bd][ch].SOC_tracking[type].tracking_data_A[i][j]
					+ myPs->testCond[bd][ch].SOC_tracking[type].tracking_data_B[i][j]);
			val2  = val1;
		}else if(SOC >= myPs->testCond[bd][ch].SOC_tracking[type].SOC[tmp1-1]){
			i = tmp1 -1;
			val1 =  (long)(temp * myPs->testCond[bd][ch].SOC_tracking[type].tracking_data_A[i][j]
					+ myPs->testCond[bd][ch].SOC_tracking[type].tracking_data_B[i][j]);
			val2  = val1;
		}else{
			val1 =  (long)(temp * myPs->testCond[bd][ch].SOC_tracking[type].tracking_data_A[i][j]
					+ myPs->testCond[bd][ch].SOC_tracking[type].tracking_data_B[i][j]);
			val2 =  (long)(temp * myPs->testCond[bd][ch].SOC_tracking[type].tracking_data_A[i+1][j]
					+ myPs->testCond[bd][ch].SOC_tracking[type].tracking_data_B[i+1][j]);
		}
	}else{
		if(SOC <= myPs->testCond[bd][ch].SOC_tracking[type].SOC[0]){
			i = 0;
			val1 =  (long)(temp * myPs->testCond[bd][ch].SOC_tracking[type].tracking_data_A[i][j]
					+ myPs->testCond[bd][ch].SOC_tracking[type].tracking_data_B[i][j]);
			val2 = val1;
		}else if(SOC >= myPs->testCond[bd][ch].SOC_tracking[type].SOC[tmp1-1]){
			i = tmp1 -1;
			val1 =  (long)(temp * myPs->testCond[bd][ch].SOC_tracking[type].tracking_data_A[i][j]
					+ myPs->testCond[bd][ch].SOC_tracking[type].tracking_data_B[i][j]);
			val2 = val1;
		}else{
			val1 =  (long)(temp * myPs->testCond[bd][ch].SOC_tracking[type].tracking_data_A[i][j]
					+ myPs->testCond[bd][ch].SOC_tracking[type].tracking_data_B[i][j]);
			val2 =  (long)(temp * myPs->testCond[bd][ch].SOC_tracking[type].tracking_data_A[i+1][j]
					+ myPs->testCond[bd][ch].SOC_tracking[type].tracking_data_B[i+1][j]);

		}
	}

	soc1 = myPs->testCond[bd][ch].SOC_tracking[type].SOC[check_i];
	soc2 = myPs->testCond[bd][ch].SOC_tracking[type].SOC[check_i+1];
	diff = soc2 - soc1;
	if(diff != 0){
		diff_current = val2 - val1;
		if(diff_current != 0){
			A = diff_current/ diff;
			B = val1 - A * soc1;
		}else{
			A = 0.0;
			B = val1;
		}
	}else{
		A = 0.0;
		B = val1;
	}
	val = (float)SOC * A + B;
	return (long)val;
}

long cFind_SOC_Tracking_Current_pattern(int bd, int ch, long refI)
{
	unsigned char type, rpt_step, stepType;
	int i, j, tmp, tmp1, check_i;
	long temp=0, SOC=0, val=0, val1, val2, diff, diff_current, soc1, soc2;
	long set_Ah, set_soc, Current_Ah = 0, Org_RefI = 0, Limit_RefI = 0;
	float rptSOC_1, rptSOC_2;
	float A, B;

	set_Ah = labs(myPs->testCond[bd][ch].safety.rptsoc);
	rpt_step = myData->bData[bd].cData[ch].misc.socTrackingStep;
	stepType = myCh->op.type;
	Org_RefI = refI;

	if(Org_RefI < 0) return Org_RefI;

	if(stepType == STEP_CHARGE){
		Current_Ah = myCh->op.charge_ampareHour;
	}else if(stepType == STEP_DISCHARGE){
		Current_Ah = myCh->op.discharge_ampareHour;
	}else if(stepType == STEP_USER_PATTERN){
		Current_Ah = myCh->op.charge_ampareHour - myCh->op.discharge_ampareHour;
		if(Current_Ah < 0) Current_Ah = 0;
	}
	
	if(set_Ah != 0){
		set_soc = labs(myPs->testCond[bd][ch].safety.soc);
		rptSOC_1 = (float)set_Ah;
		if(set_soc == 1000){
			rptSOC_2 = rptSOC_1;
			myCh->op.rptSOC = rptSOC_2;
		}else{
			rptSOC_2 = (float)rptSOC_1 * (float)(1000.0 / (1000.0 - set_soc));
			myCh->op.rptSOC = rptSOC_2;
		}
		SOC = (double)(Current_Ah * 10000.0)
			 / (double)myCh->op.rptSOC;
		myCh->op.SOC = SOC;
	}else{
		set_soc = myPs->testCond[bd][ch].step[rpt_step].rptSOC;
		rptSOC_1 = (float)myCh->op.ampareHour_SOC;
		if(set_soc == 1000){
			rptSOC_2 = rptSOC_1;
			myCh->op.rptSOC = rptSOC_2;
		}else{
			rptSOC_2 = (float)rptSOC_1 * (float)(1000.0 / (1000.0 - set_soc));
			myCh->op.rptSOC = rptSOC_2;
		}
		SOC = (double)(Current_Ah * 10000.0)
			 / (double)(myCh->op.rptSOC);
		myCh->op.SOC = SOC;
	}
	
	temp = 0;
	if(myData->mData.config.installedTemp != 0){
		temp = myData->bData[bd].cData[ch].misc.AuxTemp_max / 10;
	}else{	
		temp = myData->bData[bd].cData[ch].op.temp / 10;
	}

	type = 1;
	tmp = myPs->testCond[bd][ch].SOC_tracking[type].soc_num;
	if(tmp > (MAX_SOC_TRACKING_DATA -5)) tmp = MAX_SOC_TRACKING_DATA - 5; //25 -> rewrite 210720
	if(tmp <= 0) tmp = 1;

	for(i=0; i < tmp; i++) { // SOC
		if(SOC < myPs->testCond[bd][ch].SOC_tracking[type].SOC[i]) break;
	}
	i = i -1;
	if(i < 0){
	   	i = 0;
	}
	check_i = i;
	if(check_i >= myPs->testCond[bd][ch].SOC_tracking[type].soc_num-1){
		check_i = myPs->testCond[bd][ch].SOC_tracking[type].soc_num-2;
		if(check_i < 0) 
			check_i = 0;
	}

	tmp = myPs->testCond[bd][ch].SOC_tracking[type].temp_num;
//	if(tmp > MAX_SOC_TRACKING_DATA) tmp = MAX_SOC_TRACKING_DATA; //20
	if(tmp > (MAX_SOC_TRACKING_DATA-10)) tmp = MAX_SOC_TRACKING_DATA - 10; //20 ->rewrite 210720
	if(tmp <= 0) tmp = 1;

	for(j=0; j < tmp; j++) { // Temp
		if(temp < myPs->testCond[bd][ch].SOC_tracking[type].temp[j]) break;
	}
	j = j - 1;
	if(j < 0){
		j = 0;
	}
	tmp1 = myPs->testCond[bd][ch].SOC_tracking[type].soc_num;
	tmp = myPs->testCond[bd][ch].SOC_tracking[type].temp_num;
	if(temp > myPs->testCond[bd][ch].SOC_tracking[type].temp[tmp-1]){
		temp = myPs->testCond[bd][ch].SOC_tracking[type].temp[tmp-1];
		j = tmp-2;
		if(SOC <= myPs->testCond[bd][ch].SOC_tracking[type].SOC[0]){
			i = 0;
			val1 =  (long)(temp * myPs->testCond[bd][ch].SOC_tracking[type].tracking_data_A[i][j]
					+ myPs->testCond[bd][ch].SOC_tracking[type].tracking_data_B[i][j]);
			val2 = val1;
		}else if(SOC >= myPs->testCond[bd][ch].SOC_tracking[type].SOC[tmp1-1]){
			i = tmp1 -1;
			val1 =  (long)(temp * myPs->testCond[bd][ch].SOC_tracking[type].tracking_data_A[i][j]
					+ myPs->testCond[bd][ch].SOC_tracking[type].tracking_data_B[i][j]);
			val2 = val1;
		}else{
			val1 =  (long)(temp * myPs->testCond[bd][ch].SOC_tracking[type].tracking_data_A[i][j]
					+ myPs->testCond[bd][ch].SOC_tracking[type].tracking_data_B[i][j]);
			val2 =  (long)(temp * myPs->testCond[bd][ch].SOC_tracking[type].tracking_data_A[i+1][j]
					+ myPs->testCond[bd][ch].SOC_tracking[type].tracking_data_B[i+1][j]);
		}
	}else if(temp < myPs->testCond[bd][ch].SOC_tracking[type].temp[0]){
		temp = myPs->testCond[bd][ch].SOC_tracking[type].temp[0];
		j = 0;
		if(SOC <= myPs->testCond[bd][ch].SOC_tracking[type].SOC[0]){
			i = 0;
			val1 =  (long)(temp * myPs->testCond[bd][ch].SOC_tracking[type].tracking_data_A[i][j]
					+ myPs->testCond[bd][ch].SOC_tracking[type].tracking_data_B[i][j]);
			val2  = val1;
		}else if(SOC >= myPs->testCond[bd][ch].SOC_tracking[type].SOC[tmp1-1]){
			i = tmp1 -1;
			val1 =  (long)(temp * myPs->testCond[bd][ch].SOC_tracking[type].tracking_data_A[i][j]
					+ myPs->testCond[bd][ch].SOC_tracking[type].tracking_data_B[i][j]);
			val2  = val1;
		}else{
			val1 =  (long)(temp * myPs->testCond[bd][ch].SOC_tracking[type].tracking_data_A[i][j]
					+ myPs->testCond[bd][ch].SOC_tracking[type].tracking_data_B[i][j]);
			val2 =  (long)(temp * myPs->testCond[bd][ch].SOC_tracking[type].tracking_data_A[i+1][j]
					+ myPs->testCond[bd][ch].SOC_tracking[type].tracking_data_B[i+1][j]);
		}
	}else{
		if(SOC <= myPs->testCond[bd][ch].SOC_tracking[type].SOC[0]){
			i = 0;
			val1 =  (long)(temp * myPs->testCond[bd][ch].SOC_tracking[type].tracking_data_A[i][j]
					+ myPs->testCond[bd][ch].SOC_tracking[type].tracking_data_B[i][j]);
			val2 = val1;
		}else if(SOC >= myPs->testCond[bd][ch].SOC_tracking[type].SOC[tmp1-1]){
			i = tmp1 -1;
			val1 =  (long)(temp * myPs->testCond[bd][ch].SOC_tracking[type].tracking_data_A[i][j]
					+ myPs->testCond[bd][ch].SOC_tracking[type].tracking_data_B[i][j]);
			val2 = val1;
		}else{
			val1 =  (long)(temp * myPs->testCond[bd][ch].SOC_tracking[type].tracking_data_A[i][j]
					+ myPs->testCond[bd][ch].SOC_tracking[type].tracking_data_B[i][j]);
			val2 =  (long)(temp * myPs->testCond[bd][ch].SOC_tracking[type].tracking_data_A[i+1][j]
					+ myPs->testCond[bd][ch].SOC_tracking[type].tracking_data_B[i+1][j]);

		}
	}

	soc1 = myPs->testCond[bd][ch].SOC_tracking[type].SOC[check_i];
	soc2 = myPs->testCond[bd][ch].SOC_tracking[type].SOC[check_i+1];
	diff = soc2 - soc1;
	if(diff != 0){
		diff_current = val2 - val1;
		if(diff_current != 0){
			A = diff_current/ diff;
			B = val1 - A * soc1;
		}else{
			A = 0.0;
			B = val1;
		}
	}else{
		A = 0.0;
		B = val1;
	}
	val = (float)SOC * A + B;

	if(Org_RefI > val){
		Limit_RefI = val;
		return Limit_RefI;
	}else{
		return Org_RefI;
	}
}

long cFind_SOV_Tracking_Current(int bd, int ch)
{
	unsigned char type;
	int i, j, tmp, tmp1, check_i, save100ms_Limit;
	long temp=0, SOV=0, val=0, val1, val2, diff, diff_current, soc1, soc2;
	unsigned long advStepNo, saveDt;
	float A, B;
    
	advStepNo = myCh->misc.advStepNo;
	saveDt = (myPs->testCond[bd][ch].step[advStepNo].saveDt / 100) * 100;
	save100ms_Limit = myData->DataSave.config.save_100ms_time;

	if(myData->bData[bd].cData[ch].op.type == STEP_USER_PATTERN){
		SOV = myData->bData[bd].cData[ch].misc.tmpVsens; //tmp
	}else if(myData->bData[bd].cData[ch].op.type == STEP_USER_MAP){
		SOV = myData->bData[bd].cData[ch].misc.tmpVsens; //tmp
	}else if(myData->bData[bd].cData[ch].op.mode == CP){
		SOV = myData->bData[bd].cData[ch].misc.tmpVsens; //tmp
	}else if(myData->bData[bd].cData[ch].op.runTime > 0 &&
		myData->bData[bd].cData[ch].op.runTime < 100){ //tmp
		SOV = myData->bData[bd].cData[ch].misc.tmpVsens;
	}else if((saveDt < RTTASK_1000MS)
			&& (myData->bData[bd].cData[ch].op.runTime < save100ms_Limit)){
		SOV = myData->bData[bd].cData[ch].misc.tmpVsens; //tmp
	}else{
		SOV = myData->bData[bd].cData[ch].op.Vsens; //op
	}
	myCh->op.SOC = 0;

	temp = 0;
	if(myData->mData.config.installedTemp != 0){
		temp = myData->bData[bd].cData[ch].misc.AuxTemp_max / 10;
	}else{	
		temp = myData->bData[bd].cData[ch].op.temp / 10;
	}

	type = 1;
	tmp = myPs->testCond[bd][ch].SOC_tracking[type].soc_num;
	if(tmp > (MAX_SOC_TRACKING_DATA -5)) tmp = MAX_SOC_TRACKING_DATA - 5; //25
	if(tmp <= 0) tmp = 1;

	for(i=0; i < tmp; i++) { // SOV
		if(SOV < myPs->testCond[bd][ch].SOC_tracking[type].SOC[i]) break;
	}
	i = i -1;
	if(i < 0){
	   	i = 0;
	}
	check_i = i;
	if(check_i >= myPs->testCond[bd][ch].SOC_tracking[type].soc_num-1){
		check_i = myPs->testCond[bd][ch].SOC_tracking[type].soc_num-2;
		if(check_i < 0) 
			check_i = 0;
	}

	tmp = myPs->testCond[bd][ch].SOC_tracking[type].temp_num;
//	if(tmp > MAX_SOC_TRACKING_DATA tmp = MAX_SOC_TRACKING_DATA - 10; //20
	if(tmp > (MAX_SOC_TRACKING_DATA-10)) tmp = MAX_SOC_TRACKING_DATA - 10; //20
	if(tmp <= 0) tmp = 1;

	for(j=0; j < tmp; j++) { // Temp
		if(temp < myPs->testCond[bd][ch].SOC_tracking[type].temp[j]) break;
	}
	j = j - 1;
	if(j < 0){
		j = 0;
	}
	tmp1 = myPs->testCond[bd][ch].SOC_tracking[type].soc_num;
	tmp = myPs->testCond[bd][ch].SOC_tracking[type].temp_num;

	if(temp > myPs->testCond[bd][ch].SOC_tracking[type].temp[tmp-1]){
		temp = myPs->testCond[bd][ch].SOC_tracking[type].temp[tmp-1];
		j = tmp-2;
		if(SOV <= myPs->testCond[bd][ch].SOC_tracking[type].SOC[0]){
			i = 0;
			val1 =  (long)(temp * myPs->testCond[bd][ch].SOC_tracking[type].tracking_data_A[i][j]
					+ myPs->testCond[bd][ch].SOC_tracking[type].tracking_data_B[i][j]);
			val2 = val1;
		}else if(SOV >= myPs->testCond[bd][ch].SOC_tracking[type].SOC[tmp1-1]){
			i = tmp1 -1;
			val1 =  (long)(temp * myPs->testCond[bd][ch].SOC_tracking[type].tracking_data_A[i][j]
					+ myPs->testCond[bd][ch].SOC_tracking[type].tracking_data_B[i][j]);
			val2 = val1;
		}else{
			val1 =  (long)(temp * myPs->testCond[bd][ch].SOC_tracking[type].tracking_data_A[i][j]
					+ myPs->testCond[bd][ch].SOC_tracking[type].tracking_data_B[i][j]);
			val2 =  (long)(temp * myPs->testCond[bd][ch].SOC_tracking[type].tracking_data_A[i+1][j]
					+ myPs->testCond[bd][ch].SOC_tracking[type].tracking_data_B[i+1][j]);
		}
	}else if(temp < myPs->testCond[bd][ch].SOC_tracking[type].temp[0]){
		temp = myPs->testCond[bd][ch].SOC_tracking[type].temp[0];
		j = 0;
		if(SOV <= myPs->testCond[bd][ch].SOC_tracking[type].SOC[0]){
			i = 0;
			val1 =  (long)(temp * myPs->testCond[bd][ch].SOC_tracking[type].tracking_data_A[i][j]
					+ myPs->testCond[bd][ch].SOC_tracking[type].tracking_data_B[i][j]);
			val2  = val1;
		}else if(SOV >= myPs->testCond[bd][ch].SOC_tracking[type].SOC[tmp1-1]){
			i = tmp1 -1;
			val1 =  (long)(temp * myPs->testCond[bd][ch].SOC_tracking[type].tracking_data_A[i][j]
					+ myPs->testCond[bd][ch].SOC_tracking[type].tracking_data_B[i][j]);
			val2  = val1;
		}else{
			val1 =  (long)(temp * myPs->testCond[bd][ch].SOC_tracking[type].tracking_data_A[i][j]
					+ myPs->testCond[bd][ch].SOC_tracking[type].tracking_data_B[i][j]);
			val2 =  (long)(temp * myPs->testCond[bd][ch].SOC_tracking[type].tracking_data_A[i+1][j]
					+ myPs->testCond[bd][ch].SOC_tracking[type].tracking_data_B[i+1][j]);
		}
	}else{
		if(SOV <= myPs->testCond[bd][ch].SOC_tracking[type].SOC[0]){
			i = 0;
			val1 =  (long)(temp * myPs->testCond[bd][ch].SOC_tracking[type].tracking_data_A[i][j]
					+ myPs->testCond[bd][ch].SOC_tracking[type].tracking_data_B[i][j]);
			val2 = val1;
		}else if(SOV >= myPs->testCond[bd][ch].SOC_tracking[type].SOC[tmp1-1]){
			i = tmp1 -1;
			val1 =  (long)(temp * myPs->testCond[bd][ch].SOC_tracking[type].tracking_data_A[i][j]
					+ myPs->testCond[bd][ch].SOC_tracking[type].tracking_data_B[i][j]);
			val2 = val1;
		}else{
			val1 =  (long)(temp * myPs->testCond[bd][ch].SOC_tracking[type].tracking_data_A[i][j]
					+ myPs->testCond[bd][ch].SOC_tracking[type].tracking_data_B[i][j]);
			val2 =  (long)(temp * myPs->testCond[bd][ch].SOC_tracking[type].tracking_data_A[i+1][j]
					+ myPs->testCond[bd][ch].SOC_tracking[type].tracking_data_B[i+1][j]);

		}
	}

	soc1 = myPs->testCond[bd][ch].SOC_tracking[type].SOC[check_i];
	soc2 = myPs->testCond[bd][ch].SOC_tracking[type].SOC[check_i+1];
	diff = soc2 - soc1;

	if(diff != 0){
		diff_current = val2 - val1;
		if(diff_current != 0){
			A = diff_current/ diff;
			B = val1 - A * soc1;
		}else{
			A = 0.0;
			B = val1;
		}
	}else{
		A = 0.0;
		B = val1;
	}
	val = (float)SOV * A + B;
	return (long)val;
}

long cFind_SOV_Tracking_Current_pattern(int bd, int ch, long refI)
{
	unsigned char type;
	int i, j, tmp, tmp1, check_i, save100ms_Limit;
	long temp=0, SOV=0, val=0, val1, val2, diff, diff_current, soc1, soc2;
	long Org_RefI = 0, Limit_RefI = 0;
	unsigned long advStepNo, saveDt;
	float A, B;
   
	Org_RefI = refI;
	advStepNo = myCh->misc.advStepNo;
	saveDt = (myPs->testCond[bd][ch].step[advStepNo].saveDt / 100) * 100;
	save100ms_Limit = myData->DataSave.config.save_100ms_time;

	if(Org_RefI < 0) return Org_RefI;

	if(myData->bData[bd].cData[ch].op.type == STEP_USER_PATTERN){
		SOV = myData->bData[bd].cData[ch].misc.tmpVsens; //tmp
	}else if(myData->bData[bd].cData[ch].op.type == STEP_USER_MAP){
		SOV = myData->bData[bd].cData[ch].misc.tmpVsens; //tmp
	}else if(myData->bData[bd].cData[ch].op.mode == CP){
		SOV = myData->bData[bd].cData[ch].misc.tmpVsens; //tmp
	}else if(myData->bData[bd].cData[ch].op.runTime > 0 &&
		myData->bData[bd].cData[ch].op.runTime < 100){ //tmp
		SOV = myData->bData[bd].cData[ch].misc.tmpVsens;
	}else if((saveDt < RTTASK_1000MS)
			&& (myData->bData[bd].cData[ch].op.runTime < save100ms_Limit)){
		SOV = myData->bData[bd].cData[ch].misc.tmpVsens; //tmp
	}else{
		SOV = myData->bData[bd].cData[ch].op.Vsens; //op
	}
	myCh->op.SOC = 0;

	temp = 0;
	if(myData->mData.config.installedTemp != 0){
		temp = myData->bData[bd].cData[ch].misc.AuxTemp_max / 10;
	}else{	
		temp = myData->bData[bd].cData[ch].op.temp / 10;
	}

	type = 1;
	tmp = myPs->testCond[bd][ch].SOC_tracking[type].soc_num;
	if(tmp > (MAX_SOC_TRACKING_DATA -5)) tmp = MAX_SOC_TRACKING_DATA - 5; //25
	if(tmp <= 0) tmp = 1;

	for(i=0; i < tmp; i++) { // SOV
		if(SOV < myPs->testCond[bd][ch].SOC_tracking[type].SOC[i]) break;
	}
	i = i -1;
	if(i < 0){
	   	i = 0;
	}
	check_i = i;
	if(check_i >= myPs->testCond[bd][ch].SOC_tracking[type].soc_num-1){
		check_i = myPs->testCond[bd][ch].SOC_tracking[type].soc_num-2;
		if(check_i < 0) 
			check_i = 0;
	}

	tmp = myPs->testCond[bd][ch].SOC_tracking[type].temp_num;
//	if(tmp > MAX_SOC_TRACKING_DATA tmp = MAX_SOC_TRACKING_DATA - 10; //20
	if(tmp > (MAX_SOC_TRACKING_DATA-10)) tmp = MAX_SOC_TRACKING_DATA - 10; //20
	if(tmp <= 0) tmp = 1;

	for(j=0; j < tmp; j++) { // Temp
		if(temp < myPs->testCond[bd][ch].SOC_tracking[type].temp[j]) break;
	}
	j = j - 1;
	if(j < 0){
		j = 0;
	}
	tmp1 = myPs->testCond[bd][ch].SOC_tracking[type].soc_num;
	tmp = myPs->testCond[bd][ch].SOC_tracking[type].temp_num;

	if(temp > myPs->testCond[bd][ch].SOC_tracking[type].temp[tmp-1]){
		temp = myPs->testCond[bd][ch].SOC_tracking[type].temp[tmp-1];
		j = tmp-2;
		if(SOV <= myPs->testCond[bd][ch].SOC_tracking[type].SOC[0]){
			i = 0;
			val1 =  (long)(temp * myPs->testCond[bd][ch].SOC_tracking[type].tracking_data_A[i][j]
					+ myPs->testCond[bd][ch].SOC_tracking[type].tracking_data_B[i][j]);
			val2 = val1;
		}else if(SOV >= myPs->testCond[bd][ch].SOC_tracking[type].SOC[tmp1-1]){
			i = tmp1 -1;
			val1 =  (long)(temp * myPs->testCond[bd][ch].SOC_tracking[type].tracking_data_A[i][j]
					+ myPs->testCond[bd][ch].SOC_tracking[type].tracking_data_B[i][j]);
			val2 = val1;
		}else{
			val1 =  (long)(temp * myPs->testCond[bd][ch].SOC_tracking[type].tracking_data_A[i][j]
					+ myPs->testCond[bd][ch].SOC_tracking[type].tracking_data_B[i][j]);
			val2 =  (long)(temp * myPs->testCond[bd][ch].SOC_tracking[type].tracking_data_A[i+1][j]
					+ myPs->testCond[bd][ch].SOC_tracking[type].tracking_data_B[i+1][j]);
		}
	}else if(temp < myPs->testCond[bd][ch].SOC_tracking[type].temp[0]){
		temp = myPs->testCond[bd][ch].SOC_tracking[type].temp[0];
		j = 0;
		if(SOV <= myPs->testCond[bd][ch].SOC_tracking[type].SOC[0]){
			i = 0;
			val1 =  (long)(temp * myPs->testCond[bd][ch].SOC_tracking[type].tracking_data_A[i][j]
					+ myPs->testCond[bd][ch].SOC_tracking[type].tracking_data_B[i][j]);
			val2  = val1;
		}else if(SOV >= myPs->testCond[bd][ch].SOC_tracking[type].SOC[tmp1-1]){
			i = tmp1 -1;
			val1 =  (long)(temp * myPs->testCond[bd][ch].SOC_tracking[type].tracking_data_A[i][j]
					+ myPs->testCond[bd][ch].SOC_tracking[type].tracking_data_B[i][j]);
			val2  = val1;
		}else{
			val1 =  (long)(temp * myPs->testCond[bd][ch].SOC_tracking[type].tracking_data_A[i][j]
					+ myPs->testCond[bd][ch].SOC_tracking[type].tracking_data_B[i][j]);
			val2 =  (long)(temp * myPs->testCond[bd][ch].SOC_tracking[type].tracking_data_A[i+1][j]
					+ myPs->testCond[bd][ch].SOC_tracking[type].tracking_data_B[i+1][j]);
		}
	}else{
		if(SOV <= myPs->testCond[bd][ch].SOC_tracking[type].SOC[0]){
			i = 0;
			val1 =  (long)(temp * myPs->testCond[bd][ch].SOC_tracking[type].tracking_data_A[i][j]
					+ myPs->testCond[bd][ch].SOC_tracking[type].tracking_data_B[i][j]);
			val2 = val1;
		}else if(SOV >= myPs->testCond[bd][ch].SOC_tracking[type].SOC[tmp1-1]){
			i = tmp1 -1;
			val1 =  (long)(temp * myPs->testCond[bd][ch].SOC_tracking[type].tracking_data_A[i][j]
					+ myPs->testCond[bd][ch].SOC_tracking[type].tracking_data_B[i][j]);
			val2 = val1;
		}else{
			val1 =  (long)(temp * myPs->testCond[bd][ch].SOC_tracking[type].tracking_data_A[i][j]
					+ myPs->testCond[bd][ch].SOC_tracking[type].tracking_data_B[i][j]);
			val2 =  (long)(temp * myPs->testCond[bd][ch].SOC_tracking[type].tracking_data_A[i+1][j]
					+ myPs->testCond[bd][ch].SOC_tracking[type].tracking_data_B[i+1][j]);

		}
	}

	soc1 = myPs->testCond[bd][ch].SOC_tracking[type].SOC[check_i];
	soc2 = myPs->testCond[bd][ch].SOC_tracking[type].SOC[check_i+1];
	diff = soc2 - soc1;

	if(diff != 0){
		diff_current = val2 - val1;
		if(diff_current != 0){
			A = diff_current/ diff;
			B = val1 - A * soc1;
		}else{
			A = 0.0;
			B = val1;
		}
	}else{
		A = 0.0;
		B = val1;
	}
	val = (float)SOV * A + B;
	if(Org_RefI > val){
		Limit_RefI = val;
		return (long)Limit_RefI;
	}else{
		return (long)Org_RefI;
	}
}

long cFind_SOH_Tracking_Current(int bd, int ch) //211022
{
//	unsigned char type, rpt_step, stepType;
	unsigned char rpt_step, stepType;
//	int i, j, tmp, tmp1, check_i;
//	long temp=0, SOH=0, val=0, val1, val2, diff, diff_current, soc1, soc2;
	long SOH = 0, set_Ah, set_soh, Current_Ah = 0;
	float rptSOH_1, rptSOH_2;
//	float A, B;
	
	set_Ah = labs(myPs->testCond[bd][ch].safety.rptsoh);
	rpt_step = myData->bData[bd].cData[ch].misc.sohTrackingStep;
	stepType = myCh->op.type;

	if(stepType == STEP_CHARGE){
		Current_Ah = myCh->op.charge_ampareHour;
	}else if(stepType == STEP_DISCHARGE){
		Current_Ah = myCh->op.discharge_ampareHour;
	}
/*
	set_soh = myPs->testCond[bd][ch].step[rpt_step].rptSOH;
	rptSOH_1 = (float)myCh->op.ampareHour_SOH;
	if(set_soh == 1000){
		rptSOH_2 = rptSOH_1;
		myCh->op.rptSOH = rptSOH_2;
	}else{
		rptSOH_2 = (float)rptSOH_1 * (float)(1000.0 / (1000.0 - set_soh));
		myCh->op.rptSOH = rptSOH_2;
	}
	SOH = (double)(Current_Ah * 10000.0)
		 / (double)(myCh->op.rptSOH);
	myCh->op.SOH = SOH;
*/

	if(set_Ah != 0){
		set_soh = labs(myPs->testCond[bd][ch].safety.soh);
		rptSOH_1 = (float)set_Ah;
		if(set_soh == 1000){
			rptSOH_2 = (float)rptSOH_1;
			myCh->op.rptSOH = rptSOH_2;
		}else{
			rptSOH_2 = (float)rptSOH_1 * (float)(1000.0 / (1000.0 - set_soh));
			myCh->op.rptSOH = rptSOH_2;
		}
		SOH = (double)(Current_Ah * 10000.0)
			 / (double)myCh->op.rptSOH;
		myCh->op.SOH = SOH;
	}else{
		set_soh = myPs->testCond[bd][ch].step[rpt_step].rptSOH;
		rptSOH_1 = (float)myCh->op.ampareHour_SOH;
		if(set_soh == 1000){
			rptSOH_2 = rptSOH_1;
			myCh->op.rptSOH = rptSOH_2;
		}else{
			rptSOH_2 = (float)rptSOH_1 * (float)(1000.0 / (1000.0 - set_soh));
			myCh->op.rptSOH = rptSOH_2;
		}
		SOH = (double)(Current_Ah * 10000.0)
			 / (double)(myCh->op.rptSOH);
		myCh->op.SOH = SOH;
	}

/*	
	temp = 0;
	if(myData->mData.config.installedTemp != 0){
		temp = myData->bData[bd].cData[ch].misc.AuxTemp_max / 10;
	}else{	
		temp = myData->bData[bd].cData[ch].op.temp / 10;
	}

	type = 1;
	tmp = myPs->testCond[bd][ch].SOC_tracking[type].soc_num;
	if(tmp > (MAX_SOC_TRACKING_DATA -5)) tmp = MAX_SOC_TRACKING_DATA - 5; //25 ->rewrite 210720
	if(tmp <= 0) tmp = 1;

	for(i=0; i < tmp; i++) { // SOC
		if(SOC < myPs->testCond[bd][ch].SOC_tracking[type].SOC[i]) break;
	}
	i = i -1;
	if(i < 0){
	   	i = 0;
	}
	check_i = i;
	if(check_i >= myPs->testCond[bd][ch].SOC_tracking[type].soc_num-1){
		check_i = myPs->testCond[bd][ch].SOC_tracking[type].soc_num-2;
		if(check_i < 0) 
			check_i = 0;
	}

	tmp = myPs->testCond[bd][ch].SOC_tracking[type].temp_num;
//	if(tmp > MAX_SOC_TRACKING_DATA tmp = MAX_SOC_TRACKING_DATA; //20
	if(tmp > (MAX_SOC_TRACKING_DATA-10)) tmp = MAX_SOC_TRACKING_DATA - 10; //20 ->rewrite 210720
	if(tmp <= 0) tmp = 1;

	for(j=0; j < tmp; j++) { // Temp
		if(temp < myPs->testCond[bd][ch].SOC_tracking[type].temp[j]) break;
	}
	j = j - 1;
	if(j < 0){
		j = 0;
	}
	tmp1 = myPs->testCond[bd][ch].SOC_tracking[type].soc_num;
	tmp = myPs->testCond[bd][ch].SOC_tracking[type].temp_num;
	if(temp > myPs->testCond[bd][ch].SOC_tracking[type].temp[tmp-1]){
		temp = myPs->testCond[bd][ch].SOC_tracking[type].temp[tmp-1];
		j = tmp-2;
		if(SOC <= myPs->testCond[bd][ch].SOC_tracking[type].SOC[0]){
			i = 0;
			val1 =  (long)(temp * myPs->testCond[bd][ch].SOC_tracking[type].tracking_data_A[i][j]
					+ myPs->testCond[bd][ch].SOC_tracking[type].tracking_data_B[i][j]);
			val2 = val1;
		}else if(SOC >= myPs->testCond[bd][ch].SOC_tracking[type].SOC[tmp1-1]){
			i = tmp1 -1;
			val1 =  (long)(temp * myPs->testCond[bd][ch].SOC_tracking[type].tracking_data_A[i][j]
					+ myPs->testCond[bd][ch].SOC_tracking[type].tracking_data_B[i][j]);
			val2 = val1;
		}else{
			val1 =  (long)(temp * myPs->testCond[bd][ch].SOC_tracking[type].tracking_data_A[i][j]
					+ myPs->testCond[bd][ch].SOC_tracking[type].tracking_data_B[i][j]);
			val2 =  (long)(temp * myPs->testCond[bd][ch].SOC_tracking[type].tracking_data_A[i+1][j]
					+ myPs->testCond[bd][ch].SOC_tracking[type].tracking_data_B[i+1][j]);
		}
	}else if(temp < myPs->testCond[bd][ch].SOC_tracking[type].temp[0]){
		temp = myPs->testCond[bd][ch].SOC_tracking[type].temp[0];
		j = 0;
		if(SOC <= myPs->testCond[bd][ch].SOC_tracking[type].SOC[0]){
			i = 0;
			val1 =  (long)(temp * myPs->testCond[bd][ch].SOC_tracking[type].tracking_data_A[i][j]
					+ myPs->testCond[bd][ch].SOC_tracking[type].tracking_data_B[i][j]);
			val2  = val1;
		}else if(SOC >= myPs->testCond[bd][ch].SOC_tracking[type].SOC[tmp1-1]){
			i = tmp1 -1;
			val1 =  (long)(temp * myPs->testCond[bd][ch].SOC_tracking[type].tracking_data_A[i][j]
					+ myPs->testCond[bd][ch].SOC_tracking[type].tracking_data_B[i][j]);
			val2  = val1;
		}else{
			val1 =  (long)(temp * myPs->testCond[bd][ch].SOC_tracking[type].tracking_data_A[i][j]
					+ myPs->testCond[bd][ch].SOC_tracking[type].tracking_data_B[i][j]);
			val2 =  (long)(temp * myPs->testCond[bd][ch].SOC_tracking[type].tracking_data_A[i+1][j]
					+ myPs->testCond[bd][ch].SOC_tracking[type].tracking_data_B[i+1][j]);
		}
	}else{
		if(SOC <= myPs->testCond[bd][ch].SOC_tracking[type].SOC[0]){
			i = 0;
			val1 =  (long)(temp * myPs->testCond[bd][ch].SOC_tracking[type].tracking_data_A[i][j]
					+ myPs->testCond[bd][ch].SOC_tracking[type].tracking_data_B[i][j]);
			val2 = val1;
		}else if(SOC >= myPs->testCond[bd][ch].SOC_tracking[type].SOC[tmp1-1]){
			i = tmp1 -1;
			val1 =  (long)(temp * myPs->testCond[bd][ch].SOC_tracking[type].tracking_data_A[i][j]
					+ myPs->testCond[bd][ch].SOC_tracking[type].tracking_data_B[i][j]);
			val2 = val1;
		}else{
			val1 =  (long)(temp * myPs->testCond[bd][ch].SOC_tracking[type].tracking_data_A[i][j]
					+ myPs->testCond[bd][ch].SOC_tracking[type].tracking_data_B[i][j]);
			val2 =  (long)(temp * myPs->testCond[bd][ch].SOC_tracking[type].tracking_data_A[i+1][j]
					+ myPs->testCond[bd][ch].SOC_tracking[type].tracking_data_B[i+1][j]);

		}
	}

	soc1 = myPs->testCond[bd][ch].SOC_tracking[type].SOC[check_i];
	soc2 = myPs->testCond[bd][ch].SOC_tracking[type].SOC[check_i+1];
	diff = soc2 - soc1;
	if(diff != 0){
		diff_current = val2 - val1;
		if(diff_current != 0){
			A = diff_current/ diff;
			B = val1 - A * soc1;
		}else{
			A = 0.0;
			B = val1;
		}
	}else{
		A = 0.0;
		B = val1;
	}
	val = (float)SOC * A + B;
	return (long)val;
*/
	return 0;
}
#endif

#ifdef _EQUATION_CURRENT
long cFind_equation_current(int bd, int ch)
{	
	unsigned char mode, stepType;
	int save100ms_Limit;
	long Sensing_V, Cut_off_V; 
	unsigned long advStepNo, saveDt;
	double diff_V, variable[4], EQU_diff_V[4], EQU_Current = 0;
    
	advStepNo = myCh->misc.advStepNo;
	saveDt = (myPs->testCond[bd][ch].step[advStepNo].saveDt / 100) * 100;
	save100ms_Limit = myData->DataSave.config.save_100ms_time;
	mode = myCh->op.mode;
	stepType = myCh->op.type;

	//Sensing Votage
	if(stepType == STEP_USER_PATTERN){
		Sensing_V = myCh->misc.tmpVsens; //tmp
	}else if(stepType == STEP_USER_MAP){
		Sensing_V = myCh->misc.tmpVsens; //tmp
	}else if(mode == CP){
		Sensing_V = myCh->misc.tmpVsens; //tmp
	}else if(myCh->op.runTime > 0 && myCh->op.runTime < 100){ //tmp
		Sensing_V = myCh->misc.tmpVsens;
	}else if((saveDt < RTTASK_1000MS) && (myCh->op.runTime < save100ms_Limit)){
		Sensing_V = myCh->misc.tmpVsens; //tmp
	}else{
		Sensing_V = myCh->op.Vsens; //op
	}
	//Cut off Voltage
	if(mode == CC || mode == CP){
		if(myPs->testCond[bd][ch].step[advStepNo].endV != 0){
			Cut_off_V = myPs->testCond[bd][ch].step[advStepNo].endV;
		}else{
			Cut_off_V = myPs->testCond[bd][ch].step[advStepNo].refV;
		}
	}else{
		Cut_off_V = myPs->testCond[bd][ch].step[advStepNo].refV;
	}
	//Diff Voltage	
	diff_V = (double)(Sensing_V - Cut_off_V);
	diff_V = diff_V / 1000000.;

	//3rd variable
	variable[3] = (double)myPs->testCond[bd][ch].step[advStepNo].variable[3] / 100000.;
	//2rd variable
	variable[2] = (double)myPs->testCond[bd][ch].step[advStepNo].variable[2] / 100000.;
	//1rd variable
	variable[1] = (double)myPs->testCond[bd][ch].step[advStepNo].variable[1] / 100000.;
	//0rd variable
	variable[0] = (double)myPs->testCond[bd][ch].step[advStepNo].variable[0] / 100000.;

	myData->test_val_f[0] = variable[3];
	myData->test_val_f[1] = variable[2];
	myData->test_val_f[2] = variable[1];
	myData->test_val_f[3] = variable[0];

	//3rd equation 
	EQU_diff_V[3] 
		= variable[3] * (diff_V * diff_V * diff_V);	
	//2rd equation
	EQU_diff_V[2] 
		= variable[2] * (diff_V * diff_V);	
	//1rd equation
	EQU_diff_V[1] 
		= variable[1] * (diff_V);	
	//0rd varialbe
	EQU_diff_V[0]
		= variable[0];

	EQU_Current
		= EQU_diff_V[3] + EQU_diff_V[2] + EQU_diff_V[1] + EQU_diff_V[0];

	if(mode == CP){ //211116
		EQU_Current
			= EQU_Current * 1000.;
	}else{
		EQU_Current
			= EQU_Current * 1000000.;
	}

	//Equation Calculation Error
	if(stepType == STEP_CHARGE){
		if(EQU_Current < 0 ){
			myCh->misc.equation_calc_err_flag = P1;
		}else{
			myCh->misc.equation_calc_err_flag = P0;
		}
	}

	return (long)EQU_Current;
}
#endif

//210602 LJS
#ifdef _END_COMPARE_GOTO
int gotoStepCheck(int bd, int ch)
{
	int j, rtn;
	long type, value, sign, gotoStepNo;
	unsigned long advStepNo;
	int count = 0;
	S_CH_STEP_INFO step;
	
	step = step_info(bd, ch);
	advStepNo = step.advStepNo;
	myTestCond = &(myPs->testCond[bd][ch]);
	
	if(myData->bData[bd].cData[ch].op.type == STEP_REST) return 0;

	for(j = 0 ; j < MAX_COMP_GOTO; j++){
		type = myTestCond->step[advStepNo].endCompGoto[j].type;
		value = myTestCond->step[advStepNo].endCompGoto[j].value;
		sign = myTestCond->step[advStepNo].endCompGoto[j].sign;
		gotoStepNo = myTestCond->step[advStepNo].endCompGoto[j].gotoStepNo;
		if(type != 0 && count == 0){	
			if(myTestCond->step[advStepNo].endCompGoto[j].type == 1){
				rtn = return_check_value(myCh->op.runTime, value, sign);
				if(rtn == 1){
					count = j + 1;
				}
			}else if(myTestCond->step[advStepNo].endCompGoto[j].type == 2){
				rtn = return_check_value(myCh->op.Vsens, value, sign);
				if(rtn == 1){
					count = j + 1;
				}
			}else if(myTestCond->step[advStepNo].endCompGoto[j].type == 3){
				rtn = return_check_value(myCh->op.Isens, value, sign);
				if(rtn == 1){
					count = j + 1;
				}
			}else if(myTestCond->step[advStepNo].endCompGoto[j].type == 4){
				rtn = return_check_value(myCh->op.ampareHour, value, sign);
				if(rtn == 1){
					count = j + 1;
				}
			}else if(myTestCond->step[advStepNo].endCompGoto[j].type == 5){
				rtn = return_check_value(myCh->op.wattHour, value, sign);
				if(rtn == 1){
					count = j + 1;
				}
			}else if(myTestCond->step[advStepNo].endCompGoto[j].type == 6){
				rtn = return_check_value(myCh->op.temp, value, sign);
				if(rtn == 1){
					count = j + 1;
				}
			}
		}
	}
	if(count == 0){
		return 0;
	}else{
		return count;
	}
}

int return_check_value(long val1, long val2, long sign)
{
	int rtn = 0;

	if(sign == 1){
		if(val1 > val2){
			rtn = 1;
		}else{
			rtn = 0;
		}	
	}else if(sign == 2){
		if(val1 < val2){
			rtn = 1;
		}else {
			rtn = 0;
		}	
	}else if(sign == 3){
		if(val1 >= val2){
			rtn = 1;
		}else{
			rtn = 0;
		}	
	}else if(sign == 4){
		if(val1 <= val2){
			rtn = 1;
		}else{
			rtn = 0;
		}	
	}else if(sign == 5){
		if(val1 == val2){
			rtn = 1;
		}else{
			rtn = 0;
		}	
	}else if(sign == 6){
		if(val1 != val2){
			rtn = 1;
		}else{
			rtn = 0;
		}	
	}
	return rtn;	
}
#endif

#if CAPACITY_CONTROL == 1
long Calculate_C_Rate_Capacity(int bd, int ch, int advStepNo) //211223
{
	unsigned char	count = 0, C_Rate_Sign[10];
	int				i;
	unsigned short	C_Rate_stepNo[MAX_C_RATE_STEP_NO];
	short int		C_Rate_Persent[MAX_C_RATE_STEP_NO];
	float			C_Rate_Calc_Capacity[10];
	double			tmp1, tmp2, tmp3;	


	for(i=0; i<10; i++){ //C-RATE Count
		if(myPs->testCond[bd][ch].step[advStepNo].C_Rate_Persent[i] !=0){
			count++;
		}
	}

	for(i=0; i < count; i++){ //C-RATE Step Capacity

		C_Rate_Persent[i] = 
			myPs->testCond[bd][ch].step[advStepNo].C_Rate_Persent[i];
		C_Rate_stepNo[i] =
			myPs->testCond[bd][ch].step[advStepNo].C_Rate_stepNo[i]; 
		if(C_Rate_stepNo[i] !=0){
			myCh->misc.C_Rate_Calc_Capacity[i] = 
				myCh->misc.C_Rate_stepCapacity[C_Rate_stepNo[i]-1]
								* ((float)C_Rate_Persent[i]/10000);
			C_Rate_Calc_Capacity[i] = 
				(float) myCh->misc.C_Rate_Calc_Capacity[i] / 1000.;
		}
		C_Rate_Sign[i] =
			myPs->testCond[bd][ch].step[advStepNo].C_Rate_Sign[i]; 
	}
	tmp3 = 0;
	for(i=0; i< count; i++){ //C-RATE Sign Calculation
		tmp1 = (float)C_Rate_Calc_Capacity[i];
		tmp2 = (float)C_Rate_Calc_Capacity[i+1];
		if(tmp3 != 0) tmp1 = tmp3;
		switch(C_Rate_Sign[i]){
			case 1: // +
				tmp3 = tmp1 + tmp2;
				break;
			case 2: // - 
				tmp3 = tmp1 - tmp2;
				break;
			case 3: // *
				tmp3 = tmp1 * tmp2;
				break;
			case 4: // /
				tmp3 = tmp1 / tmp2;
				break;
			case 5: // =
				break;
		}
	}
	tmp3 = (float)tmp3 * 1000.;

	if(tmp3 >= myPs->config.maxCurrent[0]){ //Max Current Limitation
		tmp3 = myPs->config.maxCurrent[0];
	}

	return (long)tmp3;	
}

long Calculate_End_Capacity(int bd, int ch, int advStepNo, int Select) //211223
{
	unsigned char	count = 0, Capa_Sign[2], Current_Sign[2];
	int				i;
	unsigned short	Capa_StepNo[2];
	unsigned short	Current_StepNo[2];
	short int		Capa_Persent[2];
	short int		Current_Persent[2];
	float			Capa_Calc_Capacity[2];
	float			Current_Calc_Capacity[2];
	double			tmp1, tmp2, tmp3;	

	if(Select == 1){ //Capacity End 
		for(i=0; i<2; i++){ //Capacity End Count
			if(myPs->testCond[bd][ch].step[advStepNo].endCycleCapaRate[i] !=0){
				count++;
			}
		}
		for(i=0; i < count; i++){ //C-RATE Step Capacity	
			Capa_Persent[i] = 
				myPs->testCond[bd][ch].step[advStepNo].endCycleCapaRate[i];
			Capa_StepNo[i] =
				myPs->testCond[bd][ch].step[advStepNo].endCycleCapaStepNo[i]; 
			if(Capa_StepNo[i] !=0){
				myCh->misc.End_Capa_Calc_Capacity[i] = 
					myCh->misc.C_Rate_stepCapacity[Capa_StepNo[i]-1]
									* ((float)Capa_Persent[i]/10000);
				Capa_Calc_Capacity[i] = 
					(float) myCh->misc.End_Capa_Calc_Capacity[i] / 1000.;
			}
			Capa_Sign[i] =
				myPs->testCond[bd][ch].step[advStepNo].endCycleCapaSign[i]; 
		}
		tmp3 = 0;
		for(i=0; i< count; i++){ //C-RATE Sign Calculation
			tmp1 = (float)Capa_Calc_Capacity[i];
			tmp2 = (float)Capa_Calc_Capacity[i+1];
			if(tmp3 != 0) tmp1 = tmp3;
			switch(Capa_Sign[i]){
				case 1: // +
					tmp3 = tmp1 + tmp2;
					break;
				case 2: // - 
					tmp3 = tmp1 - tmp2;
					break;
				case 3: // *
					tmp3 = tmp1 * tmp2;
					break;
				case 4: // /
					tmp3 = tmp1 / tmp2;
					break;
				case 5: // =
					break;
			}
		}
		tmp3 = (float)tmp3 * 1000.;

		return (long)tmp3;	
	}else if(Select == 2){ //Current End
		for(i=0; i<2; i++){ //Current End Count
			if(myPs->testCond[bd][ch].step[advStepNo].endCycleCurrentRate[i] !=0){
				count++;
			}
		}
		for(i=0; i < count; i++){ //C-RATE Step Capacity	
			Current_Persent[i] = 
				myPs->testCond[bd][ch].step[advStepNo].endCycleCurrentRate[i];
			Current_StepNo[i] =
				myPs->testCond[bd][ch].step[advStepNo].endCycleCurrentStepNo[i];
			if(Current_StepNo[i] !=0){
				myCh->misc.End_Current_Calc_Capacity[i] = 
					myCh->misc.C_Rate_stepCapacity[Current_StepNo[i]-1]
									* ((float)Current_Persent[i]/10000);
				Current_Calc_Capacity[i] = 
					(float) myCh->misc.End_Current_Calc_Capacity[i] / 1000.;
			}
			Current_Sign[i] =
				myPs->testCond[bd][ch].step[advStepNo].endCycleCurrentSign[i]; 
		}
		tmp3 = 0;
		for(i=0; i< count; i++){ //C-RATE Sign Calculation
			tmp1 = (float)Current_Calc_Capacity[i];
			tmp2 = (float)Current_Calc_Capacity[i+1];
			if(tmp3 != 0) tmp1 = tmp3;
			switch(Current_Sign[i]){
				case 1: // +
					tmp3 = tmp1 + tmp2;
					break;
				case 2: // - 
					tmp3 = tmp1 - tmp2;
					break;
				case 3: // *
					tmp3 = tmp1 * tmp2;
					break;
				case 4: // /
					tmp3 = tmp1 / tmp2;
					break;
				case 5: // =
					break;
			}
		}
		tmp3 = (float)tmp3 * 1000.;
		return (long)tmp3;	
	}else{
		return 0;
	}
}
#endif
